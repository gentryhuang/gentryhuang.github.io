<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gentryhuang‘s blog</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gentryhuang.com/"/>
  <updated>2021-02-18T09:01:08.743Z</updated>
  <id>https://gentryhuang.com/</id>
  
  <author>
    <name>gentryhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础 - JDK动态代理</title>
    <link href="https://gentryhuang.com/posts/d38b32e5/"/>
    <id>https://gentryhuang.com/posts/d38b32e5/</id>
    <published>2021-01-03T12:30:35.000Z</published>
    <updated>2021-02-18T09:01:08.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java 中代理分为两大类，一类是静态代理，另一类是动态代理。静态代理是针对需要被代理的类在编译之前就已经写好了对应的代理类，也就是说代理关系在编译之前就确立了。动态代理是针对目标类在程序运行期间自动生成的代理类，细分为有接口的代理类和无接口的代理类。JDK动态代理支持目标类有接口的情况，目标类没有接口无法为其生成代理类，能够为没有接口生成代理类的工具如 CGLIB 等。本篇文章将对JDK动态代理实现原理进行介绍。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPrintf</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintfImpl</span> <span class="keyword">implements</span> <span class="title">IPrintf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"print: "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IPrintf PRINTF = <span class="keyword">new</span> PrintfImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDK 生成代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> $Proxy0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPrintf <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> (IPrintf) Proxy.newProxyInstance(</span><br><span class="line">                <span class="comment">// 类加载器，在程序运行时将生成的代理类加载到JVM中</span></span><br><span class="line">                PRINTF.getClass().getClassLoader(),</span><br><span class="line">                <span class="comment">// 被代理类的所有接口信息，用来确定生成的代理类可以具有哪些方法</span></span><br><span class="line">                PRINTF.getClass().getInterfaces(),</span><br><span class="line">                <span class="comment">// 调用处理器，每个代理对象都具有一个关联的调用处理器，用于指定动态生成的代理类需要完成的具体操作。</span></span><br><span class="line">                <span class="comment">// 该接口中有一个 invoke 方法，代理对象调用任何目标接口的方法时都会调用该 invoke 方法，该方法中会通过反射调用目标方法。</span></span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method 代理对象当前调用的方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span> 方法执行的结果（无返回值则为 null）</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable 异常</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">// 前置逻辑</span></span><br><span class="line">                        System.out.println(<span class="string">"before action ... "</span>);</span><br><span class="line">                        <span class="comment">// 将方法派发给目标方法</span></span><br><span class="line">                        Object result = method.invoke(PRINTF, args);</span><br><span class="line">                        <span class="comment">// 后置逻辑</span></span><br><span class="line">                        System.out.println(<span class="string">"after action ... "</span>);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IPrintf proxy = Client.getProxy();</span><br><span class="line">        proxy.print(<span class="string">"hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印结果"><a href="#打印结果" class="headerlink" title="打印结果"></a>打印结果</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/java-base-proxy-test.jpg" alt></p><h2 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h2><p>通过阿里开源 Java 应用诊断工具 Arthas 反编译代理类，结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decompiled with CFR.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.code.proxy.IPrintf;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy4</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Proxy</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">IPrintf</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态属性，每个属性对应接口中的一个方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，入参类型为 InvocationHandler</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy4(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="comment">// 调用父类 Proxy 的构造方法</span></span><br><span class="line">        <span class="keyword">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块中通过反射初始化Method属性</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="comment">// Object 中的三大方法</span></span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 目标类的接口中的方法</span></span><br><span class="line">            m3 = Class.forName(<span class="string">"com.code.proxy.IPrintf"</span>).getMethod(<span class="string">"print"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(noSuchMethodException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(classNotFoundException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;object&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m2, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m0, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标类的打印方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// this.h 是 Proxy 中的属性，即调用 Proxy.newProxyInstance 方法传入的 InvocationHandler 对象</span></span><br><span class="line">            <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;string&#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过上面反编译后的代理类代码不难看出，JDK 动态代理实现具有以下特点：</strong></p><ol><li>生成的代理类继承了 <strong>Proxy</strong> 类且实现了 <strong>目标类的接口</strong>，有参构造方法的参数类型是 <strong>InvocationHandler</strong> ，反射创建代理对象执行的就是该构造方法。</li><li>代理类通过反射为目标接口（接口列表）中的每个方法都映射一个 <strong>Method</strong> 对象。</li><li>代理类对接口中方法的实现逻辑都是通过 <strong>InvocationHandler.invoke</strong> 方法派发执行的，代理对象调用任何目标接口的方法时都会调用这个<strong>invoke</strong>方法，该方法中进行目标类的目标方法的调用，即每个方法执行逻辑都由第 2 步中的 <strong>Method</strong> 对象执行。</li></ol><p>关于 JDK 动态代理使用就介绍完毕了，下面我们对底层实现原理进行说明。实现原理中的部分描述信息会引用到上述代码片段。</p><h1 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h1><p>Java 中需要在运行期动态的生成一个类并创建其对象，一般需要使用字节码技术和反射机制。JDK 动态代理通过<code>java.lang.reflect.Proxy</code>提供了一种原生的动态代理模式，其底层通过<strong>对字节码的操作</strong>和<strong>反射的使用</strong>组装代理类，如前文中的 <strong>$Proxy4</strong>，最后通过反射创建代理对象。</p><p>JDK通过调用静态方法 <code>Proxy.newProxyInstance()</code> 创建动态代理，该方法需要三个参数：</p><ol><li>类加载器<br>通常可以从已经被加载的对象中获取其类加载器。</li><li>接口列表<br>预期代理实现的接口列表。</li><li><strong>InvocationHandler</strong> 接口的实现<br>作为动态代理对象的调用处理器，即动态代理可以将所有调用派发到该调用处理器。因此，通常会向调用处理器的构造器中传入一个目标对象的引用，从而使得调用处理器在执行中介任务时可以将请求转发。</li></ol><p>介绍完代理相关的概念和使用方式后，下面我们对 JDK 动态代理实现原理进行说明。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+--- java.lang.reflect.Proxy</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法参数类型，就是 InvocationHandler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams = &#123;InvocationHandler<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类的缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">            proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理对象调用的处理器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prohibits instantiation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供生成的动态代理类调用，也就是 Proxy 的子类。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h 用于代理对象的调用处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy 中有 3 个核心属性，下面简单介绍：</p><ol><li><strong>constructorParams</strong><br>Proxy 中的有参构造器的参数，是个固定值即调用处理器 <code>InvocationHandler</code>，生成的代理类都会调用 <code>Proxy</code> 这个父类的构造方法。</li><li><strong>proxyClassCache</strong><br>缓存生成的代理类，用于提高效率。需要注意的是，KeyFactory 和 ProxyClassFactory 都是 Proxy 的内部类，前者用于返回接口对应的弱引用，后者根据指定的类加载器和接口列表生成代理类。</li><li><strong>h</strong><br>调用处理器，该处理器会将代理对象的方法调用派发给目标方法。</li></ol><h3 id="内部类-KeyFactory"><a href="#内部类-KeyFactory" class="headerlink" title="内部类 KeyFactory"></a>内部类 KeyFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyFactory</span></span></span><br><span class="line">        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回接口对应的弱引用信息。Key1、Key2 以及 KeyX 都持有 WeakReference</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">apply</span><span class="params">(ClassLoader classLoader, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (interfaces.length) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Key1(interfaces[<span class="number">0</span>]); <span class="comment">// the most frequent</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Key2(interfaces[<span class="number">0</span>], interfaces[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> key0;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> KeyX(interfaces);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KeyFactory 就一个工作，返回接口对应的弱引用信息，KeyN 继承了 <code>WeakReference</code> 类。</p><h3 id="内部类-ProxyClassFactory"><a href="#内部类-ProxyClassFactory" class="headerlink" title="内部类 ProxyClassFactory"></a>内部类 ProxyClassFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">           implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 代理类名称前缀，具体名称为： $Proxy + Num</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 生成代理名称的序号，是自增原子类</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 生成代理类的逻辑</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> loader     类加载器</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> interfaces 接口集合</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> 代理类</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">           Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">           <span class="comment">// 遍历接口集合</span></span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 1 验证类加载器是否将当前接口名称解析为相同的类对象</span></span><br><span class="line">               Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                           intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 2 判断是否是接口</span></span><br><span class="line">               <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                           interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 3 验证接口是否重复加载</span></span><br><span class="line">               <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                           <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 4 代理所在包的名称</span></span><br><span class="line">           String proxyPkg = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 5 记录非public类型的接口，如果是非public类型的接口，则会将代理类定义在该对应的包中。当且仅当所有非public类型的接口都在一个包中才行，否则不合法</span></span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">               <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">               <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                   accessFlags = Modifier.FINAL;</span><br><span class="line">                   String name = intf.getName();</span><br><span class="line">                   <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                   String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                   <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       proxyPkg = pkg;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                               <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 6 如果接口是public类型的，则使用固定的包名： com.sun.proxy</span></span><br><span class="line">           <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">               proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 7 组装代理类名称，格式：proxyPkg + $Proxy + Num</span></span><br><span class="line">           <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">           String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 8 根据代理类名和接口列表使用 ProxyGenerator 生成指定的代理类，可能返回null （配置了虚拟机参数，将代理类字节信息输出到文件）</span></span><br><span class="line">           <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 9 调用native方法，返回代理类</span></span><br><span class="line">               <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 排除代理类生成代码中的bug，提供给代理类创建的参数存在其他问题(例如超出了虚拟机限制)。</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>ProxyClassFactory 完成生成字节码的操作，是生成代理类的完整流程，具体工作如下：</strong></p><ol><li>根据目标类的接口类型确定生成代理类全路径名</li><li>执行 <strong>ProxyGenerator.generateProxyClass</strong> 方法，根据代理类名和接口生成代理类字节码数组或文件形式</li><li>调用 <strong>native</strong> 方法将代理类字节码数据转化为代理类 Class</li></ol><h2 id="ProxyGenerator"><a href="#ProxyGenerator" class="headerlink" title="ProxyGenerator"></a>ProxyGenerator</h2><p><strong>ProxyClassFactory.apply</strong> 通过调用 <strong>ProxyGenerator.generateProxyClass</strong> 方法组装代理类，对接口的 <code>Class</code> 对象、<code>Method</code> 对象进行拆解、封装进而生成字节码层面的方法、构造方法以及静态代码块。</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"></span><br><span class="line">  <span class="comment">// JVM参数，是否将生成的代理类保存到文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles = (Boolean) AccessController.doPrivileged(<span class="keyword">new</span> GetBooleanAction(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object 三大方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method hashCodeMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method equalsMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method toStringMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理类全路径名</span></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="comment">// 接口数组</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] interfaces;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> accessFlags;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ProxyGenerator 中的常量池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ProxyGenerator.ConstantPool cp = <span class="keyword">new</span> ProxyGenerator.ConstantPool();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录方法标识，用于生成代理类中的方法的属性。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ProxyGenerator.FieldInfo&gt; fields = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成的方法信息集合，包括构造方法、静态代码块。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ProxyGenerator.MethodInfo&gt; methods = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法签名到方法代理对象的映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;ProxyGenerator.ProxyMethod&gt;&gt; proxyMethods = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> proxyMethodCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 反射获取三大方法对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hashCodeMethod = Object.class.getMethod("hashCode");</span><br><span class="line">            equalsMethod = Object.class.getMethod("equals", Object.class);</span><br><span class="line">            toStringMethod = Object.class.getMethod("toString");</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var1.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var1 代理类名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var2 目标类接口集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ProxyGenerator</span><span class="params">(String var1, Class&lt;?&gt;[] var2, <span class="keyword">int</span> var3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = var1;</span><br><span class="line">        <span class="keyword">this</span>.interfaces = var2;</span><br><span class="line">        <span class="keyword">this</span>.accessFlags = var3;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>JDK 动态代理涉及到的基础类先介绍到这里，下面我们从 <code>Proxy.newProxyInstance</code> 入口出发，根据调用链逐步分析源代码。</p><h2 id="newProxyInstance"><a href="#newProxyInstance" class="headerlink" title="newProxyInstance"></a>newProxyInstance</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">+--- Proxy</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader     代理类的加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces 目标类的接口列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h          代理对象方法调用都会分派给该调用处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用处理器是必传参数</span></span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接口列表</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 查找或生成指定的代理类。</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 对生成的代理类进行安全检查</span></span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 获取代理类的指定构造方法，即参数类型为 InvocationHandler 的构造方法</span></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 保证代理类的构造方法 cons 具有访问权限，便于后续反射创建代理对象</span></span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 反射创建代理对象，注意参数为 InvocationHandler</span></span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong><code>Proxy.newProxyInstance</code> 方法是生成代理对象的入口，下面对该方法的逻辑进行简单说明：</strong></p><ol><li>调用 <code>getProxyClass0</code> 方法根据指定的类加载器和接口列表获取代理类。这一步是整个代理逻辑的核心实现。</li><li>反射获取参数为 <code>InvocationHandler</code>的代理类的构造方法，并保证该构造方法是可访问的。</li><li>通过 <strong>newInstance</strong> 方法反射创建代理对象，参数类型为 <code>InvocationHandler</code> 。</li></ol><p>第 2、3 步都很容易理解，下面我们重点来分析获取代理类的 <code>getProxyClass0</code> 方法。</p><h2 id="getProxyClass0"><a href="#getProxyClass0" class="headerlink" title="getProxyClass0"></a>getProxyClass0</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--- Proxy</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成代理类。在调用此方法之前，必须调用checkProxyAccess方法来执行权限检查。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取代理类：</span></span><br><span class="line"><span class="comment">         * 1. 如果代理类存在则返回缓存的副本。</span></span><br><span class="line"><span class="comment">         * 2. 不存在，则通过 ProxyClassFactory 创建代理类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前文中有提到代理类缓存属性 <code>WeakCache proxyClassCache</code> ，它的主要作用就是先查找对应的代理类缓存，没有的话就通过 <code>java.lang.reflect.Proxy.ProxyClassFactory#apply</code> 方法创建代理类，该方法在前文中已经详细说明。下面我们对 <strong><code>ProxyGenerator.generateProxyClass</code> 根据代理类名和接口生成代理类字节码数组或文件形式</strong> 这一步骤进行说明。</p><h2 id="generateProxyClass"><a href="#generateProxyClass" class="headerlink" title="generateProxyClass"></a>generateProxyClass</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成代理类-字节码形式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var0 代理类名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var1 目标类接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line"></span><br><span class="line">        ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">        <span class="comment">// 生成目标类的接口信息的字节码</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加JVM 参数 sun.misc.ProxyGenerator.saveGeneratedFiles ，则保存到文件</span></span><br><span class="line">        <span class="keyword">if</span> (saveGeneratedFiles) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> var1 = var0.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                        Path var2;</span><br><span class="line">                        <span class="keyword">if</span> (var1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 创建目录</span></span><br><span class="line">                            Path var3 = Paths.get(var0.substring(<span class="number">0</span>, var1).replace(<span class="string">'.'</span>, File.separatorChar));</span><br><span class="line">                            Files.createDirectories(var3);</span><br><span class="line"></span><br><span class="line">                            var2 = var3.resolve(var0.substring(var1 + <span class="number">1</span>, var0.length()) + <span class="string">".class"</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            var2 = Paths.get(var0 + <span class="string">".class"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 保存到文件</span></span><br><span class="line">                        Files.write(var2, var4, <span class="keyword">new</span> OpenOption[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var4x) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"I/O exception saving generated file: "</span> + var4x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var4;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>generateProxyClass 方法用于根据代理类名称和接口列表生成预期的代理类的字节码（数组）信息，最后通过 JDK 的本地方法转化为具体的代理类。该方法支持通过配置<strong>JVM参数</strong>将目标代理类输出到文件中。</p><p>在分析 <code>ProxyGenerator.generateClassFile</code> 方法之前，我们先对涉及的核心类和方法进行简单说明。注意该方法整个流程比较复杂，本文只对整体逻辑进行说明，具体细节可以参考源代码。</p><h2 id="ProxyMethod"><a href="#ProxyMethod" class="headerlink" title="ProxyMethod"></a>ProxyMethod</h2><p>方法代理类，用于拆解、封装 <strong>Method</strong> 的信息，作为后续方法字节码生成的数据来源。</p><h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyMethod</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法名</span></span><br><span class="line">        <span class="keyword">public</span> String methodName;</span><br><span class="line">        <span class="comment">// 参数类型</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line">        <span class="comment">// 返回值类型</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; returnType;</span><br><span class="line">        <span class="comment">// 异常类型</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt;[] exceptionTypes;</span><br><span class="line">        <span class="comment">// 方法所在接口</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; fromClass;</span><br><span class="line">        <span class="comment">// 当前方法对应的序列号，如 m0</span></span><br><span class="line">        <span class="keyword">public</span> String methodFieldName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ProxyMethod</span><span class="params">(String var2, Class&lt;?&gt;[] var3, Class&lt;?&gt; var4, Class&lt;?&gt;[] var5, Class&lt;?&gt; var6)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.methodName = var2;</span><br><span class="line">            <span class="keyword">this</span>.parameterTypes = var3;</span><br><span class="line">            <span class="keyword">this</span>.returnType = var4;</span><br><span class="line">            <span class="keyword">this</span>.exceptionTypes = var5;</span><br><span class="line">            <span class="keyword">this</span>.fromClass = var6;</span><br><span class="line">            <span class="keyword">this</span>.methodFieldName = <span class="string">"m"</span> + ProxyGenerator.<span class="keyword">this</span>.proxyMethodCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其它代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="generateMethod"><a href="#generateMethod" class="headerlink" title="generateMethod"></a>generateMethod</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyMethod</span><br><span class="line"> <span class="keyword">private</span> ProxyGenerator.<span class="function">MethodInfo <span class="title">generateMethod</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">// 方法签名 如：toString 方法的描述信息 Ljava/lang/reflect/Method;  void print(String message) 描述信息 (Ljava/lang/String;)V</span></span><br><span class="line">            String var1 = ProxyGenerator.getMethodDescriptor(<span class="keyword">this</span>.parameterTypes, <span class="keyword">this</span>.returnType);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 MethodInfo 对象，同时会初始化 ByteArrayOutputStream 对象</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 方法名 + 方法签名</span></span><br><span class="line">            ProxyGenerator.MethodInfo var2 = ProxyGenerator.<span class="keyword">this</span>.<span class="keyword">new</span> MethodInfo(<span class="keyword">this</span>.methodName, var1, <span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 方法参数</span></span><br><span class="line">            <span class="keyword">int</span>[] var3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.parameterTypes.length];</span><br><span class="line">            <span class="keyword">int</span> var4 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var3.length; ++var5) &#123;</span><br><span class="line">                var3[var5] = var4;</span><br><span class="line">                var4 += ProxyGenerator.getWordsPerType(<span class="keyword">this</span>.parameterTypes[var5]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span> var7 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过字节输出流 ByteArrayOutputStream 写入方法的二进制信息，即 MethodInfo 中的输出流中</span></span><br><span class="line">            DataOutputStream var9 = <span class="keyword">new</span> DataOutputStream(var2.code);</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.code_aload(<span class="number">0</span>, var9);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 写入接口方法的 InvocationHandler.invoke 处理逻辑</span></span><br><span class="line">            var9.writeByte(<span class="number">180</span>);</span><br><span class="line">            var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getFieldRef(<span class="string">"java/lang/reflect/Proxy"</span>, <span class="string">"h"</span>, <span class="string">"Ljava/lang/reflect/InvocationHandler;"</span>));</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.code_aload(<span class="number">0</span>, var9);</span><br><span class="line">            var9.writeByte(<span class="number">178</span>);</span><br><span class="line">            var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getFieldRef(ProxyGenerator.dotToSlash(ProxyGenerator.<span class="keyword">this</span>.className), <span class="keyword">this</span>.methodFieldName, <span class="string">"Ljava/lang/reflect/Method;"</span>));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.parameterTypes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ProxyGenerator.<span class="keyword">this</span>.code_ipush(<span class="keyword">this</span>.parameterTypes.length, var9);</span><br><span class="line">                var9.writeByte(<span class="number">189</span>);</span><br><span class="line">                var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/Object"</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> var10 = <span class="number">0</span>; var10 &lt; <span class="keyword">this</span>.parameterTypes.length; ++var10) &#123;</span><br><span class="line">                    var9.writeByte(<span class="number">89</span>);</span><br><span class="line">                    ProxyGenerator.<span class="keyword">this</span>.code_ipush(var10, var9);</span><br><span class="line">                    <span class="keyword">this</span>.codeWrapArgument(<span class="keyword">this</span>.parameterTypes[var10], var3[var10], var9);</span><br><span class="line">                    var9.writeByte(<span class="number">83</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var9.writeByte(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            var9.writeByte(<span class="number">185</span>);</span><br><span class="line">            var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getInterfaceMethodRef(<span class="string">"java/lang/reflect/InvocationHandler"</span>, <span class="string">"invoke"</span>, <span class="string">"(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;"</span>));</span><br><span class="line">            var9.writeByte(<span class="number">4</span>);</span><br><span class="line">            var9.writeByte(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 返回类型</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.returnType == Void.TYPE) &#123;</span><br><span class="line">                var9.writeByte(<span class="number">87</span>);</span><br><span class="line">                var9.writeByte(<span class="number">177</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.codeUnwrapReturnValue(<span class="keyword">this</span>.returnType, var9);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 写入方法处理异常字节信息</span></span><br><span class="line">            <span class="keyword">short</span> var6;</span><br><span class="line">            <span class="keyword">short</span> var8 = var6 = (<span class="keyword">short</span>) var2.code.size();</span><br><span class="line">            List var13 = ProxyGenerator.computeUniqueCatchList(<span class="keyword">this</span>.exceptionTypes);</span><br><span class="line">            <span class="keyword">if</span> (var13.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Iterator var11 = var13.iterator();</span><br><span class="line">                <span class="keyword">while</span> (var11.hasNext()) &#123;</span><br><span class="line">                    Class var12 = (Class) var11.next();</span><br><span class="line">                    var2.exceptionTable.add(<span class="keyword">new</span> ProxyGenerator.ExceptionTableEntry(var7, var8, var6, ProxyGenerator.<span class="keyword">this</span>.cp.getClass(ProxyGenerator.dotToSlash(var12.getName()))));</span><br><span class="line">                &#125;</span><br><span class="line">                var9.writeByte(<span class="number">191</span>);</span><br><span class="line">                var6 = (<span class="keyword">short</span>) var2.code.size();</span><br><span class="line">                var2.exceptionTable.add(<span class="keyword">new</span> ProxyGenerator.ExceptionTableEntry(var7, var8, var6, ProxyGenerator.<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/Throwable"</span>)));</span><br><span class="line">                ProxyGenerator.<span class="keyword">this</span>.code_astore(var4, var9);</span><br><span class="line">                var9.writeByte(<span class="number">187</span>);</span><br><span class="line">                var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/UndeclaredThrowableException"</span>));</span><br><span class="line">                var9.writeByte(<span class="number">89</span>);</span><br><span class="line">                ProxyGenerator.<span class="keyword">this</span>.code_aload(var4, var9);</span><br><span class="line">                var9.writeByte(<span class="number">183</span>);</span><br><span class="line">                var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/reflect/UndeclaredThrowableException"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"(Ljava/lang/Throwable;)V"</span>));</span><br><span class="line">                var9.writeByte(<span class="number">191</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var2.code.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"code size limit exceeded"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var2.maxStack = <span class="number">10</span>;</span><br><span class="line">                var2.maxLocals = (<span class="keyword">short</span>) (var4 + <span class="number">1</span>);</span><br><span class="line">                var2.declaredExceptions = <span class="keyword">new</span> <span class="keyword">short</span>[<span class="keyword">this</span>.exceptionTypes.length];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> var14 = <span class="number">0</span>; var14 &lt; <span class="keyword">this</span>.exceptionTypes.length; ++var14) &#123;</span><br><span class="line">                    var2.declaredExceptions[var14] = ProxyGenerator.<span class="keyword">this</span>.cp.getClass(ProxyGenerator.dotToSlash(<span class="keyword">this</span>.exceptionTypes[var14].getName()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> var2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>generateMethod 方法根据 <code>ProxyMethod</code> 信息，按照方法的构造组装代表字节码信息的 <code>MethodInfo</code>，最终将该信息写入到输出流中。</p><h2 id="MethodInfo"><a href="#MethodInfo" class="headerlink" title="MethodInfo"></a>MethodInfo</h2><p>ProxyMethod 对象经过解析后会组装成 MethodInfo 对象，该对象封装了代理类中方法的字节码信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> accessFlags;</span><br><span class="line">        <span class="comment">// 方法名</span></span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="comment">// 方法签名</span></span><br><span class="line">        <span class="keyword">public</span> String descriptor;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">short</span> maxStack;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">short</span> maxLocals;</span><br><span class="line">        <span class="comment">// 输出流，方法字节码会写入到该流中</span></span><br><span class="line">        <span class="keyword">public</span> ByteArrayOutputStream code = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">public</span> List&lt;ProxyGenerator.ExceptionTableEntry&gt; exceptionTable = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">short</span>[] declaredExceptions;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MethodInfo</span><span class="params">(String var2, String var3, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = var2;</span><br><span class="line">            <span class="keyword">this</span>.descriptor = var3;</span><br><span class="line">            <span class="keyword">this</span>.accessFlags = var4;</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(var2);</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(var3);</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(<span class="string">"Code"</span>);</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(<span class="string">"Exceptions"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略写入输出流逻辑</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="FieldInfo"><a href="#FieldInfo" class="headerlink" title="FieldInfo"></a>FieldInfo</h2><p>FieldInfo 用于封装方法在代理类中的静态属性信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> accessFlags;</span><br><span class="line">        <span class="comment">// m + N，方法在代理类中的字段名</span></span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="comment">// 固定值 Ljava/lang/reflect/Method;</span></span><br><span class="line">        <span class="keyword">public</span> String descriptor;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FieldInfo</span><span class="params">(String var2, String var3, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = var2;</span><br><span class="line">            <span class="keyword">this</span>.descriptor = var3;</span><br><span class="line">            <span class="keyword">this</span>.accessFlags = var4;</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(var2);</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(var3);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入输出流</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutputStream var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            var1.writeShort(<span class="keyword">this</span>.accessFlags);</span><br><span class="line">            var1.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(<span class="keyword">this</span>.name));</span><br><span class="line">            var1.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(<span class="keyword">this</span>.descriptor));</span><br><span class="line">            var1.writeShort(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>介绍完必要的前置概念和类信息后，我们回到 <code>ProxyGenerator.generateClassFile</code> 方法，继续接着流程往下分析。</p><h2 id="generateClassFile"><a href="#generateClassFile" class="headerlink" title="generateClassFile"></a>generateClassFile</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</span><br><span class="line">        <span class="comment">// 1. 将 Object 中的三大方法对象Method拆解，组装成 ProxyMethod 对象</span></span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(hashCodeMethod, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(equalsMethod, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(toStringMethod, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将目标类的接口中的方法对象Method拆解，组装成 ProxyMethod 对象</span></span><br><span class="line">        Class[] var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">        <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line">        <span class="keyword">int</span> var3;</span><br><span class="line">        Class var4;</span><br><span class="line">        <span class="comment">// 2.1 遍历接口</span></span><br><span class="line">        <span class="keyword">for</span> (var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            var4 = var1[var3];</span><br><span class="line">            <span class="comment">// 2.3 获取接口中的方法列表</span></span><br><span class="line">            Method[] var5 = var4.getMethods();</span><br><span class="line">            <span class="keyword">int</span> var6 = var5.length;</span><br><span class="line">            <span class="comment">// 2.4 遍历当前接口中的方法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> var7 = <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">                Method var8 = var5[var7];</span><br><span class="line">                <span class="comment">// 2.5 对接口中的方法拆解、组装成 ProxyMethod 对象，然后加入缓存 proxyMethods 中</span></span><br><span class="line">                <span class="keyword">this</span>.addProxyMethod(var8, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取缓存的方法代理对象 ProxyMethod 集合</span></span><br><span class="line">        Iterator var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line">        <span class="comment">// 校验相同方法签名的返回类型</span></span><br><span class="line">        List var12;</span><br><span class="line">        <span class="keyword">while</span> (var11.hasNext()) &#123;</span><br><span class="line">            var12 = (List) var11.next();</span><br><span class="line">            checkReturnTypes(var12);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator var15;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 生成构造方法字节码信息并加入到 methods 缓存起来</span></span><br><span class="line">            <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateConstructor());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 遍历方法代理对象列表，生成方法字节码信息并缓存到 methods 中</span></span><br><span class="line">            var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line">            <span class="keyword">while</span> (var11.hasNext()) &#123;</span><br><span class="line">                var12 = (List) var11.next();</span><br><span class="line">                var15 = var12.iterator();</span><br><span class="line">                <span class="keyword">while</span> (var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod) var15.next();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.1 生成方法的 FieldInfo 并加入到 fields 集合中，即代理类中方法Method的字段属性</span></span><br><span class="line">                    <span class="keyword">this</span>.fields.add(<span class="keyword">new</span> ProxyGenerator.FieldInfo(var16.methodFieldName, <span class="string">"Ljava/lang/reflect/Method;"</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.2 生成方法的 MethodInfo 并加入到 methods 集合中，注意 MethodInfo 中的 ByteArrayOutputStream</span></span><br><span class="line">                    <span class="keyword">this</span>.methods.add(var16.generateMethod());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 生成静态代码块字节码信息（根据 proxyMethods 中的信息）</span></span><br><span class="line">            <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateStaticInitializer());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"unexpected I/O Exception"</span>, var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 方法数量限制</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.methods.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"method limit exceeded"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.fields.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"field limit exceeded"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 代理类字节码组装</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.1. 处理代理类 和 Proxy 的全路径类，并入放入常量池 cp 中</span></span><br><span class="line">            <span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className));</span><br><span class="line">            <span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/Proxy"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.2. 处理代理类的接口，并放入常量池 cp 中</span></span><br><span class="line">            var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">            var2 = var1.length;</span><br><span class="line">            <span class="keyword">for</span> (var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                var4 = var1[var3];</span><br><span class="line">                <span class="keyword">this</span>.cp.getClass(dotToSlash(var4.getName()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.cp.setReadOnly();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.3. 字节类型数据的输出流，内存操作流</span></span><br><span class="line">            ByteArrayOutputStream var13 = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            DataOutputStream var14 = <span class="keyword">new</span> DataOutputStream(var13);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var14.writeInt(-<span class="number">889275714</span>);</span><br><span class="line">                var14.writeShort(<span class="number">0</span>);</span><br><span class="line">                var14.writeShort(<span class="number">49</span>);</span><br><span class="line">                <span class="keyword">this</span>.cp.write(var14);</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.accessFlags);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7.3.1 写入代理类名称信息</span></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className)));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7.3.2 写入Proxy名称信息</span></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/Proxy"</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7.3.4 写入接口列表</span></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.interfaces.length);</span><br><span class="line">                Class[] var17 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">                <span class="keyword">int</span> var18 = var17.length;</span><br><span class="line">                <span class="comment">// 遍历接口列表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> var19 = <span class="number">0</span>; var19 &lt; var18; ++var19) &#123;</span><br><span class="line">                    Class var22 = var17[var19];</span><br><span class="line">                    <span class="comment">// 写入接口信息</span></span><br><span class="line">                    var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(var22.getName())));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/// 7.3.5 写入字段信息，即接口方法的标识，如 m1、m2</span></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.fields.size());</span><br><span class="line">                var15 = <span class="keyword">this</span>.fields.iterator();</span><br><span class="line">                <span class="keyword">while</span> (var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo) var15.next();</span><br><span class="line">                    var20.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7.3.6 写入方法，包括构造方法、静态代码块</span></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.methods.size());</span><br><span class="line">                var15 = <span class="keyword">this</span>.methods.iterator();</span><br><span class="line">                <span class="keyword">while</span> (var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo) var15.next();</span><br><span class="line">                    var21.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line">                var14.writeShort(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4 返回字节数组信息</span></span><br><span class="line">                <span class="keyword">return</span> var13.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"unexpected I/O Exception"</span>, var9);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>generateClassFile 方法逻辑还是比较复杂的，下面对主要流程进行说明：</strong></p><ol><li>将 Object 中的三大方法对象解析、组装成 ProxyMethod 对象。</li><li>将目标类的接口中的方法对象解析、组装成 ProxyMethod 对象。</li><li>生成构造方法字节码信息并封装到 MethodInfo 对象中。</li><li>将第 1、2 步骤中组装的 ProxyMethod 对象进行解析，生成代表该方法字段标识的 FieldInfo 对象并缓存起来，解析为该方法的字节码信息的 MethodInfo 对象并缓存起来。</li><li>根据第 1、2 步骤中组装的 ProxyMethod 对象生成静态代码块字节码信息并封装到 MethodInfo 对象中并缓存起来。</li><li>对代理类中的方法数量做限制。</li><li>依次将代理类相关类路径、接口路径、代理类名、Proxy名、接口名、FieldInfo信息、MehodInfo信息写入到字节输出流中。</li><li>生成代理类字节码数组</li></ol><p>整个过程介绍完毕，下面对该过程中涉及的核心方法进行说明。</p><h3 id="addProxyMethod"><a href="#addProxyMethod" class="headerlink" title="addProxyMethod"></a>addProxyMethod</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将方法对象拆解，组装成 ProxyMethod 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var1 方法对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var2 方法所在接口/类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addProxyMethod</span><span class="params">(Method var1, Class&lt;?&gt; var2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 方法名</span></span><br><span class="line">        String var3 = var1.getName();</span><br><span class="line">        <span class="comment">// 2 方法参数类型</span></span><br><span class="line">        Class[] var4 = var1.getParameterTypes();</span><br><span class="line">        <span class="comment">// 3 方法返回类型</span></span><br><span class="line">        Class var5 = var1.getReturnType();</span><br><span class="line">        <span class="comment">// 4 方法异常类型</span></span><br><span class="line">        Class[] var6 = var1.getExceptionTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 方法签名，如 hashCode()、equals(Ljava/lang/Object;)，最为缓存的 key</span></span><br><span class="line">        String var7 = var3 + getParameterDescriptors(var4);</span><br><span class="line"></span><br><span class="line">        Object var8 = (List) <span class="keyword">this</span>.proxyMethods.get(var7);</span><br><span class="line">        <span class="keyword">if</span> (var8 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator var9 = ((List) var8).iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (var9.hasNext()) &#123;</span><br><span class="line">                ProxyGenerator.ProxyMethod var10 = (ProxyGenerator.ProxyMethod) var9.next();</span><br><span class="line">                <span class="keyword">if</span> (var5 == var10.returnType) &#123;</span><br><span class="line">                    ArrayList var11 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                    collectCompatibleTypes(var6, var10.exceptionTypes, var11);</span><br><span class="line">                    collectCompatibleTypes(var10.exceptionTypes, var6, var11);</span><br><span class="line">                    var10.exceptionTypes = <span class="keyword">new</span> Class[var11.size()];</span><br><span class="line">                    var10.exceptionTypes = (Class[]) var11.toArray(var10.exceptionTypes);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var8 = <span class="keyword">new</span> ArrayList(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">this</span>.proxyMethods.put(var7, var8);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 ProxyMethod 对象，并保存到 proxyMethods 中</span></span><br><span class="line">        ((List) var8).add(<span class="keyword">new</span> ProxyGenerator.ProxyMethod(var3, var4, var5, var6, var2));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述方法用于将 <code>Method</code> 对象拆解、组装为 <code>ProxyMethod</code> 对象，为后续组装代理类的方法字节码做准备。</p><h3 id="generateConstructor"><a href="#generateConstructor" class="headerlink" title="generateConstructor"></a>generateConstructor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line">    <span class="keyword">private</span> ProxyGenerator.<span class="function">MethodInfo <span class="title">generateConstructor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建构造方法字节码的 MethodInfo</span></span><br><span class="line">        ProxyGenerator.MethodInfo var1 = <span class="keyword">new</span> ProxyGenerator.MethodInfo(<span class="string">"&lt;init&gt;"</span>, <span class="string">"(Ljava/lang/reflect/InvocationHandler;)V"</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入 MethodInfo 的输出流中</span></span><br><span class="line">        DataOutputStream var2 = <span class="keyword">new</span> DataOutputStream(var1.code);</span><br><span class="line">        <span class="keyword">this</span>.code_aload(<span class="number">0</span>, var2);</span><br><span class="line">        <span class="keyword">this</span>.code_aload(<span class="number">1</span>, var2);</span><br><span class="line">        var2.writeByte(<span class="number">183</span>);</span><br><span class="line">        var2.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/reflect/Proxy"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"(Ljava/lang/reflect/InvocationHandler;)V"</span>));</span><br><span class="line">        var2.writeByte(<span class="number">177</span>);</span><br><span class="line">        var1.maxStack = <span class="number">10</span>;</span><br><span class="line">        var1.maxLocals = <span class="number">2</span>;</span><br><span class="line">        var1.declaredExceptions = <span class="keyword">new</span> <span class="keyword">short</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> var1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>generateConstructor 方法用于生成构造方法的字节码信息。</p><h3 id="generateStaticInitializer"><a href="#generateStaticInitializer" class="headerlink" title="generateStaticInitializer"></a>generateStaticInitializer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"> <span class="keyword">private</span> ProxyGenerator.<span class="function">MethodInfo <span class="title">generateStaticInitializer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ProxyGenerator.MethodInfo var1 = <span class="keyword">new</span> ProxyGenerator.MethodInfo(<span class="string">"&lt;clinit&gt;"</span>, <span class="string">"()V"</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">byte</span> var2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> var4 = <span class="number">0</span>;</span><br><span class="line">        DataOutputStream var6 = <span class="keyword">new</span> DataOutputStream(var1.code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法列表</span></span><br><span class="line">        Iterator var7 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line">        <span class="comment">// 根据方法信息初始化对应的字段</span></span><br><span class="line">        <span class="keyword">while</span> (var7.hasNext()) &#123;</span><br><span class="line">            List var8 = (List) var7.next();</span><br><span class="line">            Iterator var9 = var8.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (var9.hasNext()) &#123;</span><br><span class="line">                ProxyGenerator.ProxyMethod var10 = (ProxyGenerator.ProxyMethod) var9.next();</span><br><span class="line">                <span class="comment">// 方法字段初始化</span></span><br><span class="line">                var10.codeFieldInitialization(var6);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        var6.writeByte(<span class="number">177</span>);</span><br><span class="line">        <span class="keyword">short</span> var3;</span><br><span class="line">        <span class="keyword">short</span> var5 = var3 = (<span class="keyword">short</span>) var1.code.size();</span><br><span class="line">        var1.exceptionTable.add(<span class="keyword">new</span> ProxyGenerator.ExceptionTableEntry(var4, var5, var3, <span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/NoSuchMethodException"</span>)));</span><br><span class="line">        <span class="keyword">this</span>.code_astore(var2, var6);</span><br><span class="line">        var6.writeByte(<span class="number">187</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/NoSuchMethodError"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">89</span>);</span><br><span class="line">        <span class="keyword">this</span>.code_aload(var2, var6);</span><br><span class="line">        var6.writeByte(<span class="number">182</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/Throwable"</span>, <span class="string">"getMessage"</span>, <span class="string">"()Ljava/lang/String;"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">183</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/NoSuchMethodError"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"(Ljava/lang/String;)V"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">191</span>);</span><br><span class="line">        var3 = (<span class="keyword">short</span>) var1.code.size();</span><br><span class="line">        var1.exceptionTable.add(<span class="keyword">new</span> ProxyGenerator.ExceptionTableEntry(var4, var5, var3, <span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/ClassNotFoundException"</span>)));</span><br><span class="line">        <span class="keyword">this</span>.code_astore(var2, var6);</span><br><span class="line">        var6.writeByte(<span class="number">187</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/NoClassDefFoundError"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">89</span>);</span><br><span class="line">        <span class="keyword">this</span>.code_aload(var2, var6);</span><br><span class="line">        var6.writeByte(<span class="number">182</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/Throwable"</span>, <span class="string">"getMessage"</span>, <span class="string">"()Ljava/lang/String;"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">183</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/NoClassDefFoundError"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"(Ljava/lang/String;)V"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">191</span>);</span><br><span class="line">        <span class="keyword">if</span> (var1.code.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"code size limit exceeded"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var1.maxStack = <span class="number">10</span>;</span><br><span class="line">            var1.maxLocals = (<span class="keyword">short</span>) (var2 + <span class="number">1</span>);</span><br><span class="line">            var1.declaredExceptions = <span class="keyword">new</span> <span class="keyword">short</span>[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> var1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>generateStaticInitializer 方法用于生成代理类的静态代码块信息。</p><p>至此，JDK 动态代理的整个流程介绍完毕。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JDK 动态代理是针对接口做的代理，目标类没有实现接口是无法通过这个方式创建代理对象。通过拼接字节码生成类是十分灵活的，理论上不管是有接口的类还是普通类都是可以实现代理的，CGLIB 就是通过拼接字节码来实现非接口类的代理逻辑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Java 中代理分为两大类，一类是静态代理，另一类是动态代理。静态代理是针对需要被代理的类在编译之前就已经写好了对应的代理类，也就是说代理关
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="代理" scheme="https://gentryhuang.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>并发 - 线程池工具类</title>
    <link href="https://gentryhuang.com/posts/9e3a7d05/"/>
    <id>https://gentryhuang.com/posts/9e3a7d05/</id>
    <published>2020-12-09T16:00:00.000Z</published>
    <updated>2020-12-24T13:19:46.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章 <a href="https://gentryhuang.com/posts/d7cef21d/">线程池</a> 对线程池的原理进行了说明，并对线程池的源码进行了深入分析，本篇文章对线程工具类 Executors 进行分析，需要说明的是 Executors 中除了并行计算的 WorkStealingPool 线程池，其它的都是直接基于 ThreadPoolExecutor 来实现的。本篇文章主要说明 Executors 基于 ThreadPoolExecutor 创建的线程池。</p><h1 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h1><p>FixedThreadPool 属于固定线程数的线程池，使用 Executors.newFixedThreadPool()  方法创建。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li>指定线程数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建固定数量的线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nThreads 核心线程数 = 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>指定线程数和线程工厂<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建固定数量的线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nThreads      核心线程数 = 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory 线程工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">            threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>核心线程数和最大线程数一致，并且使用的任务队列为无界队列。线程池中的线程数随着任务的提交会从 0 增加到核心线程数 nThreads，完成预热之后，线程池中的线程数将会保持 nThreads，之后的任务提交一律放入任务队列中，由空闲的核心线程从队列取出并执行。如果有工作线程退出，线程池将会创建新的工作线程以补足执行的数目 nThreads 。此外，由于使用的是无界队列，隐藏的默认拒绝策略是无效的，并且默认情况下线程池是不会回收核心线程数内的线程，keepAliveTime 同样是个无效参数。</p><h2 id="运行示意图"><a href="#运行示意图" class="headerlink" title="运行示意图"></a>运行示意图</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/concurrent-threadpool-fixed.jpg" alt></p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>适用于为了满足资源管理的需求，而需要限制线程数量的应用场景。</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>由于使用了无界的任务队列，当大量的任务提交到线程池，可能会造成任务堆积，而线程池的拒绝策略又处于失效状态，从而导致 OOM 。</p><h1 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h1><p>SingleThreadExecutor 属于固定线程数的线程池，使用 Executors.newSingleThreadExecutor()  方法创建。</p><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建单个线程的线程池</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">             <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">             <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建单个线程的线程池</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> threadFactory 线程工厂</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">             <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">             <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">             threadFactory));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>SingleThreadExecutor 和 FixedThreadPool 基本一致，区别在于前者的核心线程数和最大线程数固定为 1 ，并且是一个包装 ThreadPoolExecutor 的线程池，支持调用 finalize() 方法通知垃圾收集器时关闭线程池。</p><h2 id="运行示意图-1"><a href="#运行示意图-1" class="headerlink" title="运行示意图"></a>运行示意图</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/concurrent-threadpool-single.jpg" alt></p><h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><p>保证了所有任务都是被顺序执行，任意时间点最多会有一个任务处于活动状态。</p><h2 id="存在问题-1"><a href="#存在问题-1" class="headerlink" title="存在问题"></a>存在问题</h2><p>和 FixedThreadPool 是一样的问题，使用了无界的任务队列，当大量的任务提交到线程池，可能会造成任务堆积，而线程池的拒绝策略又处于失效状态，从而导致 OOM 。</p><h1 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h1><p>CachedThreadPool 属于缓冲线程池，会根据需要创建新线程。使用 Executors.newCachedThreadPool()  方法创建。</p><h2 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">            <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">            <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">            threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><p>核心线程数为 0 ，最大线程数为 <strong>Integer.MAX_VALUE</strong>，可以认为是无界的。使用的任务队列是没有容量的 <strong>SynchronousQueue</strong> ，即线程池使用这个队列意味着每次都要创建新的线程来处理任务。 keepAliveTime 被设置为 60L，单位为 TimeUnit.SECONDS ，意味着 CachedThreadPool 中的空闲线程等待任务的最大时长为 60s 。</p><p>CachedThreadPool 总体上有以下几个特点：</p><ol><li>无核心线程数，且最大的线程数是 <strong>Integer.MAX_VALUE</strong> 。</li><li>任务队列并不会存储任务，如果有空闲线程则队列会把任务交给空闲线程执行，如果没有空闲线程则迫使线程池尝试创建一个新的线程执行任务。这个特点是任务队列 <strong>SynchronousQueue</strong> 提供的。</li><li>由于 keepAliveTime 被设置为 60L，因此会在该时间内缓存线程，被缓存的线程会等待 <strong>SynchronousQueue</strong> 队列中的任务。</li><li>线程池长时间闲置得话也不会消耗什么资源，因为线程池中的线程都是可回收的，和固定线程数的线程池不同，核心线程会不断轮询任务（不开启回收核心线程）。</li></ol><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>一个比较特殊的阻塞队列，其本身不存储元素。每个插入操作必须等待另一个线程执行移除操作，反之亦然。如果使用该阻塞队列，只有当两个线程执行相反模式的操作才能配对成功，否则先执行的一方只能等待。下图是对线程池使用该队列处理任务过程的描述：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-syncronousqueue.jpg" alt></p><h2 id="运行示意图-2"><a href="#运行示意图-2" class="headerlink" title="运行示意图"></a>运行示意图</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/concurrent-threadpool-cacheed.jpg" alt></p><h2 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h2><p>处理大量短时间任务，或者负载较轻的服务器。</p><h2 id="存在问题-2"><a href="#存在问题-2" class="headerlink" title="存在问题"></a>存在问题</h2><p>由于允许创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程最终超过了操作系统的上限而无法创建新线程，容易导致 CPU 飙升和 OOM。</p><h1 id="Executors-创建线程问题"><a href="#Executors-创建线程问题" class="headerlink" title="Executors 创建线程问题"></a>Executors 创建线程问题</h1><p>Executors 工具类创建的线程池都会存在一定的风险，相比较而言手动创建线程池更加合理，因为可以根据不同的场景对线程池进行定制，来提升程序的性能和减少资源消耗。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>无论是使用 Executors 工具类还是定制线程池，都应该避免任务大量堆积，否则可能出现 OOM ；还应该避免过度创建新线程，否则可能由于创建大量线程导致系统崩溃。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇文章 &lt;a href=&quot;https://gentryhuang.com/posts/d7cef21d/&quot;&gt;线程池&lt;/a&gt; 对线程池的原
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>并发 - 线程池</title>
    <link href="https://gentryhuang.com/posts/d7cef21d/"/>
    <id>https://gentryhuang.com/posts/d7cef21d/</id>
    <published>2020-12-02T16:00:00.000Z</published>
    <updated>2021-01-04T06:57:56.894Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最初的时候并没有线程池的概念，而是先有线程。每个任务都需要对应一个线程，任务少的情况没有太大问题，任务过多就出现了各种性能和资源开销问题，更重要的是可创建线程的数量是有上限的，不可能无限的创建。在并发环境下，系统不能够确定在某一时刻有多少任务需要执行，有多少资源需要投入。</p><p>针对上述问题，于是诞生了线程池，用来平衡线程与系统资源之间的关系。<strong>线程池解决问题思路</strong>如下：</p><ol><li>对于反复创建线程开销问题，线程池采用固定数量的线程一直保持工作状态并能反复执行任务。</li><li>对于创建过多线程占用太多资源问题，线程池会根据需要创建线程，灵活地控制线程数量，避免使用过多资源。</li></ol><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>线程池是一种<strong>管理线程和任务的工具</strong>，是应用场景最多的并发框架之一，几乎所有需要异步或并发执行任务的应用程序都可以使用线程池，合理地使用线程池可以带来可观得性能提升和响应速度。具体好处如下：</p><ul><li>解耦：线程的创建与任务执行完全分开。</li><li>降低资源消耗：线程的复用降低了线程创建和销毁带来的资源消耗。</li><li>提高响应速度：大多情况下（线程池预热后），到达的任务可以不需要等待线程创建就能立即执行，消除了线程创建所带来的延迟，提升了响应速度。</li><li>便于线程管理：线程是稀缺资源，不能无限制地创建，使用线程池可以对线程进行统一分配、调优和监控。</li></ul><p>关于线程池的概述就介绍这么多，本篇文章介绍的线程池核心是 JDK 中提供的 <code>ThreadPoolExecutor</code> 类，具体涉及的接口和实现类如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-threadpoolexecutor-base-uml.jpg" alt></p><p>需要说明的是，关于<strong>Scheduled类型</strong>的线程池继承体系本篇文章没有介绍到，它是基于本篇文章着重介绍的 <strong>ThreadPoolExecutor</strong> 的扩展实现，支持时间纬度执行任务。</p><h1 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h1><p>线程池的设计没有办法直接采用一般意义上池化资源方案，而是采用<strong>生产者 - 消费者</strong>模式，将任务和线程解耦并不直接关联，从而良好的缓冲任务、复用线程，缓冲任务通过阻塞队列实现，工作线程从阻塞队列中获取任务以实现线程复用。线程池的使用方是生产者，线程池本身是消费者。至于为什么线程池没有采用一般意义上池化资源的设计方法，这个取决于线程对象的特殊性，线程有着特殊的生命周期，一旦一个线程启动执行任务就不能再次启动了。</p><h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><p>任务的执行不一定非要通过开启新线程，任务在线程执行之前它也是一个实现类，也有对应的方法。因此我们可以定义出方法级别调用和线程级别调用。</p><h3 id="线程级别调用"><a href="#线程级别调用" class="headerlink" title="线程级别调用"></a>线程级别调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">      &#125;).start();</span><br></pre></td></tr></table></figure><h3 id="方法级别调用"><a href="#方法级别调用" class="headerlink" title="方法级别调用"></a>方法级别调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((Runnable) () -&gt; &#123;</span><br><span class="line">          <span class="comment">//..</span></span><br><span class="line">        &#125;).run();</span><br></pre></td></tr></table></figure><p>线程池对任务的处理最终是通过方法级别调用的来完成，在后面分析源码的时候我们可以看到。</p><h2 id="Executor-框架"><a href="#Executor-框架" class="headerlink" title="Executor 框架"></a>Executor 框架</h2><p>Executor 是一个异步任务的框架，根据一组执行策略进行调用、调度、执行和控制，目的是提供一种将<strong>任务提交</strong>和<strong>任务执行</strong>分离的机制。 </p><h3 id="两级调度模型"><a href="#两级调度模型" class="headerlink" title="两级调度模型"></a>两级调度模型</h3><p>最早 Java 的线程既是任务体也是执行机制，从 JDK5 开始，把任务体和执行机制进行了分离。任务体包括 Runnable 和 Callable，而执行机制由 Executor 框架提供。</p><p>Java 线程会被一对一映射为操作系统线程，在 Java 线程启动时创建对应的操作系统线程，同样地，当该 Java 线程终止时对应的操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的 CPU 。对于计算复杂的应用，我们通常会将其拆解为若干个任务并交给 Java 多个线程，这个动作是由用户级别的调度器 Executor 框架完成的，它会将这若干个任务映射为对应数量的线程。在底层，操作系统内核将这些线程映射到硬件处理器上。由此可见，创建一个线程远比创建一个对象要复杂得多，不仅要在 JVM 堆中分配内存，还需要调用操作系统内核 API 来为线程分配资源，因此应该避免频繁创建和销毁。</p><p>这个过程属于两级调度模型，对应的示意图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-executor.jpg" alt></p><p>从示意图可看出，应用程序通过 Executor 框架控制上层的调度。而下层的调度由操作系统内核控制，应用程序是无法控制的。</p><h3 id="Executor-框架结构"><a href="#Executor-框架结构" class="headerlink" title="Executor 框架结构"></a>Executor 框架结构</h3><p>Executor 框架主要由三大部分组成，具体如下：</p><ul><li>任务体<br>包括 Runnable 接口和 Callable 接口及其实现。</li><li>任务的执行<br>包括任务执行机制的核心接口 Executor，继承 Executor 的 ExecutorService 接口和它的实现们。</li><li>异步计算结果<br>包括核心接口 Future 以及对应的实现们，特别是 FutureTask 实现类。</li></ul><h3 id="Executor-框架成员"><a href="#Executor-框架成员" class="headerlink" title="Executor 框架成员"></a>Executor 框架成员</h3><p>Executor 框架是线程池实现的基础，它的主要成员有 <code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code>、<code>Executors</code>、<code>Runnable</code>、<code>Callable</code> 以及 <code>Future</code> 。</p><p>下面正式进入到代码层面的介绍，定时任务实现类 <code>ScheduledThreadPoolExecutor</code> 继承自 <code>ThreadPoolExecutor</code> ，用于实现定时执行，本文暂不介绍它的实现。</p><h3 id="Executor-接口"><a href="#Executor-接口" class="headerlink" title="Executor 接口"></a>Executor 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Runable 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executor 接口仅定义了一个方法，参数是 Runnable 类型，该方法的目的是<strong>将任务提交和任务执行细节解耦</strong>。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需将任务提交到执行器 Executor 中，由执行器完成线程的调配和任务的执行。需要注意的是，该接口是没有返回值的，也就意味着无法判断提交的任务是否被线程池执行成功。</p><h3 id="ExecutorService-接口"><a href="#ExecutorService-接口" class="headerlink" title="ExecutorService 接口"></a>ExecutorService 接口</h3><p>ExecutorService 接口继承自 Executor 接口，一般我们自定义线程池时使用的就是这个接口，该接口中定义的方法加上继承过来的 <strong>execute</strong> 方法在很多场景中已经可以满足需求了。</p><p>该接口中的方法如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-executorservice-method.jpg" alt></p><p>上图中的方法大致分类如下：</p><ol><li>向线程池提交任务方法<blockquote><p><strong>submit</strong> 方法和前文中的 <strong>Executor</strong> 接口中的 <strong>execute</strong> 方法有所不同，虽然也是向线程池提交任务，但是有返回值 Future ，并且参数类型不仅支持 <strong>Runnable</strong> 类型还支持 Callable 类型。</p></blockquote></li><li>执行任务方法<blockquote><p><strong>invokeAll</strong> 方法用于执行多个任务，同时支持设置超时时间。<strong>invokeAny</strong> 方法用于执行多个方法中的一个即可，任务执行完成就可以返回，同样支持设置超时时间。这两类方法的底层需要依赖 execute 方法。</p></blockquote></li><li>关闭线程池方法<blockquote><p><strong>shutdown</strong> 和 <strong>shutdownNow</strong> 方法用于关闭线程池。</p></blockquote></li><li>判断线程池是否关闭<blockquote><p><strong>isShutdown</strong> 判断线程池是否已经开始了关闭工作，即是否执行了 shutdown 或者 shutdownNow 方法。注意，该方法返回 true 并不代表线程池此时已经彻底关闭了，仅说明线程池开始了关闭的流程，此时线程池中可能依然有线程在执行任务，队列中仍有等待被执行的任务。</p></blockquote></li><li>判断线程池是否终止方法<blockquote><p><strong>isTerminated</strong> 和 <strong>awaitTermination</strong> 方法用于判断线程池是否终止。只有在调用关闭方法后才有调用的意义。</p></blockquote></li></ol><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future 的继承体系如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-future-hierarchy.jpg" alt></p><p>由上图的UML可知，FutureTask 通过 RunnableFuture 间接实现了 Runnable 接口，因此 <code>Executor.execute</code> 方法支持将 FutureTask 提交到线程池。接下来介绍 AbstractExecutorService 抽象实现类就能很清晰看出 FutureTask 的作用。</p><h3 id="AbstractExecutorService-实现"><a href="#AbstractExecutorService-实现" class="headerlink" title="AbstractExecutorService 实现"></a>AbstractExecutorService 实现</h3><p>AbstractExecutorService 抽象类实现自 ExecutorService 接口，在其基础上实现了几个常用的方法，这些方法供子类进行调用。<strong>将执行任务的流程串联起来，保证下层的实现（如 ThreadPoolExecutor）只需关注执行任务的方法即可</strong>。具体方法如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-abstract-method.jpg" alt></p><p>由于 <strong>invokeAll</strong> 方法和 <strong>invokeAny</strong> 方法更多的是执行将任务提交给线程池前的工作，它们并没有将任务提交给线程池，需要通过 Executor 中的 execute 方法实现，而 execute 方法最终要交给具体子类实现。因此，不再对这两类方法展开说明。下面重点介绍下 <strong>newTaskFor</strong> 方法和 <strong>submit</strong> 方法。</p><h4 id="newTaskFor-方法"><a href="#newTaskFor-方法" class="headerlink" title="newTaskFor 方法"></a>newTaskFor 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractExecutorService</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 Runnable 包装成 FutureTask</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value    任务执行成功的返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 Callable 包装成 FutureTask</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，<strong>newTaskFor</strong>  方法用于将 Runnable 和 Callable 类型的任务统一包装成 FutureTask ，FutureTask 又间接继承了 Runnable 接口。我们知道，Runnable 的 <strong>void run()</strong> 方法是没有返回值的， 而 Callable 的 <strong>V call()</strong> 方法是有返回值的，但 Executor 中的 <strong>void execute(Runnable command)</strong>方法是不关心返回结果的，它只负责处理 Runnable 类型的任务。综上，不难看出 <strong>newTaskFor</strong> 方法就是为了屏蔽不同类型任务的差异，以达到统一交给 <strong>Executor.execute</strong> 执行的目的。下面我们继续看提交任务的另外一种方式。</p><h4 id="submit-提交任务"><a href="#submit-提交任务" class="headerlink" title="submit 提交任务"></a>submit 提交任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractExecutorService</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交 Runnable 任务，不需要返回结果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交 Runnable 任务，任务执行成功的返回结果为 result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交 Callable 任务，任务执行成功返回结果是Callable#call 方法返回值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Runnable 的 <strong>void run()</strong> 方法没有返回值，但是有的时候我们需要返回值，这个时候 <strong>submit</strong> 方法就可以实现，只需在该方法的第二个参数传入预期结果，当任务执行完成后会自动返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span></span><br></pre></td></tr></table></figure><p>此外，我们可以看出 <strong>submit</strong> 方法提交任务的能力是通过 <strong>execute</strong> 方法实现的。定义于最上层接口 Executor 中的 <strong>void execute(Runnable command)</strong> 方法不会返回执行结果，想要执行结果就需要通过 FutureTask 包装任务，然后将包装后的任务 <strong>FutureTask</strong> 交给 <strong>Executor.execute</strong> 方法执行，执行后的结果也会保存到 <strong>FutureTask</strong> 中。关于 Future 的继承体系不展开分析，下面概述下 submit 提交任务的原理。</p><ol><li>调用 newTaskFor 方法将 Runnable 和 Callable 类型的任务统一包装成 FutureTask 对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callable</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;      </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Runnable</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将 Runnable 适配成 Callable</span></span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Runnable task;</span><br><span class="line">        <span class="keyword">final</span> T result;</span><br><span class="line">        RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务执行还是调用 run 方法，返回结果是传入的预期值</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            task.run();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>包装的本质是将任务统一适配为Callable类型，因为Callable类型任务可以通过call方法返回执行结果。</li><li>当任务执行的时候，FutureTask 中的 run 方法会执行，这个过程是最关键的一步。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">           !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                        <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Callable&lt;V&gt; c = callable;</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">               V result;</span><br><span class="line">               <span class="keyword">boolean</span> ran;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 被适配的Runnable 和 Callable 方法级别调用</span></span><br><span class="line">                   result = c.call();</span><br><span class="line">                   ran = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                   result = <span class="keyword">null</span>;</span><br><span class="line">                   ran = <span class="keyword">false</span>;</span><br><span class="line">                   setException(ex);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (ran)</span><br><span class="line">                   <span class="comment">// 将执行结果保存到 FutureTask 中</span></span><br><span class="line">                   set(result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">           <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">           runner = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">           <span class="comment">// leaked interrupts</span></span><br><span class="line">           <span class="keyword">int</span> s = state;</span><br><span class="line">           <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">               handlePossibleCancellationInterrupt(s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>通过FutureTask#get方法从 FutureTask 中取出任务执行结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> s = state;</span><br><span class="line">      <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">          s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">      <span class="comment">// 从 FutureTask 中取出任务执行结果</span></span><br><span class="line">      <span class="keyword">return</span> report(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">int</span> s = state;</span><br><span class="line">      <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">          (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">     <span class="comment">// 从 FutureTask 中取出任务执行结果</span></span><br><span class="line">      <span class="keyword">return</span> report(s);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="提交任务方式"><a href="#提交任务方式" class="headerlink" title="提交任务方式"></a>提交任务方式</h4><p>最上层接口 Executor 中的 <strong>void execute(Runnable)</strong> 不需要获取结果，不会使用 FutureTask 包装任务。抽象实现类 AbstractExecutorService 中的 <strong>Future&lt;?&gt; submit()</strong> 需要获取结果，因此使用了 FutureTask 包装任务。</p><blockquote><p>需要获取任务结果用 submit 方法，不需要获取结果用 execute 方法。</p></blockquote><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-principle.jpg" alt></p><p>上图展示了线程池的运行机制，线程池运行机制主要分成两个部分，线程管理和任务管理。下面对线程池的主要处理流程进行说明：</p><ol start="0"><li>主线程提交任务到线程池。</li><li>如果当前线程池中的线程少于核心线程数，则创建新的线程来执行任务。</li><li>如果线程池中的线程达到或超过核心线程数，则将任务加入到阻塞队列中。</li><li>如果在第 2 步中无法将任务加入阻塞队列，则依据最大线程数创建新的线程来处理任务。</li><li>如果在第 3 步创建新线程会使线程池中线程数超出最大线程数，任务将被拒绝并使用饱和策略处理（拒绝策略）。</li><li>处理完任务的线程会自旋获取新的任务去执行，当线程获取不到任务时，线程会被回收（一般针对非核心线程）。</li></ol><p>其中第 1 步和第 3 步涉及到创建线程，该过程需要获取全局锁，因为关闭线程池也需要获取这个全局锁。当线程池完成了<strong>预热</strong>即核心线程数创建完毕，在一定程度上就不需要频繁创建线程，也就降低了获取全局锁的频次，对于线程池来说全局锁是一个严重的可伸缩瓶颈。关于流程中的概念下文会陆续说明。</p><h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>线程池核心实现就在 <strong>ThreadPoolExecutor</strong> 实现类中，该类实现了线程池所需的各个方法，包括最核心的 <strong>execute</strong> 方法。开发者可以基于该实现类来进行功能上的扩展，定时任务实现类 <code>ScheduledThreadPoolExecutor</code> 就是基于 <code>ThreadPoolExecutor</code> 扩展的功能。</p><p>在详细介绍 <code>ThreadPoolExecutor</code> 运行机制之前，我们先对其核心概念，属性、方法等进行简单介绍。</p><h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // 核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize, // 最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime, // 空闲线程存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit, // 空闲线程存活时间的单位</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory, // 线程工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                           RejectedExecutionHandler handler // 饱和策略</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;<span class="comment">//...&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>corePoolSize</strong><blockquote><p>核心线程数，线程池的基本大小。当提交一个任务到线程池时，线程池会创建一个基本线程来执行任务，即使其它空闲的基本线程能够执行新任务也会创建线程，只有线程池预热完毕（线程池中线程数达到核心线程数）才不再创建核心线程。</p></blockquote></li></ul><p><strong>特别说明：</strong></p><ol><li>核心线程并不是特指某一个或某几个线程，而是针对设置的核心线程数而言，任何一个线程都可以是核心线程。</li><li>corePoolSize 表示的是线程池的常驻线程数，如果设置为 0 则表示在没有任何任务时需要销毁线程池。如果大于 0 ，即使没有任务时也会保证线程池的线程数等于此值。</li><li>关于此值设置的合理性，如果设置的较小，则会频繁的创建和销毁线程（非核心线程）；设置过大，则会浪费资源。</li></ol><ul><li><p><strong>maximumPoolSize</strong></p><blockquote><p>最大线程数，线程池允许创建的最大线程数，最大线程数 = 核心线程数 + 非核心线程数。此值只有在任务比较多且阻塞队列放不下时才会用到。</p></blockquote></li><li><p><strong>keepAliveTime</strong></p><blockquote><p>空闲线程存活时间，线程池中的线程空闲时间超过该值也没任务可做那么就需要回收销毁。如果设置为 0，表示一旦空闲立即回收。该参数一般只会对非核心线程起作用，核心线程不会因为空闲太长时间而被关闭，当最大线程数等于核心线程数时，那么线程池在空闲的时候也不会销毁任何线程。但是可通过调用 <strong>allowCoreThreadTimeOut(true)</strong> 方法使核心线程数内的线程也可以被回收。</p></blockquote></li><li><p><strong>unit</strong></p><blockquote><p>和 keepAliveTime 参数一起使用，是时间单位。如：天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）等。</p></blockquote></li><li><p><strong>workQueue</strong></p><blockquote><p>用于存放等待执行的任务的阻塞队列，是 BlockingQueue 接口的实现。当线程池中的线程数大于等于核心线程数时才会用到该队列，注意和有没有空闲核心线程无关。</p></blockquote></li><li><p><strong>threadFactory</strong></p><blockquote><p>线程工厂，线程池中的线程就由它创建。如果没有设置就使用默认的线程工厂。</p></blockquote></li><li><p><strong>handler</strong></p><blockquote><p>饱和策略（拒绝策略），当阻塞队列和线程池都满了，说明线程池处于饱和状态，需要采取一种策略处理提交的新任务，默认是直接抛出异常。</p></blockquote></li></ul><p><strong>通过配置不同的参数，就可以创建出行为不同的线程池，这也是线程池高度灵活性的基础。</strong></p><h2 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">--- ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">     <span class="comment">//======= 约定使用32位表示线程池状态和数量，高3位表示状态 ，低29位表示数量 =============/</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池初始化状态码，状态为 RUNNING，线程数为 0</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * COUNT_BITS 为 29 (0001 1101)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池允许最大线程池临界值，1 * 2^29 = 536870912</span></span><br><span class="line"><span class="comment">      * 过程：（1）001 （2）左移29位得到001后跟29个0 -&gt; 0010 0000 0000 0000 0000 0000 0000 0000 （3）减去1得0001 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 运行状态：111 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 关闭状态：000 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN = <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 停止状态：001 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 整理状态：010 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING = <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 终止状态：011 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 获取线程池的状态。将整数 c 的低 29 位置为 0 就得到了线程池的状态</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &amp; ~CAPACITY;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 用于计算线程池中线程数量。将整数 c 的高 3 位置为 0，就得到了线程池中的线程数</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 获取线程池状态码</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> rs | wc;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 比较状态</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &lt; s;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 当前线程池是否处于运行状态</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 增加线程池中的线程数量</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndIncrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 减少线程池中的线程数量</span></span><br><span class="line"><span class="comment">      * Attempts to CAS-decrement the workerCount field of ctl.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndDecrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementWorkerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">         &#125; <span class="keyword">while</span> (!compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池阻塞队列</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池全局锁</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 1.用于保存和移除线程池创建的Worker，用来控制线程的生命周期。</span></span><br><span class="line"><span class="comment">      * 2.对于垃圾回收来说，即使Worker中封装的thread完成了任务的执行（包括异常情况），但是如果Worker不被回收那么thread仍然被强引用着。</span></span><br><span class="line"><span class="comment">      * 3.该Hash表是线程不安全的，操作时需要加全局锁</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 全局锁条件 - 条件队列</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 追踪线程池最大值，仅在获取到全局锁条件下执行</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池完成任务数量</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程工厂</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 饱和策略</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 保活时间，即最大允许空闲时间</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 是否允许核心线程被回收</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 核心线程池数，不会被回收，即 workers的最小值。除非设置 allowCoreThreadTimeOut 。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 最大线程数</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 默认的饱和策略，直接抛出异常</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> AbortPolicy();</span><br></pre></td></tr></table></figure><p>上面的属性都很重要，其中还包含了部分属性的操作方法，这些都会在下面的源码分析中不断出现。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Public constructors and methods 构造方法们</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">              Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">              threadFactory, defaultHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">              <span class="comment">// 当没有指定线程工厂时，使用默认的线程创建工厂</span></span><br><span class="line">              Executors.defaultThreadFactory(), handler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">              maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">              maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">              keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">              <span class="keyword">null</span> :</span><br><span class="line">              AccessController.getContext();</span><br><span class="line">      <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">      <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">      <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">      <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">      <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">      <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>创建线程池时如果不指定线程工厂则会使用默认的线程工厂，默认线程工厂创建的线程都属于同一个线程组，拥有相同的优先级，并且都是非守护线程，具体代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">--- Executors</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            <span class="comment">// 线程组</span></span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">"-thread-"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 创建线程</span></span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 设置为非守护线程</span></span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 设置优先级</span></span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>线程池采用的是 <strong>Integer.SIZE</strong> 32 位的整数来存放线程池的<strong>状态</strong>和池中的<strong>线程数</strong>，其中高 3 位表示线程池状态即可以表示 7 种状态，低 29 位表示线程数即可以存放 5 亿多个线程。这种设计思想对整数赋予了双重角色，通过高低位的不同，既表示线程池状态，又表示工作线程数目，这是一个典型的高效优化。要知道用一个变量存储两个值，可以避免在做相关决策时出现不一致的情况，省去了占用锁资源去维护两个变量的一致性。这种方式在其它框架中也多有使用，如 Dubbo 协议就使用 16 个字节共 128 位，每一位用来表示不同意义的数值。</p><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>线程池的状态表示如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-threadpoolexecutor-ctl.jpg" alt></p><p>注意，<strong>线程池的状态并非用户显示配置（用户调用关闭方法除外），而是随着线程池的运行由内部自行维护，和线程的执行密切相关</strong>，下面分别说明线程池的状态及其状态流转。</p><h4 id="RUNNING"><a href="#RUNNING" class="headerlink" title="RUNNING"></a>RUNNING</h4><ul><li><strong>状态说明</strong><br>线程池处于 RUNNING 状态允许接受新的任务，处理任务队列中的任务。</li><li><strong>状态转换</strong><br>线程池一旦被创建就处于 RUNNING 状态，并且线程池中的线程数为 0 。</li></ul><h4 id="SHUTDOWN"><a href="#SHUTDOWN" class="headerlink" title="SHUTDOWN"></a>SHUTDOWN</h4><ul><li><strong>状态说明</strong><br>线程池处于 SHUTDOWN 状态时，不再接收新任务，但能处理任务队列中的任务。</li><li><strong>状态转换</strong><br>调用线程池的shutdown()方法时，线程池由RUNNING -&gt; SHUTDOWN 。</li></ul><h4 id="STOP"><a href="#STOP" class="headerlink" title="STOP"></a>STOP</h4><ul><li><strong>状态说明</strong><br>线程池处在 STOP 状态时，不能接收新任务，也不处理任务队列中的任务，并且会<strong>中断</strong>正在处理任务的线程。</li><li><strong>状态转换</strong><br>调用线程池的shutdownNow()方法时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP 。</li></ul><h4 id="TIDYING"><a href="#TIDYING" class="headerlink" title="TIDYING"></a>TIDYING</h4><ul><li><strong>状态说明</strong><br>所有的任务已终止，线程池中线程数为 0 ，线程池会变为TIDYING状态（线程池内部自动更新状态）。当线程池变为TIDYING状态后，会紧接着执行钩子方法terminated()。若用户需要在线程池变为TIDYING时，进行相应的处理，可以通过重写terminated()方法来实现。 </li><li><strong>状态转换</strong><br>当线程池在 SHUTDOWN 状态下时，阻塞队列为空并且线程池中线程数为 0 时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在 STOP 状态下，线程池中线程数为 0 时，就会由STOP -&gt; TIDYING。</li></ul><h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><ul><li><strong>状态说明</strong><br>线程池彻底终止，就变成 TERMINATED 状态。</li><li><strong>状态转换</strong><br>线程池处在TIDYING状态时，执行完 terminated() 方法之后，就会由 TIDYING -&gt; TERMINATED。</li></ul><p>下面进行小结，线程池状态及流转（线程池的生命周期）如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-status.jpg" alt></p><h2 id="任务执行机制"><a href="#任务执行机制" class="headerlink" title="任务执行机制"></a>任务执行机制</h2><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>任务调度是线程池的主要入口，所有任务的调度都是由<strong>execute方法</strong>完成的，当用户提交了一个任务后，任务调度阶段将决定如何执行该任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 任务体不允许为 null</span></span><br><span class="line">     <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取线程池的状态码,该值包含了线程池的状态和线程数</span></span><br><span class="line">     <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 1 如果当前线程数少于核心线程数，则创建一个 Worker 来执行任务，即创建一个线程并将 command 作为该线程的第一个任务</span></span><br><span class="line">     <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">         <span class="comment">// 返回 false 说明线程池不允许创建线程，可能原因：（1）线程池关闭（2）当前线程数已经达到临界值</span></span><br><span class="line">         <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         <span class="comment">// 创建失败，重读线程池状态码</span></span><br><span class="line">         c = ctl.get();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2 如果线程池处于运行状态，则尝试将任务添加到阻塞队列 workQueue 中</span></span><br><span class="line">     <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">         <span class="comment">// 再次获取线程池状态码</span></span><br><span class="line">         <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">         <span class="comment">// 双重检查，再次判断线程池状态。如果线程状态变了（非运行状态）就需要从阻塞队列移除任务，同时执行拒绝策略。防止线程池关闭。</span></span><br><span class="line">         <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">             reject(command);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 如果线程池状态仍然是运行状态，并且线程池为空则创建一个非核心线程来执行任务，防止线程提交到阻塞队列后线程都关闭了。</span></span><br><span class="line">             <span class="comment">// 一般这种情况是设置核心线程数为 0 </span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">             addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 3 如果任务队列满了，则根据 maximumPoolSize 创建非核心线程。如果创建失败，说明当前线程数已经达到 maximumPoolSize 或线程池关闭，需要执行拒绝策略</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">         reject(command);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>execute 方法逻辑体现了提交任务到线程池的流程</strong>，上面代码已经详细注释。需要强调的是，符合将任务加入阻塞队列中的情况，会进行双重检查线程池的状态，因为是直接将任务入队，和前后两种情况不一样，即使任务成功排队，也有可能出现线程池关闭或线程池为空的情况。</p><p>下面通过一张图进行阐述正常流（不考虑线程池关闭等情况）的流程：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-process.jpg" alt></p><h3 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h3><p>任务缓冲是线程池管理任务的核心部分，通过一个阻塞队列来实现。<strong>线程池的本质是对任务和线程的管理</strong>，而做到这一点关键的思想是将任务和线程解耦，阻塞队列缓冲任务，工作线程自旋从阻塞队列中获取任务。</p><p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。</p><p>线程池中的阻塞队列参数非常重要，<strong>不同的阻塞队列对线程池有不同影响</strong>，下面对线程池常用的阻塞队列进行说明。</p><ul><li><p><strong>ArrayBlockingQueue</strong><br>基于数组结构的有界阻塞队列，该队列按照先进先出原则对元素进行排序。</p></li><li><p><strong>LinkedBlockingQueue</strong><br>基于链表结构的无界阻塞队列，该队列按照先进先出规则对元素进行排序。此队列的默认长度为 <strong>Integer.MAX_VALUE</strong>，使用该队列作为任务队列有容量危险。</p></li><li><p><strong>SynchronousQueue</strong><br>一个比较特殊的阻塞队列，其本身不存储元素。每个插入操作必须等待另一个线程执行移除操作，反之亦然。如果使用该阻塞队列，只有当两个线程执行相反模式的操作才能配对成功，否则先执行的一方只能等待。下图是对线程池使用该队列处理任务过程的描述：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-syncronousqueue.jpg" alt></p></li><li><p><strong>PriorityBlockingQueue</strong><br>支持优先级排序的无界阻塞队列，默认自然排序规则，不能保证同优先级元素的顺序。</p></li><li><p><strong>DelayQueue</strong><br>一个实现 PriorityBlockingQueue 实现延迟获取的无界队列，在创建元素时可以指定多久才能从队列中移除，只有延时期满后才能从队列中获取元素。</p></li><li><p><strong>LinkedBlockingDeque</strong><br>一个由链表结构构成的双向阻塞队列。队列头部和尾部都可以添加和移除元素。</p></li></ul><h3 id="任务申请"><a href="#任务申请" class="headerlink" title="任务申请"></a>任务申请</h3><p>任务执行有两种情况，一种是任务直接交给新创建的线程执行。另一种是线程执行 <strong>getTask</strong> 方法从任务队列中获取任务并执行，执行完任务的线程会继续尝试从任务队列中申请任务再去执行。第一种情况仅出现在用户提交任务到线程池，线程池为该任务创建线程的时候。第二种情况是线程执行任务最多的情况，包括线程池存在的线程执行任务，创建的非核心线程执行任务。</p><p>任务申请的核心方法 <strong>getTask</strong> 是配合 <strong>Worker线程</strong> 工作的，用于 <strong>Worker线程</strong> 拉取任务队列，下面对该方法进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 返回null 表示可以对当前线程进行回收</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取线程池状态码</span></span><br><span class="line">         <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">         <span class="comment">// 获取线程池状态</span></span><br><span class="line">         <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 线程池状态为SHUTDOWN且队列为空 或 线程池状态为 STOP，应该回收线程。这个条件不仅可以回收非核心线程，也可以回收核心线程。todo 核心线程唯一回收条件</span></span><br><span class="line">         <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">             <span class="comment">// 减少线程池中的线程数</span></span><br><span class="line">             decrementWorkerCount();</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 线程池中的线程数</span></span><br><span class="line">         <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 是否需要进行超时控制。即允许核心线程数内的线程回收，或线程池中的线程数超过了核心线程数，那么有可能发生超时关闭</span></span><br><span class="line">         <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 控制线程池中线程数的关键</span></span><br><span class="line">         <span class="comment">//1. wc &gt; maximumPoolSize ，可能是在此方法执行阶段同时执行 setMaximumPoolSize 方法修改了最大值。</span></span><br><span class="line">         <span class="comment">//2. timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，且线程上一轮获取任务超时</span></span><br><span class="line">         <span class="comment">//3. 结果：如果线程池中的线程数大于最大线程数或获取任务超时（不设置 allowCoreThreadTimeOut，核心线程没有超时概念），并且（线程数 &gt; 1 或 任务队列为空），则应该回收当前线程。</span></span><br><span class="line">         <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">             <span class="comment">// 减少工作线程数</span></span><br><span class="line">             <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 根据timed来判断：</span></span><br><span class="line">             <span class="comment">// 1. 如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务则返回null</span></span><br><span class="line">             <span class="comment">// 2. 否则通过take方法获取任务，如果队列为空则take方法会阻塞直到队列不为空</span></span><br><span class="line">             Runnable r = timed ?</span><br><span class="line">                     <span class="comment">// 超时获取任务，因为线程超时要被回收。如果线程在等待的过程发生了中断，会抛出中断异常</span></span><br><span class="line">                     workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                     <span class="comment">// 不需要超时，如果线程在等待的过程发生了中断，会抛出中断异常</span></span><br><span class="line">                     workQueue.take();</span><br><span class="line">             <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                 <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 如果 r == null ，说明获取任务超时</span></span><br><span class="line">             timedOut = <span class="keyword">true</span>;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">             <span class="comment">// 获取任务时当前线程发生中断，重置超时标记并重试</span></span><br><span class="line">             timedOut = <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述方法用于从任务队列中<strong>不断</strong>拉取待执行的任务，具体执行流程如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-gettask-process.jpg" alt></p><p>下面对主要逻辑进行说明：</p><ol><li>该方法返回 null 时，表示当前线程可以被回收了，包括核心线程。这也是该方法多次判断的原因，控制线程池中线程数量，进而控制线程池的状态。</li><li>在没有设置 allowCoreThreadTimeOut 时，核心线程数的线程会阻塞等待任务，不会被回收。</li><li>超时回收，在 keepAliveTime 对应的具体时间内都没有任务，应该回收非核心线程。</li><li>以下情况需要返回 null，回收当前线程。<ul><li>线程池处于 STOP 状态。</li><li>线程池处于 SHUTDOWN 状态，且阻塞队列为空。</li><li>线程池中的线程数大于最大线程数。</li><li>线程获取任务超时再次重试时，仍为可回收线程。</li></ul></li></ol><p>getTask 方法还是比较复杂的，整个逻辑中进行了多次判断，目的是控制线程的数量，进而维护线程池的状态。需要特殊说明的是，当线程获取任务超时时并没有立刻回收该线程，而是让线程重试，这么做是为了防止该线程可能会成为核心线程，避免误回收，如果误回收在后续流程中还需要重新创建线程，因此重试一次代价会小一些。</p><h3 id="任务执行-1"><a href="#任务执行-1" class="headerlink" title="任务执行"></a>任务执行</h3><p>任务执行是 <strong>Worker线程</strong> 的工作，我们会在下面详细介绍。 </p><h3 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h3><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>线程池的拒绝策略属于一种限流保护机制，防止线程池崩溃。线程池拒绝任务的时机如下：</p><ol><li>执行关闭方法后线程池处于关闭状态及以上状态</li><li>线程池处于运行状态，但是没有能力（阻塞队列已满，线程数达到最大值）处理新提交的任务了。</li></ol><p>JDK 内置了 4 种拒绝策略，默认使用 AbortPolicy 策略。拒绝策略如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-rejectedexecutionhandler.jpg" alt></p><h4 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 丢弃任务并抛出异常（默认策略）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 直接抛出异常</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> e te</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                   <span class="string">" rejected from "</span> +</span><br><span class="line">                   e.toString());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>AbortPolicy 策略是线程池默认的拒绝策略，在任务不能再提交到线程池时抛出异常，能够及时反馈程序的运行状态。对于比较核心的业务推荐使用此拒绝策略，因为当系统不能承载更大的并发流量时，业务方能够及时地通过异常发现。</p><h4 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 由提交任务的线程自己来执行任务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 只要线程池没有被关闭，就由提交任务的线程自己来执行这个任务。</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 线程池没有关闭</span></span><br><span class="line">          <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">              <span class="comment">// 方法级别调用</span></span><br><span class="line">              r.run();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>CallerRunsPolicy 策略是由提交任务的线程处理任务，此策略适合让所有任务都执行完毕。</p><h4 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 直接忽略任务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 直接忽略</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>DiscardPolicy 策略会直接丢弃任务，并且不会抛出异常。此策略会导致业务方无法发现异常，不建议核心业务采用此策略。</p><h4 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将阻塞队列头的任务扔掉，然后将当前任务提交到线程池尝试执行。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将队列都任务移除，并将当前任务提交到线程池</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">               e.getQueue().poll();</span><br><span class="line">               e.execute(r);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>DiscardOldestPolicy 策略会丢弃队列最前面的任务，然后重新提交被拒绝的任务。这种策略存在丢失任务的风险。</p><p>自定义拒绝策略只需要实现 RejectedExecutionHandler 接口，重写 rejectedExecution 方法即可。如果不自定义拒绝策略，线程池将使用默认的拒绝策略。</p><h1 id="Worker线程管理"><a href="#Worker线程管理" class="headerlink" title="Worker线程管理"></a>Worker线程管理</h1><p>前文在介绍任务执行机制的时候涉及到 Worker线程，线程池维护的线程模块其实就是一组 <strong>Worker对象</strong> ，下面我们就来看看 ThreadPoolExecutor 的内部类 Worker 。</p><h2 id="Worker线程"><a href="#Worker线程" class="headerlink" title="Worker线程"></a>Worker线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker持有的线程，即任务执行的真正线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主线程提交任务到线程池，任务就会存放到这里。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于存放当前线程完成的任务数。注意和 completedTaskCount 的区别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker 唯一的构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask 任务，可能为 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// 设置状态值为 -1，防止在启动线程之前，线程就被中断。因为AQS中默认的 state 为 0，Worker中实现的 tryAcquire 方法内存值就是 0，修改值为 1</span></span><br><span class="line">        setState(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 使用工厂创建线程，注意创建出来的线程的任务体就是 Worker 本身。这意味着当线程启动时，Worker#run方法就会执行</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker 实现了 Runnable 接口，重写了run() 方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里调用了外部类的 runWorker 方法</span></span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------- Worker继承了AQS类，下面的核心方法是重写了AQS的方法，使用独占锁获得执行权，不支持锁的重入 -----------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 独占式获取资源。AQS 中默认的 state 为 0。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * unlock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中断线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池在创建线程时，会将线程封装成工作线程Worker，目的是<strong>管理线程的状态并维护线程的生命周期</strong>。</p><p><strong>工作线程Worker 比较特别，下面对其关键点进行说明：</strong></p><ul><li>继承了 AQS ，实现了一套独占锁机制。<blockquote><p>1.Worker 并没有直接使用可重入锁 ReentrantLock ，而是通过继承 AQS 实现了不可重入的独占锁，目的就是通过不可重入的特性判断 Worker 中封装线程的执行状态。<br>2.在线程执行任务期间会加 Worker非重入锁，表示当前线程正在执行任务中，并不是处于空闲状态，不应该中断该线程。<br>3.如果线程不是独占锁的状态则表明该线程处于空闲状态，可以对该线程进行中断</p></blockquote></li></ul><ol start="2"><li><p>实现了 Runnable 接口，它是一个任务体并重写的 run 方法，该方法是线程池执行任务的关键。</p><blockquote><p>在创建 Worker 成功后，紧接着就会启动 Worker 封装的真实 Thread ，启动成功后 Worker 中的 run 方法就会执行。</p></blockquote></li><li><p>内部封装了实际执行任务的线程。 </p><blockquote><p>内部封装的线程是线程池的工厂创建出来的，它的使命就是执行 Worker 中的 run 方法中的任务。那业务任务谁来执行？ 同样地，也是该线程执行，只不过它使用的是方法级别的调用。</p></blockquote></li><li><p>内部封装了初始化任务体</p><blockquote><p>Worker 使用 firstTask 保存传入的第一个任务，该任务允许为null。如果该任务非空，那么线程就会在启动后优先执行这个任务，一般对应于核心线程的创建；如果该任务为空，对应于非核心线程的创建，用于去执行任务队列中的任务。</p></blockquote></li><li><p>线程复用</p><blockquote><p>一个 Worker 对应线程池中的一个线程，线程复用的逻辑实现是在 Worker 类中的 run 方法中执行 runWorker 方法。由上面的第 2、3 两个说明，很容易得出，当 Worker 中的线程启动后会执行 Worker 这个任务体的 run 方法，进而该线程就会执行 runWorker 方法，然后进入到 while 自旋，实现线程的复用。</p></blockquote></li><li><p>线程回收</p><blockquote><p>线程池管理着线程的生命周期，需要对长时间空闲的线程、启动失败的线程以及执行任务出现异常的线程进行回收。线程池使用了HashSet这个Hash表去持有Worker的引用，这样可以通过添加引用和移除引用的操作来控制线程的生命周期。</p></blockquote></li></ol><p>前文对线程池的任务执行机制进行了介绍，下图是 <strong>Worker</strong> 执行任务的模型：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-worker-process-simple.jpg" alt></p><h2 id="新增线程"><a href="#新增线程" class="headerlink" title="新增线程"></a>新增线程</h2><p>如果说 <strong>execute</strong> 方法逻辑体现了提交任务到线程池的流程，那么 <strong>addWorker</strong> 方法则体现了线程池执行任务的开端，即接收任务、创建线程、启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//-------------------------------  1 创建线程前的检测工作 -------------------------------------/</span></span><br><span class="line">     <span class="comment">// for 跳出标志</span></span><br><span class="line">     retry:</span><br><span class="line">     <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//------------------------- 1.1 创建线程前，对线程池状态和队列进行检查，判断是否还可以创建线程 ----------------------/</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取线程池状态码</span></span><br><span class="line">         <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取线程池状态</span></span><br><span class="line">         <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          * 如果线程池状态范围是：[SHUTDOWN，TERMINATED]，出现下列任一种情况都不允许创建Worker:</span></span><br><span class="line"><span class="comment">          * 1 firstTask != null</span></span><br><span class="line"><span class="comment">          * 2 workQueue 为空</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          *小结：</span></span><br><span class="line"><span class="comment">          * 1 线程池处于 SHUTDOWN 状态时，不允许提交任务，但是已经存在的任务需要继续执行。</span></span><br><span class="line"><span class="comment">          *  1.1 当 firstTask == null 时且阻塞队列不为空，说明非提交任务创建线程，执行阻塞队列中的任务，允许创建 Worker</span></span><br><span class="line"><span class="comment">          *  1.2 当 firstTask == null 但阻塞队列为空，不能创建 Worker</span></span><br><span class="line"><span class="comment">          *  1.3 当 firstTask ！= null 时，不能创建</span></span><br><span class="line"><span class="comment">          * 2 线程池状态大于 SHUTDOWN 状态时，不允许提交任务，且中断正在执行的任务。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                 !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">//---------------------------- 2 创建线程前，对线程池中线程数检查，判断是否还可以创建线程 ---------------------/</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">             <span class="comment">// 获取线程池线程数</span></span><br><span class="line">             <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 判断线程池线程数是否达到边界值：1 临界值 2 核心线程数或最大线程数</span></span><br><span class="line">             <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 增加线程池中线程数如果成功，则表示创建 Worker 前的校验工作完成，可以进行创建 Worker 流程了。</span></span><br><span class="line">             <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                 <span class="keyword">break</span> retry;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 增加线程数失败，说明可能其它线程也在尝试创建Worker，就需要回到起点，重新校验。</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">//并发影响，需要重新获取线程池状态码</span></span><br><span class="line">             c = ctl.get();</span><br><span class="line"></span><br><span class="line">             <span class="comment">//线程池状态是否改变，改变了则需要重头校验，否则只需要再次校验线程数即可</span></span><br><span class="line">             <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                 <span class="keyword">continue</span> retry;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//----------------------------------   创建 Worker 流程     ------------------------------------/</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// Worker 中的线程是否启动的标志</span></span><br><span class="line">     <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Worker 是否添加到 workers 集合中的标志</span></span><br><span class="line">     <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     Worker w = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 创建 Worker，将任务传入。注意，如果是非提交任务创建Worker的话，firstTask 为null</span></span><br><span class="line">         w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将创建的Worker中的线程临时保存到 t，这个是真正的线程，Worker 只是对线程进行了包装。</span></span><br><span class="line">         <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Worker 中的线程创建成功</span></span><br><span class="line">         <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 加锁，注意这个锁的粒度是全局的。也就是说，当这里获取到锁，线程池不能关闭，因为线程池关闭也需要锁。</span></span><br><span class="line">             <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">             mainLock.lock();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 再次获取线程池状态</span></span><br><span class="line">                 <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 如果线程池是运行状态，或者是关闭状态且传入的任务为null(不接收新任务，但是会继续执行任务队列中的任务)，符合条件。</span></span><br><span class="line">                 <span class="comment">// 此外都不符合条件，线程池不会维护当前创建的Worker线程，该Worker线程由于没有被引用最后会被JVM回收</span></span><br><span class="line">                 <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 提前检查新创建的Worker中的线程是否是启动状态</span></span><br><span class="line">                     <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 将新创建的 Worker 加入到 workers 集合，意味着线程池持有当前 Worker 的引用，当前 Worker 不会被 GC。</span></span><br><span class="line">                     workers.add(w);</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 更新 largestPoolSize 的值，该值用于追踪线程池中出现过的最大线程数量</span></span><br><span class="line">                     <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                     <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                         largestPoolSize = s;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 更新标记值</span></span><br><span class="line">                     workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="comment">// 全局锁释放，注意全局锁释放的时机</span></span><br><span class="line">                 mainLock.unlock();</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// Worker线程只有添加到Worker集合后才能启动线程</span></span><br><span class="line">             <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                 <span class="comment">// 启动Worker中的线程，这一步的意义重大</span></span><br><span class="line">                 t.start();</span><br><span class="line">                 <span class="comment">// 标记线程启动成功</span></span><br><span class="line">                 workerStarted = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 线程加入线程池失败或启动失败，需要清理工作</span></span><br><span class="line">         <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">             addWorkerFailed(w);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> workerStarted;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>线程池通过上述方法增加线程，该方法仅完成创建线程并使它运行，最后返回是否成功。至于是哪种情况下增加线程，该方法并不关心。下图是新增Worker线程的流程图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-addworker-process.jpg" alt></p><p>还需要强调一点，该方法只是创建并启动线程，线程还没有执行任务。再分析执行任务逻辑之前，先来看看创建 Worker 的异常流程，<code>addWorkerFailed</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得全局锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 从 workers 缓存中移除启动失败的 Worker</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少线程池中线程数，因为在此之前递增了</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试终止线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法名非常直观，就是执行 addWorker 失败的处理方法。该方法主要做了以下工作：</p><ol><li>从 Worker 缓存集合中移除启动失败的 Worker 便于 GC 。</li><li>递减线程池中线程数，在校验是否允许创建 Worker 流程中递增了线程数，这里需要递减。</li><li>尝试终止线程池，新增线程失败的原因可能是线程池状态处于[SHUTDOWN,TERMINATED]，这种情况下要尝试更新线程池的状态为终止状态。</li></ol><h2 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h2><p>Worker 中的线程启动成功后，其 run 方法会调用 <strong>runWorker</strong> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Worker 实现了 Runnable 接口，重写了run() 方法。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里调用了外部类的 runWorker 方法</span></span><br><span class="line">     runWorker(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>runWorker 方法是执行提交任务和阻塞队列中等待任务的核心实现，接下来我们分析它的具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 当前线程，即 w 中的线程</span></span><br><span class="line">      Thread wt = Thread.currentThread();</span><br><span class="line">      <span class="comment">// 获取该线程的第一个任务，可能没有。如果有的话，优先执行该任务。</span></span><br><span class="line">      Runnable task = w.firstTask;</span><br><span class="line">      w.firstTask = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将 state 值由由 -1 设置为 0，这样就可以允许中断了 。</span></span><br><span class="line">      w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 循环调用getTask() 方法从任务队列中获取任务并执行</span></span><br><span class="line">          <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123; </span><br><span class="line"></span><br><span class="line">              <span class="comment">// 申请Worker非重入锁，标志着自己处于工作状态。</span></span><br><span class="line">              w.lock();</span><br><span class="line"></span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * 该if判断保证了：如果线程池正在停止，需要确保当前线程是中断状态，否则要保证当前线程不是中断状态。</span></span><br><span class="line"><span class="comment">               *</span></span><br><span class="line"><span class="comment">               * 出现以下任何一种情况都需要中断线程：</span></span><br><span class="line"><span class="comment">               * 1 如果线程池状态大于等于 STOP，并且当前线程没有被中断</span></span><br><span class="line"><span class="comment">               * 2 如果当前线程被中断了并且线程池状态大于等于 STOP 状态（恢复中断标识）</span></span><br><span class="line"><span class="comment">               * 使用interrupted()方法判断线程是否被中断，该方法会清除中断标志位，既确保了在线程RUNNING或者SHUTDOWN状态时线程是非中断状态的，又支持了线程池是STOP状态下的判断</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">              <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                      (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                  <span class="comment">// 中断当前线程，进行中断标志复位</span></span><br><span class="line">                  wt.interrupt();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// ThreadPoolExecutor 的扩展方法</span></span><br><span class="line">                  beforeExecute(wt, task);</span><br><span class="line"></span><br><span class="line">                  Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 执行目标任务,方法级别调用。</span></span><br><span class="line">                      task.run();</span><br><span class="line"></span><br><span class="line">                  &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                      thrown = x;</span><br><span class="line">                      <span class="keyword">throw</span> x;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                      thrown = x;</span><br><span class="line">                      <span class="keyword">throw</span> x;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                      thrown = x;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      <span class="comment">// ThreadPoolExecutor 的扩展方法</span></span><br><span class="line">                      afterExecute(task, thrown);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="comment">// 置空 task,为下一个任务做准备</span></span><br><span class="line">                  task = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">// 更新Worker线程完成任务数量</span></span><br><span class="line">                  w.completedTasks++;</span><br><span class="line">                  <span class="comment">// 释放 Worker非重入锁</span></span><br><span class="line">                  w.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// while 循环没有出现异常，completedAbruptly 才会被设置为 false</span></span><br><span class="line">          completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 线程退出 while 循环后需要进行回收，可能情况如下：</span></span><br><span class="line"><span class="comment">           * 1 任务队列中已经没有要执行的任务了</span></span><br><span class="line"><span class="comment">           * 2 任务执行过程出现异常</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          processWorkerExit(w, completedAbruptly);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>线程执行任务的流程如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-runworker-process.jpg" alt></p><p>执行任务逻辑已经详细注释，下面对该方法简要分析：</p><ol><li>线程执行任务有两个途径，通过取 Worker 的 firstTask 或者调用 getTask 方法从任务队列中取出待执行的任务。</li><li>线程复用得益于对线程的封装，封装后的线程不再局限于执行当前任务，而是while循环不断地通过getTask()方法获取任务，然后执行任务，从而实现了线程的复用。</li><li><strong>线程在执行任务前会先申请对应 Worker 独占锁，标志自己处于工作状态，不应该中断该线程</strong>，这是对线程封装的好处。</li><li>当线程池状态大于等于 STOP 状态，要保证当前线程是中断状态，否则要保证当前线程不是中断状态。</li><li>线程通过调用任务的 <strong>run</strong> 方法来执行对应的任务，而不是启动线程，这个正是前文特别说明的<strong>方法级别调用</strong>。 </li><li>当 Worker 封装的线程退出循环后，执行 <strong>processWorkerExit()</strong> 方法对该线程进行回收。</li><li>可以通过重写 beforeExecute() 和 afterExecute() 方法来实现 ThreadPoolExecutor 的扩展功能。</li></ol><h3 id="再谈线程复用"><a href="#再谈线程复用" class="headerlink" title="再谈线程复用"></a>再谈线程复用</h3><p>线程池会使用一定数量的线程去执行任务，通常线程数量远小于任务数量，针对这种情况线程池通过线程复用的方式让同一个线程去执行不同的任务。我们知道线程池是将线程和任务解耦，摆脱了一个任务必须一个线程的限制，这也是线程复用的必要条件。线程池使用<strong>Worker</strong>对线程的封装，也就是<strong>Worker线程</strong>，线程启动后会去执行一个<strong>循环任务</strong>，该任务可以执行线程的<strong>首个任务</strong>和<strong>轮询任务队列中的任务</strong>，线程通过调用任务的 <strong><code>run</code></strong> 方法实现任务的执行。</p><p>线程复用的逻辑主要在 runWorker 方法中，该方法是 Worker 类的 run 方法中的逻辑，Worker 中封装的线程启动后会执行 Worker 的 run 方法进而执行 runWorker 方法。整个逻辑简化后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">runWorker(Worker w) &#123;</span><br><span class="line">    <span class="comment">// 线程首个任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    <span class="comment">// 轮询任务队列中的任务</span></span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 线程执行任务的 run 方法，即方法级别的调用</span></span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            task = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程回收"><a href="#线程回收" class="headerlink" title="线程回收"></a>线程回收</h2><p>线程池中线程的销毁依赖JVM自动回收，Worker 线程结束任务或异常退出后，Worker 会主动清除自身在线程池中的引用，这意味着线程池可以回收该线程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 线程执行任务抛出了异常</span></span><br><span class="line">       <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">           <span class="comment">// 减少线程池中线程数量</span></span><br><span class="line">           decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取全局锁</span></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">       mainLock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 累计线程池完成的任务数量</span></span><br><span class="line">           completedTaskCount += w.completedTasks;</span><br><span class="line">           <span class="comment">// 将线程引用移出线程池</span></span><br><span class="line">           workers.remove(w);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 释放全局锁</span></span><br><span class="line">           mainLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 尝试终止线程池</span></span><br><span class="line">       tryTerminate();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果线程池状态小于 STOP 状态，说明还可以处理任务</span></span><br><span class="line">       <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 1. 当前线程处理任务没有出现异常</span></span><br><span class="line">           <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">               <span class="comment">// 获取核心线程数，如果设置了允许回收核心线程数，则返回 0，否则取核心线程数</span></span><br><span class="line">               <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 1.1 如果 allowCoreThreadTimeOut=true，并且任务队列中有任务，至少保留一个worker线程</span></span><br><span class="line">               <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; !workQueue.isEmpty())</span><br><span class="line">                   min = <span class="number">1</span>;</span><br><span class="line">              </span><br><span class="line">               <span class="comment">// 1.2 如果 allowCoreThreadTimeOut=false，线程池中线程数不能少于 corePoolSize</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// 线程池中线程数大于等于 min ，说明无需创建线程。</span></span><br><span class="line">               <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                   <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 执行到这里的可能情况：</span></span><br><span class="line">           <span class="comment">// 1 线程池中没有线程执行任务队列中的任务，需要创建线程取执行。（核心线程数设置为 0 或 允许回收核心线程）</span></span><br><span class="line">           <span class="comment">// 2 线程池中线程数小于核心线程数，需要创建线程补充核心线程数。（核心线程数 &gt; 0）</span></span><br><span class="line">           <span class="comment">// 3 当前线程执行任务过程出现异常，而且当前线程被回收了，为了确保有线程执行任务，这里需要创建线程。</span></span><br><span class="line">           addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>线程回收流程如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-worker-exit.jpg" alt></p><p>需要注意的是，线程销毁工作不是只有 <code>processWorkerExit</code> 方法才能完成，前文介绍的新增Worker线程逻辑中对异常流处理的 <code>addWorkerFailed</code> 方法也可以做到。这两者销毁线程的时机不同，前者是线程执行任务的逻辑中销毁，后者是创建线程后启动失败的处理。</p><p>上述 <code>processWorkerExit</code> 方法在将Worker线程移除线程池后也就完成了线程的回收工作，但由于执行该方法的原因很多，线程正常退出<code>getTask</code>方法或者执行任务异常都会执行该方法，因此在该方法中需要额外完成两个工作。一是使线程池自适应当前状态，另一个是根据需要创建线程。</p><p>至此，<code>processWorkerExit</code> 执行完之后Worker线程被销毁，该线程的整个生命周期结束。下面对整个过程使用流程图的形式进行总结，流程图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-worker-process.jpg" alt></p><h1 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h1><p>调用线程池的 <code>shutdown</code> 或 <code>shutdownNow</code> 方法来关闭线程池，两者的原理有点差异，下面我们分别说明这两个方法。</p><h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 全局锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">     mainLock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         checkShutdownAccess();</span><br><span class="line">         <span class="comment">// 设置线程池状态为 SHUTDOWN</span></span><br><span class="line">         advanceRunState(SHUTDOWN);</span><br><span class="line">         <span class="comment">// 尝试中断线程池所有中闲置的线程</span></span><br><span class="line">         interruptIdleWorkers();</span><br><span class="line">         <span class="comment">// hook</span></span><br><span class="line">         onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         mainLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 尝试终止线程池</span></span><br><span class="line">     tryTerminate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>shutdown() 方法可以安全地关闭一个线程池，体现在下面几个方面：</strong></p><ol><li>只是将线程池的状态置为 SHUTDOWN ，这意味着线程池不能接收新的任务，再有新的任务被提交则根据拒绝策略进行处理。</li><li>会执行完正在执行的任务和队列中等待的任务，任务全部结束后才会彻底关闭线程池。</li><li>尝试中断线程池中所有闲置的线程。</li><li>调用tryTerminate尝试终止线程池，用于将线程池的状态更新为 TERMINATED 。</li></ol><h2 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     List&lt;Runnable&gt; tasks;</span><br><span class="line">     <span class="comment">// 全局锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">     mainLock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         checkShutdownAccess();</span><br><span class="line">         <span class="comment">// 设置线程池状态为 STOP</span></span><br><span class="line">         advanceRunState(STOP);</span><br><span class="line">         <span class="comment">// 尝试中断线程池中所有启动状态的线程</span></span><br><span class="line">         interruptWorkers();</span><br><span class="line">         <span class="comment">// 将阻塞队列中正在等待的所有任务进行备份，然后清空阻塞队列并返回备份。有了这个备份，可以根据需要做补救措施。</span></span><br><span class="line">         tasks = drainQueue();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         mainLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 尝试终止线程池</span></span><br><span class="line">     tryTerminate();</span><br><span class="line">     <span class="keyword">return</span> tasks;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>shutdownNow() 方法表示立即关闭线程池，工作如下：</p><ol><li>将线程池状态置为 STOP 状态。</li><li>中断所有Worker线程，包括空闲和非空闲。</li><li>清空阻塞队列并返回等待执行的任务备份。</li><li>调用tryTerminate尝试终止线程池，用于将线程池的状态更新为 TERMINATED 。</li></ol><h2 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate()"></a>tryTerminate()</h2><p>对于 <strong>tryTerminate()</strong> 方法的调用，前文中的<strong>新增线程失败逻辑、线程退出while逻辑以及两种关闭线程池的方法</strong>都会调用了该方法，下面我们来看看这个方法的具体逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 线程池状态码</span></span><br><span class="line">          <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 以下几种情况不能终止线程池，直接返回（STOP 状态可不会直接返回）</span></span><br><span class="line">           <span class="comment">//1. 线程池是运行状态 RUNNING</span></span><br><span class="line">           <span class="comment">//2. 大于等于 TIDYING 状态，此时线程池中已经没有正在运行的线程了</span></span><br><span class="line">           <span class="comment">//3. SHUTDOWN 状态且阻塞队列非空，这种情况需要执行完任务队列中的任务</span></span><br><span class="line">          <span class="keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 执行到这里，说明已经具备终止线程池的条件，只差线程回收了。</span></span><br><span class="line">          <span class="comment">// 线程池中线程数量不为 0，向任意空闲线程发出中断信号，所有被阻塞的线程（执行poll/take）最终都会被一个个唤醒，回收。</span></span><br><span class="line">          <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">              <span class="comment">// 这里既不是中断所有线程，也不是中断所有空闲线程，而是中断任意一个空闲线程，原因如下：</span></span><br><span class="line">              <span class="comment">// 1. tryTerminate() 方法多处被调用，需要中断线程逻辑在上层已经进行了处理，如 shutdown 方法调用时会中断所有空闲线程</span></span><br><span class="line">              <span class="comment">// 2. interruptIdleWorkers(ONLY_ONE) 方法用在 tryTerminate() 方法中主要为了唤醒 getTask()方法中存在执行workQueue.take()等待的线程，防止一直等待造成线程无法回收。</span></span><br><span class="line">              <span class="comment">//    即使有多个线程阻塞等待，唤醒任意一个也足够了，被唤醒的线程在退出while循环后会再次调用tryTerminate()方法，继续中断阻塞等待线程。此外线程退出后进入到processWorkerExit()方法中</span></span><br><span class="line">              <span class="comment">//    会要申请全局锁的，如果全部唤醒会出现竞争锁的情况。</span></span><br><span class="line">              interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 全局锁</span></span><br><span class="line">          <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 终止线程池时加全局锁，保证CAS执行成功，即线程池状态依次更新为 TIDYING 和 TERMINATED 。</span></span><br><span class="line">          <span class="comment">// 这里可能发生并发问题，如两个线程都通过了 workerCountOf(c) != 0 条件，执行到这里就需要加锁。</span></span><br><span class="line">          mainLock.lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 设置线程池状态码为 TIDYING</span></span><br><span class="line">              <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">// 状态设置成功后执行 terminated() 钩子方法</span></span><br><span class="line">                      terminated();</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 设置线程池状态码为 TERMINATED 终止状态</span></span><br><span class="line">                      ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                      termination.signalAll();</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              mainLock.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// else retry on failed CAS</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>tryTerminate() 方法主要根据线程池状态判断是否终止线程池，下面进行简单总结：</strong></p><ol><li>判断线程池是否可以终止，原则是线程池处于关闭状态、队列中没有任务的情况下可以终止。</li><li>interruptIdleWorkers()方法的执行表示线程池具备终止条件，向任意空闲线程发送中断信号<strong>防止 <code>getTask</code> 方法中存在核心线程执行 <code>workQueue.take()</code>时一直阻塞，导致线程无法回收</strong>。</li><li>符合终止线程池的条件时，先获取全局锁，然后先将线程池状态置为 TIDYING 状态，设置成功后会执行 terminated() 钩子方法，最后将线程池状态设置为 TERMINATED 状态，完成线程池状态更新后释放全局锁。</li></ol><p>下面我们来简单分析一下<code>interruptIdleWorkers</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中断所有闲置的Worker</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyOne 是否仅中断一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">// 全局锁，涉及到 workers 操作线程池都会加该锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历 workers ，对每个非中断线程进行中断操作。</span></span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">                Thread t = w.thread;</span><br><span class="line">                <span class="comment">// 如果线程非中断状态，且能 tryLock() 成功，说明该线程闲置，需要进行中断</span></span><br><span class="line">                <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        w.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前文也进行了说明，Worker 继承了AQS，在Worker线程处理任务时会申请Worker独占锁，<code>interruptIdleWorkers</code> 在进行中断时会使用 <strong>tryLock()</strong> 来判断该Worker线程是否正在处理任务，如果 <strong>tryLock()</strong> 返回true，说明该Worker线程处于空闲状态，可以被中断。</p><p><strong>注意事项：</strong></p><ol><li>线程池中多处执行 <code>tryTerminate</code> 方法的目的是将符合条件的线程池终止，前文也提到线程池的状态是内部自行维护的，并非人为设置。如用户执行 <code>shutdown</code> 和 <code>shutdownNow</code> 方法只是将线程池的状态设置为 <strong>SHUTDOWN</strong> 和 <strong>STOP</strong> ，后续的 <strong>TIDYING</strong> 和 <strong>TERMINATED</strong> 状态的设置就在于此。</li><li><code>tryTerminate</code> 方法中的 <code>interruptIdleWorkers(ONLY_ONE)</code> 的作用是防止线程池在终止的过程中 <code>getTask</code> 方法中存在执行 <code>workQueue.take()</code> 阻塞的线程，因为此时线程池不允许再有新的任务添加到阻塞队列中，这样一来线程将一直阻塞下去，线程池永远都终止不了。</li></ol><p>线程池中虽然多处使用中断来期望中断任务的执行，但由于 <strong>Java 中不推荐强行停止线程的机制的限制，因为强制的让一个线程被动的退出是很不安全的，内部的数据不一致会对程序造成不可预知的后果</strong>。即使调用了 shutdownNow 方法，如果被中断的线程对于中断信号不敏感，那么依然有可能导致任务不会停止。</p><h1 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h1><p>线程池太大或太小都会导致麻烦，选择一个合适的线程池是非常有必要的。调整线程池中的数量是为了充分并合理地使用 CPU 和内存资源，从而最大限度地提高程序性能。通常我们需要根据任务执行的性质来选择对应的策略。</p><h2 id="CPU-密集型任务"><a href="#CPU-密集型任务" class="headerlink" title="CPU 密集型任务"></a>CPU 密集型任务</h2><p>如果任务主要进行大量复杂的计算，例如加密、解密、压缩等，那么意味着 CPU 的处理能力是稀缺的资源，应当分配较少的线程，通常按照 CPU 核数 或者 CPU 核数 + 1 进行设置。 计算任务会占用大量的 CPU 资源，CPU 的每个核工作基本都是高负荷的，如果设置过多的线程，每个线程都会尝试抢占 CPU 资源，这就造成了不必要的上下文切换（CPU并没有太多空闲），性能反而由于线程数量过多导致性能下降。</p><h2 id="IO-密集型任务"><a href="#IO-密集型任务" class="headerlink" title="IO 密集型任务"></a>IO 密集型任务</h2><p>I/O 操作比较多的任务，如数据库操作、文件读写、网络通信等，一般不会消耗太多 CPU 资源，但是普遍需要较长时间的等待，对于这类任务可以配置适当多的线程，如 CPU 核数 * 2 。由于 IO 读写速度相比于 CPU 的速度是比较慢的，设置过少的线程数是不能充分利用 CPU 资源。</p><h2 id="合适线程数"><a href="#合适线程数" class="headerlink" title="合适线程数"></a>合适线程数</h2><p>Brain Goetz 推荐的计算方法如下：</p><blockquote><p>线程数 = CPU核数 × 目标CPU利用率 ×（1 + 平均等待时间/平均工作时间）</p></blockquote><p>通过上面的公式可以大致计算出一个合理的线程数（核心线程数和最大线程数统称）。如果任务平均等待时间长则线程数就应该多，对应于 IO 密集型任务。如果平均工作时间长则线程数就应该少，对应于 CPU 密集型任务。</p><p>线程数太少可能会使得程序整体性能降低，线程数太多可能会消耗内存资源以及造成不必要的上下文切换。想用准确定制线程池需要做的工作很多，除了考虑线程数还可以合理使用线程池的阻塞队列实现任务的调度，还可以根据业务等纬度实现线程池隔离。</p><h1 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h1><p>线程池提供了一些用于获取属性的方法，这些属性可以用来对线程池进行监控。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-monitor-method.jpg" alt></p><p>线程池还提供了一些用于设置核心属性的方法，使用方可以通过这些方法动态设置线程池的核心策略，线程池内部会处理好当前状态并做到平滑修改。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-dynamic-method.jpg" alt></p><h2 id="动态设置核心线程数"><a href="#动态设置核心线程数" class="headerlink" title="动态设置核心线程数"></a>动态设置核心线程数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="comment">// 计算核心线程数变化值</span></span><br><span class="line">        <span class="keyword">int</span> delta = corePoolSize - <span class="keyword">this</span>.corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 覆盖原来的corePoolSize</span></span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池的线程数大于变更的核心线程数，说明有多余的worker线程，此时会向空闲的worker线程发起中断请求以实现回收</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 核心线程数大于原来值，尝试增加核心线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取 任务数和 delta 两者的最小值</span></span><br><span class="line">            <span class="keyword">int</span> k = Math.min(delta, workQueue.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 预先创建足够多的新Worker以达到核心线程数，并处理队列中的任务。队列空了则停止</span></span><br><span class="line">            <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (workQueue.isEmpty())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="动态设置最大线程数"><a href="#动态设置最大线程数" class="headerlink" title="动态设置最大线程数"></a>动态设置最大线程数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaximumPoolSize</span><span class="params">(<span class="keyword">int</span> maximumPoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 覆盖原来的 maximumPoolSize</span></span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是设置小了的话，此时会向空闲的worker线程发起中断请求以实现回收</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; maximumPoolSize)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="动态设置空闲时间"><a href="#动态设置空闲时间" class="headerlink" title="动态设置空闲时间"></a>动态设置空闲时间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeepAliveTime</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (time == <span class="number">0</span> &amp;&amp; allowsCoreThreadTimeOut())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Core threads must have nonzero keep alive times"</span>);</span><br><span class="line">        <span class="comment">// 计算超时时间</span></span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = unit.toNanos(time);</span><br><span class="line">        <span class="comment">// 计算差值</span></span><br><span class="line">        <span class="keyword">long</span> delta = keepAliveTime - <span class="keyword">this</span>.keepAliveTime;</span><br><span class="line">        <span class="comment">// 覆盖原来的 keepAliveTime</span></span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = keepAliveTime;</span><br><span class="line">        <span class="comment">// 如果时间设置比原来小，则向空闲的worker线程发起中断请求以实现回收</span></span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="允许核心线程超时回收"><a href="#允许核心线程超时回收" class="headerlink" title="允许核心线程超时回收"></a>允许核心线程超时回收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allowCoreThreadTimeOut</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 核心线程必须要有保活时间</span></span><br><span class="line">        <span class="keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Core threads must have nonzero keep alive times"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value != allowCoreThreadTimeOut) &#123;</span><br><span class="line">            allowCoreThreadTimeOut = value;</span><br><span class="line">            <span class="comment">// 允许回收则立即中断空闲线程</span></span><br><span class="line">            <span class="keyword">if</span> (value)</span><br><span class="line">                interruptIdleWorkers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对线程池核心点进行了详细分析，先是简单介绍了线程池产生的背景，接着说明了线程池的优势，最后对线程池源码进行了分析。从任务提交到线程池，到线程池创建线程并处理任务，到最后线程被回收，最后简单介绍了线程池的配置以及线程池的监控。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最初的时候并没有线程池的概念，而是先有线程。每个任务都需要对应一个线程，任务少的情况没有太大问题，任务过多就出现了各种性能和资源开销问题，更
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>并发 - Java并发工具类</title>
    <link href="https://gentryhuang.com/posts/37f29896/"/>
    <id>https://gentryhuang.com/posts/37f29896/</id>
    <published>2020-11-05T16:00:00.000Z</published>
    <updated>2020-12-24T13:49:23.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 JDK 的并发包中提供了几个非常有用的并发工具类。 <code>CountDownLatch</code>、<code>CyclicBarrier</code> 和 <code>Semaphore</code> 工具类提供了并发流程控制的手段，它们都是对 AQS 应用。本篇文章将介绍其简单使用以及内部原理。</p><table><thead><tr><th align="left">工具类</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td align="left">Semaphore</td><td>信号量，通过控制 ‘许可证’ 的数量来协调各个线程，以保证合理的使用公共资源。</td><td>线程只有拿到 ‘许可证’ 才能继续运行</td></tr><tr><td align="left">CyclicBarrier</td><td>循环栅栏，让一组线程到达一个栅栏（同步点）时被阻塞，直到最后一个线程到达栅栏时，被栅栏拦截的线程才会继续运行。</td><td>强调一组线程都到达同步点才会继续往下执行</td></tr><tr><td align="left">CountDownLatch</td><td>门栓，等待多线程完成</td><td>强调一个或多个线程等待其它线程完成操作</td></tr></tbody></table><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><p><strong>场景</strong></p><blockquote><p>加工厂生产产品，产品需要三道工序进行检测，只有三道工序检测通过才能进入下一个环节。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定线程数线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品质量检测</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要3个工人进行检测，就用3来初始化一个 CountDownLatch</span></span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> no = i;</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 检测</span></span><br><span class="line">                            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                            log.info(<span class="string">"No."</span> + no + <span class="string">" 完成检测。"</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">// 调用 countDown() 代表完成。这里指某个员工完成检测任务</span></span><br><span class="line">                            latch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"产品质量检测中....."</span>);</span><br><span class="line">        <span class="comment">// 调用await() 代表线程阻塞等待其它线程完成，即同步状态 state 减为 0。这里指产品等待检测完成</span></span><br><span class="line">        latch.await();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"产品质量检测完毕，进入下一个环节。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[main] INFO com.code.juc.tool.CountDownLatchDemo - 产品质量检测中.....</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.CountDownLatchDemo - No.2 完成检测。</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.CountDownLatchDemo - No.3 完成检测。</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CountDownLatchDemo - No.1 完成检测。</span><br><span class="line">[main] INFO com.code.juc.tool.CountDownLatchDemo - 产品质量检测完毕，进入下一个环节。</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>以上例子中，main 线程调用了 <code>latch.await()</code> 进行阻塞等待，即它阻塞在门栓上（叫啥无所谓，中文是门栓、栅栏），只有当条件满足时（其它线程调用 <code>latch.countDown()</code> 递减 state 为0）它才能通过这个门栓。这个例子比较简单，只有一个线程调用 <code>await</code> 方法等待其它线程完成，这属于 <code>一对多</code> 关系。CountDownLatch 还可以实现复杂的 <code>多对多</code> 关系的场景，有 m 个线程在门栓上等待 n 个线程完成任务，直到 n 个线程都完成任务，这 m 个线程才能同时通过门栓。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-1.jpg" alt></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>根据 CountDownLatch 的使用例子分析源码，按照执行流程逐一分析。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Synchronization control For CountDownLatch. // 继承AQS的内部类</span></span><br><span class="line"><span class="comment">     * Uses AQS state to represent count. // 使用 AQS 的状态表示 数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 有参构造方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> count 数量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="comment">// 调用父类方法，设置状态值</span></span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取数量</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 调用父类方法，获取状态值</span></span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 覆写父类方法 （获取同步状态（这里表示数量） - 共享方式）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 覆写父类方法（释放同步状态（这里表示数量） - 共享方式）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> releases 没有意义的参数，用不到</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="comment">// 执行递减数量时，如果数量已经是 0 ，则直接返回 false，说明状态已经被其它线程递减为 0 了，当前线程无需唤醒 await() 阻塞的线程（们）</span></span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> nextc = c - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，需要一个 &gt;= 0 的整数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count the number of times &#123;<span class="doctag">@link</span> #countDown&#125; must be invoked</span></span><br><span class="line"><span class="comment">     *              before threads can pass through &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> count&#125; is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch 类是对 AQS 共享模式的使用。既然是使用 AQS 框架，那么就是一个固定的模式，AQS 已经处理好了同步状态的获取与释放以及阻塞与唤醒，自定义组件只需继承 AQS 以及根据同步状态获取方式（独占/共享）实现模版方法即可。前面也说了，AQS 准备好了一切，只需要条件触发就可以执行对应的任务，而实现的模版方法正是触发条件。</p><p>CountDownLatch 主要有两个核心方法，<code>await</code> 和 <code>countDown</code> 。<code>countDown</code> 方法每次调用都会将 <code>state</code> 减 1 ，直到 <code>state</code> 的值为 0。<code>await</code> 方法可以被多个线程调用，调用 <code>await</code> 方法的线程进入 AQS 的阻塞队列中并挂起，当且仅当 <code>state</code> 为 0 时，线程会从阻塞队列中依次被唤醒过来。</p><h4 id="await-等待"><a href="#await-等待" class="headerlink" title="await 等待"></a>await 等待</h4><p>await 方法是一个阻塞方法，当且仅当同步状态 state 减至 0，该方法才会返回，否则调用该方法的线程将阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--- CountDownLatch</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 可中断获取同步状态</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="comment">// 中断则抛出中断异常</span></span><br><span class="line">      <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// main 线程调用 await 时，state = 3，条件成立 </span></span><br><span class="line">      <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 接下来就是 AQS 的工作了，共享方式可中断获取同步状态</span></span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch 的 await 方法简单，直接传入数量值为 1 尝试获取同步状态（其实传入值是没有意义的，用不到）。CountDownLatch 覆写了模版方法即条件，条件成立则 AQS 完成阻塞任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 入队 ，即当前线程加入阻塞队列，共享方式</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 尝试获取前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// CountDownLatch 实现的条件，state != 0 时，返回 -1</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 找大哥，找到大哥就挂起自己，然后等待大哥唤醒自己。没有找到则继续找，直到找到或其前驱节点是 head 节点，找到则挂起等待，是 head 则尝试获取同步状态。</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="comment">// 线程被中断则抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch 的 await 方法到此就结束了，下面总结下该方法的核心步骤。</p><ul><li><p>main 线程没有获取到同步状态会进入阻塞队列<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-2.jpg" alt><br>main 线程对应的节点入队完成，如上图。需要注意的是，因为 main 线程对应节点入队时阻塞队列为空，因此需要构建阻塞队列，使用一个虚节点作为 head 。如果节点在入队时已经存在阻塞队列，那么直接挂到阻塞队列尾部即可。</p></li><li><p>尝试获取同步状态<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-3.jpg" alt><br>入队后进入for 循环，此时main线程对应的节点的前驱节点是 head，但 tryAcquireShared 返回 -1,此时进入 <code>找大哥</code> 的流程中。<code>找大哥</code> 就是将当前节点的<strong>有效</strong>前驱节点等待状态 waitStatus 设置为 -1。这里是将 main 线程对应节点的前驱节点 head 的 waitStatus 设置为 -1。</p></li><li><p>挂起，等待前置节点唤醒<br>找到大哥后挂起自己，等待大哥（有效前置节点）唤醒自己。</p></li></ul><br>以上是 main 线程获取同步状态失败后，进入阻塞队列等待唤醒的过程。需要说明的是，CountDownLatch 可以有多个线程等待其它线程完成，例子中只是使用一个线程等待而已。<h4 id="countDown-唤醒"><a href="#countDown-唤醒" class="headerlink" title="countDown 唤醒"></a>countDown 唤醒</h4><p>countDown 方法每次调用都会将同步状态 state 减 1，直到减少至 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">--- CountDownLatch</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放同步状态</span></span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有当 state 减到 0 时， tryReleaseShared 方法才返回 true，否则仅是将 state 减 1 并返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            <span class="comment">// state == 0 时，唤醒阻塞的线程。 注意，这里是 t1 线程唤醒阻塞的线程即 main 线程</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// t1 线程执行到这里，唤醒阻塞队列中等待的 main 线程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">            <span class="comment">// 将当前 head 保存起来，因为其它线程可能会占领它，此时是虚节点</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="comment">// main 线程入队时已经把 head 当作大哥了，即 将 head 的 waitStatus 设置为 -1 (Node.SIGNAL)</span></span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                     <span class="comment">// cas 将 head 的 waitStatus 设置 为 0。</span></span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 唤醒 head 下一个有效节点。这里是 main 线程对应的节点</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">            </span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面代码只是正常情况下一个完整流程，即 main 线程加入阻塞队列并挂起后，t2、t3、t1 分别执行 <code>countDown</code> 方法递减 <code>state</code> 的值，到了 t1 调用该方法时，刚好 <code>state</code> 的值被减至 0 ，然后线程 t1 执行唤醒阻塞队列中的线程逻辑。下面对该过程进行总结。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-4.jpg" alt></p><p>至此，唤醒条件已经具备，即 <code>state = 0</code> ，下面我们回到之前线程挂起的代码处，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 尝试获取前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// CountDownLatch 实现的条件，state != 0 时，返回 -1</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 2 main 占据 head 并继续唤醒后置阻塞的线程</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// 1 线程 t1 唤醒阻塞的 main 线程，该方法返回，即 main 线程继续执行尝试再次获取同步状态</span></span><br><span class="line">                    parkAndCheckInterrupt())  </span><br><span class="line">                    <span class="comment">// 如果线程被中断则抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>main 线程被唤醒后从 parkAndCheckInterrupt 方法返回，如果没有被中断，则继续尝试获取同步状态，此时可以获取到同步状态（r &gt;= 0 成立）。接下来 main 线程会进入到 setHeadAndPropagate 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将当前 head 保存起来，因为其它线程可能会占领它</span></span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below </span></span><br><span class="line">        <span class="comment">// node 节点占领 head，即 main 线程占领 head</span></span><br><span class="line">        setHead(node); </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里条件判断对应的场景比较多，毕竟是 AQS 统一处理方法，因此考虑的情况比较全面。对于 CountDownLatch ，就是唤醒 node 之后的有效节点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点的后置节点</span></span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="comment">// 如果为 null 或者 是共享方式的节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                <span class="comment">// 接着唤醒阻塞线程 （共享式）。注意，这里是醒来的阻塞线程继续唤醒后置还在阻塞的线程。</span></span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 占领 head </span></span><br><span class="line"><span class="comment">     * Sets head of queue to be node, thus dequeuing. Called only by</span></span><br><span class="line"><span class="comment">     * acquire methods.  Also nulls out unused fields for sake of GC</span></span><br><span class="line"><span class="comment">     * and to suppress unnecessary signals and traversals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>setHeadAndPropagate 方法主要做了两件事，node 占领 head 并唤醒 node 后置的<strong>有效</strong>节点。由于例子中只有 main 线程进入了阻塞队列，它后面没有等待唤醒的线程节点，但为了研究源码我们假设 main 线程对应节点后面还有一个 线程 t 节点等待唤醒，那么 main 线程会执行 doReleaseShared 方法来唤醒线程 t ，此时 head 是 main 线程对应的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 将当前 head 保存起来，因为其它线程可能会占领它</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//  h == null 说明阻塞队列为空，h == tail 说明头节已经是最后一个节点或者是刚刚初始化的节点，这对应 CountDownLatch 来说都应该结束。</span></span><br><span class="line">        <span class="comment">//  按照例子走到这里，head 就 main线程对应的节点，同时 tail 也是 main 线程对应的节点。不过我们假设了 线程 t ，因此条件是成立的</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="comment">// h 的状态，即 main 线程对应节点状态，由入队方法可知，t 线程对应节点会把 main 线程对应节点作为 大哥节点，即 waitStatus 设置为 -1（Node.SIGNAL)</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 可能会失败</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唤醒 h 的后置节点，也就是阻塞队列中的第一个节点。这里是线程 t 对应的节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; </span><br><span class="line">                          <span class="comment">// todo 这里可能会失败 </span></span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">          &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 线程执行到这里，如果唤醒的线程已经占领了 head，此时 h != head，当前线程继续循环。如果 h == head ，说明，唤醒的线程还没有占领 head，当前线程退出循环</span></span><br><span class="line">        <span class="comment">// 这里可能 main 线程执行到这里时，main 线程唤醒的线程 t 已经占领了 head ,此时 h != head </span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setHeadAndPropagate 方法和 doReleaseShared 方法配合，依次唤醒阻塞的线程，即 执行 doReleaseShared 方法的线程唤醒它的后置阻塞线程，醒来的线程会再次尝试获取同步状态然后进入到 setHeadAndPropagate 方法中先占领 head，然后调用 doReleaseShared 方法继续唤醒它的后置阻塞节点。需要说明的是，AQS 的 <code>doReleaseShared</code> 方法极端场景还是挺多的，这里结合 CountDownLatch 来说明。</p><p>我们抛开给出的例子，根据以下场景分析几个特殊的情况</p><blockquote><p>要进行体能测试，每组三个同学进行短跑，在体育老师发出起跑指令前，这三个同学都要在起跑线待着，当体育老师准备完毕后会发出开始跑的指令，那这三个同学就会一起跑向终点的测试仪。这里 CountDownLatch 的数量 为 1，即同步状态为 1 。</p></blockquote><ul><li><p><strong>h != head 的情况</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-5.jpg" alt><br>当 t1 被唤醒后，唤醒 t1 的线程 t 执行到上图中的代码处，还没有退出循环，t1 已经占领了 head（此时图中的 head 要指向 t1 线程对应的节点，且 t1 线程节点 thread 置空，prev 置空。图中没有体现出来），此时 head != h ，线程 t 将会进行下一轮循环。</p></li><li><p><strong>compareAndSetWaitStatus(h, Node.SIGNAL, 0) 失败</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-6.jpg" alt><br>线程 t 进行第二轮循环时，刚好被唤醒的线程 t1 也进入该循环，此时两个线程并发执行，假设线程 t CAS 操作成功，然后退出循环，线程 t1 失败，将会进行下一轮循环。注意，此时虚节点的 next 指针还存在，因为我们假设的是 t1 线程失败了，t 线程成功退出了，t 线程不属于阻塞队列中的线程，它不会维护阻塞队列节点关系，如果是 t1 线程成功并退出循环就会清除它上一个节点的 next ，这里就是虚节点。</p></li><li><p><strong>执行 else if (ws == 0 &amp;&amp;..) 分支</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-7.jpg" alt><br>t1 线程第二次循环时，唤醒的 t2 线程还没有占领 head，此时的 head 还是 t1 线程对应的节点，但是 waitStatus 被之前的 t 线程通过 CAS 设置为 0 了，因此进入到 else if 分支，然后再次把节点 watiStatus 设置为 -3 。执行到 h == head 判断处时，假设 t2 还是没有占领 head ，此时 t1 退出循环，然后清除其前置节点的 next 指针，即虚节点。</p></li><li><p><strong>compareAndSetWaitStatus(h, 0, Node.PROPAGATE) 失败</strong><br>进入这个方法的前提是 ws == 0，即 head 的 waitStatus 出现了 0，此时如果 CAS 失败，一般有两种可能，一种是线程并发执行 CAS 只有一个会成功，另一种是其它的线程把该节点的 waitStatus 值修改了，此时能改 head 的状态值的很可能是节点入队引起的修改，因为新节点要把有效的前驱节点状态值设置为 -1 。在 CountDownLatch 中一般不会发生第二种可能，因为一旦唤醒条件成立，就不会再有节点需要入队阻塞了。</p></li></ul><p>剩下的 t2 线程、t3 线程依次会被唤醒，需要注意的是 t3 线程被唤醒占领头节点后也会进入到 doReleaseShared 方法的循环中，此时它对应的节点既是 head 又是 tail，就直接退出循环，结束整个流程了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>CountDownLatch 的构造函数需要一个 int 类型的参数作为数量（用来计数），如果想等待 N 个任务完成（N 个线程执行完任务），就需要传入 N 。CountDownLatch 的 countDown 方法用于将 N 减 1 ,await 方法会阻塞当前调用线程（阻塞在门栓上，门栓是一个同步点的概念），直到 N 减至 0 被阻塞的线程才会继续往下执行。此外，CountDownLatch 还提供了一个带有指定时间的 await 方法，用于等待超时的场景，超过等待时间就不会再等，被阻塞线程继续往下执行。这个方法很简单，就是在 await 方法的基础上增加了超时判断，下面粘贴下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">--- CountDownLatch</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">            doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared timed mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanosTimeout max wait time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 计算出等待的最迟时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 计算出等待剩余时间</span></span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="comment">// 超过等待时间，则不再等待，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// 执行挂起的最小时间粒度</span></span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    <span class="comment">// 挂起 nanosTimeout 时间后自动醒来</span></span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意，N 值必须 大于等于 0，如果 N 等于 0 ，调用 await 方法时当前线程不会被阻塞，此外 CountDownLatch 不支持重新初始化，也不支持修改数量的值。</p></blockquote><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="使用例子-1"><a href="#使用例子-1" class="headerlink" title="使用例子"></a>使用例子</h3><p><strong>场景</strong></p><blockquote><p>某个公司部门举办团建活动，需要员工自行拼车前往目的地，司机会在指定的地点等待拼车的 4 个人到齐后才发车。我们假设该部门某个团队有 8 个人，那么就需要拼 2 辆车前往目的地。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定线程数线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要等待 4 个同学到齐，到齐后发车，因此这里初始化一个带有 Runnable 参数的 CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, () -&gt; log.info(<span class="string">"4人已到齐，请系好安全带，现在出发赶往目的地 !"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8个人，需要 2 辆车。这里会循环使用 CyclicBarrier</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 赶往拼车地点</span></span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">                    log.info(<span class="string">"到达指定拼车地点 !"</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                   </span><br><span class="line">                    <span class="comment">// 一组人员全部到达后，才能出发。 即 一组线程全部到达栅栏后，被阻塞的线程才能继续执行</span></span><br><span class="line">                    log.info(<span class="string">"出发了 !"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException exception) &#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CyclicBarrierDemo - 4人已到齐，请系好安全带，现在出发赶往目的地 !</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-8] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-7] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-7] INFO com.code.juc.tool.CyclicBarrierDemo - 4人已到齐，请系好安全带，现在出发赶往目的地 !</span><br><span class="line">[pool-1-thread-7] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-8] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>以上例子中，使用循环体和线程池模拟 8 个线程执行任务，其中每 4 个线程为一组，只有这 4 个线程都到达栅栏，例子中是到达指定拼车点，才能继续往下执行，否则都会阻塞在栅栏上等待其它线程到达栅栏。到达栅栏的定义是 线程调用 await 方法。一组线程都到达栅栏后，由最后到达的线程执行及时任务，没有任务则不执行。CyclicBarrier 是可循环使用的栅栏，当一组线程都到齐后，CyclicBarrier 进行下一个循环，下一组线程进行同样的操作。</p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>CyclicBarrier 的字面意思是可循环使用的栅栏，因为它的栅栏可以重复使用（通过重置关键属性）。它要做的事情是，让一组线程到达一个栅栏（是一个同步点）时被阻塞，直到最后一个线程到达栅栏时，栅栏才会打开，所有被栅栏拦截的线程才能继续运行。它的功能是通过组合 <code>ReentrantLock</code> 和 <code>Condition</code> 来达到的。我们还是基于使用例子来分析源码。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cb-1.jpg" alt></p><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栅栏所处的代。栅栏上阻塞的线程被唤醒或者栅栏被重置，就开启新的一代</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 栅栏是否被打破，默认为 false</span></span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁对应的条件，阻塞线程在栅栏或者唤醒阻塞在栅栏上的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栅栏要拦截的线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一组线程都到达栅栏后优先执行的任务，即如果设置这个这个任务，那么被阻塞在栅栏上的线程要等这个任务结束后才能被唤醒。注意，这个任务是被最后到达的线程执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前栅栏所处的代，如果第一次就是 1 代，如果第2次使用就是 2 代</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 还要等待的线程数，即还没有到栅栏的线程数。这个初始值 是 parties 值，每个线程到栅栏就减 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CyclicBarrier 高级构造函数，支持优先执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CyclicBarrier 默认的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier 默认的构造方法的参数表示栅栏拦截的线程数，每个线程调用 await 方法都会告诉 CyclicBarrier 我已经到达栅栏，此时栅栏要把拦截的线程数减 1 ，然后阻塞当前线程，直到要拦截的线程都到达栅栏时，栅栏才会打开，即最后到达的线程唤醒阻塞在栅栏上的线程，然后这组线程都从 await 方法处继续往下执行。 CyclicBarrier 还提供一个高级构造函数，用于在最后一个线程到达栅栏时，优先执行的任务，便于处理复杂的业务场景。注意，<strong>执行优先任务先于唤醒阻塞线程</strong> ，代码中所有体现。</p><h4 id="下一代栅栏"><a href="#下一代栅栏" class="headerlink" title="下一代栅栏"></a>下一代栅栏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---CyclicBarrier</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启下一代栅栏</span></span><br><span class="line"><span class="comment">     * 1 唤醒阻塞在上一代栅栏上的线程</span></span><br><span class="line"><span class="comment">     * 2 重置 count 和 generation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// signal completion of last generation</span></span><br><span class="line">        trip.signalAll();</span><br><span class="line">        <span class="comment">// set up next generation</span></span><br><span class="line">        count = parties;</span><br><span class="line">        generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>开启下一代栅栏很好理解，因为要开启下一代栅栏了，当前代栅栏上阻塞的线程需要被唤醒，同时初始化好下一代栅栏。</p><h4 id="打破栅栏"><a href="#打破栅栏" class="headerlink" title="打破栅栏"></a>打破栅栏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---CyclicBarrier</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 打破栅栏</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 设置栅栏已破标志</span></span><br><span class="line">          generation.broken = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">// 重置 count</span></span><br><span class="line">          count = parties;</span><br><span class="line">          <span class="comment">// 唤醒阻塞在栅栏上的线程</span></span><br><span class="line">          trip.signalAll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打破栅栏需要标记当前代的栅栏不可用，并且要唤醒阻塞在这个不可用的栅栏上的线程，因为这里不进行唤醒的话，阻塞的线程将一直挂起。这里重制 count 不明白是干嘛的。</p><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">--- CyclicBarrier</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不带超时机制的方法，例子中使用的就是这个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// false , 0</span></span><br><span class="line">            <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 带有超时机制的方法，如果超过等待时间，当前线程没有被唤醒则 抛出 TimeoutException</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">               BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier 提供了 await 两个重载方法，一个是不带超时机制的方法，另一个是带有超时机制的方法。下面我们分析 CyclicBarrier 核心代码 <code>dowait</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">--- CyclicBarrier</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用可重入锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取标志着当前栅栏的 代</span></span><br><span class="line">            <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查当前代的栅栏是否被打破，如果当前代的栅栏被打破需要 抛出 BrokenBarrierException 异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查当前线程中断状态，如果被中断了，则要抛出 InterruptedException 异常，并且打破栅栏</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递减 count 的值</span></span><br><span class="line">            <span class="keyword">int</span> index = --count;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果 count 递减后的值为 0 ，说明当前代的栅栏要拦截的最后一个线程也到达栅栏</span></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 标志优先任务是否失败，默认是 false</span></span><br><span class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果指定了优先任务，就交给最后到达的线程执行</span></span><br><span class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 设置标志</span></span><br><span class="line">                    ranAction = <span class="keyword">true</span>;</span><br><span class="line">                   </span><br><span class="line">                    <span class="comment">// 唤醒当前代的栅栏上阻塞的任务，并开启下一代 （栅栏可以重复使用）</span></span><br><span class="line">                    nextGeneration();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果执行优先任务失败，则打破栅栏</span></span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// ---------------------- 执行到这里的线程不是最后一个线程，因此需要阻塞，等待最后一个线程到来并唤醒自己 ---------------/</span></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 不带超时机制</span></span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        <span class="comment">// 释放锁，加入等待队列 (ConditionObject)</span></span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="comment">// 带超时机制，并且超时时间 &gt; 0</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        <span class="comment">// 释放锁，加入等待队列 (ConditionObject)，如果到时间还没有被唤醒则不再阻塞</span></span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 执行到这里说明，线程进入等待队列后被中断了</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="comment">// 栅栏仍是进入等待队列的前的栅栏，此时应该打破栅栏，并且抛出中断异常</span></span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 1 g != generation，说明新一代的栅栏生成了，即最后一个线程也到达了栅栏，此时只需复位被中断线程的中断标志</span></span><br><span class="line">                        <span class="comment">// 2 栅栏被打破了（一定要抛出异常），被打破异常交由后续逻辑处理，此时只需复位被中断线程的中断标志</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 线程被唤醒后，还没从 await 方法返回栅栏就被打破了，直接抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 这个方法很重要，被唤醒后的线程正常逻辑都会从该方法返回出去</span></span><br><span class="line"><span class="comment">                 * 1 最后一个线程到达后会做三件事：执行优先任务、唤醒当前代的栅栏上阻塞的线程、开启栅栏的下一代</span></span><br><span class="line"><span class="comment">                 * 2 当前所在的方法是加了 ReentrantLock 锁的，因此我们要知道以下信息：</span></span><br><span class="line"><span class="comment">                 *   1）最后一个到达线程在没有执行完三件事前，是不会释放锁的</span></span><br><span class="line"><span class="comment">                 *   2）唤醒的阻塞线程并不能马上从 await 方法返回，它需要先去竞争锁，获取锁后才能从 await 方法返回</span></span><br><span class="line"><span class="comment">                 *   3）即使最后一个线程开启了栅栏的下一代，在它没有释放锁前，其它组的线程也要阻塞，比如例子中的后四个线程</span></span><br><span class="line"><span class="comment">                 * 3 被最后一个线程唤醒的线程执行到这里时，新一代的栅栏一定已经存在了。注意，这里说的是被最后一个线程唤醒的线程，并不是由于超时机制醒来的线程</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 超时机制醒来的线程，如果发现已经超时了，则打破栅栏，抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>涉及到的源码已经分析过了，下面结合使用例子简单分析下过程</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cb-2.jpg" alt></p><p>CyclicBarrier 整个过程还是挺清晰的，没有使用 CAS 重试等机制，因为栅栏等待线程的 await 方法直接使用了ReentrantLock 锁，线程要到达栅栏必须拿到锁才行，整个过程是串行化的。分析完核心方法后，我们再看下其它几个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">--- CyclicBarrier</span><br><span class="line">    <span class="comment">// 重置栅栏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">            nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在栅栏上等待线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parties - count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断栅栏是否被打破</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generation.broken;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>CyclicBarrier 和 CountDownLatch 还是有点像的，前者强调的是一组线程到达同步点即栅栏，后者强调的是阻塞在同步点的线程等待其它线程完成任务。具体区别如下：</p><ul><li>作用不同<br>CyclicBarrier 要等固定数量线程到达同步点，CountDownLatch 等待的不是线程而是同步状态state递减为 0。前者针对线程，后者针对事件/任务（根据需要调用 countDown 方法）。</li><li>重用性不同<br>CyclicBarrier 可以重复使用，上一代使用完后自动初始化下一代，也可以调用 reset 方法重置。 CountDownLatch 只能使用一次，在同步状态减为 0 后门栓打开后，就不能再次使用，想要使用需要新建实例。</li><li>唤起任务数不同<br>CyclicBarrier 只能唤醒一个任务，CountDownLatch 可以唤醒多个任务</li></ul><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="使用例子-2"><a href="#使用例子-2" class="headerlink" title="使用例子"></a>使用例子</h3><p><strong>场景</strong></p><blockquote><p>有一些加工厂是对环境有很大污染的，如果要生产产品必须要有关机构申请生产许可证，拿到许可证后才可以生产，完成一定规模后需要归还许可证，便于其它工厂可以申请。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定线程数线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有 3 个许可证书，每个加工厂公平获取。</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有 6 个加工厂想要获取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取许可证</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    log.info(<span class="string">"拿到了许可证"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理任务</span></span><br><span class="line">                    log.warn(<span class="string">"凭借许可证处理任务..."</span>);</span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log.info(<span class="string">"归还许可证"</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-1] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-2] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-3] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-4] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-5] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-6] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>以上例子中，使用循环体和线程池模拟 6 个线程，即 6 个加工厂获取生产许可证。Semaphore 的许可证数量为 3，即监管部门目前只有 3 个生产许可证，此时 6 个工厂只能有其中三个可以获取到，另外 3 个工厂只能等待生产许可证的归还，如果不归还将一直等着。</p><h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><p>Semaphore 是用来控制同时访问特定资源的线程数量，它通过协调各个线程来保证合理的使用有限的公共资源。Semaphore 也是对 AQS 共享模式的使用，因此套路也是一样的。它接收一个整形的数字 permits，也是 AQS 的 state，表示可用的许可证数量，即允许 permits 个线程获取许可证，也就是最大并发数是 permits。因为是共享模式的使用，因此需要重写对应的模版方法 <code>tryAcquireShared</code> 和 <code>tryReleaseShared</code> ，前者用来判断能否获取到许可证，后者用来判断能否归还许可整（总是返回true）。此外，Semaphore 在此基础上增加了公平和非公平获取同步状态的功能。Semaphore 的用法很简单，它的 <code>acquire</code> 方法获取许可证，<code>release</code> 方法归还许可证，获取不到许可证的线程就加入阻塞队列中，等待其它线程释放许可证。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-1.jpg" alt></p><h4 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h4><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-2.jpg" alt></p><p>前面也提到了，Semaphore 是对 AQS 共享模式的使用，并且支持公平和非公平的状态管理方式，即对同步状态 state 的操作。通过上图的 UML 类图更加清晰，Semaphore 既可以公平实现方式创建对象，又能以非公平方式创建对象。</p><h4 id="Sync-内部类"><a href="#Sync-内部类" class="headerlink" title="Sync 内部类"></a>Sync 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 AQS 的内部类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信号量的同步实现。使用 AQS 的同步状态 state 表示许可证。分为 公平和非公平两种实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法，设置 AQS 的同步状态 state。对于 Semaphore 来说表示许可证</span></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取同步状态，即许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非公平实现，共享式获取许可证。返回剩余许可证数量</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式释放同步状态方法，即归还许可证。该方法总是返回 true</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="comment">// 归还 releases 个许可证 (注意，如果不获取先释放的话，许可证会变多的)</span></span><br><span class="line">                <span class="keyword">int</span> next = current + releases;</span><br><span class="line">                <span class="comment">// 这里判断归还数量不能小于 0</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                <span class="comment">// CAS 更新 state （AQS 中的方法 ）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync 内部类首先对同步状态 state 进行了初始化，先确定同步状态 state 的值，即表示的意义，这里指许可证。第二个是获取同步状态 - tryAcquireShared，这里指获取许可证，Sync 中没有进行实现而是交给了两个子类。第三个是释放同步状态 - tryReleaseShared，这里指归还许可证，Sync 中统一实现了这个逻辑。下面我们分别看下其子类实现。</p><h4 id="NonfairSync-内部类"><a href="#NonfairSync-内部类" class="headerlink" title="NonfairSync 内部类"></a>NonfairSync 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 AQS 的内部类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信号量的同步实现。使用 AQS 的同步状态 state 表示许可证。分为 公平和非公平两种实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法，设置 AQS 的同步状态 state。对于 Semaphore 来说表示许可证</span></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取同步状态，即许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非公平实现要执行的方法，共享式获取许可证。返回剩余许可证数量</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式释放同步状态方法，即归还许可证。该方法总是返回 true</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="comment">// 归还 releases 个许可证 (注意，如果不获取先释放的话，许可证会变多的)</span></span><br><span class="line">                <span class="keyword">int</span> next = current + releases;</span><br><span class="line">                <span class="comment">// 这里判断归还数量不能小于 0</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                <span class="comment">// CAS 更新 state （AQS 中的方法 ）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式获取同步状态的方法，这里是非公平方式获取许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NonfairSync 内部类只做了一件事情，重写 AQS 的 tryAcquireShared 方法，需要注意它的非公平性，也就是不关心阻塞队列中有没有还在等待的线程，直接尝试获取许可证。</p><h4 id="FairSync-内部类"><a href="#FairSync-内部类" class="headerlink" title="FairSync 内部类"></a>FairSync 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 AQS 的内部类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信号量的同步实现。使用 AQS 的同步状态 state 表示许可证。分为 公平和非公平两种实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法，设置 AQS 的同步状态 state。对于 Semaphore 来说表示许可证</span></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取同步状态，即许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非公平实现，共享式获取许可证。返回剩余许可证数量</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式释放同步状态方法，即归还许可证。该方法总是返回 true</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="comment">// 归还 releases 个许可证 (注意，如果不获取先释放的话，许可证会变多的)</span></span><br><span class="line">                <span class="keyword">int</span> next = current + releases;</span><br><span class="line">                <span class="comment">// 这里判断归还数量不能小于 0</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                <span class="comment">// CAS 更新 state （AQS 中的方法 ）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式获取同步状态的方法，这里是非公平方式获取许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式获取同步状态的方法， 这里是 公平方式获取许可证。返回剩余许可证数</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="comment">// 是否有线程在排队等待许可证</span></span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FairSync 内部类同样只做了一件事情，重写 AQS 的 tryAcquireShared 方法，以公平的方式实现，也就是线程在获取许可证之前，先判断阻塞队列中是否还有等待的线程，有的话就直接返回 -1 进入阻塞队列中等待。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 以非公平方式创建 Semaphore</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">     sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 可选择公平/非公平方式创建 Semaphore</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">     sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>和 ReentrantLock 有点类似，实现了公平和非公平方式，默认使用非公平实现。</p><h4 id="acquire-系列方法"><a href="#acquire-系列方法" class="headerlink" title="acquire 系列方法"></a>acquire 系列方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">--- Semaphore</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可响应中断地获取许可证（获取一个许可证）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 的方法</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">       <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- Semaphore</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取许可证（获取一个许可证），对中断不敏感</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 的方法</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 内部会调用 doReleaseShared 方法</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- Semaphore</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 Semaphore 获取给定数量的许可证，不够就阻塞等待，对中断敏感</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        sync.acquireSharedInterruptibly(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 Semaphore 获取给定数量的许可证，不够就阻塞等待，对中断不敏感</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        sync.acquireShared(permits);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过 acquire 方法也可以看出，AQS 框架在实现共享式获取同步状态时，当且仅当同步状态处理结果小于 0 时，线程才会走入队流程。因为都是共享式实现，AQS 底层处理是一样的，因此后续的入队、找有效前驱节点以及挂起操作和 CountDownLatch 是一样的，就不再分析了。继续看它的释放同步状态的方法。</p><h4 id="release-系列方法"><a href="#release-系列方法" class="headerlink" title="release 系列方法"></a>release 系列方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">--- Semaphore</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归还许可证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 方法</span></span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归还给定数量的许可证到 Semaphore</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">         <span class="comment">// AQS 方法</span></span><br><span class="line">        sync.releaseShared(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Semaphore 实现的释放同步状态方法</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过 release 系列方法也可以看出，AQS 框架在实现共享式释放同步状态时，当且仅当同步状态处理结果为 true 时，才会唤醒阻塞队列的线程。因为都是共享式实现，AQS 底层处理是一样的，因此唤醒的流程和 CountDownLatch 是一样的。</p><h4 id="例子流程"><a href="#例子流程" class="headerlink" title="例子流程"></a>例子流程</h4><ul><li><p>Semaphore 初始化 3 个 许可证<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-3.jpg" alt><br>同一个JVM进程中，某一时刻对 resource 访问的最大并发请求数为3</p></li><li><p>某一时刻t1、t2、t3获取到许可证，t4进入阻塞队列等待<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-4.jpg" alt><br>线程t1、t2、t3拿到许可证去访问资源，此时 Semaphore 中已经没有可用的许可证了，t4只能加入阻塞队列等待许可证的释放。这里 t4 要入队。</p></li><li><p>t3 访问资源后归还许可证，t4 获取到获取到许可证<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-5.jpg" alt><br>这个过程可能会有多种情况，如，t4 在没有挂起之前，t3 已经归还了许可证，此时 t4 直接就可以拿到。如果 t4 不太幸运的话，会挂起然后等待t3来唤醒。Semaphore 的一些特殊情况可以参考 CountDownLatch。</p></li><li><p>其它线程获取许可证依次类推</p></li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Semaphore 使用的注意事项：</p><ol><li>获取和释放的许可证数量必须一致，否则随着许可证的获取和归还流程推进，最后会导致许可证数量不够，将出现程序卡死。</li><li>在初始化 Semaphore 的时候可以设置释放公平，这个可以根据情景选择，一般设置为 true 更合理，因为 Semaphore 本身就是限制同时请求量的，不针对某个请求的。</li><li>获取和释放许可证不一定非要同一个线程来完成，可以是 线程 A 获取，线程 B 释放，逻辑合理即可。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是 ReentrantLock，还是 CountDownLatch、CyclicBarrier、Semaphore 等 ，它们都是对 AQS 应用，至于是实现锁的功能，还是实现同步组件根据具体场景进行设计。本质上都离不开同步状态 <code>state</code>、独占方式 <code>tryAcquire-tryRelease</code> 获取与释放方法，共享方式 <code>tryAcquireShared-tryReleaseShared</code> 获取与释放方法，此外 AQS 也支持自定义同步组件同时实现独占和共享两种方式，以及公平和非公平实现，不同组件表示的意义是不同的。AQS 还提供了 <code>等待队列</code> 机制，ReentrantLock 就基于该机制实现了等待与唤醒机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 JDK 的并发包中提供了几个非常有用的并发工具类。 &lt;code&gt;CountDownLatch&lt;/code&gt;、&lt;code&gt;CyclicBa
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
      <category term="AQS" scheme="https://gentryhuang.com/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>AQS 原理分析 - Condition实现原理</title>
    <link href="https://gentryhuang.com/posts/40e44c1f/"/>
    <id>https://gentryhuang.com/posts/40e44c1f/</id>
    <published>2020-10-26T13:45:45.000Z</published>
    <updated>2021-01-04T08:50:29.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在 JUC 之前，Java 实现等待/通知模式是通过定义在 Object 中的一组监视器方法 <code>wait方法</code>、<code>notify()</code>以及 <code>notifyAll()</code> 与 <code>synchronized</code> 关键配合完成。在 JUC 中单独提供了一套等待/通知模式的实现方式，具体实现是 <code>Condition</code> 接口与 <code>Lock</code> 接口配合完成。</p><p><code>Condition</code> 接口提供了类似 Object 的监视器方法，但该接口中定义的方法功能上更强大。比如，<code>Condition</code> 支持响应/不响应中断以及等待超时等接口。</p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>生产者-消费者是 Condition 其中的一个经典使用场景，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notFull Condition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notEmpty Condition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组，大小为 100</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分别为添加的下标、移除的下标和数组当前数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产</span></span><br><span class="line"><span class="comment">     * 如果数组满了，则添加线程进入等待状态，直到有空位才能生产</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x item</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 元素数量等于数组长度，线程等待</span></span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加元素</span></span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="comment">// 添加下标 putptr 递增，和移除的下标 takeptr 对应。</span></span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 数组元素个数递增</span></span><br><span class="line">            ++count;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生产后通知消费</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费</span></span><br><span class="line"><span class="comment">     * 如果数组为空，则消费线程进入等待状态，直到数组中有元素才能继续消费</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> item</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 数组为空，线程等待</span></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出元素</span></span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            <span class="comment">// 移除下标递增</span></span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 数组元素个数递减</span></span><br><span class="line">            --count;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消费后通知生产</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上述示例中，BoundedBuffer 实现了生产者-消费者模式，下面进行简单概述：</strong></p><ol><li>使用 Condition 时先获取相应的 Lock 锁，和 Object 类中的方法类似，需要先获取某个对象的监视器锁才能执行等待、通知方法。</li><li>生产和消费方法中判断数组状态使用的是 while 自旋而非 if 判断，目的是防止过早或意外的通知，当且仅当条件满足才能从 await() 返回。</li></ol><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>Condition 结合 Lock 实现的等待通知机制包括两部分内容即等待和通知，分别依赖单向链表和双向链表。Condition 接口的实现类是 AQS 内部类 ConditionObject，它内部维护的队列称为条件队列，基于单向链表实现。Lock 是基于 AQS 实现的，它内部维护的队列称为同步队列，基于双向链表实现。Condition 对象是由 Lock 对象创建出来的，并且一个 Lock 对象可以创建多个 Condition 对象，每个 Condition 对象共享 Lock 这个外部资源。</p><p>获取到同步状态（锁）的线程调用 <code>await</code> 方法进行等待时，会先将自己打包成一个节点并加入到对应的条件队列中，加入成功后会<strong>完全释放同步状态</strong>，释放同步状态成功后会在该条件队列的尾部等待，于此同时该线程在同步队列中的节点也会被移除。在某个 Condition 上（条件队列）等待的线程节点被<code>signal</code> 或 <code>signalAll</code> 后，对应的线程节点会被转到外部类的同步队列中，这意味着该节点有了竞争同步状态的机会，线程需要获取到同步状态才能继续后续的逻辑。需要说明的是，一个锁对象可以同时创建 N 个 Condition 对象（对应 N 个条件队列），这表明获取到同步状态的线程可以有选择地加入条件队列并在该队列中等待，其它获取到同步状态的线程可以有选择地唤醒某个条件队列中的等待的线程。但不管有多少个条件队列，竞争同步状态的线程节点需要统一转到外部类的同步队列中，也就是 Lock 维护的双向链表，此后就是竞争同步状态的逻辑了。</p><p>下图简单描述了 Condition 的工作原理：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-condition-process.jpg" alt></p><p>以上就是 Condition 实现的等待-通知机制。需要说明的是，上述描述没有涉及过多的细节，如异常流的处理。接下来我们通过对代码层面的解析来全面了解 Condition 的机制。</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-condition-method.jpg" alt></p><p>Condition 接口中定义的方法和 Object 中的监视器方法类似，区别在于前者支持响应中断和超时等待。下面对该接口中定义的方法进行简单说明：</p><ol><li><strong>void await() throws InterruptedException 方法</strong><blockquote><p>响应中断的等待方法，线程进入条件队列挂起，直到被通知或中断。</p></blockquote></li><li><strong>void awaitUninterruptibly() 方法</strong><blockquote><p>不响应中断的等待方法，不会抛出中断异常，仅仅复位中断标志，线程进入条件队列挂起，直到被通知或中断。</p></blockquote></li><li><strong>long awaitNanos(long nanosTimeout) throws InterruptedException 方法</strong><blockquote><p>在 await() 基础上增加了超时功能，线程进入条件队列挂起直到被通知、中断或超时，如果在 nanosTimeout 内返回，那么返回值就是 nanosTimeout - 实际耗时，如果返回值是 0 或者负数，表示超时了。</p></blockquote></li><li><strong>boolean awaitUntil(Date deadline) throws InterruptedException 方法</strong><blockquote><p>在 await() 基础上增加了超时功能，线程进入条件队列挂起直到被通知、中断或者到某个时间。如果没有到指定时间就通知，返回 true，否则表示超时。</p></blockquote></li><li><strong>boolean await(long time, TimeUnit unit) throws InterruptedException 方法</strong><blockquote><p>和 awaitUntil(Date deadline) 方法几乎一致，前者是绝对时间，后者是时间粒度。</p></blockquote></li><li><strong>void signal() 方法</strong><blockquote><p>将条件队列中的头节点转到同步队列中，以等待竞争同步状态。</p></blockquote></li><li><strong>void signalAll() 方法</strong><blockquote><p>将条件队列中的所有节点依次转到同步队列中，以等待竞争同步状态。此时条件队列进入下一个周期。</p></blockquote></li></ol><p>在 JUC 中 Condition 主要基于 <code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 实现的，在语义中就是我们说的锁概念，而锁又是基于 AQS 实现的。总的来说，Condition 依赖 Lock，Lock 实现是基于 AQS 的。下面以 <code>ReentrantLock</code> 作为 Condition 的实现进行说明。</p><h2 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h2><p><code>ConditionObject</code>实现了 Condition 接口，同时作为<code>AbstractQueuedSynchronizer</code>的内部类，因为 Condition 的操作需要获取到同步状态，因此其实现类作为<code>AbstractQueuedSynchronizer</code>的内部类是比较合理的，这意味着<code>ConditionObject</code>可以访问外部资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractQueuedSynchronizer</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 条件队列 - 头节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 条件队列 - 尾节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a new &#123;<span class="doctag">@code</span> ConditionObject&#125; instance.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>每个 ConditionObject 对象内部维护了一个基于单向链表的条件队列</strong>，该队列是 Condition 实现等待-通知机制的关键。既然是链表，其中的节点定义是什么呢？ConditionObject 没有重新定义链表节点，而是直接使用外部类 AbstractQueuedSynchronizer 定义的 Node ，这也是合理的。下面我们简单看下该 Node 的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractQueuedSynchronizer</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 共享类型节点，表明节点在共享模式下等待</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 独占类型节点，表明节点在独占模式下等待</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态 - 取消（线程已经取消）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态 - 通知（后继线程需要被唤醒）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态 - 条件等待（线程在 Condition 上等待）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态 - 传播（无条件向后传播唤醒动作）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态，初始值为 0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同步队列中使用，前驱节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同步队列中使用，后继节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 节点中封装的线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 条件队列中使用，后置节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>条件队列和同步队列共同使用上述的 <strong>Node</strong> 节点构建队列，区别在于前者底层数据结构是双向链表，节点的维护使用 <strong>prev</strong> 和 <strong>next</strong> 属性，后者底层数据结构是单向链表，节点维护使用 <strong>nextWaiter</strong> 属性，两者中的节点等待状态都是使用 <strong>waitStatus</strong> 属性。</p><p><code>ReentrantLock</code> 对象和 <code>ReentrantReadWriteLock</code> 对象可以创建多个 ConditionObject 对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>下面对 <code>ReentrantLock</code> 和 <code>ConditionObject</code> 的关联关系进行说明：</strong></p><ol><li>ConditionObject 维护的条件队列和 ReentrantLock 维护的同步队列的节点都是 Node 的实例，条件队列的线程节点需要移动到同步队列中以参与竞争同步状态。</li><li>ReentrantLock 对象与 ConditionObject 对象的比例关系为： 1 : N ，每个 ConditionObject 都能直接访问 ReentrantLock 这个外部类资源。</li><li>一个同步队列对应 N 个条件队列，同步队列中的线程（获取到同步状态）可以选择性地进入不同的条件队列进行等待，而多个条件队列中的线程节点要参与竞争同步状态就需要进入同一个同步队列。</li></ol><p>接下来对等待和通知的核心代码进行分析，根据主要流程分别说明。</p><h2 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h2><p><code>ConditionObject</code> 中实现了几种不同功能的等待方法，在介绍 <code>Condition</code> 接口时已经详细说明，下面先对 <code>await()</code> 的方法实现进行分析。</p><p>当获取同步状态的线程调用 <code>await()</code> 方法时，相当于同步队列的头节点中的线程（获取了同步状态的节点）进入到 Condition 的条件队列中，完全释放同步状态后同步队列将会移除该线程对应的节点。需要说明的是，下图中的第 2 步中释放同步状态失败的情况是针对没有获取到同步状态就执行 <code>await</code> 方法的情况，获取到同步状态的线程在释放状态的时候一般是不会出释放同步状态失败的情况。值得一提的是，同步队列中头节点的线程是先释放同步状态然后才会占领头节点进而去唤醒后继等待的线程，也就是同步队列中的头节点就是供持有同步状态的线程占领，进而唤醒后继等待线程。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-condition-await-process.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 响应中断</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 将当前线程封装到节点中，并将节点加入到条件队列尾部</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 保存并完全释放同步状态，注意是完全释放，因为允许可重入锁。如果没有持锁会抛出异常，也就是释放同步状态失败</span></span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="comment">// 记录中断模式</span></span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *3. 判断上述加入到条件队列的线程节点是否被移动到了同步队列中，不在则挂起线程（曾经获取到锁的线程）。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 循环结束的条件：</span></span><br><span class="line"><span class="comment">         * 1. 其它线程调用 signal/signalAll 方法，将当前线程节点移动到同步队列中，节点对应的线程将会在竞争同步状态的过程被前驱节点唤醒。</span></span><br><span class="line"><span class="comment">         * 2. 其它线程中断了当前线程，当前线程会自行尝试进入同步队列中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// 挂起线程，直到被唤醒或被中断</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 检测中断模式：</span></span><br><span class="line"><span class="comment">             * 在线程从 park 中返回时，需要判断是被唤醒返回还是被中断返回。</span></span><br><span class="line"><span class="comment">             * 1). 如果线程没有被中断，则返回 0，此时需要重试循环继续判断当前线程节点是否在同步队列中。</span></span><br><span class="line"><span class="comment">             * 2). 如果线程被中断</span></span><br><span class="line"><span class="comment">             *   - 中断发生在被唤醒之前，当前线程（线程节点）会尝试自行进入同步队列并返回 THROW_IE，后续需要抛出中断异常。todo</span></span><br><span class="line"><span class="comment">             *   - 中断发生在被唤醒之后，即当前线程（线程节点）尝试自行进入同步队列失败（说明其它线程调用过了 signal/signalAll 唤醒线程并尝试将线程节点转到同步队列），</span></span><br><span class="line"><span class="comment">             *     返回 REINTERRUPT ，后续需要重新中断线程，向后传递中断标志。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 醒来后，被移动到同步队列的节点 node 重新尝试获取同步状态成功，且获取同步状态的过程中如果被中断，接着判断中断模式非 THROW_IE 的情况会更新为 REINTERRUPT</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 清理取消节点。正常情况下 signal/signalAll 将节点转到同步队列的同时会将节点的 nextWaiter 置空，这里主要对自行进入到同步队列中的节点进行处理。</span></span><br><span class="line">        <span class="comment">// 1） 中断模式为 THROW_IE 的情况下 nextWaiter 不会被置空，且等待状态为 0 ，这种情况下节点应该从条件队列中移除。</span></span><br><span class="line">        <span class="comment">// 2） fullyRelease 方法出现异常，nextWaiter 不会被置空，且等待状态为 CANCELLED，清理任务会由后继的节点完成。</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">            <span class="comment">// 清理条件队列中取消的节点（重组链表）</span></span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 如果线程发生过中断则根据 THROW_IE 或 REINTERRUPT 分别抛出异常或者重新中断。 todo 最终都要抛出异常还获取个球球的锁</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>下面对上述整个等待流程进行概述：</strong></p><ol><li>将获取到同步状态的线程封装到节点中并加入到条件队列。</li><li>完全释放同步状态，并记录获取到的同步状态，为后面重新竞争同步状态做准备。</li><li>在条件队列中等待被唤醒，或者被中断。</li><li>再次竞争挂起等待前的同步状态。</li><li>对中断情况的处理，抛出异常或重新中断线程以复位中断标志。</li></ol><p>以上对整个等待流程进行了总体描述，需要注意的是，<strong>当线程从<code>await()</code>方法返回时，当前线程一定获取了<code>Condition</code>相关联的锁</strong>。下面对其中的分支流进行说明。</p><h3 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h3><p>将当前线程封装到节点中，然后加入到当前 Condition 对象维护的条件队列的尾部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 条件队列尾节点</span></span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选出条件队列中有效尾节点。这里主要处理 fullyRelease 方法出现异常的情况。</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 如果需要，清理条件队列中取消的节点（重组链表）</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 重读尾节点，可能为 null</span></span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点封装当前线程，节点状态为 CONDITION</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化条件队列，firstWaiter 更新为当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前节点加入到条件队列尾</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新条件队列尾指针指向</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="comment">// 返回当前线程关联的节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特别说明：</strong></p><p>addConditionWaiter() 方法不一定是线程安全的，没有获取到锁就调用 <strong>await</strong> 方法就是不安全操作。虽然没有获取到锁的线程执行 <strong>await</strong> 方法最终会抛出异常，遗留在条件队列的节点也会被后继节点清理，但是如果持锁和不持锁的两个线程同时调用 <strong>await</strong> 方法就可能会产生并发问题，使 ConditionObject 维护的条件队列中节点产生覆盖，这是一种破坏行为，最终会导致有些成功调用 await 方法的线程可能永远没有办法被唤醒(非正常唤醒除外，如中断)，更没有机会再次获取锁，因为条件队列中并没有记录它们，记录的是非法调用的线程节点。</p><p>上述过程涉及到清理无效节点的逻辑，该逻辑由 <code>unlinkCancelledWaiters()</code> 方法完成，下面我们来分析该方法。</p><h3 id="unlinkCancelledWaiters"><a href="#unlinkCancelledWaiters" class="headerlink" title="unlinkCancelledWaiters"></a>unlinkCancelledWaiters</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 从首节点开始进行节点检测</span></span><br><span class="line">            Node t = firstWaiter;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录上一个非取消状态节点，参照节点是当前遍历节点</span></span><br><span class="line">            Node trail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 保存当前节点的下一个节点，在当前节点处于取消状态时进行替换</span></span><br><span class="line">                Node next = t.nextWaiter;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果节点的等待状态不是 CONDITION，表明这个节点被取消了。</span></span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                    <span class="comment">// 取消状态的节点要断开和链表的关联</span></span><br><span class="line">                    t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 重组链表，保证链条为空或者所有节点都是非取消状态</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * trail == null，表明 next 之前的节点的等待状态均为取消状态，此时更新 firstWaiter 引用指向</span></span><br><span class="line"><span class="comment">                     * trail != null，表明 next 之前有节点的等待状态为 CONDITION ，此时只需 trail.nextWaiter 指向 next 节点</span></span><br><span class="line"><span class="comment">                     * 注意：</span></span><br><span class="line"><span class="comment">                     * 1 firstWaiter 一定指向链表第一个非取消节点，或者为 null</span></span><br><span class="line"><span class="comment">                     * 2 trail 第一次赋值的话一定和 firstWaiter 一样的值</span></span><br><span class="line"><span class="comment">                     * 3 firstWaiter 一旦被赋予非 null 的值后就不会再变动，后续的节点连接就看 trail 的表演：</span></span><br><span class="line"><span class="comment">                     *   - 如果当前节点是取消节点，就 trail.nextWaiter 指向 next 节点</span></span><br><span class="line"><span class="comment">                     *   - 如果当前节点是非取消节点，trail 跟着节点走</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                        firstWaiter = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        trail.nextWaiter = next;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前节点没有后继则遍历结束，此时当前节点是无效节点，因此将 lastWaiter 回退即更新为上一个非取消节点</span></span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                        lastWaiter = trail;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前节点处于等待状态</span></span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    trail = t;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 下一个节点</span></span><br><span class="line">                t = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>unlinkCancelledWaiters() 方法用于清理取消节点，重新构造链表，主要处理因中断自行加入同步队列和释放同步状态异常的情况。<strong>取消节点的定义是线程节点挂起时被中断或释放同步状态失败。</strong></p><p>线程节点加入到条件队列后就可以执行完全释放同步状态操作，下面我们看具体的逻辑。</p><h3 id="fullyRelease"><a href="#fullyRelease" class="headerlink" title="fullyRelease"></a>fullyRelease</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取同步状态（拿到同步状态的线程）</span></span><br><span class="line">            <span class="keyword">int</span> savedState = getState();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放指定数量的同步状态</span></span><br><span class="line">            <span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync.tryRelease ，没有持有锁会抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 返回同步状态，释放之前的值</span></span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放同步状态失败，需要将节点状态设置为取消状态，后续会被清理</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法用于完全释放同步状态，属于 <code>AbstractQueuedSynchronizer</code> 中定义的方法，上文也提到 <code>ConditionObject</code> 是 <code>AbstractQueuedSynchronizer</code> 的内部类，因此可以共享外部资源。注意，该方法是完全释放同步状态，一般情况下为了避免死锁的产生，锁的实现上一般支持重入功能。</p><p>需要特别说明的是，如果线程没有获取到同步状态就执行 <code>await()</code> 方法，该线程关联的节点能进入到条件队列中，但是进入条件队列后需要调用 <code>fullyRelease</code> 方法执行同步状态释放逻辑，由于没有获取到同步状态在执行到 <code>ReentrantLock.tryRelease</code> 方法时会抛出异常，进而 finally 块中将节点状态进行更新 <code>node.waitStatus = Node.CANCELLED</code> ，这个已经入队到条件队列的节点会被<strong>后续节点</strong>清理出去，也即执行 <code>unlinkCancelledWaiters</code> 方法。</p><p>释放持有的同步状态后会进入自旋等待逻辑，该过程会对通知和中断进行不同的处理。</p><h3 id="等待转入同步队列"><a href="#等待转入同步队列" class="headerlink" title="等待转入同步队列"></a>等待转入同步队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">   <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 挂起线程，直到被唤醒或被中断</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检测中断模式：</span></span><br><span class="line"><span class="comment">         * 在线程从 park 中返回时，需要判断是被唤醒返回还是被中断返回。</span></span><br><span class="line"><span class="comment">         * 1. 如果线程没有被中断，则返回 0，此时需要重试循环继续判断当前线程节点是否在同步队列中。</span></span><br><span class="line"><span class="comment">         * 2. 如果线程被中断</span></span><br><span class="line"><span class="comment">         *   - 中断发生在被唤醒之前，当前线程（线程节点）会尝试自行进入同步队列并返回 THROW_IE，后续需要抛出中断异常。</span></span><br><span class="line"><span class="comment">         *   - 中断发生在被唤醒之后，即当前线程（线程节点）尝试自行进入同步队列失败（说明其它线程调用过了 signal/signalAll 唤醒线程并尝试将线程节点转到同步队列），</span></span><br><span class="line"><span class="comment">         *     返回 REINTERRUPT ，后续需要重新中断线程，向后传递中断标志，由后续代码去处理中断。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">          <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>以上自旋等待逻辑主要包括两部分工作，检查节点是否在同步队列中和处理中断。下面我们分别来看这两个逻辑。</p><h3 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue"></a>isOnSyncQueue</h3><p>检查节点是否已经转到同步队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractQueuedSynchronizer</span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 同步队列中的节点状态可能为 0、SIGNAL = -1、PROPAGATE = -3、CANCELLED = 1，但不会是 CONDITION = -2</span></span><br><span class="line"><span class="comment">         * 2 node.prev 仅会在节点获取同步状态后，调用 setHead 方法将自己设为头结点时被设置为 null，所以只要节点在同步队列中，node.prev 一定不会为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 条件队列中节点是使用 nextWaiter 指向后继节点，next 均为 null 。同步队列中节点是使用 next 指向后继节点。</span></span><br><span class="line"><span class="comment">         * 2 node.next != null 代表当前节点 node 一定在同步队列中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * node.next == null 也不能说明节点 node 一定不在同步队列中，因为同步队列入队方法不是同步的而是自旋方式，</span></span><br><span class="line"><span class="comment">         * 是先设置 node.prev，后设置 node.next，CAS 失败时 node 可能已经在同步队列上了，所以这里还需要进一步查找。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从同步队列尾部开始搜索，查找是否存在 node 节点。</span></span><br><span class="line"><span class="comment">     * 为什么不从头开始搜索？因为节点的 prev 可能会为 null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if present</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t == node)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            t = t.prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="checkInterruptWhileWaiting"><a href="#checkInterruptWhileWaiting" class="headerlink" title="checkInterruptWhileWaiting"></a>checkInterruptWhileWaiting</h3><p>检查在线程挂起期间是否发生中断，若发生中断则需要进行特殊处理，即尝试自行进入同步队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                 (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                 <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>方法逻辑如下：</strong></p><blockquote><ol><li>线程未被中断，则返回 0</li><li>线程被中断且自行入同步队列成功，则返回 THROW_IE，这种情况下后续需要抛出中断异常</li><li>线程被中断且未能自行入同步队列（其它线程已经执行 signal/signalAll 方法，节点状态已被更改），则返回 REINTERRUPT ，这种情况下后续需要重新中断线程以恢复中断标志</li></ol></blockquote><h3 id="transferAfterCancelledWait"><a href="#transferAfterCancelledWait" class="headerlink" title="transferAfterCancelledWait"></a>transferAfterCancelledWait</h3><p>取消等待（中断）后的转移节点操作，即线程被中断优先尝试自行加入同步队列，如果在中断之前已经执行过加入操作就等待加入同步队列完成。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-condition-Interrupt-signal.jpg" alt></p><p><strong>注意：</strong></p><ol><li><strong>由于中断尝试自行加入同步队列的线程节点并没有与条件队列断开连接，该节点会在后续的逻辑中进行清除。</strong></li><li><strong>即使发生了中断，节点依然会转到到同步队列中。</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 中断如果发生在 节点被转到同步队列前，应该尝试自行将节点转到同步队列中，并返回 true</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">           <span class="comment">// 将节点转到同步队列中</span></span><br><span class="line">           enq(node);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 如果上面的CAS失败，则表明已经有线程调用 signal/signalAll 方法更新过节点状态（CONDITION -&gt; 0 ），并调用 enq 方法尝试将节点转到同步队列中。</span></span><br><span class="line"><span class="comment">         * 2. 这里使用 while 进行判断节点是否已经在同步队列上的原因是，signal/signalAll 方法可能仅设置了等待状态，还没有完成将线程节点转到同步队列中，所以这里用自旋的</span></span><br><span class="line"><span class="comment">         * 方式等待线程节点加入到同步队列，否则会影响后续重新获取同步状态（调用 acquireQueued() 方法，该方法需要线程节点入同步队列才能调用，否则会抛出np异常）。这种情况表明了中断发生在节点被转移到同步队列期间。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">           <span class="comment">// 让出 CPU</span></span><br><span class="line">           Thread.yield();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 中断在节点被转到同步队列期间或之后发生，返回 false</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>判断中断发生的时机：</strong></p><blockquote><ol><li>中断在节点被转到同步队列前发生，此时返回 true</li><li>中断在节点被转到同步队列过程或之后发生，此时返回 false</li></ol></blockquote><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>在解析通知源码之前我们先回到线程挂起等待源码处，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">   <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 挂起线程，直到被唤醒或被中断</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 有中断情况，进进行处理</span></span><br><span class="line">       <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>线程释放同步状态成功后会挂起等待其它线程唤醒自己（同步队列中的线程节点），或者被其它线程中断。关于线程挂起等待时被中断的处理逻辑前文已经解析，主要是确保被中断的线程也能加入到同步队列中。下图对通知流程进行了简单地描述。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-condition-signal.jpg" alt></p><p><strong>下面对通知流程进行说明：</strong></p><ol><li>将条件队列中头节点转到同步队列中。</li><li>根据情况决定是否唤醒对应的线程，不唤醒则在同步队列中等待，唤醒则准备竞争同步状态。</li></ol><p>下面我们解析正常通知逻辑。</p><h3 id="通知单个节点"><a href="#通知单个节点" class="headerlink" title="通知单个节点"></a>通知单个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将条件队列中的头节点转到同步队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查线程是否获取了独占锁，未获取独占锁调用 signal 方法是不合法的</span></span><br><span class="line">         <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 条件队列的头节点</span></span><br><span class="line">         Node first = firstWaiter;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将条件队列的头节点转到同步队列中</span></span><br><span class="line">         <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">            doSignal(first);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="comment">// 因为条件队列的 firstWaiter 要出队转到同步队列中，因此使用 firstWaiter 后继节点占领 firstWaiter。</span></span><br><span class="line">            <span class="keyword">if</span> ((firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">              <span class="comment">// 只有一个节点的话，尾节点指向设置为 null</span></span><br><span class="line">              lastWaiter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 断开 first 与条件队列的连接</span></span><br><span class="line">              first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 transferForSignal 方法将节点移到同步队列中，如果转到同步队列失败，则对后面的节点进行操作，依次类推</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="通知所有节点"><a href="#通知所有节点" class="headerlink" title="通知所有节点"></a>通知所有节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 检查线程是否获取了独占锁，未获取独占锁调用 signalAll 方法是不合法的</span></span><br><span class="line">   <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 条件队列的头节点</span></span><br><span class="line">     Node first = firstWaiter;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">          doSignalAll(first);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 置空条件队列的头、尾指针，因为当前队列元素要全部出队，避免将新入队的节点误唤醒</span></span><br><span class="line">     lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 将条件队列中所有的节点都转到同步队列中。</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">         </span><br><span class="line">          Node next = first.nextWaiter;      </span><br><span class="line">          <span class="comment">// 将节点从条件队列中移除</span></span><br><span class="line">          first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">// 将节点转到同步队列中</span></span><br><span class="line">          transferForSignal(first);</span><br><span class="line">             </span><br><span class="line">          first = next;</span><br><span class="line">         &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="加入同步队列"><a href="#加入同步队列" class="headerlink" title="加入同步队列"></a>加入同步队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果更新节点的等待状态由 CONDITION 到 0 失败，则说明该节点已经被取消（如被中断），也就不需要再转到同步队列中了。</span></span><br><span class="line"><span class="comment">     * 由于整个 signal /signalAll 都需要拿到锁才能执行，因此这里不存在线程竞争的问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 enq 方法将 node 加入到同步队列中尾，并返回 node 的前驱节点</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取前驱节点的等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1 如果前驱节点的等待状态 ws &gt; 0，说明前驱节点已经被取消了，此时应该唤醒 node 对应的线程去尝试获取同步状态，准确的应该是先找大哥，找大哥过程会剔除它的无效前驱节点。</span></span><br><span class="line"><span class="comment">     *    注意，这里只是入队并没有执行剔除取消节点的逻辑，虽然AQS唤醒操作支持从尾节点向前寻找最前的有效节点并唤醒，但还是应该主动唤醒 node 对应的线程，以更新大哥节点。</span></span><br><span class="line"><span class="comment">     * 2 如果前驱节点的等待状态 ws &lt;= 0 ，通过 CAS 操作将 node 的前驱节点 p 的等待状态设置为 SIGNAL，当节点 p 释放同步状态后会唤醒它的后继节点 node。</span></span><br><span class="line"><span class="comment">     *   如果 CAS 设置失败（可能节点 p 在此期间被取消了），则应该立即唤醒 node 节点对应的线程，原因和 1 一致。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加入同步队列主要逻辑如下：</strong></p><ol><li>由于执行 signal/signalAll 方法需要持有同步状态，因此 transferForSignal 方法是不存在并发问题的。</li><li>对条件队列中的非 CONDITION 状态的节点不执行转入同步队列操作。</li><li>将符合条件的节点加入到同步队列中，并返回前驱节点。</li><li>正常情况下不会执行 <code>LockSupport.unpark(node.thread)</code> 唤醒线程，而是节点进入同步队列然后方法返回 true，transferForSignal 方法结束。</li><li>同步队列中 node 的前驱节点取消等待，或者 CAS 等待状态失败，需要唤醒线程，这个属于异常流。</li></ol><p>注意，执行 <code>signal</code> 或 <code>signalAll</code> 方法仅仅让线程节点具备竞争同步状态的机会，确切地说是将条件队列的节点移动到同步队列中，仅此而已。至于能不能获取到同步状态需要看具体竞争结果，要知道不仅条件队列中线程节点阻塞等待，同步队列中可能也有大量的线程节点在等待唤醒，况且条件队列中的线程节点需要移动到同步队列中才有资格参与同步状态的竞争。</p><p>通过下面的伪代码可以推演出多种可能情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认使用的是非公平锁，意味着即使同步队列中有等待唤醒的节点，锁还是有可能被其它线程获取。</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// business</span></span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// business</span></span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从等待中醒来"><a href="#从等待中醒来" class="headerlink" title="从等待中醒来"></a>从等待中醒来</h2><p>线程节点移动到同步队列后被唤醒，线程从等待中醒来，继续从 <code>LockSupport.park(this)</code> 向后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">   <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 挂起线程，直到被唤醒或被中断</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 检测中断模式</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="检查中断模式"><a href="#检查中断模式" class="headerlink" title="检查中断模式"></a>检查中断模式</h3><p>线程从挂起返回后会检查中断状态，检查中断逻辑前文已经说明，这里不再重复介绍。</p><p>以下情况会使 <code>LockSupport.park(this)</code> 返回：</p><ol><li>线程节点被同步队列中其它节点唤醒，不仅仅是它的前驱节点，还可能是头节点（头节点线程进行 signal 时，线程节点的前驱节点取消了或更新前驱节点状态失败）。</li><li>线程在挂起时被中断。</li><li>虚假唤醒，和 Object.wait() 存在同样的问题，一般使用自旋避免。</li></ol><h3 id="竞争同步状态"><a href="#竞争同步状态" class="headerlink" title="竞争同步状态"></a>竞争同步状态</h3><p>线程节点转入同步队列后，就可以尝试竞争同步状态了，注意预获取同步状态是之前释放锁前的值，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//醒来后，被移动到同步队列的节点 node 重新尝试获取同步状态成功，且获取同步状态的过程中如果被中断，接着判断中断模式非 THROW_IE 的情况会更新为 REINTERRUPT</span></span><br><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br></pre></td></tr></table></figure><p>这里回到了竞争同步状态的逻辑，获取到同步状态则继续向后执行，也意味着可以从 <strong>await</strong> 方法返回，没能获取到同步状态则继续在同步队列中等待。</p><h3 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">     <span class="comment">// 中断线程，复位中断标志</span></span><br><span class="line">     selfInterrupt();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>await() 方法返回之前会对中断进行处理，因为它支持响应中断，关于中断模式前文已经说明，会对被中断的线程进行特殊处理，保证被中断的线程也要转到同步队列中。</p><h2 id="超时等待"><a href="#超时等待" class="headerlink" title="超时等待"></a>超时等待</h2><p>这里以超时时间粒度的等待方法为例简单介绍超时等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 加入条件队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 完全释放同步状态</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="comment">// 过期时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 中断模式</span></span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时的话，自行转入到同步队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 超时时间到，跳出自旋等待</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            transferAfterCancelledWait(node);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自旋还是挂起</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查中断模式</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算超时时间</span></span><br><span class="line">        nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 竞争同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时等待是在 <code>await()</code> 方法的基础上增加了等待的超时时间，如果超过超时时间则不再等待其它线程唤醒，自行加入到同步队列中并退出自旋等待，然后尝试竞争同步状态。</p><h2 id="忽略中断"><a href="#忽略中断" class="headerlink" title="忽略中断"></a>忽略中断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加入条件队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 完全释放同步状态</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="comment">// 中断模式</span></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自旋等待</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 竞争同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">        <span class="comment">// 发生中断需要复位中断标志</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法和 <code>await()</code> 方法最大的区别是对中断不做特别处理，如果有中断发生复位中断标志即可，不会抛出中断异常。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="和对象监视器的联系"><a href="#和对象监视器的联系" class="headerlink" title="和对象监视器的联系"></a>和对象监视器的联系</h2><ol><li>Condition 定义的方法和对象监视器方法类似。</li><li>对象监视器方法需要和 <code>synchronized</code> 关键字一起使用，且必须先拿到锁才能执行监视器方法。Condition 对象需要和 Lock 对象绑定，同样需要先获取到锁才能执行 Condition 的方法。</li></ol><h2 id="和对象监视器的区别"><a href="#和对象监视器的区别" class="headerlink" title="和对象监视器的区别"></a>和对象监视器的区别</h2><ol><li>Condition 接口中定义的方法功能更加完善，如忽略中断、等待超时。</li><li>Condition 是代码层面上的实现，对象监视器是JVM指令层面上的实现。</li><li>Condition 与 Lock 结合拥有一个同步队列和多个条件队列，而对象监视器模型上有一个同步队列和一个条件队列。</li><li>Condition 支持唤醒特定线程，对象监视器方法唤醒线程是随机的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在 JUC 之前，Java 实现等待/通知模式是通过定义在 Object 中的一组监视器方法 &lt;code&gt;wait方法&lt;/code&gt;、&lt;co
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
      <category term="AQS" scheme="https://gentryhuang.com/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - 链表</title>
    <link href="https://gentryhuang.com/posts/2362a8ea/"/>
    <id>https://gentryhuang.com/posts/2362a8ea/</id>
    <published>2020-10-20T11:33:59.000Z</published>
    <updated>2020-11-05T15:46:20.745Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol><li><p>redis中的链表</p><p>链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置这中数据结构，所以redis构建了自己的链表实现。</p></li><li><p>redis链表节点的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">  <span class="comment">// 前置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="comment">// 后置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">// 节点的值 (可用于保存各种不同类型的值)</span></span><br><span class="line">  <span class="keyword">void</span> *value</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>redis链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数，用于复制链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数，用于释放链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数，用于对比链表节点所保存的值和其他值是否相等</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>redis链表的特点</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)</span><br><span class="line">- 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点</span><br><span class="line">- 带表头和表尾指针：使用list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)</span><br><span class="line">- 带链表长度计数器：程序使用list结构的len属性标记链表中节点的个数，程序获取链表中节点个数的复杂度为O(1)</span><br><span class="line">- 多态：链表可以保存各种不同类型的值</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>链表在redis中的应用</p><p>链表被广泛用于实现redis的各种功能，如：列表键、发布与订阅、慢查询、监视器，redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;redis中的链表&lt;/p&gt;
&lt;p&gt;链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis数据结构" scheme="https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - 简单动态字符串</title>
    <link href="https://gentryhuang.com/posts/aa1d8127/"/>
    <id>https://gentryhuang.com/posts/aa1d8127/</id>
    <published>2020-10-18T11:00:50.000Z</published>
    <updated>2020-11-05T15:46:20.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h3><ol><li><p>初识动态字符串</p><p>redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS作为redis的默认字符串表示。 <code>在redis中，c字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如日志。当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，redis就会使用SDS来表示字符串值。</code> 值的注意的是，对于redis中的key都是使用SDS来实现的。此外，SDS除了用来保存Redis数据库中的字符串值之外，SDS还被用作缓冲区（buffer）: AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区。</p></li><li><p>sds的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">  <span class="comment">// 记录buf数组中已使用字节的数量等价于sds所保存字符串的长度</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">  <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">  <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>sds遵循c字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在sds的len属性中，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由sds函数自动完成的。遵循空字符结尾的好处是，sds可以直接使用一部分C字符串函数库里面的函数。</p></li><li><p>sds与c字符串的区别</p><p>c语言使用的简单字符串表示方式，并不能满足redis对字符串在安全性、效率以及功能方面的要求。</p><p>3.1  常数复杂度获取字符串长度</p><blockquote><p>因为c字符串并不记录自身的长度信息，所以要获取长度就必须遍历整个字符串，故获取字符串长度的复杂度为O(N)。而redis的sds结构中通过len属性记录了sds的长度，故获取字符串长度的复杂度为O(1)。注意，设置和更新sds长度的工作是由sds的API在执行时自动完成的，使用sds无须进行任何手动修改长度的操作。</p></blockquote><p>3.2 避免缓冲区溢出</p><blockquote><p>c字符串不记录自身长度，很容易造成缓冲区溢出。与c字符串不同，sds的空间分配策略完全杜绝了发生缓冲区溢出的可能性，当sds api需要对sds进行修改时，api会先检查sds的空间是否满足需要，如果不满足的话，api会自动将sds的空间扩展至执行所需的大小，然后才执行实际的修改操作，因此使用sds既不需要手动修改sds的空间大小，也不会出现c字符串中可能出现的缓冲区溢出问题。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line">    <span class="comment">//追加时先进行扩容，后面详细说明</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//拼接字符串</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s:原数组     </span></span><br><span class="line"><span class="comment">//strlen(t) 需拼接的目标数组的长度</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>3.3 内存分配与释放</p><p>因为c字符串的长度和底层数组的长度之间存在着关联性，所以<code>每次增加或者缩短一个c字符串，程序都总要对保存这个c字符串的数字进行一次分配操作</code>，但是内存分配操作涉及到复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，为了避免c字符串的这种缺陷，sds通过未使用空间解除了字符串长度和底层数组长度之间的关联，通过未使用空间，sds实现了空间预分配和惰性空间释放两种优化策略。</p><ul><li><p>空间预分配</p><p>空间预分配用于优化sds的字符串增长操作：当sds的api对一个sds进行修改，并且需要对sds进行空间扩展的时候，程序不仅会为sds分配修改所必须要的空间，还会为sds分配额外的未使用空间。通过空间预分配策略，redis可以减少连续执行字符串增长操作所需的内存重新分配次数，在扩展sds空间之前，sds api 会先检查未使用空间是否足够，如果足够就直接使用未使用空间，而不需要执行内存重新分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis 扩容源码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，</span></span><br><span class="line"><span class="comment"> * buf 至少会有 addlen + 1 长度的空余空间</span></span><br><span class="line"><span class="comment"> * （额外的 1 字节是为 \0 准备的）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *  sds ：扩展成功返回扩展后的 sds</span></span><br><span class="line"><span class="comment"> *        扩展失败返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前的空余空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 最少需要的长度</span></span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class="line">        <span class="comment">// 那么为它分配两倍于所需长度的空间</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足，分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 sds 的空余长度</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 sds</span></span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额外分配未使用空间数量的计算策略：</p><blockquote><ol><li>对sds修改后，sds的长度（即len属性的值）小于1MB，那么程序分配和len属性同样大小的未使用空间，这时sds的len属性的值将和free属性的值相同。例如：修改后sds的len变成10字节，那么程序也会分配10字节的未使用空间，sds的buf数组的实际长度：10 + 10 + 1 = 21字节</li><li>对sds修改后，sds的长度大于等于1MB，那么程序会分配1MB的未使用空间。例如：修改后sds的len变成30MB，那么程序会分配1MB的未使用空间，sds的buf数组的时间长度：30MB + 1MB + 1byte</li></ol></blockquote></li><li><p>惰性空间释放</p><p>惰性空间释放用于优化sds的字符串缩短操作：当sds的api需要缩短sds保存的字符串时，程序并不立即使用内存重分配来回收缩短后多来的字节，而是使用free属性将这些字节的数量纪录起来，用于将来对sds进行增长操作时，这些未使用空间可能就派上用场了。注意，sds也提供了相应的api，可以真正地释放sds的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</p></li></ul><p>3.4 二进制安全</p><blockquote><p>c字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里不能包含空字符，否则在读取的时候会被默认为结束字符，这些限制使得c字符串只能保存文本数据，不能保存图片、音视频、压缩文件这类的二进制数据。sds的api都是二进制安全的，所有的sds api都会以<code>二进制的方式处理sds存放在buf数组里的数据</code>,程序不会对其中的数据做任何限制、过滤，数据写入时是什么样，它被读取时就是什么样。<code>这也是将sds的buf属性称为字节数组的原因，redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据</code>。</p></blockquote></li><li><p>c字符串和sds之间的区别</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         C字符串                                    SDS</span><br><span class="line">- 获取字符串长度的复杂度为O（n）                 获取字符串长度的复杂度O（1）</span><br><span class="line">- API是不安全的，可能造成缓冲区溢出                      API是安全的</span><br><span class="line">- 修改字符串长度N次，必然要执行N次内存重分配     修改字符长度N次，最多执行N次内存重分配</span><br><span class="line">- 只能保存文本数据                                 可以保存文本或者二进制数据</span><br><span class="line">- 可使用&lt;string.h&gt;库中的函数                   可使用一部分&lt;string.h&gt;库中的函数</span><br></pre></td></tr></table></figure></li><li><p>sds更多的api可参考源码</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简单动态字符串&quot;&gt;&lt;a href=&quot;#简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;简单动态字符串&quot;&gt;&lt;/a&gt;简单动态字符串&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初识动态字符串&lt;/p&gt;
&lt;p&gt;redis没有直接使用C语言传统的字符串表示（以空字
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis数据结构" scheme="https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 优雅停机</title>
    <link href="https://gentryhuang.com/posts/ef4cfe7a/"/>
    <id>https://gentryhuang.com/posts/ef4cfe7a/</id>
    <published>2020-09-25T16:00:00.000Z</published>
    <updated>2021-02-17T06:43:59.410Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>优雅停机仅存在于服务重启、下线这样的部署阶段，优雅停机是一个应用生命周期的一部分，它保障了应用的健壮性。dubbo是通过jdk的ShutdownHook来完成优雅停机的，所以如果用户使用 kill -9 pid 等强制关闭指令，是不会执行优雅停机的，只有通过 kill pid 即正常退出进程，才会执行。</p><h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><ul><li>优雅停机的服务端有正在处理中的请求，不能被停机指令中断，除非超时</li><li>优雅停机的消费端不应该再发起新的请求</li><li>消费端不应该请求已经下线的服务提供者</li></ul><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>应用的重新启动、停机等操作，避免了对业务的连续性造成影响，如：集群中的某个应用存在逻辑上的bug，需要修改程序，这时候就可以使用优雅停机平滑下线，不会造成调用方异常问题。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/shutdownhook.png" alt></p><p><font color="#c7254e"> dubbo中实现优雅停机主要包含以下步骤 </font></p><ol><li>收到kill 9 进程退出信号时，spring容器会触发容器销毁事件  (其实是spring注册的jvm钩子程序执行的，后面会看到)</li><li>provider端会取消注册服务元数据信息</li><li>consumer端会收到最新地址列表（准备停机地址不在该地址列表中）</li><li>dubbo协议会发送readonly事件报文通知consumer服务不可用</li><li>服务端等待已经执行的任务结束并不再处理新的请求</li></ol><p><strong>说明</strong></p><ul><li>上图中的流程是使用spring构建的dubbo应用</li><li>上图中的流程没有体现出优雅停机的消费端角色，该角色做的工作相对简单，主要是不再发起新的调用请求和等待响应返回，超时才会强制关闭</li><li>注册中心已经通知了最新服务列表，发送readonly事件主要考虑到注册中心推送服务有网络延迟以及客户端计算服务列表也需要时间。消费端收到后会设置对应的provider为不可用状态，下次负载均衡就不会调用这个下线的服务</li></ul><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>dubbo对优雅停机的实现在不同的版本中有所差异，下面从2.5.x、2.6.x以及2.7.x这三个版本分别分析。</p><h4 id="2-5-x的优雅停机"><a href="#2-5-x的优雅停机" class="headerlink" title="2.5.x的优雅停机"></a>2.5.x的优雅停机</h4><p>注册shutdown hook</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 省略其它代码    </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Run shutdown hook now."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 销毁资源</span></span><br><span class="line"><span class="comment">                     * 1 注册中心数据销毁： 删除注册中心中本节点对应的提供者地址以及订阅数据</span></span><br><span class="line"><span class="comment">                     * 2 协议流程数据销毁： 取消该协议所有已经暴露和引用的服务，释放协议所占用的所有资源，比如连接和端口</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    ProtocolConfig.destroyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"DubboShutdownHook"</span>));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p> ProtocolConfig.destroyAll()方法是用来释放资源的，由于dubbo支持多注册中心和多协议，因此具体销毁实现细节取决于具体的注册中心和具体的协议，这里不再展开说明。</p><h4 id="2-6-x的优雅停机"><a href="#2-6-x的优雅停机" class="headerlink" title="2.6.x的优雅停机"></a>2.6.x的优雅停机</h4><p> spring也依赖shutdown hook完成优雅停机，其注册jvm钩子的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a shutdown hook with the JVM runtime, closing this context</span></span><br><span class="line"><span class="comment"> * on JVM shutdown unless it has already been closed at that time.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Delegates to &#123;<span class="doctag">@code</span> doClose()&#125; for the actual closing procedure.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Runtime#addShutdownHook</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #close()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doClose()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No shutdown hook registered yet.</span></span><br><span class="line"><span class="keyword">this</span>.shutdownHook = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (startupShutdownMonitor) &#123;</span><br><span class="line">doClose();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// 注册jvm钩子</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">this</span>.shutdownHook);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring的shutdownhook具体任务如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Actually performs context closing: publishes a ContextClosedEvent and</span></span><br><span class="line"><span class="comment">  * destroys the singletons in the bean factory of this application context.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;Called by both &#123;<span class="doctag">@code</span> close()&#125; and a JVM shutdown hook, if any.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> org.springframework.context.event.ContextClosedEvent</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #destroyBeans()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #close()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #registerShutdownHook()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.active.get() &amp;&amp; <span class="keyword">this</span>.closed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Closing "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LiveBeansView.unregisterApplicationContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Publish shutdown event   // 注意容器关系事件的发布</span></span><br><span class="line">publishEvent(<span class="keyword">new</span> ContextClosedEvent(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception thrown from ApplicationListener handling ContextClosedEvent"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop all Lifecycle beans, to avoid delays during individual destruction.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleProcessor != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.lifecycleProcessor.onClose();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception thrown from LifecycleProcessor on context close"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy all cached singletons in the context's BeanFactory.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close the state of this context itself.</span></span><br><span class="line">closeBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let subclasses do some final clean-up if they wish...</span></span><br><span class="line">onClose();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.active.set(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dubbo2.6.x支持使用spring构建dubbo应用时，能够安全使用优雅停机。由于dubbo注册了jvm停止的钩子，<font color="#c7254e"> spring可能 </font> 也注册了jvm停机的钩子，这种情况下两个并发执行的线程可能引用已经销毁的资源，导致优雅停机失效。比如，dubbo正在执行的任务需要引用spring中的bean，但此时spring钩子已经关闭spring上下文，导致访问spring资源都会报错。因此对于这种情况，dubbo在2.6.3中新增ShutdownHookListener 类用来解决并发问题，该类实现了ApplicationListener接口，当进程退出时jvm钩子会被触发，此时spring和dubbo注册的jvm钩子都会被回调，spring注册的jvm钩子程序中spring发出容器关闭事件，ShutdownHookListener接收到关闭事件后执行dubbo的jvm钩子程序进行资源的释放，这样就避免使用无效spring bean的问题，从而完成优雅停机。</p><p><font color="#c7254e"> ShutdownHookListener </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHookListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            <span class="comment">// 使用spring框架时也不应该删除dubbo shutdown hook，因为spring可能没有注册ContextClosed 事件</span></span><br><span class="line">            DubboShutdownHook shutdownHook = DubboShutdownHook.getDubboShutdownHook();</span><br><span class="line">            shutdownHook.destroyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#c7254e"> AbstractConfig中依然保留JVM停止钩子 </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 省略无关代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.name"</span>, <span class="string">"dubbo.service.protocol"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.host"</span>, <span class="string">"dubbo.service.server.host"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.port"</span>, <span class="string">"dubbo.service.server.port"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.threads"</span>, <span class="string">"dubbo.service.max.thread.pool.size"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.consumer.timeout"</span>, <span class="string">"dubbo.service.invoke.timeout"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.consumer.retries"</span>, <span class="string">"dubbo.service.max.retry.providers"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.consumer.check"</span>, <span class="string">"dubbo.service.allow.no.provider"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.service.url"</span>, <span class="string">"dubbo.service.address"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this is only for compatibility</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Dubbo 的优雅停机 ShutdownHook 在 AstractConfig 的静态代码块中，这保证了ShutdownHook能够给被初始化。</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 1 Dubbo 是 通过 JDK的ShutdownHook来完成优雅停机的</span></span><br><span class="line"><span class="comment">         * 2 ShutdownHook本质上是一个线程，任务体在对应的run方法中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><font color="#c7254e">DubboShutdownHook </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboShutdownHook</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DubboShutdownHook<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShutdownHook,类属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DubboShutdownHook dubboShutdownHook = <span class="keyword">new</span> DubboShutdownHook(<span class="string">"DubboShutdownHook"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DubboShutdownHook <span class="title">getDubboShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dubboShutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Has it already been destroyed or not?</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 是否已经被销毁标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean destroyed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DubboShutdownHook</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShutdownHook的任务体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Run shutdown hook now."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        destroyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Destroy all the resources, including registries and protocols.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 销毁所有的资源，包括 Registry相关 和 Protocol相关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果已经销毁则忽略</span></span><br><span class="line">        <span class="keyword">if</span> (!destroyed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁所有的 Registry,取消应用程序中的服务提供者和消费者的订阅与注册</span></span><br><span class="line">        AbstractRegistryFactory.destroyAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 销毁所有的 Protocol</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 这里的Protocol比较多，大体上可以分两类：</span></span><br><span class="line"><span class="comment">         * 1 和Registry相关的Protocol，RegistryProtocol关注服务的注册</span></span><br><span class="line"><span class="comment">         * 2 具体协议，如 DubboProtocol、httpProtocol等,关注服务的暴露和引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (String protocolName : loader.getLoadedExtensions()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Protocol protocol = loader.getLoadedExtension(protocolName);</span><br><span class="line">                <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    protocol.destroy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#c7254e">DubboShutdownHook与protocol、registry的关系图 </font></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/shutdownhook-process.jpg" alt></p><p><font color="#c7254e"> 图解(以dubbo协议和zookeeper注册中心为例) <font></font></font></p><p><font color="#c7254e"> Registry相关 <font></font></font></p><ul><li>AbstractRegistryFactory#destroyAll方法，遍历所有的Registry并调用Registry#destroy方法。然后清空Registry缓存集合。</li><li>AbstractRegistry 实现了公用的销毁逻辑：取消注册和订阅。服务提供者和消费者都会执行注册和订阅，因此都需要进行取消。</li><li>FailbackRegistry实现销毁公用的重试任务</li><li>ZookeeperRegistry销毁其对应的客户端连接</li></ul><p><font color="#c7254e"> Protocol相关 <font></font></font></p><ul><li>AbstractProtocol#destroy方法，销毁协议对应的服务消费者拥有的Invoker， 销毁协议对应的服务提供者的所有Exporter。</li><li>DubboProtocol销毁所有通信 ExchangeClient 和 ExchangeServer</li></ul><p><strong>小结</strong></p><ul><li>dubbo2.6.3在spring环境中注册两个钩子的情况，ShutdownHookListener解决了并发执行问题</li><li>使用ShutdownHookListener也不能移除调dubbo注册的jvm钩子，因为不能保证应用中一定会注册spring的shutdown hook</li></ul><h4 id="2-7-x优雅停机"><a href="#2-7-x优雅停机" class="headerlink" title="2.7.x优雅停机"></a>2.7.x优雅停机</h4><p>从dubbo的2.6.3版本开始，解决了使用spring构建的dubbo可能发生优雅停机并发执行shutdown hook的问题。但是还是存在一个问题，那就是如果在spring环境下没有注册spring的jvm钩子，虽然没有大问题，但是还是有不完整的。dubbo2.7.x进行显示地注册spring的jvm钩子，并且移除dubbo的jvm钩子，解决了当前问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ApplicationContext&gt; CONTEXTS = <span class="keyword">new</span> ConcurrentHashSet&lt;ApplicationContext&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ApplicationListener SHUTDOWN_HOOK_LISTENER = <span class="keyword">new</span> ShutdownHookListener();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addApplicationContext</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        CONTEXTS.add(context);</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ConfigurableApplicationContext) &#123;</span><br><span class="line">            <span class="comment">// 显示注册spring的jvm钩子</span></span><br><span class="line">            ((ConfigurableApplicationContext) context).registerShutdownHook();</span><br><span class="line">            <span class="comment">// 显示移除dubbo的jvm钩子</span></span><br><span class="line">            DubboShutdownHook.getDubboShutdownHook().unregister();</span><br><span class="line">        &#125;</span><br><span class="line">        BeanFactoryUtils.addApplicationListener(context, SHUTDOWN_HOOK_LISTENER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHookListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">                DubboShutdownHook shutdownHook = DubboShutdownHook.getDubboShutdownHook();</span><br><span class="line">                shutdownHook.doDestroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>dubbo2.7.x优雅停机的实现，解决了spring环境下两个钩子并发的问题，并且显示注册spring的jvm钩子。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优雅停机并不是java中的概念，也不是只有dubbo框架进行了扩展实现，springboot、docker等都有涉及到优雅停机。dubbo中的优雅停机是不断优化的，2.5.x中的存在一定的问题，2.6.x在一般场景下是没有问题的，2.7.x是对之前版本的完善和优化。如果 ShutdownHook 不能生效，可以在需要的时机自行调用DubboShutdownHook.destroyAll()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;优雅停机仅存在于服务重启、下线这样的部署阶段，优雅停机是一个应用生命周期的一部分，它保障了应用的健壮性。dubbo是通过jdk的Shutdo
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Spring" scheme="https://gentryhuang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 本地暴露</title>
    <link href="https://gentryhuang.com/posts/751c0982/"/>
    <id>https://gentryhuang.com/posts/751c0982/</id>
    <published>2020-09-19T16:00:00.000Z</published>
    <updated>2021-02-19T02:20:35.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有了前面一系列文章铺垫，再来看服务暴露与服务引用就简单很多了。本地暴露需要配置、SPI、动态代理、协议等知识，其中协议部分会在后面的文章中着重分析。</p><h2 id="配置承载"><a href="#配置承载" class="headerlink" title="配置承载"></a>配置承载</h2><p>无论是服务暴露还是服务引用，Dubbo 框架都会根据配置覆盖策略对配置项进行聚合处理，配置覆盖策略参见<a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/xml.html" target="_blank" rel="noopener">官网</a> 。Dubbo 支持动态添加配置项即服务治理，其中不允许 Provider 端配置项透传到客户端的都会进行特殊处理. </p><h2 id="服务暴露配置"><a href="#服务暴露配置" class="headerlink" title="服务暴露配置"></a>服务暴露配置</h2><ul><li>仅本地暴露<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"local"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li>仅远程暴露<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"remote"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li>本暴露和远程暴露<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在不配置 scope 的情况下，默认两种方式都暴露</span><br></pre></td></tr></table></figure></li><li>不暴露<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"none"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="服务暴露机制"><a href="#服务暴露机制" class="headerlink" title="服务暴露机制"></a>服务暴露机制</h2><p>Dubbo 服务暴露分为两部分，先将持有的服务信息（服务对象，服务接口，服务 URL信息）通过动态代理工厂转换成 Invoker ，再把 Invoker 通过具体的协议转成 Exporter（注意，这里涉及到多协议的知识后面文章会详细分析） 。Dubbo 框架在进行服务暴露时，无论是 API 配置、XML 配置还是注解配置，最终都会转成 ServiceBean，它继承自 ServiceConfig ，注意这里是指使用 Spring 环境时，如果仅使用 Dubbo API 配置的话，会转成 ServiceConfig 。因为 Spring 是主流，下面没有特别说明都是在 Spring 环境下。</p><h2 id="服务暴露方式"><a href="#服务暴露方式" class="headerlink" title="服务暴露方式"></a>服务暴露方式</h2><p>Dubbo 支持两种服务暴露方式，分为延迟暴露和立即暴露。延迟暴露的入口是 ServiceBean 的 afterPropertiesSet 方法，立即暴露的入口是 ServiceBean 的 onApplicationEvent 方法。</p><h3 id="Spring支持的-Dubbo-IOC"><a href="#Spring支持的-Dubbo-IOC" class="headerlink" title="Spring支持的 Dubbo IOC"></a>Spring支持的 Dubbo IOC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="comment">// 为Spring拓展工厂注入上下文 ,用于Dubbo IOC</span></span><br><span class="line">        SpringExtensionFactory.addApplicationContext(applicationContext);</span><br><span class="line">        <span class="keyword">if</span> (applicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SPRING_CONTEXT = applicationContext;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method method = applicationContext.getClass().getMethod(<span class="string">"addApplicationListener"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;ApplicationListener<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">// backward compatibility to spring 2.0.1</span></span><br><span class="line">                method.invoke(applicationContext, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">                <span class="comment">// 当前Spring容器是否支持上下文监听</span></span><br><span class="line">                supportedApplicationListener = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (applicationContext <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Method method = AbstractApplicationContext.class.getDeclaredMethod("addListener", new Class&lt;?&gt;[]&#123;ApplicationListener.class&#125;); // backward compatibility to spring 2.0.1</span><br><span class="line">                        <span class="keyword">if</span> (!method.isAccessible()) &#123;</span><br><span class="line">                            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(applicationContext, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">                        supportedApplicationListener = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean#setApplicationContext 方法用于将 Spring 的上下文设置设置到 SpringExtensionFactory 中，这样 Dubbo IOC 就可以使用 Spring 管理的对象了。</p><h3 id="延迟暴露"><a href="#延迟暴露" class="headerlink" title="延迟暴露"></a>延迟暴露</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务暴露的入口，非延迟暴露 。收到 Spring 容器的刷新事件执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否有延迟暴露 &amp;&amp; 是否已暴露 &amp;&amp; 是不是已被取消暴露</span></span><br><span class="line">        <span class="keyword">if</span> (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"The service ready on spring started. service: "</span> + getInterface());</span><br><span class="line">            &#125;</span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 delay</span></span><br><span class="line">        Integer delay = getDelay();</span><br><span class="line">        ProviderConfig provider = getProvider();</span><br><span class="line">        <span class="keyword">if</span> (delay == <span class="keyword">null</span> &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果前面获取的 delay 为空，这里继续获取</span></span><br><span class="line">            delay = provider.getDelay();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 判断 delay 是否为空，或者等于 -1，当 delay 为空，或者等于-1时，该方法返回 true，而不是 false</span></span><br><span class="line"><span class="comment">         * 2 supportedApplicationListener 变量用于表示当前的 Spring 容器是否支持 ApplicationListener，这个值初始为 false。</span></span><br><span class="line"><span class="comment">         * 在 Spring 容器将自己设置到 ServiceBean 中时，ServiceBean 的 setApplicationContext 方法会检测 Spring 容器是否支持 ApplicationListener,若支持，则将 supportedApplicationListener 置为 true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> supportedApplicationListener &amp;&amp; (delay == <span class="keyword">null</span> || delay == -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置项</span></span><br><span class="line">        <span class="keyword">return</span> delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的 isDelay 方法，当方法返回 true 时，表示无需延迟导出。返回 false 时，表示需要延迟导出，与字面意思是相反的。</p><h3 id="立即暴露"><a href="#立即暴露" class="headerlink" title="立即暴露"></a>立即暴露</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务暴露的入口，延迟暴露</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"deprecation"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getProvider() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Map&lt;String, ProviderConfig&gt; providerConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (providerConfigMap != <span class="keyword">null</span> &amp;&amp; providerConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> ((protocolConfigMap == <span class="keyword">null</span> || protocolConfigMap.size() == <span class="number">0</span>)</span><br><span class="line">                        &amp;&amp; providerConfigMap.size() &gt; <span class="number">1</span>) &#123; <span class="comment">// backward compatibility</span></span><br><span class="line">                    List&lt;ProviderConfig&gt; providerConfigs = <span class="keyword">new</span> ArrayList&lt;ProviderConfig&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() != <span class="keyword">null</span> &amp;&amp; config.isDefault().booleanValue()) &#123;</span><br><span class="line">                            providerConfigs.add(config);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!providerConfigs.isEmpty()) &#123;</span><br><span class="line">                        setProviders(providerConfigs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ProviderConfig providerConfig = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate provider configs: "</span> + providerConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                            &#125;</span><br><span class="line">                            providerConfig = config;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        setProvider(providerConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getApplication() == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getApplication() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (applicationConfigMap != <span class="keyword">null</span> &amp;&amp; applicationConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ApplicationConfig applicationConfig = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (ApplicationConfig config : applicationConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate application configs: "</span> + applicationConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        applicationConfig = config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    setApplication(applicationConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getModule() == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getModule() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (moduleConfigMap != <span class="keyword">null</span> &amp;&amp; moduleConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ModuleConfig moduleConfig = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (ModuleConfig config : moduleConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate module configs: "</span> + moduleConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        moduleConfig = config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    setModule(moduleConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((getRegistries() == <span class="keyword">null</span> || getRegistries().isEmpty())</span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getRegistries() == <span class="keyword">null</span> || getProvider().getRegistries().isEmpty())</span><br><span class="line">                &amp;&amp; (getApplication() == <span class="keyword">null</span> || getApplication().getRegistries() == <span class="keyword">null</span> || getApplication().getRegistries().isEmpty())) &#123;</span><br><span class="line">            Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (registryConfigMap != <span class="keyword">null</span> &amp;&amp; registryConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                List&lt;RegistryConfig&gt; registryConfigs = <span class="keyword">new</span> ArrayList&lt;RegistryConfig&gt;();</span><br><span class="line">                <span class="keyword">for</span> (RegistryConfig config : registryConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        registryConfigs.add(config);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (registryConfigs != <span class="keyword">null</span> &amp;&amp; !registryConfigs.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">super</span>.setRegistries(registryConfigs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getMonitor() == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getMonitor() == <span class="keyword">null</span>)</span><br><span class="line">                &amp;&amp; (getApplication() == <span class="keyword">null</span> || getApplication().getMonitor() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Map&lt;String, MonitorConfig&gt; monitorConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (monitorConfigMap != <span class="keyword">null</span> &amp;&amp; monitorConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                MonitorConfig monitorConfig = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (MonitorConfig config : monitorConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (monitorConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate monitor configs: "</span> + monitorConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        monitorConfig = config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (monitorConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    setMonitor(monitorConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((getProtocols() == <span class="keyword">null</span> || getProtocols().isEmpty())</span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getProtocols() == <span class="keyword">null</span> || getProvider().getProtocols().isEmpty())) &#123;</span><br><span class="line">            Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (protocolConfigMap != <span class="keyword">null</span> &amp;&amp; protocolConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                List&lt;ProtocolConfig&gt; protocolConfigs = <span class="keyword">new</span> ArrayList&lt;ProtocolConfig&gt;();</span><br><span class="line">                <span class="keyword">for</span> (ProtocolConfig config : protocolConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        protocolConfigs.add(config);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (protocolConfigs != <span class="keyword">null</span> &amp;&amp; !protocolConfigs.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">super</span>.setProtocols(protocolConfigs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getPath() == <span class="keyword">null</span> || getPath().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; beanName.length() &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; getInterface() != <span class="keyword">null</span> &amp;&amp; getInterface().length() &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; beanName.startsWith(getInterface())) &#123;</span><br><span class="line">                setPath(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟暴露</span></span><br><span class="line">        <span class="keyword">if</span> (!isDelay()) &#123;</span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean#afterPropertiesSet 的方法不仅支持延迟暴露，还会在 Spring 生命周期内把 Dubbo 的核心配置承载对象设置到 ServiceBean 中（或其父类中）。ServiceBean 配置继承关系如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>AbstractConfig</span><br><span class="line"><span class="bullet">  - </span>AbstractMethodConfig</span><br><span class="line"><span class="bullet">    - </span>AbstractInterfaceConfig</span><br><span class="line"><span class="bullet">      - </span>AbstractServiceConfig</span><br><span class="line"><span class="bullet">        - </span>ServiceConfig</span><br><span class="line"><span class="bullet">          - </span>ServiceBean</span><br></pre></td></tr></table></figure><p>关于配置在之前的文章中应详细介绍，可以参考 <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 。</p><h2 id="服务暴露过程"><a href="#服务暴露过程" class="headerlink" title="服务暴露过程"></a>服务暴露过程</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-local.jpg" alt></p><p>上图是服务本地暴露的主要流程，配置检查和初始化完成后，生成 URL，然后将服务导出到 JVM 中。配置加载及配置承载对象的初始对应的三种方式在前面的文章中已经详细分析过，可以参考 <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 、<a href="https://gentryhuang.com/posts/a8d76a91/">XML配置</a> 、<a href="https://gentryhuang.com/posts/1a889dcd/">注解配置</a> 。下面分析具体源码。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>以延迟暴露的方式进行分析，默认情况下就是延迟暴露的方式。ServiceBean 是 Dubbo 框架与 Spring 框架进行整合的关键，可以看做是两个框架之间的桥梁。ReferenceBean 具有同样的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类 ServiceConfig 的 export 方法进行服务暴露</span></span><br><span class="line">        <span class="keyword">super</span>.export();</span><br><span class="line">        <span class="comment">// 发布服务暴露完成的事件</span></span><br><span class="line">        publishExportEvent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publishExportEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceBeanExportedEvent exportEvent = <span class="keyword">new</span> ServiceBeanExportedEvent(<span class="keyword">this</span>);</span><br><span class="line">        applicationEventPublisher.publishEvent(exportEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean 中的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">213195494150089726L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">transient</span> ApplicationContext SPRING_CONTEXT;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo 服务注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> Service service;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String beanName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否支持 Spring 上下文监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">boolean</span> supportedApplicationListener;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 事件发布对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.service = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceBean</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(service);</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getSpringContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SPRING_CONTEXT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入事件发布对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationEventPublisher</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.6.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在服务暴露之前，Dubbo 需要检查配置，或者补充缺省配置。配置检查完毕后，会根据配置组装 URL 。在 Dubbo 中，URL 十分重要，详细参见 <a href="https://gentryhuang.com/posts/46f95e97/">URL统一模型</a> 。</p><h4 id="检查配置"><a href="#检查配置" class="headerlink" title="检查配置"></a>检查配置</h4><p>我们继续从入口看起，ServiceBean 的父类 ServiceConfig 类，下面我们先看下这个类中的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3033787999037024738L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应 Protocol 实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应 ProxyFactory 实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; RANDOM_PORT_MAP = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时暴露线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService delayExportExecutor = Executors.newSingleThreadScheduledExecutor(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboServiceDelayExporter"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务URL集合</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务配置暴露的Exporter:</span></span><br><span class="line"><span class="comment">     * URL: Exporter 不一定是 1:1 的关系，需要看scope的值：</span></span><br><span class="line"><span class="comment">     * 1 scope 未设置时，会暴露Local + Remote两个，也就是URL : Exporter = 1:2</span></span><br><span class="line"><span class="comment">     * 2 scope设置为空时，不会暴露，也就是URL:Exporter = 1:0</span></span><br><span class="line"><span class="comment">     * 3 scope甚至为local 或 Remote 任一个时，会暴露对应的，也就是URL:Exporter = 1:1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Exporter&lt;?&gt;&gt; exporters = <span class="keyword">new</span> ArrayList&lt;Exporter&lt;?&gt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非配置，通过interfaceName 通过反射获得</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; interfaceClass;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口的实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T ref;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法配置对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;MethodConfig&gt; methods;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供者配置对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ProviderConfig provider;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exported;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否未暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> unexported;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String generic;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceConfig</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        appendAnnotation(Service<span class="class">.<span class="keyword">class</span>, <span class="title">service</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们从 ServiceConfig#export 方法继续进行分析，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 暴露服务入口，加jvm锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 当export 或者 delay 未配置时，从ProviderConfig对象读取</span></span><br><span class="line">       <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (export == <span class="keyword">null</span>) &#123;</span><br><span class="line">               export = provider.getExport();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (delay == <span class="keyword">null</span>) &#123;</span><br><span class="line">               delay = provider.getDelay();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 不暴露服务(export = false),则不进行暴露服务逻辑</span></span><br><span class="line">       <span class="keyword">if</span> (export != <span class="keyword">null</span> &amp;&amp; !export) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 延迟暴露的话，就是使用任务线程池ScheduledExecutorService处理</span></span><br><span class="line">       <span class="keyword">if</span> (delay != <span class="keyword">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           delayExportExecutor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   doExport();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           doExport();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果我们只是想本地启动服务进行一些调试工作，这个时候我们并不希望把本地启动的服务暴露出去，此时，我们就可以通过配置 export 禁止服务暴露，如：</p><blockquote><p>&lt;dubbo:provider export=”false” /&gt;</p></blockquote><p>我们继续跟进 doExport 方法，该方法主要进行配置的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 服务暴露，jvm锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 检查是否可以暴露，若可以，标记已经暴露然后执行服务暴露逻辑</span></span><br><span class="line">       <span class="keyword">if</span> (unexported) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already unexported!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果已经暴露了直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (exported) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 标记已经暴露过了</span></span><br><span class="line">       exported = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">// 校验interfaceName 是否合法，即接口名非空</span></span><br><span class="line">       <span class="keyword">if</span> (interfaceName == <span class="keyword">null</span> || interfaceName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"&lt;dubbo:service interface=\"\" /&gt; interface not allow null!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 校验provider是否为空(为空则新建一个)并拼接属性配置（环境变量 + .properties文件中的 属性）到ProviderConfig对象</span></span><br><span class="line">       checkDefault();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检测application，module等核心配置类对象是否为空，若为空则尝试从其他配置类对象中获取对应的实例。即： 从ProviderConfig 对象中，读取application,module,registries,monitor,protocols配置对象</span></span><br><span class="line">       <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (application == <span class="keyword">null</span>) &#123;</span><br><span class="line">               application = provider.getApplication();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">module</span> = provider.getModule();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">               registries = provider.getRegistries();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               monitor = provider.getMonitor();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (protocols == <span class="keyword">null</span>) &#123;</span><br><span class="line">               protocols = provider.getProtocols();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 从ModuleConfig 对象中，读取registries,monitor配置对象</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">               registries = <span class="keyword">module</span>.getRegistries();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               monitor = <span class="keyword">module</span>.getMonitor();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 从ApplicationConfig 对象中，读取registries,monitor配置对象</span></span><br><span class="line">       <span class="keyword">if</span> (application != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">               registries = application.getRegistries();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               monitor = application.getMonitor();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检测ref是否泛化接口的实现</span></span><br><span class="line">       <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> GenericService) &#123;</span><br><span class="line">           <span class="comment">// 设置 interfaceClass 为 GenericService.class</span></span><br><span class="line">           interfaceClass = GenericService<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isEmpty(generic)) &#123;</span><br><span class="line">               <span class="comment">// 设置 generic = "true"</span></span><br><span class="line">               generic = Boolean.TRUE.toString();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 普通接口的实现</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 通过反射获取对应的接口的Class</span></span><br><span class="line">               interfaceClass = Class.forName(interfaceName, <span class="keyword">true</span>, Thread.currentThread()</span><br><span class="line">                       .getContextClassLoader());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 检验接口和方法 （接口非空，方法都在接口中定义）</span></span><br><span class="line">           checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 校验引用ref是否实现了当前接口</span></span><br><span class="line">           checkRef();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 标记为非泛化实现</span></span><br><span class="line">           generic = Boolean.FALSE.toString();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** 处理服务接口客户端本地代理,即本地存根。目前已经废弃，此处主要用于兼容，使用stub属性. todo 服务端没有意义 &#123;<span class="doctag">@link</span> StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125; */</span></span><br><span class="line">       <span class="keyword">if</span> (local != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果local属性设置为ture，表示使用缺省代理类名，即：接口名 + Local 后缀</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="string">"true"</span>.equals(local)) &#123;</span><br><span class="line">               local = interfaceName + <span class="string">"Local"</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           Class&lt;?&gt; localClass;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 获取本地存根类</span></span><br><span class="line">               localClass = ClassHelper.forNameWithThreadContextClassLoader(local);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法</span></span><br><span class="line">           <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(localClass)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The local implementation class "</span> + localClass.getName() + <span class="string">" not implement interface "</span> + interfaceName);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** 处理服务接口客户端本地代理(stub 属性)相关，即本地存根。目的：想在客户端【服务消费方】执行需要的逻辑，不局限服务提供的逻辑。本地存根类编写方式是固定。todo 服务端没有意义 &#123;<span class="doctag">@link</span> StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125;*/</span></span><br><span class="line">       <span class="keyword">if</span> (stub != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果stub属性设置为ture，表示使用缺省代理类名，即：接口名 + Stub 后缀</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="string">"true"</span>.equals(stub)) &#123;</span><br><span class="line">               stub = interfaceName + <span class="string">"Stub"</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           Class&lt;?&gt; stubClass;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 获取本地存根类</span></span><br><span class="line">               stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 判断interfaceClass 是否是 stubClass 的接口，即 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法</span></span><br><span class="line">           <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(stubClass)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The stub implementation class "</span> + stubClass.getName() + <span class="string">" not implement interface "</span> + interfaceName);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 校验ApplicationConfig配置</span></span><br><span class="line">       checkApplication();</span><br><span class="line">       <span class="comment">// 校验RegistryConfig配置</span></span><br><span class="line">       checkRegistry();</span><br><span class="line">       <span class="comment">// 校验ProtocolConfig配置数组</span></span><br><span class="line">       checkProtocol();</span><br><span class="line">       <span class="comment">// 读取环境变量和properties配置到ServiceConfig对象（自己）</span></span><br><span class="line">       appendProperties(<span class="keyword">this</span>);</span><br><span class="line">       <span class="comment">// 校验Stub和Mock相关的配置</span></span><br><span class="line">       checkStubAndMock(interfaceClass);</span><br><span class="line">       <span class="comment">// 服务路径，缺省是接口名</span></span><br><span class="line">       <span class="keyword">if</span> (path == <span class="keyword">null</span> || path.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           path = interfaceName;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 暴露服务</span></span><br><span class="line">       doExportUrls();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 1 ProviderModel 表示服务提供者模型，此对象中存储了和服务提供者相关的信息，比如服务的配置信息，服务实例等。每个被导出的服务对应一个 ProviderModel</span></span><br><span class="line"><span class="comment">        * 2 ApplicationModel 持有所有的 ProviderModel</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       ProviderModel providerModel = <span class="keyword">new</span> ProviderModel(getUniqueServiceName(), <span class="keyword">this</span>, ref);</span><br><span class="line">       ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以上就是配置检查的相关分析，下面对配置检查的主要逻辑进行简单的总结，如下：</p><ol><li>检测 <a href="dubbo:service">dubbo:service</a> 标签的 interface 属性合法性，不合法则抛出异常</li><li>检测 ProviderConfig、ApplicationConfig 等核心配置类对象是否为空，若为空，则尝试创建或从其他配置类对象中获取相应的实例。</li><li>检测并处理泛化服务和普通服务类</li><li>检测本地存根配置，并进行相应的处理</li><li>对 ApplicationConfig、RegistryConfig 等配置类进行检测，并读取环境变量和properties配置到配置承载对象中</li></ol><p>设置配置到配置承载对象在之前的文章中详细说明了，可以参见 <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 。</p><h4 id="多协议多注册中心暴露"><a href="#多协议多注册中心暴露" class="headerlink" title="多协议多注册中心暴露"></a>多协议多注册中心暴露</h4><p>Dubbo 允许使用不同的协议暴露服务，也支持向多个注册中心注册服务，Dubbo 在 ServiceConifg#doExportUrls 中对多协议，多注册中心进行了支持，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 加载注册中心URL 数组 【协议已经处理过，不再是配置的注册中心协议 如：zookeeper ,而是统一替换成了registry】</span></span><br><span class="line">       List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">// 遍历协议集合，支持多协议暴露。</span></span><br><span class="line">       <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">           doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面代码比较简单，首先是通过 loadRegistries 加载注册中心URL，然后再遍历 ProtocolConfig 集合使用具体的协议导出每个服务。并在导出服务的过程中，将服务注册到注册中心。下面，我们先来看一下 loadRegistries 方法的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 加载注册中心URL数组</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> provider 是否是服务提供者</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> URL数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> List&lt;URL&gt; <span class="title">loadRegistries</span><span class="params">(<span class="keyword">boolean</span> provider)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 校验RegistryConfig 配置数组，不存在会抛出异常，并且该方法会初始化RegistryConfig的配置属性【见API与属性配置】</span></span><br><span class="line">       checkRegistry();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建注册中心URL数组</span></span><br><span class="line">       List&lt;URL&gt; registryList = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">       <span class="keyword">if</span> (registries != <span class="keyword">null</span> &amp;&amp; !registries.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 遍历RegistryConfig 数组</span></span><br><span class="line">           <span class="keyword">for</span> (RegistryConfig config : registries) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 获取注册中心的地址</span></span><br><span class="line">               String address = config.getAddress();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 地址为空就使用 0.0.0.0 任意地址</span></span><br><span class="line">               <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                   address = Constants.ANYHOST_VALUE;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 如果配置了启动参数的注册中心地址，它的优先级最高，就进行覆盖</span></span><br><span class="line">               String sysaddress = System.getProperty(<span class="string">"dubbo.registry.address"</span>);</span><br><span class="line">               <span class="keyword">if</span> (sysaddress != <span class="keyword">null</span> &amp;&amp; sysaddress.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   address = sysaddress;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 选择有效的注册中心地址</span></span><br><span class="line">               <span class="keyword">if</span> (address.length() &gt; <span class="number">0</span> &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 创建参数集合map,用于 URL的构建</span></span><br><span class="line">                   Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 将应用配置对象和注册中心配置对象的属性添加到参数集合map中</span></span><br><span class="line">                   appendParameters(map, application);</span><br><span class="line">                   <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 需要注意的是：RegistryConfig 的 getAddress方法上使用了 <span class="doctag">@Parameter</span>(excluded = true)注解，因此它的address属性不会加入到参数集合map中</span></span><br><span class="line"><span class="comment">                    *  <span class="doctag">@Parameter</span>(excluded = true)</span></span><br><span class="line"><span class="comment">                    *  public String getAddress() &#123;return address;&#125;</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   appendParameters(map, config);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 添加 path,dubbo,timestamp,pid 到参数集合map中</span></span><br><span class="line">                   map.put(<span class="string">"path"</span>, RegistryService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>; <span class="comment">// 这里的path要和服务暴露逻辑中的path区分，注册中心的URL中的path为RegistryService的全路径名</span></span><br><span class="line">                   map.put(<span class="string">"dubbo"</span>, Version.getProtocolVersion());</span><br><span class="line">                   map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                   <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 参数集合map中不存在 protocol 参数【以上配置对象的属性中没有有效的协议protocol参数】，就默认 使用 dubbo 作为 协议protocol的值</span></span><br><span class="line">                   <span class="keyword">if</span> (!map.containsKey(<span class="string">"protocol"</span>)) &#123;</span><br><span class="line">                       <span class="comment">// todo remote扩展实现已经不存在了，不需考虑这种情况</span></span><br><span class="line">                       if (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension("remote")) &#123;</span><br><span class="line">                           map.put(<span class="string">"protocol"</span>, <span class="string">"remote"</span>);</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           map.put(<span class="string">"protocol"</span>, <span class="string">"dubbo"</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 解析地址，创建 URL数组，注意address可能包含多个注册中心ip, 【数组大小可能为一】</span></span><br><span class="line">                   List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 循环 dubbo Register url</span></span><br><span class="line">                   <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                       <span class="comment">// 设置 registry=$&#123;protocol&#125;参数,设置到注册中心的 URL的参数部分的位置上，并且是追加式的添加</span></span><br><span class="line">                       url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());</span><br><span class="line">                       <span class="comment">// 重置 URL中的 protocol属性为 'registry',即将URL的协议头设置为'registry'</span></span><br><span class="line">                       url = url.setProtocol(Constants.REGISTRY_PROTOCOL);</span><br><span class="line">                       <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        * 通过判断条件，决定是否添加url到registryList中，条件如下：</span></span><br><span class="line"><span class="comment">                        * 1 如果是服务提供者,是否只订阅不注册，如果是就不添加到注册中心URL数组中</span></span><br><span class="line"><span class="comment">                        * 2 如果是服务消费者，是否是只注册不订阅，如果是就不添加到注册中心URL数组中</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                       <span class="keyword">if</span> ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class="keyword">true</span>)) || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, <span class="keyword">true</span>))) &#123;</span><br><span class="line">                           registryList.add(url);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> registryList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析注册中心地址，创建 URL数组</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> address</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> defaults</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;URL&gt; <span class="title">parseURLs</span><span class="params">(String address, Map&lt;String, String&gt; defaults)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 判断注册中心地址的有效性</span></span><br><span class="line">       <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 注册中心地址address 可以使用"|"或";"作为分割符，设置多个注册中心分组。注意：一个注册中心集群是一个分组而不是多个。</span></span><br><span class="line">       String[] addresses = Constants.REGISTRY_SPLIT_PATTERN.split(address);</span><br><span class="line">       <span class="keyword">if</span> (addresses == <span class="keyword">null</span> || addresses.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//here won't be empty</span></span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;URL&gt; registries = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">       <span class="comment">// 遍历注册中心分组</span></span><br><span class="line">       <span class="keyword">for</span> (String addr : addresses) &#123;</span><br><span class="line">           registries.add(parseURL(addr, defaults));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> registries;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析单个 URL，将defaults属性集合 里的参数合并到 注册中心地址address中，合并逻辑：</span></span><br><span class="line"><span class="comment">    * 使用 defaults 集合对注册中心urL的属性 进行 '查漏补缺', 即 将defaults集合中不在 注册中心url上的属性 设置到url上，存在则忽略</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> address  注册中心地址</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> defaults 参数集合</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> Dubbo URL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> URL <span class="title">parseURL</span><span class="params">(String address, Map&lt;String, String&gt; defaults)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String url;</span><br><span class="line">       <span class="keyword">if</span> (address.indexOf(<span class="string">"://"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           url = address;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           String[] addresses = Constants.COMMA_SPLIT_PATTERN.split(address);</span><br><span class="line">           url = addresses[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">if</span> (addresses.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">               StringBuilder backup = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; addresses.length; i++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                       backup.append(<span class="string">","</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   backup.append(addresses[i]);</span><br><span class="line">               &#125;</span><br><span class="line">               url += <span class="string">"?"</span> + Constants.BACKUP_KEY + <span class="string">"="</span> + backup.toString();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       String defaultProtocol = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"protocol"</span>);</span><br><span class="line">       <span class="keyword">if</span> (defaultProtocol == <span class="keyword">null</span> || defaultProtocol.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           defaultProtocol = <span class="string">"dubbo"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String defaultUsername = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"username"</span>);</span><br><span class="line">       String defaultPassword = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"password"</span>);</span><br><span class="line">       <span class="keyword">int</span> defaultPort = StringUtils.parseInteger(defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"port"</span>));</span><br><span class="line">       String defaultPath = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"path"</span>);</span><br><span class="line">       Map&lt;String, String&gt; defaultParameters = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> HashMap&lt;String, String&gt;(defaults);</span><br><span class="line">       <span class="keyword">if</span> (defaultParameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">           defaultParameters.remove(<span class="string">"protocol"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"username"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"password"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"host"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"port"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"path"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 分离url中的各个参数，然后根据各个参数构建标准的Dubbo URL -&gt; protocol://username:password@host:port/path?key=value&amp;key=value...</span></span><br><span class="line">       URL u = URL.valueOf(url);</span><br><span class="line">       <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">       String protocol = u.getProtocol();</span><br><span class="line">       String username = u.getUsername();</span><br><span class="line">       String password = u.getPassword();</span><br><span class="line">       String host = u.getHost();</span><br><span class="line">       <span class="keyword">int</span> port = u.getPort();</span><br><span class="line">       String path = u.getPath();</span><br><span class="line">       Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(u.getParameters());</span><br><span class="line">       <span class="keyword">if</span> ((protocol == <span class="keyword">null</span> || protocol.length() == <span class="number">0</span>) &amp;&amp; defaultProtocol != <span class="keyword">null</span> &amp;&amp; defaultProtocol.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           changed = <span class="keyword">true</span>;</span><br><span class="line">           protocol = defaultProtocol;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((username == <span class="keyword">null</span> || username.length() == <span class="number">0</span>) &amp;&amp; defaultUsername != <span class="keyword">null</span> &amp;&amp; defaultUsername.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           changed = <span class="keyword">true</span>;</span><br><span class="line">           username = defaultUsername;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((password == <span class="keyword">null</span> || password.length() == <span class="number">0</span>) &amp;&amp; defaultPassword != <span class="keyword">null</span> &amp;&amp; defaultPassword.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           changed = <span class="keyword">true</span>;</span><br><span class="line">           password = defaultPassword;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (port &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (defaultPort &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               changed = <span class="keyword">true</span>;</span><br><span class="line">               port = defaultPort;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               changed = <span class="keyword">true</span>;</span><br><span class="line">               port = <span class="number">9090</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (path == <span class="keyword">null</span> || path.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (defaultPath != <span class="keyword">null</span> &amp;&amp; defaultPath.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               changed = <span class="keyword">true</span>;</span><br><span class="line">               path = defaultPath;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (defaultParameters != <span class="keyword">null</span> &amp;&amp; defaultParameters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : defaultParameters.entrySet()) &#123;</span><br><span class="line">               String key = entry.getKey();</span><br><span class="line">               String defaultValue = entry.getValue();</span><br><span class="line">               <span class="keyword">if</span> (defaultValue != <span class="keyword">null</span> &amp;&amp; defaultValue.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   String value = parameters.get(key);</span><br><span class="line">                   <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                       changed = <span class="keyword">true</span>;</span><br><span class="line">                       parameters.put(key, defaultValue);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 根据标准构建的Ddubbo URL中的参数的值是否有效，会重新构建Dubbo URL，区别在于之前无效的参数都是用默认值替换</span></span><br><span class="line">       <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">           u = <span class="keyword">new</span> URL(protocol, username, password, host, port, path, parameters);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> u;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，本文主要分析 Dubbo 的本地暴露，本地暴露不会向注册中心注册服务，因为仅用于 JVM 内部调用，相关信息放在内存中。在下一篇远程暴露时会用到，这里为了完整就提前分析了。</p><p>加载注册中心URL代码还是挺复杂的，主要逻辑如下：</p><ol><li>检测是否存在注册中心配置类，不存在则抛出异常。存在则初始化RegistryConfig的配置属性。</li><li>组装参数集合，应用于注册中心URL的属性 ‘查漏补缺’。</li><li>构建注册中心URL列表</li></ol><p>有关注册中心URL构建还有一个数据流向操作，上面代码中也注释了，比较简单，因为会在远程暴露时用到，这里简单介绍下，以 Redis 注册中心为例进行说明，更常用 Zookeeper 作为注册中心。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-registry.jpg" alt></p><h4 id="组装-URL"><a href="#组装-URL" class="headerlink" title="组装 URL"></a>组装 URL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用不同的协议，逐个向注册中心分组暴露服务。该方法中包含了本地和远程两种暴露方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> protocolConfig 协议配置对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registryURLs   处理过的注册中心分组集合【已经添加了ApplicationConfig和RegistryConfig的参数】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 协议名</span></span><br><span class="line">        String name = protocolConfig.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 协议名为空时，缺省设置为 dubbo</span></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            name = <span class="string">"dubbo"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建参数集合map，用于Dubbo URL 的构建（服务提供者URL）</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将side,dubbo,timestamp,pid参数，添加到map集合中</span></span><br><span class="line">        map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class="line">        map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());</span><br><span class="line">        map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射将各种配置对象中的属性添加到map集合中，map用于URL的构建【注意属性覆盖问题】</span></span><br><span class="line">        appendParameters(map, application);</span><br><span class="line">        appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">        appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">        appendParameters(map, protocolConfig);</span><br><span class="line">        appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将MethodConfig 对象数组添加到 map 集合中。就是将每个MethodConfig和其对应的ArgumentConfig对象数组添加到map中【处理方法相关的属性到map】</span></span><br><span class="line">        <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// methods 为 MethodConfig 集合，MethodConfig 中存储了 &lt;dubbo:method&gt; 标签的配置信息</span></span><br><span class="line">            <span class="keyword">for</span> (MethodConfig method : methods) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 将MethodConfig对象的属性添加到map集合中，其中属性键 = 方法名.属性名。如：</span></span><br><span class="line"><span class="comment">                 * &lt;dubbo:method name="sleep" retries="2"&gt;&lt;/dubbo:method&gt;对应的MethodConfig，属性到map的格式：&#123;"sleep.retries":2&#125;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                appendParameters(map, method, method.getName());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当配置了 MehodConfig.retry = false 时，强制禁用重试</span></span><br><span class="line">                String retryKey = method.getName() + <span class="string">".retry"</span>;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class="line">                    String retryValue = map.remove(retryKey);</span><br><span class="line">                    <span class="comment">// 检测 MethodConfig retry 是否为 false，若是，则设置重试次数为0</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"false"</span>.equals(retryValue)) &#123;</span><br><span class="line">                        map.put(method.getName() + <span class="string">".retries"</span>, <span class="string">"0"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将MethodConfig下的ArgumentConfig 对象数组即&lt;dubbo:argument&gt; 标签中的配置信息，添加到 map 集合中</span></span><br><span class="line">                List&lt;ArgumentConfig&gt; arguments = method.getArguments();</span><br><span class="line">                <span class="keyword">if</span> (arguments != <span class="keyword">null</span> &amp;&amp; !arguments.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (ArgumentConfig argument : arguments) &#123;</span><br><span class="line">                        <span class="comment">// 检测type 属性是否为空</span></span><br><span class="line">                        <span class="keyword">if</span> (argument.getType() != <span class="keyword">null</span> &amp;&amp; argument.getType().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 通过反射取出接口的方法列表</span></span><br><span class="line">                            Method[] methods = interfaceClass.getMethods();</span><br><span class="line">                            <span class="comment">// 遍历接口中的方法列表</span></span><br><span class="line">                            <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">                                    String methodName = methods[i].getName();</span><br><span class="line">                                    <span class="comment">// 比对方法名，查找目标方法</span></span><br><span class="line">                                    <span class="keyword">if</span> (methodName.equals(method.getName())) &#123;</span><br><span class="line">                                        <span class="comment">// 通过反射取出目标方法的参数类型列表</span></span><br><span class="line">                                        Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();</span><br><span class="line">                                        <span class="comment">// 若果配置index配置项，且值不为-1</span></span><br><span class="line">                                        <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123;</span><br><span class="line">                                            <span class="comment">// 从argtypes数组中获取下标index处的元素argType，并检测ArgumentConfig中的type属性与argType名称是否一致，不一致则抛出异常</span></span><br><span class="line">                                            <span class="keyword">if</span> (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                <span class="comment">// 将ArgumentConfig对象的属性添加到map集合中，键前缀=方法名.index，如：map = &#123;"sleep.2":true&#125;</span></span><br><span class="line">                                                appendParameters(map, argument, method.getName() + <span class="string">"."</span> + argument.getIndex());</span><br><span class="line">                                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config error : the index attribute and type attribute not match :index :"</span> + argument.getIndex() + <span class="string">", type:"</span> + argument.getType());</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                            <span class="comment">// 遍历参数类型数组argtypes，查找argument.type类型的参数</span></span><br><span class="line">                                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; argtypes.length; j++) &#123;</span><br><span class="line">                                                Class&lt;?&gt; argclazz = argtypes[j];</span><br><span class="line">                                                <span class="comment">// 从参数类型列表中查找类型名称为argument.type的参数</span></span><br><span class="line">                                                <span class="keyword">if</span> (argclazz.getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                    <span class="comment">// 将ArgumentConfig对象的属性添加到map集合中</span></span><br><span class="line">                                                    appendParameters(map, argument, method.getName() + <span class="string">"."</span> + j);</span><br><span class="line">                                                    <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span> &amp;&amp; argument.getIndex() != j) &#123;</span><br><span class="line">                                                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config error : the index attribute and type attribute not match :index :"</span> + argument.getIndex() + <span class="string">", type:"</span> + argument.getType());</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 用户未配置 type 属性，但配置了index属性，且index != -1</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123; <span class="comment">// 指定单个参数的位置</span></span><br><span class="line">                            <span class="comment">// 将ArgumentConfig对象的属性添加到map集合中</span></span><br><span class="line">                            appendParameters(map, argument, method.getName() + <span class="string">"."</span> + argument.getIndex());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config must set index or type attribute.eg: &lt;dubbo:argument index='0' .../&gt; or &lt;dubbo:argument type=xxx .../&gt;"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// end of methods for</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//--- 检测 generic 是否 为 true ,并根据检测结果向map中添加不同的信息 ---/</span></span><br><span class="line">        <span class="comment">// 将 generic,methods,revision 加入到数组</span></span><br><span class="line">        <span class="keyword">if</span> (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">            map.put(Constants.GENERIC_KEY, generic);</span><br><span class="line">            map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先从MAINFEST.MF 中获取版本号，若获取不到，再从jar包命名中可能带的版本号作为结果，如 2.6.5.RELEASE。若都不存在，返回默认版本号【源码运行可能会没有】</span></span><br><span class="line">            String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">            <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                map.put(<span class="string">"revision"</span>, revision); <span class="comment">// 修订号</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为接口生成包裹类 Wrapper，Wrapper 中包含了接口的详细信息，如接口方法，字段信息等</span></span><br><span class="line">            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加方法名到 map 中，如果包含多个方法名，则用逗号隔开，比如：method=a,b</span></span><br><span class="line">            <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.warn(<span class="string">"NO method found in service interface "</span> + interfaceClass.getName());</span><br><span class="line">                <span class="comment">// 没有方法名就添加 method=*</span></span><br><span class="line">                map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将逗号作为分隔符连接方法名，并将连接后的字符串放入 map 中</span></span><br><span class="line">                map.put(Constants.METHODS_KEY, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">","</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// token 【使暴露出去的服务更安全，使用token做安全校验】</span></span><br><span class="line">        <span class="keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">                map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(Constants.TOKEN_KEY, token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 协议为injvm时，不注册，不通知</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) &#123;</span><br><span class="line">            protocolConfig.setRegister(<span class="keyword">false</span>);</span><br><span class="line">            map.put(<span class="string">"notify"</span>, <span class="string">"false"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得基础路径</span></span><br><span class="line">        String contextPath = protocolConfig.getContextpath();</span><br><span class="line">        <span class="keyword">if</span> ((contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span>) &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            contextPath = provider.getContextpath();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---------------------------- 主机绑定 -------------------------------------/</span></span><br><span class="line">        <span class="comment">// 获得注册到注册中心的服务提供者host，并为map设置bind.ip , anyhost 两个key</span></span><br><span class="line">        String host = <span class="keyword">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">        <span class="comment">// 获取端口，并为map设置bing.port key</span></span><br><span class="line">        Integer port = <span class="keyword">this</span>.findConfigedPorts(protocolConfig, name, map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建Dubbo URL对象 【注意这里的 path 的值】</span></span><br><span class="line"><span class="comment">         * 1 name: 协议名</span></span><br><span class="line"><span class="comment">         * 2 host: 主机名</span></span><br><span class="line"><span class="comment">         * 3 port: 端口</span></span><br><span class="line"><span class="comment">         * 4 path: 【基础路径】/path</span></span><br><span class="line"><span class="comment">         * 5 parameters: 属性集合map</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(name, host, port, (contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span> ? <span class="string">""</span> : contextPath + <span class="string">"/"</span>) + path, map);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码比较复杂，不过总体上是将配置承载对象中的属性添加到参数集合中用于构建 Dubbo URL 。其中涉及到的将配置对象的属性添加到参数集合的 appendParameters 方法可以参见  <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 。</p><h3 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h3><p>服务暴露的准备工作完成后，接下来就可以执行服务暴露工作了。服务暴露，分为本地暴露和远程暴露。我们先不研究细节，先从宏观层面上看一下服务暴露逻辑。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用不同的协议，逐个向注册中心分组暴露服务。该方法中包含了本地和远程两种暴露方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> protocolConfig 协议配置对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registryURLs   处理过的注册中心分组集合【已经添加了ApplicationConfig和RegistryConfig的参数】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果存在当前协议对应的 ConfiguratorFactory 扩展实现，就创建配置规则器 Configurator，将配置规则应用到url todo 这里应该不会存在把？</span></span><br><span class="line">        <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">url</span>.<span class="title">getProtocol</span>())) </span>&#123;</span><br><span class="line">            <span class="comment">// 加载ConfiguratorFactory ，并生成Configurator，将配置规则应用到url中</span></span><br><span class="line">            url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">url</span>.<span class="title">getProtocol</span>()).<span class="title">getConfigurator</span>(<span class="title">url</span>).<span class="title">configure</span>(<span class="title">url</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从URL中获取暴露方式</span></span><br><span class="line">        String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 scope = none，则不进行暴露，直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// scope != remote，本地暴露</span></span><br><span class="line">            <span class="keyword">if</span> (!Constants.SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                exportLocal(url);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// scope != local，远程暴露，包含了服务暴露和服务注册两个过程</span></span><br><span class="line">            <span class="keyword">if</span> (!Constants.SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to url "</span> + url);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (registryURLs != <span class="keyword">null</span> &amp;&amp; !registryURLs.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 遍历注册中心URL数组</span></span><br><span class="line">                    <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                        <span class="comment">// dynamic属性：服务是否动态注册，如果设为false,注册后将显示disable状态，需要人工启用，并且服务提供者停止时，也不会自动下线，需要人工禁用</span></span><br><span class="line">                        url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 获取监控中心URL</span></span><br><span class="line">                        URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 监控URL不能空，就将监控中心的URL作为monitor参数添加到服务提供者的URL中，并且需要编码。通过这样方式，服务提供者的URL中就包含了监控中心的配置</span></span><br><span class="line">                            url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(<span class="string">"Register dubbo service "</span> + interfaceClass.getName() + <span class="string">" url "</span> + url + <span class="string">" to registry "</span> + registryURL);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                     </span><br><span class="line">                        <span class="comment">// 获取配置的动态代理的生成方式 &lt;dubbo:service proxy=""/&gt;,可选jdk/javassist,默认使用javassist</span></span><br><span class="line">                        String proxy = url.getParameter(Constants.PROXY_KEY);</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                            registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);</span><br><span class="line">                        &#125;</span><br><span class="line">                     </span><br><span class="line">                        <span class="comment">// 使用ProxyFactory 创建 AbstractProxyInvoker 对象</span></span><br><span class="line">                        Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(</span><br><span class="line">                                ref,</span><br><span class="line">                                (Class) interfaceClass,</span><br><span class="line">                                registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString())</span><br><span class="line">                        );</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 创建 DelegateProviderMetaDataInvoker 对象，在Invoker对象基础上，增加了当前服务提供者ServiceConfig对象，即把Invoker和ServiceConfig结合在了一起</span></span><br><span class="line">                        DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line">                        <span class="comment">// 暴露服务，生成Exporter:</span></span><br><span class="line">                        Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 添加到 Exporter 集合</span></span><br><span class="line">                        exporters.add(exporter);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 无效注册中心，仅暴露服务</span></span><br><span class="line">                    <span class="comment">// 使用ProxyFactory 创建 Invoker 对象</span></span><br><span class="line">                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                    <span class="comment">// 创建 DelegateProviderMetaDataInvoker 对象</span></span><br><span class="line">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 使用Protocol 暴露Invoker 对象</span></span><br><span class="line">                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                    <span class="comment">// 添加到 Exporter 集合</span></span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从宏观层面上看，服务暴露的方式取决于 scope 参数，该参数值在文章前面有具体说明。</p><h3 id="创建-Invoker"><a href="#创建-Invoker" class="headerlink" title="创建 Invoker"></a>创建 Invoker</h3><p>不管是本地暴露，还是远程暴露，进行服务暴露之前，都需要先创建 Invoker ，这一点非常重要。在 Dubbo 中，Invoker 是一个非常重要的模型，无论是在服务提供端，还是服务消费端均会出现 Invoker。Dubbo 官方文档中对 Invoker 进行了说明。</p><blockquote><p>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p></blockquote><p>Invoker 是由 ProxyFactory 创建的，Dubbo 默认的 ProxyFactory 实现类是 JavassistProxyFactory ，在 <a href="https://gentryhuang.com/posts/c2df2fc6/">Javassist动态代理</a> 中进行了详细的说明。</p><h3 id="本地暴露"><a href="#本地暴露" class="headerlink" title="本地暴露"></a>本地暴露</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 本地暴露</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportLocal</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 1 若果URl的协议头是injvm，说明已经暴露到本地了，无需再次暴露</span></span><br><span class="line"><span class="comment">       * 2 非injvm协议就基于原有的URL构建协议为injvm，主机地址 127.0.0.1，端口为0 的新的 URL</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">          URL local = URL.valueOf(url.toFullString())</span><br><span class="line">                  .setProtocol(Constants.LOCAL_PROTOCOL)</span><br><span class="line">                  .setHost(LOCALHOST)</span><br><span class="line">                  .setPort(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 添加服务接口的实现类【仅用于RestProtocol协议】到线程变量中</span></span><br><span class="line">          ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 创建 Invoker，这里 proxyFactory 会在运行时执行 JavassistProxyFactory 的 getInvoker 方法 （默认情况，也可通过参数指定）</span></span><br><span class="line">          Invoker invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, local);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 这里的 protocol 会在运行时调用 InjvmProtocol 的 export 方法</span></span><br><span class="line">          Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 添加到Exporter集合中</span></span><br><span class="line">          exporters.add(exporter);</span><br><span class="line"></span><br><span class="line">          logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to local registry"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>本地暴露的代码比较简单，下面总结下流程：</p><ol><li>根据 URL 协议头决定是否暴露服务，如果需要暴露就创建 injvm 协议的 URL</li><li>然后通过 SPI 机制分别获取运行时的 proxyFactory 和 protocol 扩展实现，这就是 Dubbo SPI 自适应的好处</li><li>使用proxyFactory创建 Invoker(AbstractProxyInvoker) </li><li>使用protocol进行服务暴露</li></ol><p>以上流程的前 3 步已经分析过，下面对第 4 步进行分析。</p><h4 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h4><p>本地暴露涉及的 Protocol 类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-local-protocol.jpg" alt></p><p>由上图的 UML 类图可知，Protocol 有两个 Wrapper 类，由 Dubbo SPI 机制我们知道执行 Protocol#export 方法的顺序：</p><blockquote><p>Protocol$Adaptive =&gt; ProtocolListenerWrapper ==&gt; ProtocolFilterWrapper =&gt; InjvmProtocol</p></blockquote><p>下面对执行链进行分析，其中 Protocol 自适应扩展对象原理在 <a href="https://gentryhuang.com/posts/3e0b5964/">自适应扩展</a> 中已经详细分析。这里说明下，上图的 UML 类图中其它的先不做分析，只关注本地暴露相关的， Dubbo 中的多协议部分会单独作为一个模块分析。</p><h4 id="ProtocolListenerWrapper"><a href="#ProtocolListenerWrapper" class="headerlink" title="ProtocolListenerWrapper"></a>ProtocolListenerWrapper</h4><p>实现 Protocol 接口，是 Protocol 的 Wrapper 类，在服务暴露时用于给 Exporter 添加监听器，监听 Exporter 暴露和取消。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolListenerWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolListenerWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker Service invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// registry协议开头的服务暴露逻辑，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 服务暴露，创建 Exporter</span></span><br><span class="line">        Exporter&lt;T&gt; export = protocol.export(invoker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 ExporterListener</span></span><br><span class="line">        List&lt;ExporterListener&gt; exporterListeners = Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">getActivateExtension</span>(<span class="title">invoker</span>.<span class="title">getUrl</span>(), <span class="title">Constants</span>.<span class="title">EXPORTER_LISTENER_KEY</span>))</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 ListenerExporterWrapper 包装 Exporter，为 Exporter邦定监听器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListenerExporterWrapper&lt;T&gt;(export, exporterListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProtocolListenerWrapper 在服务暴露流程中的逻辑如下：</p><ol><li>判断当前Invoker对应的URL协议是否为 registry，远程暴露时需要用到注册中心，执行到这里时协议会为 registry，这种情况就无需绑定监听器。</li><li>使用具体协议暴露服务，创建 Exporter</li><li>获取ExporterListener，用户可以自行实现监听器。注意，实现的监听器是自动激活类型</li><li>将获取的监听器绑定到服务暴露生成的Exporter</li></ol><h4 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a>Exporter</h4><p>Exporter 是 Invoker 服务在 Protocol 上的对象。更多可以参考 <a href="https://gentryhuang.com/posts/e2577ca1/">Dubbo项目结构总览</a> 。本地暴露涉及到的 UML 类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-local-exporter.jpg" alt></p><h5 id="InjvmExporter"><a href="#InjvmExporter" class="headerlink" title="InjvmExporter"></a>InjvmExporter</h5><p>实现 AbstractExporter 抽象类，Injvm Exporter 实现类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InjvmExporter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractExporter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exporter 集合</span></span><br><span class="line"><span class="comment">     * key : 服务键</span></span><br><span class="line"><span class="comment">     * 该值实际就是 &#123;<span class="doctag">@link</span> com.alibaba.dubbo.rpc.protocol.AbstractProtocol#exporterMap&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，发起暴露</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 服务键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporterMap AbstractExporter的缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    InjvmExporter(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) &#123;</span><br><span class="line">        <span class="keyword">super</span>(invoker);</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.exporterMap = exporterMap;</span><br><span class="line">        <span class="comment">// 加入到Exporter集合[会把自己加入到AbstractProtocol中的Map中]</span></span><br><span class="line">        exporterMap.put(key, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.unexport();</span><br><span class="line">        <span class="comment">// 移除 key对应的Exporter</span></span><br><span class="line">        exporterMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InjvmExporter 会将自身的对象放入到其父类 AbstractExporter 和自身的缓存中，这也是本地暴露的本质。</p><h5 id="ListenerExporterWrapper"><a href="#ListenerExporterWrapper" class="headerlink" title="ListenerExporterWrapper"></a>ListenerExporterWrapper</h5><p>实现 Exporter 接口，具有监听器功能的 Exporter 的 Wrapper 类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ListenerExporter</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 实现 Exporter接口，具有监听器功能的Exporter包装器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerExporterWrapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Exporter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ListenerExporterWrapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真实的Exporter 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exporter&lt;T&gt; exporter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exporter 监听器数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExporterListener&gt; listeners;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListenerExporterWrapper</span><span class="params">(Exporter&lt;T&gt; exporter, List&lt;ExporterListener&gt; listeners)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"exporter == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.exporter = exporter;</span><br><span class="line">        <span class="keyword">this</span>.listeners = listeners;</span><br><span class="line">        <span class="comment">// 执行监听器</span></span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) &#123;</span><br><span class="line">            RuntimeException exception = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (ExporterListener listener : listeners) &#123;</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 事件触发【服务导出后】回调，可以进行自定义实现ExporterListener，重新该方法</span></span><br><span class="line">                        listener.exported(<span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException t) &#123;</span><br><span class="line">                        logger.error(t.getMessage(), t);</span><br><span class="line">                        exception = t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消服务暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exporter.unexport();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 执行监听器</span></span><br><span class="line">            <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) &#123;</span><br><span class="line">                RuntimeException exception = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (ExporterListener listener : listeners) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            listener.unexported(<span class="keyword">this</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RuntimeException t) &#123;</span><br><span class="line">                            logger.error(t.getMessage(), t);</span><br><span class="line">                            exception = t;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> exception;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ListenerExporterWrapper是一个 Wrapper 类，是用来给 Exporter 绑定 ExporterListener 监听器的。</p><h5 id="ExporterListener"><a href="#ExporterListener" class="headerlink" title="ExporterListener"></a>ExporterListener</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExporterListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The exporter exported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当服务暴露完成</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Protocol#export(Invoker)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exported</span><span class="params">(Exporter&lt;?&gt; exporter)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The exporter unexported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当服务取消完成</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Exporter#unexport()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unexported</span><span class="params">(Exporter&lt;?&gt; exporter)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exporter 的监听器，是一个扩展点。用户可以自定义实现，用来监听服务暴露。</p><h4 id="ProtocolFilterWrapper"><a href="#ProtocolFilterWrapper" class="headerlink" title="ProtocolFilterWrapper"></a>ProtocolFilterWrapper</h4><p>实现 Protocol 接口，是 Protocol 的 Wrapper 类，用于给 Invoker 增加过滤链。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolFilterWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolFilterWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建带Filter链的Invoker 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker Invoker对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     URL中参数名 【如：用于获得ServiceConfig或ReferenceConfig配置的自定义过滤器】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> group   分组 【暴露服务时：group=provider; 引用服务时：group=consumer】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 在执行的时候执行Filter </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Invoker&lt;T&gt; last = invoker;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有的过滤器，包括类上带有@Active注解的和在XML中配置的</span></span><br><span class="line">        List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter<span class="class">.<span class="keyword">class</span>).<span class="title">getActivateExtension</span>(<span class="title">invoker</span>.<span class="title">getUrl</span>(), <span class="title">key</span>, <span class="title">group</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒序循环 Filter，递归包装Invoker，就是一个链表结构： Xx1Filter-&gt;Xx2Filter-&gt;Xx3Filter-&gt;...-&gt;Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (!filters.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Filter filter = filters.get(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br><span class="line">                <span class="comment">// 创建新的Invoker 对象， 用于包装 next</span></span><br><span class="line">                last = <span class="keyword">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.getInterface();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.getUrl();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.isAvailable();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 调用Invoker的invoke方法的时候会执行</span></span><br><span class="line"><span class="comment">                     *  1 调用Filter#invoke(invoker,invocation)方法，不断执行过滤器逻辑</span></span><br><span class="line"><span class="comment">                     *  2 在Filter中会调用Invoker#invoker(invocation)方法，最后会执行到Invoker【如：InjvmInvoker,DubboInvoker等】的invoke方法</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> filter.invoke(next, invocation);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        invoker.destroy();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.getDefaultPort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 Invoker的URL中 protocol=registry,说明是注册中心的协议，这种情况无需创建Filter过滤器。</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立带有Filter 过滤链的 Invoker，再暴露服务</span></span><br><span class="line">        <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProtocolFilterWrapper 在服务暴露时就做了一件事，为 Invoker 增加过滤链。其中key和group参数是用来获取自定义过滤器的，具体规则参见 <a href="https://gentryhuang.com/posts/5d81f464/#getActivateExtension-%E6%96%B9%E6%B3%95">Dubbo SPI</a> 。过滤器链如下，包含 Dubbo 自带过滤器和用户自定义过滤器。</p><blockquote><p>EchoFilter - 回声探测过滤器<br>ClassLoaderFilter - 类加载器切换过滤器<br>GenericFilter - 服务提供者的泛化调用过滤器<br>ContextFilter - 服务提供者的上下文过滤器<br>TraceFilter - 追踪过滤器<br>TimeoutFilter - 服务提供者的超时过滤器<br>MonitorFilter - 监控过滤器<br>ExceptionFilter - 加工异常过滤器<br>XxxFilter - 自定义过滤器</p></blockquote><p>构建 Invoker 的过器滤链过程如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-invoker-filter-chain.jpg" alt></p><p>需要注意的是，返回的 Invoker 是一个匿名内部类对象，该对象的 invoke 方法没有其它逻辑，仅用来执行 <code>Filter.invoke</code> 方法。当向该 Invoker 发起调用时，会先执行过滤器链，只有当过滤器链执行完毕后，才会执行真正的 Invoker 的逻辑。</p><h4 id="InjvmProtocol"><a href="#InjvmProtocol" class="headerlink" title="InjvmProtocol"></a>InjvmProtocol</h4><p>实现 AbstractProtocol 抽象类，Injvm 协议实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * InjvmProtocol</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjvmProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = Constants.LOCAL_PROTOCOL;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例：在Dubbo SPI中，被初始化有且仅有一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InjvmProtocol INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InjvmProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        INSTANCE = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得单例子</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InjvmProtocol <span class="title">getInjvmProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">InjvmProtocol</span>.<span class="title">NAME</span>)</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_PORT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行服务暴露，创建InjvmExporter[并把自己-&gt;Exporter存入到父类的 &#123;<span class="doctag">@link</span> #exporterMap&#125; 属性中，key:当前服务键，value:Exporter]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker Service invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Exporter，并且把自己添加到 exporterMap 中，exporterMap 是父类属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>injvm 协议暴露服务比较简单，直接创建 InjvmExporter 对象，然后放入内存中即可，没有其它逻辑。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章详细分析了 Dubbo 本地服务导出过程，包括配置检测，URL 组装，Invoker 创建过程等，下一篇文章将分析远程暴露。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有了前面一系列文章铺垫，再来看服务暴露与服务引用就简单很多了。本地暴露需要配置、SPI、动态代理、协议等知识，其中协议部分会在后面的文章中着
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 泛化实现</title>
    <link href="https://gentryhuang.com/posts/bb5fc918/"/>
    <id>https://gentryhuang.com/posts/bb5fc918/</id>
    <published>2020-08-14T16:00:00.000Z</published>
    <updated>2021-02-22T03:19:58.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 中的泛化接口实现主要用于服务端没有 API 接口及模型类元的情况，泛化实现需要实现 <strong>GenericService</strong> 接口。调用端在引用某个服务时可以指定通用调用（generic配置项），进而可以调用该服务对应的泛化实现。服务消费端无需关注泛化实现的细节，只需要引用服务的时候指定通用调用即可。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>通常用于框架集成，比如：实现一个通用的远程服务 Mock 框架，可通过实现 <strong>GenericService</strong> 接口处理所有服务请求。</p><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>服务端需要实现 <strong>GenericService</strong> 接口以实现泛化功能。</p><ul><li>泛化实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericService</span> <span class="keyword">implements</span> <span class="title">GenericService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛化实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method         调用端调用的方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameterTypes 方法参数类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args           参数值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> GenericException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object $invoke(String method, String[] parameterTypes, Object[] args) <span class="keyword">throws</span> GenericException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"sayHello"</span>.equals(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"print "</span> + args[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"not find method!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>服务暴露<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.code.dubbo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"myGenericService"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>说明：</strong>泛化实现暴露出去需要依托已有的服务接口，将接口的实现设置成泛化实现即可。</p><h2 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h2><ul><li>服务引入<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">interface</span>=<span class="string">"com.code.dubbo.DemoService"</span> <span class="attr">generic</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>说明：</strong> </p><ol><li>消费端需要引入 <strong>interface</strong> 配置项的依赖，并且设置 <strong>generic</strong> 属性，以指定引用的服务为通用调用。</li><li><strong>generic</strong> 配置项支持设置 true、nativejava 以及 bean，在 Dubbo 2.7 中还支持了 protobuf-json 和 raw.return ，用于对参数进行序列化和反序列化。</li><li>消费端调用服务和普通的消费者一摸一样。</li></ol><ul><li>远程调用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DemoService demoService = (DemoService) applicationContext.getBean(<span class="string">"demoService"</span>);</span><br><span class="line">String result = demoService.sayHello(<span class="string">"gentryhuang"</span>);</span><br></pre></td></tr></table></figure></li></ul><h1 id="GenericImplFilter"><a href="#GenericImplFilter" class="headerlink" title="GenericImplFilter"></a>GenericImplFilter</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = Constants.CONSUMER, value = Constants.GENERIC_KEY, order = <span class="number">20000</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericImplFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(GenericImplFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛化参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private static final Class&lt;?&gt;[] GENERIC_PARAMETER_TYPES = new Class&lt;?&gt;[]&#123;String.class, String[].class, Object[].class&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获得 generic 配置项</span></span><br><span class="line">        String generic = invoker.getUrl().getParameter(Constants.GENERIC_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  泛化实现的调用 - 客户端调用的服务是 GenericService</span></span><br><span class="line">        <span class="keyword">if</span> (ProtocolUtils.isGeneric(generic) <span class="comment">// 判断是否开启了泛化引用</span></span><br><span class="line">                &amp;&amp; !Constants.$INVOKE.equals(invocation.getMethodName()) <span class="comment">// 方法名非 $invoke</span></span><br><span class="line">                <span class="comment">// 调用信息是 RpcInvocation 类型</span></span><br><span class="line">                &amp;&amp; invocation <span class="keyword">instanceof</span> RpcInvocation) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 序列化参数</span></span><br><span class="line">            RpcInvocation invocation2 = (RpcInvocation) invocation;</span><br><span class="line">            <span class="comment">// 调用的方法名</span></span><br><span class="line">            String methodName = invocation2.getMethodName();</span><br><span class="line">            <span class="comment">// 参数类型列表</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = invocation2.getParameterTypes();</span><br><span class="line">            <span class="comment">// 参数值列表</span></span><br><span class="line">            Object[] arguments = invocation2.getArguments();</span><br><span class="line">            <span class="comment">// 参数类型名列表</span></span><br><span class="line">            String[] types = <span class="keyword">new</span> String[parameterTypes.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">                types[i] = ReflectUtils.getName(parameterTypes[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 根据 generic 的值选择对应序列化参数的方式</span></span><br><span class="line">            Object[] args;</span><br><span class="line">            <span class="comment">// 3.1 generic == bean</span></span><br><span class="line">            <span class="keyword">if</span> (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;</span><br><span class="line">                args = <span class="keyword">new</span> Object[arguments.length];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                    <span class="comment">// 将参数进行转换： POJO -&gt; JavaBeanDescriptor</span></span><br><span class="line">                    args[i] = JavaBeanSerializeUtil.serialize(arguments[i], JavaBeanAccessor.METHOD);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 generic != bean</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将参数进行转换：POJO -&gt; Map</span></span><br><span class="line">                args = PojoUtils.generalize(arguments);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4、重新设置RPC调用信息，通过新的PpcInvocation就能调用到泛化实现的服务</span></span><br><span class="line">            <span class="comment">// 4.1 设置调用方法的名字为 $invoke</span></span><br><span class="line">            invocation2.setMethodName(Constants.$INVOKE);</span><br><span class="line">            <span class="comment">// 4.2 设置调用方法的参数类型为 GENERIC_PARAMETER_TYPES</span></span><br><span class="line">            invocation2.setParameterTypes(GENERIC_PARAMETER_TYPES);</span><br><span class="line">            <span class="comment">// 4.3 设置调用方法的参数数据，分别为方法名，参数类型数组，参数数组</span></span><br><span class="line">            invocation2.setArguments(<span class="keyword">new</span> Object[]&#123;methodName, types, args&#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 方法调用</span></span><br><span class="line">            Result result = invoker.invoke(invocation2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6、反序列化结果及异常结果处理</span></span><br><span class="line">            <span class="keyword">if</span> (!result.hasException()) &#123;</span><br><span class="line">                <span class="comment">// 获取调用结果</span></span><br><span class="line">                Object value = result.getValue();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 反射方法对象</span></span><br><span class="line">                    Method method = invoker.getInterface().getMethod(methodName, parameterTypes);</span><br><span class="line">                    <span class="comment">// generic=bean 的情况，反序列化： JavaBeanDescriptor -&gt; 结果</span></span><br><span class="line">                    <span class="keyword">if</span> (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(value);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> JavaBeanDescriptor) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(JavaBeanSerializeUtil.deserialize((JavaBeanDescriptor) value));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(</span><br><span class="line">                                    <span class="string">"The type of result value is "</span> +</span><br><span class="line">                                            value.getClass().getName() +</span><br><span class="line">                                            <span class="string">" other than "</span> +</span><br><span class="line">                                            JavaBeanDescriptor<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>() +</span></span><br><span class="line">                                            ", and the result is " +</span><br><span class="line">                                            value);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// generic = true，反序列化： Map -&gt; Pojo</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(PojoUtils.realize(value, method.getReturnType(), method.getGenericReturnType()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 异常结果处理</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.getException() <span class="keyword">instanceof</span> GenericException) &#123;</span><br><span class="line">                GenericException exception = (GenericException) result.getException();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String className = exception.getExceptionClass();</span><br><span class="line">                    Class&lt;?&gt; clazz = ReflectUtils.forName(className);</span><br><span class="line">                    Throwable targetException = <span class="keyword">null</span>;</span><br><span class="line">                    Throwable lastException = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 创建异常对象</span></span><br><span class="line">                        targetException = (Throwable) clazz.newInstance();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        lastException = e;</span><br><span class="line">                        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : clazz.getConstructors()) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                targetException = (Throwable) constructor.newInstance(<span class="keyword">new</span> Object[constructor.getParameterTypes().length]);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable e1) &#123;</span><br><span class="line">                                lastException = e1;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (targetException != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Field field = Throwable.class.getDeclaredField("detailMessage");</span><br><span class="line">                            <span class="keyword">if</span> (!field.isAccessible()) &#123;</span><br><span class="line">                                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            field.set(targetException, exception.getExceptionMessage());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                            logger.warn(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        result = <span class="keyword">new</span> RpcResult(targetException);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastException != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> lastException;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Can not deserialize exception "</span> + exception.getExceptionClass() + <span class="string">", message: "</span> + exception.getExceptionMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略泛化引用的调用 - GenericService 调用服务接口</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        <span class="comment">//  普通调用</span></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>GenericImplFilter</strong> 是服务消费端的过滤器，主要是对 <strong>泛化引用</strong> 和 <strong>泛化实现</strong> 在调用端的处理。关于泛化引用部分在泛化调用中已经详细说明，下面对泛化实现的逻辑进行说明：</p><ol><li>获取 generic 配置项，判断是否开启泛化引用。</li><li>从调用信息对象 RpcInvocation 中获取调用的方法名、参数类型列表、参数值列表。</li><li>根据 generic 的值选择对应的序列化方式对参数进行序列化。</li><li>重置调用信息对象中的方法名、方法参数类型、方法参数，以构造符合 $invoke 方法的格式，重置完成后进行方法调用。</li><li>对正常结果进行反序列化，以及根据 GenericException 异常，创建原始异常 targetException 并返回给调用端。</li></ol><p>这里需要说明的是上述的第 5 步，为什么执行 <strong>invoker.invoke(invocation2)</strong> 方法就会调用泛化实现 <strong>$invoke</strong> 方法？ 原因如下：</p><ol><li>服务暴露的过程确定了服务实现对象和服务接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--- ServiceConfig#doExport</span><br><span class="line">        <span class="comment">// 检测ref是否泛化接口的实现</span></span><br><span class="line">        <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> GenericService) &#123;</span><br><span class="line">            <span class="comment">// 设置 interfaceClass 为 GenericService.class</span></span><br><span class="line">            interfaceClass = GenericService<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(generic)) &#123;</span><br><span class="line">                <span class="comment">// 设置 generic = "true"</span></span><br><span class="line">                generic = Boolean.TRUE.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意：</strong> 虽然接口设置为了 GenericService ，但是不影响服务暴露，服务暴露的 URL 中使用接口名表示服务接口信息，也就是 interface 的值。</p><ol start="2"><li>将服务实例封装成 Invoker ,服务实例就是 GenericService 实例。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将传入的服务实例封装成Invoker</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * create invoker.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxy Service对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type  Service接口类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url   Service对应的Dubbo URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> invoker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">&lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br></pre></td></tr></table></figure></li></ol><h1 id="GenericFilter"><a href="#GenericFilter" class="headerlink" title="GenericFilter"></a>GenericFilter</h1><p><strong>GenericFilter</strong> 不会特别处理泛化实现的调用，将这种情况当作普通调用对待。</p><h1 id="泛化实现流程图"><a href="#泛化实现流程图" class="headerlink" title="泛化实现流程图"></a>泛化实现流程图</h1><p><img src="/posts/bb5fc918/dubbo-filter-generic-impl.jpg" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Dubbo 提供了 <strong>GenericService</strong> 接口用于实现泛化服务，由于泛化实现对于调用端来说是没有具体接口的，因此泛化实现必须依托现有的服务接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Dubbo 中的泛化接口实现主要用于服务端没有 API 接口及模型类元的情况，泛化实现需要实现 &lt;strong&gt;GenericService
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Filter" scheme="https://gentryhuang.com/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 泛化调用</title>
    <link href="https://gentryhuang.com/posts/ffce7d6d/"/>
    <id>https://gentryhuang.com/posts/ffce7d6d/</id>
    <published>2020-08-12T14:59:38.000Z</published>
    <updated>2021-02-22T03:02:52.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 中的泛化调用主要用于客户端没有 <strong>API接口及模型类元</strong> 的情况。即客户端只需根据服务端提供的API文档，无需引入相关接口依赖，直接通过 <strong>GenericSerive</strong> 接口来发起服务调用，参数及返回值中的所有 <code>POJO</code> 均使用 <code>Map</code> 表示。泛化调用对于服务提供端是无需关注的，按正常服务暴露即可。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="服务测试框架"><a href="#服务测试框架" class="headerlink" title="服务测试框架"></a>服务测试框架</h2><p>服务测试框架是作为各个 RPC 服务的调用端，一般情况下，调用端是需要依赖服务提供方接口的。而作为一个通用的测试框架不应该依赖所有服务提供方的接口，不能因为每发布一个新的服务就升级这个测试框架。这时就需要让调用方在没有服务提供方接口的情况下，仍然可以正常地发起 RPC 调用。</p><h2 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h2><p>各个业务方可以使用 HTTP 的方式，通过服务网关调用其它服务。这种场景和通用的服务测试框架有同样的问题，不应该也不能依赖所有服务提供方的接口，也需要调用方在没有服务提供方接口的情况下，仍然可以正常地发起 RPC 调用。</p><h1 id="代理必要性"><a href="#代理必要性" class="headerlink" title="代理必要性"></a>代理必要性</h1><p>在 Dubbo 调用的过程中，调用端是通过动态代理向服务端发起远程调用，一般调用端是通过服务端接口自动生成代理对象的。但 RPC 调用的本质是调用端向服务端发送一条请求消息，服务端接收并处理，然后向调用端发送一条响应消息，调用端收到并处理响应消息，一次 RPC 调用就完成了。不难看出，是否使用代理，是否使用服务接口代理不是最重要的，重要的是调用端在没有服务接口的情况下仍然能够向服务端发送正确的请求消息。对于调用端来说，服务接口的作用仅用于创建代理对象，基于面向接口开发。</p><p>关键点在于，只要调用端将调用环境信息，如接口名，方法名，参数信息等发送给服务端，服务端就能解析并处理这条请求消息。但 Dubbo 的调用端向服务端发送消息是通过代理对象来完成的，基于这种情况，Dubbo 定义了一个统一的接口 <strong>GenericSerive</strong> ，调用端在使用该接口的代理时指定相关调用信息即可。<strong>GenericSerive</strong> 接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛化调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method         方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameterTypes 参数类型数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args           参数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> invocation 调用结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> GenericException potential exception thrown from the invocation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object $invoke(String method, String[] parameterTypes, Object[] args) <span class="keyword">throws</span> GenericException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛化调用异步支持 （2.7 新增）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameterTypes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> GenericException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> CompletableFuture&lt;Object&gt; $invokeAsync(String method, String[] parameterTypes, Object[] args) <span class="keyword">throws</span> GenericException &#123;</span><br><span class="line">        Object object = $invoke(method, parameterTypes, args);</span><br><span class="line">        <span class="keyword">if</span> (object <span class="keyword">instanceof</span> CompletableFuture) &#123;</span><br><span class="line">            <span class="keyword">return</span> (CompletableFuture&lt;Object&gt;) object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>服务端无需关注泛化调用，不做任何处理，正常服务暴露即可。</p><ul><li>接口定义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NotGenericService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getRemark</span><span class="params">(GenericRequest request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>服务暴露<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.code.dubbo.NotGenericService"</span> <span class="attr">ref</span>=<span class="string">"notGenericServiceImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h2><ul><li>服务引入<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"notGenericService"</span> <span class="attr">interface</span>=<span class="string">"com.code.dubbo.NotGenericService"</span> <span class="attr">generic</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>说明：</strong> </p><ol><li>消费端无需引入 <strong>interface</strong> 配置项的依赖，因为设置了 <strong>generic</strong> 属性，此时 Dubbo 只会将该配置项值看作是一个字符串，不会检查该接口是否存在。</li><li><strong>interface</strong> 配置项的值是要引用的服务，通过该配置，可以从注册中心获取到所有该服务的提供方的地址。</li><li><strong>generic</strong> 配置项支持设置 true、nativejava 以及 bean，在 Dubbo 2.7 中还支持了 protobuf-json 和 raw.return ，用于对参数进行序列化和反序列化。</li></ol><ul><li>服务调用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GenericService genericService = (GenericService) applicationContext.getBean(<span class="string">"notGenericService"</span>);</span><br><span class="line"><span class="comment">// 通过 GenericSerive 发起服务调用，参数及返回值中的所有 `POJO` 均使用 `Map` 表示</span></span><br><span class="line">Map&lt;String, Object&gt; genericParamMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">genericParamMap.put(<span class="string">"class"</span>,<span class="string">"com.code.dubbo.GenericRequest"</span>);</span><br><span class="line">genericParamMap.put(<span class="string">"remark"</span>, <span class="string">"this is remark!"</span>);</span><br><span class="line"><span class="comment">// 泛化值类型 Map</span></span><br><span class="line">Object getRemark = genericService.$invoke(<span class="string">"getRemark"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"com.code.dubbo.GenericRequest"</span>&#125;, <span class="keyword">new</span> Object[]&#123;genericParamMap&#125;);</span><br></pre></td></tr></table></figure></li></ul><h1 id="泛化接口类型"><a href="#泛化接口类型" class="headerlink" title="泛化接口类型"></a>泛化接口类型</h1><p>调用方在进行泛化调用的时候之所以可以直接使用 <strong>GenericService</strong> 转换，是在服务引用的时候会判断是否是泛化引用，如果是泛化引用则将接口类型设置为 <strong>GenericService</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--- ReferenceConfig#init</span><br><span class="line"> <span class="comment">// 是否是泛化引用，就直接设置当前接口为 GenericService</span></span><br><span class="line">        <span class="keyword">if</span> (ProtocolUtils.isGeneric(getGeneric())) &#123;</span><br><span class="line">            interfaceClass = GenericService<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 普通接口的实现</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 根据接口名，获得对应的接口类</span></span><br><span class="line">                interfaceClass = Class.forName(interfaceName, <span class="keyword">true</span>, Thread.currentThread().getContextClassLoader());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 校验接口和方法</span></span><br><span class="line">            checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong> 泛化引用虽然会将服务接口类型设置为 <strong>GenericService</strong> ，但是并不影响服务发现。</p><h1 id="GenericImplFilter"><a href="#GenericImplFilter" class="headerlink" title="GenericImplFilter"></a>GenericImplFilter</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = Constants.CONSUMER, value = Constants.GENERIC_KEY, order = <span class="number">20000</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericImplFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(GenericImplFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛化参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private static final Class&lt;?&gt;[] GENERIC_PARAMETER_TYPES = new Class&lt;?&gt;[]&#123;String.class, String[].class, Object[].class&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获得 generic 配置项</span></span><br><span class="line">        String generic = invoker.getUrl().getParameter(Constants.GENERIC_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  泛化实现的调用 - 客户端调用的服务是 GenericService</span></span><br><span class="line">        <span class="keyword">if</span> (ProtocolUtils.isGeneric(generic) <span class="comment">// 判断是否开启了泛化引用</span></span><br><span class="line">                &amp;&amp; !Constants.$INVOKE.equals(invocation.getMethodName()) <span class="comment">// 方法名非 $invoke</span></span><br><span class="line">                <span class="comment">// 调用信息是 RpcInvocation 类型</span></span><br><span class="line">                &amp;&amp; invocation <span class="keyword">instanceof</span> RpcInvocation) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 省略客户端调用泛化实现的逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 泛化引用的调用 - GenericService 调用服务接口</span></span><br><span class="line">        <span class="keyword">if</span> (invocation.getMethodName().equals(Constants.$INVOKE) <span class="comment">// 调用方法是 $invoke</span></span><br><span class="line">                &amp;&amp; invocation.getArguments() != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; invocation.getArguments().length == <span class="number">3</span> <span class="comment">// 方法参数是 3 个</span></span><br><span class="line">                <span class="comment">// 判断是否开启了泛化引用</span></span><br><span class="line">                &amp;&amp; ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 方法参数列表</span></span><br><span class="line">            Object[] args = (Object[]) invocation.getArguments()[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 根据 generic 的值校验参数值</span></span><br><span class="line">            <span class="comment">// 3.1 genecric = nativejava的情况，校验方法参数是否都为 byte[]</span></span><br><span class="line">            <span class="keyword">if</span> (ProtocolUtils.isJavaGenericSerialization(generic)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(<span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span> </span>== arg.getClass())) &#123;</span><br><span class="line">                        error(generic, <span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">arg</span>.<span class="title">getClass</span>().<span class="title">getName</span>())</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 generic = bean 的情况，校验方法参数 为 JavaBeanDescriptor</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(arg <span class="keyword">instanceof</span> JavaBeanDescriptor)) &#123;</span><br><span class="line">                        error(generic, JavaBeanDescriptor<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">arg</span>.<span class="title">getClass</span>().<span class="title">getName</span>())</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 通过隐式参数，传递 generic 配置项</span></span><br><span class="line">            ((RpcInvocation) invocation).setAttachment(Constants.GENERIC_KEY, invoker.getUrl().getParameter(Constants.GENERIC_KEY));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 普通调用</span></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GenericImplFilter</strong> 是服务消费端的过滤器，主要是对 <strong>泛化引用</strong> 和 <strong>泛化实现</strong> 在调用端的处理。</p><h2 id="泛化调用"><a href="#泛化调用" class="headerlink" title="泛化调用"></a>泛化调用</h2><p>调用端进行泛化调用的时候，会对参数进行校验，防止服务端接收到参数时反序列化失败；还会将 <strong>generic</strong> 配置项通过隐式参数的形式传递到服务端。</p><h2 id="泛化实现"><a href="#泛化实现" class="headerlink" title="泛化实现"></a>泛化实现</h2><p>调用端对泛化实现的服务进行调用时，会对参数进行序列化，并重新设置 <strong>RpcInvocation</strong> 的方法名、参数类型以及参数值。</p><h1 id="GenericFilter"><a href="#GenericFilter" class="headerlink" title="GenericFilter"></a>GenericFilter</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = Constants.PROVIDER, order = -<span class="number">20000</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 是否是泛化调用: 方法名：$invoke &amp; 参数个数：3 &amp; 调用接口非 GenericService</span></span><br><span class="line">        <span class="keyword">if</span> (inv.getMethodName().equals(Constants.$INVOKE)</span><br><span class="line">                &amp;&amp; inv.getArguments() != <span class="keyword">null</span> &amp;&amp; inv.getArguments().length == <span class="number">3</span></span><br><span class="line">                &amp;&amp; !invoker.getInterface().equals(GenericService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">            <span class="comment">// 调用的服务方法名</span></span><br><span class="line">            String name = ((String) inv.getArguments()[<span class="number">0</span>]).trim();</span><br><span class="line">            <span class="comment">// 调用的服务方法参数类型</span></span><br><span class="line">            String[] types = (String[]) inv.getArguments()[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 嗲用的服务方法参数列表</span></span><br><span class="line">            Object[] args = (Object[]) inv.getArguments()[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 2. 反射获得提供方的方法对象，注意这里的 invoker 是服务端的，因此 interface 是服务接口，而非GenericService</span></span><br><span class="line">                Method method = ReflectUtils.findMethodByMethodSignature(invoker.getInterface(), name, types);</span><br><span class="line">                <span class="comment">// 2.1 获取服务提供方的目标方法的参数类型</span></span><br><span class="line">                Class&lt;?&gt;[] params = method.getParameterTypes();</span><br><span class="line">                <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    args = <span class="keyword">new</span> Object[params.length];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3 获得 generic 配置项</span></span><br><span class="line">                String generic = inv.getAttachment(Constants.GENERIC_KEY);</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isBlank(generic)) &#123;</span><br><span class="line">                    generic = RpcContext.getContext().getAttachment(Constants.GENERIC_KEY);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4 根据 generic 的配置项反序列化参数值</span></span><br><span class="line">                <span class="comment">// 4.1 如果没有设置 generic 或者 generic = true，反序列化参数，Map-&gt;Pojo (在 java 中，pojo通常用map来表示)</span></span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isEmpty(generic) || ProtocolUtils.isDefaultGenericSerialization(generic)) &#123;</span><br><span class="line">                    args = PojoUtils.realize(args, params, method.getGenericParameterTypes());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.2 generic = nativejava, 反序列化参数， byte[]-&gt; Pojo</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ProtocolUtils.isJavaGenericSerialization(generic)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span> </span>== args[i].getClass()) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                UnsafeByteArrayInputStream is = <span class="keyword">new</span> UnsafeByteArrayInputStream((<span class="keyword">byte</span>[]) args[i]);</span><br><span class="line">                                args[i] = ExtensionLoader.getExtensionLoader(Serialization<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                                        .<span class="title">getExtension</span>(<span class="title">Constants</span>.<span class="title">GENERIC_SERIALIZATION_NATIVE_JAVA</span>)</span></span><br><span class="line"><span class="class">                                        .<span class="title">deserialize</span>(<span class="title">null</span>, <span class="title">is</span>).<span class="title">readObject</span>()</span>;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Deserialize argument ["</span> + (i + <span class="number">1</span>) + <span class="string">"] failed."</span>, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(</span><br><span class="line">                                    <span class="string">"Generic serialization ["</span> +</span><br><span class="line">                                            Constants.GENERIC_SERIALIZATION_NATIVE_JAVA +</span><br><span class="line">                                            <span class="string">"] only support message type "</span> +</span><br><span class="line">                                            <span class="keyword">byte</span>[]<span class="class">.<span class="keyword">class</span> +</span></span><br><span class="line">                                            " and your message type is " +</span><br><span class="line">                                            args[i].getClass());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.3 generic = bean ，反序列化参数，JavaBeanDescriptor -&gt; Pojo</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (args[i] <span class="keyword">instanceof</span> JavaBeanDescriptor) &#123;</span><br><span class="line">                            args[i] = JavaBeanSerializeUtil.deserialize((JavaBeanDescriptor) args[i]);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(</span><br><span class="line">                                    <span class="string">"Generic serialization ["</span> +</span><br><span class="line">                                            Constants.GENERIC_SERIALIZATION_BEAN +</span><br><span class="line">                                            <span class="string">"] only support message type "</span> +</span><br><span class="line">                                            JavaBeanDescriptor<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>() +</span></span><br><span class="line">                                            " and your message type is " +</span><br><span class="line">                                            args[i].getClass().getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 5 方法参数转换完毕，进行方法调用。</span></span><br><span class="line">                <span class="comment">// 注意此时创建了一个新的 RpcInvocation 对象。$invoke 泛化调用被转为具体的普通调用</span></span><br><span class="line">                Result result = invoker.invoke(<span class="keyword">new</span> RpcInvocation(method, args, inv.getAttachments()));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果调用结果有异常，并且非GenericException异常，则使用 GenericException 包装</span></span><br><span class="line">                <span class="keyword">if</span> (result.hasException() &amp;&amp; !(result.getException() <span class="keyword">instanceof</span> GenericException)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(<span class="keyword">new</span> GenericException(result.getException()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// generic=nativejava的情况下，序列化结果， 结果 -&gt; btyp[]</span></span><br><span class="line">                <span class="keyword">if</span> (ProtocolUtils.isJavaGenericSerialization(generic)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        UnsafeByteArrayOutputStream os = <span class="keyword">new</span> UnsafeByteArrayOutputStream(<span class="number">512</span>);</span><br><span class="line">                        ExtensionLoader.getExtensionLoader(Serialization<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                                .<span class="title">getExtension</span>(<span class="title">Constants</span>.<span class="title">GENERIC_SERIALIZATION_NATIVE_JAVA</span>)</span></span><br><span class="line"><span class="class">                                .<span class="title">serialize</span>(<span class="title">null</span>, <span class="title">os</span>).<span class="title">writeObject</span>(<span class="title">result</span>.<span class="title">getValue</span>())</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(os.toByteArray());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Serialize result failed."</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// generic=bean 的情况下，序列化结果， 结果 -&gt; JavaBeanDescriptor</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(JavaBeanSerializeUtil.serialize(result.getValue(), JavaBeanAccessor.METHOD));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// generic=true 的情况下，序列化结果，Pojo -&gt; Map</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(PojoUtils.generalize(result.getValue()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 普通调用（包括调用泛化实现）</span></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GenericFilter</strong> 是服务端的过滤器，用于处理泛化调用逻辑，不会处理对泛化实现的调用，会将其当作普通调用处理。该过滤主要逻辑如下：</p><ol><li>从调用信息 Invocation 中获取服务方法名、方法参数类型、方法参数列表。</li><li>反射获取提供方的方法对象，注意这里的 invoker 是服务端的，因此 interface 是服务接口，而非GenericService 。</li><li>从隐式参数中获取 generic 配置项，该配置项决定了参数反序列化的方式。</li><li>构建新的 RpcInvocation 对象进行方法调用，本质上是将 $invoke 泛化调用被转为具体的普通调用。</li><li>对调用结果进行处理，其中会对正常结果进行序列化处理，然后响应给调用端。若是异常结果，且非 GenericException 异常，则使用 GenericException 包装后返回，防止异常在服务消费端不存在导致反序列化失败。</li></ol><h1 id="泛化调用流程图"><a href="#泛化调用流程图" class="headerlink" title="泛化调用流程图"></a>泛化调用流程图</h1><p><img src="/posts/ffce7d6d/dubbo-filter-generic-process.jpg" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Dubbo 泛化调用实际是在 Filter 过滤链上执行的序列化和反序列化操作，服务端通过调用端传递的调用信息反射获取对应的服务方法，进而进行服务调用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Dubbo 中的泛化调用主要用于客户端没有 &lt;strong&gt;API接口及模型类元&lt;/strong&gt; 的情况。即客户端只需根据服务端提供的AP
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Filter" scheme="https://gentryhuang.com/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo过滤器 - ExceptionFilter</title>
    <link href="https://gentryhuang.com/posts/c5f1bd62/"/>
    <id>https://gentryhuang.com/posts/c5f1bd62/</id>
    <published>2020-08-08T13:59:38.000Z</published>
    <updated>2021-02-19T14:29:14.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>ExceptionFilter</strong> 是服务端的过滤器，它不是一个统一处理异常的过滤器，关注点不在于捕获异常，而是为了找到那些返回的自定义异常，会把异常包装成 <strong>RuntimeException</strong> 。 因为异常类可能不存在于消费端，避免消费端出现不能反序列化异常的情况。</p><h1 id="ExceptionFilter"><a href="#ExceptionFilter" class="headerlink" title="ExceptionFilter"></a>ExceptionFilter</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = Constants.PROVIDER)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExceptionFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(LoggerFactory.getLogger(ExceptionFilter<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExceptionFilter</span><span class="params">(Logger logger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 服务调用</span></span><br><span class="line">            Result result = invoker.invoke(invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 泛化调用直接抛出，非泛化调用分类处理</span></span><br><span class="line">            <span class="keyword">if</span> (result.hasException() &amp;&amp; GenericService<span class="class">.<span class="keyword">class</span> !</span>= invoker.getInterface()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取异常对象</span></span><br><span class="line">                    Throwable exception = result.getException();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 2. 如果是 checked 异常，则直接抛出</span></span><br><span class="line">                    <span class="keyword">if</span> (!(exception <span class="keyword">instanceof</span> RuntimeException) &amp;&amp; (exception <span class="keyword">instanceof</span> Exception)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3. 在方法签名上有声明，直接抛出</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Method method = invoker.getInterface().getMethod(invocation.getMethodName(), invocation.getParameterTypes());</span><br><span class="line">                        Class&lt;?&gt;[] exceptionClassses = method.getExceptionTypes();</span><br><span class="line">                        <span class="keyword">for</span> (Class&lt;?&gt; exceptionClass : exceptionClassses) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (exception.getClass().equals(exceptionClass)) &#123;</span><br><span class="line">                                <span class="keyword">return</span> result;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 未在方法签名上定义的异常，在服务端打印 错误日志</span></span><br><span class="line">                    logger.error(<span class="string">"Got unchecked and undeclared exception which called by "</span> + RpcContext.getContext().getRemoteHost()</span><br><span class="line">                            + <span class="string">". service: "</span> + invoker.getInterface().getName() + <span class="string">", method: "</span> + invocation.getMethodName()</span><br><span class="line">                            + <span class="string">", exception: "</span> + exception.getClass().getName() + <span class="string">": "</span> + exception.getMessage(), exception);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4. 异常类和接口类在同一个 jar 包里，直接抛出</span></span><br><span class="line">                    String serviceFile = ReflectUtils.getCodeBase(invoker.getInterface());</span><br><span class="line">                    String exceptionFile = ReflectUtils.getCodeBase(exception.getClass());</span><br><span class="line">                    <span class="keyword">if</span> (serviceFile == <span class="keyword">null</span> || exceptionFile == <span class="keyword">null</span> || serviceFile.equals(exceptionFile)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 5. 是JDK自带的异常，直接抛出</span></span><br><span class="line">                    String className = exception.getClass().getName();</span><br><span class="line">                    <span class="keyword">if</span> (className.startsWith(<span class="string">"java."</span>) || className.startsWith(<span class="string">"javax."</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 6. 是Dubbo中定义异常，直接抛出</span></span><br><span class="line">                    <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RpcException) &#123;</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 7. 否则，包装成RuntimeException 抛给客户端</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(<span class="keyword">new</span> RuntimeException(StringUtils.toString(exception)));</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Fail to ExceptionFilter when called by "</span> + RpcContext.getContext().getRemoteHost()</span><br><span class="line">                            + <span class="string">". service: "</span> + invoker.getInterface().getName() + <span class="string">", method: "</span> + invocation.getMethodName()</span><br><span class="line">                            + <span class="string">", exception: "</span> + e.getClass().getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 直接抛出</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Got unchecked and undeclared exception which called by "</span> + RpcContext.getContext().getRemoteHost()</span><br><span class="line">                    + <span class="string">". service: "</span> + invoker.getInterface().getName() + <span class="string">", method: "</span> + invocation.getMethodName()</span><br><span class="line">                    + <span class="string">", exception: "</span> + e.getClass().getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo 内部的异常处理类 ExceptionFilter 的处理逻辑如上面代码所示，其中 1-6 种情况客户端都能反序列化成功，第 7 步是一个兜底操作，为了防止客户端反序列化异常失败。</p><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>Dubbo 官方推荐异常处理方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 建议使用异常汇报错误，而不是返回错误码，异常信息能携带更多信息，并且语义更友好。</span><br><span class="line"></span><br><span class="line">* 如果担心性能问题，在必要时，可以通过 override 掉异常类的 fillInStackTrace() 方法为空方法，使其不拷贝栈信息。</span><br><span class="line"></span><br><span class="line">* 查询方法不建议抛出 checked 异常，否则调用方在查询时将过多的 try...catch，并且不能进行有效处理。</span><br><span class="line"></span><br><span class="line">* 服务提供方不应将 DAO 或 SQL 等异常抛给消费方，应在服务实现中对消费方不关心的异常进行包装，否则可能出现消费方无法反序列化相应异常。</span><br></pre></td></tr></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>通过 <strong>ExceptionFilter</strong> 源码可知，自定义的异常如果不符合前面的 6 种情况，那么最后返回给客户端的异常会被包装成 <strong>RuntimeException</strong> ，自定义的异常也就无效了。既然如此，能不能剔除掉 <strong>ExceptionFilter</strong> 过滤器，这样就不会将自定义的异常自动包装了。但是这样的话又回到了最开始的痛点，没有 <strong>ExceptionFilter</strong> 过滤器处理客户端可能无法正确反序列化自定义的异常。因此，我们就可以自定义一个 Filter 来统一处理这种情况。</p><h2 id="BizException"><a href="#BizException" class="headerlink" title="BizException"></a>BizException</h2><p>一般自定义异常都是unchecked 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8056580241015398148L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常业务编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认异常构造器.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据异常信息和原生异常构造对象.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code    错误码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 异常信息.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause   原生异常.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(<span class="keyword">final</span> String code, <span class="keyword">final</span> String msg, <span class="keyword">final</span> Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg, cause);</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据异常构造业务对象，设置 编码及 消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(<span class="keyword">final</span> String code, <span class="keyword">final</span> String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据异常信息和原生异常构造对象.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 异常信息.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause   原生异常.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(<span class="keyword">final</span> String msg, <span class="keyword">final</span> Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据异常信息构造对象.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 异常信息.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(<span class="keyword">final</span> String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据异常构造业务对象，设置 编码及 消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(<span class="keyword">final</span> ResultCode resultCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(resultCode.getMsg());</span><br><span class="line">        <span class="keyword">this</span>.code = resultCode.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据异常构造业务对象，设置 编码及 消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(<span class="keyword">final</span> ResultCode resultCode, <span class="keyword">final</span> Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(resultCode.getMsg(), cause);</span><br><span class="line">        <span class="keyword">this</span>.code = resultCode.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据原生异常构造对象.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause 原生异常.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(<span class="keyword">final</span> Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义-Filter"><a href="#自定义-Filter" class="headerlink" title="自定义 Filter"></a>自定义 Filter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = &#123;CommonConstants.PROVIDER&#125;, order = <span class="number">999999</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderExceptionFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Environment <span class="title">getEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        JsonKvFormat kvFormat = makeJsonKvFormat(invoker, invocation);</span><br><span class="line">        Result result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// invoke</span></span><br><span class="line">            result = invoker.invoke(invocation);</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> timeOut = Long.parseLong(environment.getProperty(<span class="string">"time.out"</span>));</span><br><span class="line">            <span class="keyword">if</span> ((endTime - startTime) &gt; timeOut) &#123;</span><br><span class="line">                recordTimeOutLog(kvFormat, endTime - startTime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断调用是否有异常</span></span><br><span class="line">            <span class="keyword">if</span> (result.hasException() &amp;&amp; GenericService<span class="class">.<span class="keyword">class</span> !</span>= invoker.getInterface()) &#123;</span><br><span class="line">                Throwable exception = result.getException();</span><br><span class="line">                <span class="comment">// 是否是自定义异常</span></span><br><span class="line">                <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> BizException) &#123;</span><br><span class="line">                    String code = ((BizException) exception).getCode();</span><br><span class="line">                    recordBizLog(kvFormat, result);</span><br><span class="line">                    result.setValue(com.yunhu.rpc.result.Result.failResult(code, exception.getMessage()));</span><br><span class="line">                    <span class="comment">// 是否是不记录日志的自定义异常</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> NoRecordException) &#123;</span><br><span class="line">                    String code = ((NoRecordException) exception).getCode();</span><br><span class="line">                    result.setValue(com.yunhu.rpc.result.Result.failResult(code, exception.getMessage()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 非自定义异常统一处理</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    recordErrorLog(kvFormat, exception);</span><br><span class="line">                    result.setValue(com.yunhu.rpc.result.Result.failResult(BizExceptionEnum.SYSTEM_ERROR.getCode(), BizExceptionEnum.SYSTEM_ERROR.getMessage()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//清除异常，否则调用方会以运行时异常报错！</span></span><br><span class="line">                result.setException(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            recordErrorLog(kvFormat, e);</span><br><span class="line">            result.setException(<span class="keyword">null</span>);</span><br><span class="line">            result.setValue(com.yunhu.rpc.result.Result.failResult(BizExceptionEnum.SYSTEM_ERROR.getCode(), BizExceptionEnum.SYSTEM_ERROR.getMessage()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li>这里自定义 Filter 的前提是返回结果是以状态码表示的，异常的处理最终也是通过状态码返回。</li><li>自定义的 Filter 的优先级相比较 Dubbo 内置的 ExceptionFilter 的优先级要高。即使调用出现异常，自定义 Filter 会清除异常信息，到 ExceptionFilter 时就不会走异常处理流程了。</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Dubbo 框架的异常处理过滤器进行了介绍，并实现了自定义的异常处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;ExceptionFilter&lt;/strong&gt; 是服务端的过滤器，它不是一个统一处理异常的过滤器，关注点不在于捕获异常，而
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Filter" scheme="https://gentryhuang.com/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo过滤器 - TokenFilter</title>
    <link href="https://gentryhuang.com/posts/4c117d83/"/>
    <id>https://gentryhuang.com/posts/4c117d83/</id>
    <published>2020-08-06T12:59:38.000Z</published>
    <updated>2021-02-19T02:56:10.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 框架支持通过令牌验证在注册中心控制权限，以决定是否下发令牌给消费者，以防止消费者绕过注册中心访问服务提供者，另外通过注册中心可灵活改变授权方式，而不需修改或升级提供者。</p><p><img src="/posts/4c117d83/dubbo-filter-token.jpg" alt></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li>全局开启令牌<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--随机token令牌，使用UUID生成--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">token</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--固定token令牌，相当于密码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">token</span>=<span class="string">"123456"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li>服务级别开启令牌<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--随机token令牌，使用UUID生成--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">token</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--固定token令牌，相当于密码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">token</span>=<span class="string">"123456"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Token-流转"><a href="#Token-流转" class="headerlink" title="Token 流转"></a>Token 流转</h1><h2 id="服务提供端"><a href="#服务提供端" class="headerlink" title="服务提供端"></a>服务提供端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--- ServiceConfig#doExportUrlsFor1Protocol</span><br><span class="line">  <span class="comment">// token 【使暴露出去的服务更安全，使用token做安全校验】</span></span><br><span class="line">  <span class="keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">     <span class="comment">// true || default 时，UUID 随机生成</span></span><br><span class="line">     <span class="keyword">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">            map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(Constants.TOKEN_KEY, token);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>服务提供者将设置的 Token 最终会设置到 URL 中，最终写入到注册中心上。</p><h2 id="服务消费端"><a href="#服务消费端" class="headerlink" title="服务消费端"></a>服务消费端</h2><p>服务消费者从注册中心获取服务提供者的 URL ，从而获得该服务的 Token 。在创建 RpcInvocation 时会自动带上 Token，最终会将 Token 发送到服务提供方，而 TokenFilter 就是处理来自服务消费方的 Token 的。</p><h1 id="TokenFilter"><a href="#TokenFilter" class="headerlink" title="TokenFilter"></a>TokenFilter</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = Constants.PROVIDER, value = Constants.TOKEN_KEY)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对请求的令牌做校验</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inv</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 获得服务提供者配置的Token 值</span></span><br><span class="line">        String token = invoker.getUrl().getParameter(Constants.TOKEN_KEY);</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.isNotEmpty(token)) &#123;</span><br><span class="line">            Class&lt;?&gt; serviceType = invoker.getInterface();</span><br><span class="line">            <span class="comment">// 从 RpcInvocation 的 隐式参数中，获得 Token 值</span></span><br><span class="line">            Map&lt;String, String&gt; attachments = inv.getAttachments();</span><br><span class="line">            String remoteToken = attachments == <span class="keyword">null</span> ? <span class="keyword">null</span> : attachments.get(Constants.TOKEN_KEY);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 验证消费方【RpcInvocation的信息】传过来的的Token 和 服务提供者配置的Token 释放一致，不一致就抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (!token.equals(remoteToken)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Invalid token! Forbid invoke remote service "</span> + serviceType + <span class="string">" method "</span> + inv.getMethodName() + <span class="string">"() from consumer "</span> + RpcContext.getContext().getRemoteHost() + <span class="string">" to provider "</span> + RpcContext.getContext().getLocalHost());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Dubbo 框架支持通过令牌验证在注册中心控制权限，以决定是否下发令牌给消费者，以防止消费者绕过注册中心访问服务提供者，另外通过注册中心可灵
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Filter" scheme="https://gentryhuang.com/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo过滤器 - EchoFilter</title>
    <link href="https://gentryhuang.com/posts/2e2f77b9/"/>
    <id>https://gentryhuang.com/posts/2e2f77b9/</id>
    <published>2020-08-03T14:59:38.000Z</published>
    <updated>2021-02-19T02:16:35.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>回声测试用于检测服务是否可用，回声测试按照正常请求流程执行，能够测试整个调用是否通畅，可用于监控。</p><h1 id="EchoService"><a href="#EchoService" class="headerlink" title="EchoService"></a>EchoService</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EchoService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * echo test.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message message.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object $echo(Object message);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费端的服务对象（代理对象）自动实现 <strong>EchoService</strong> 接口，只需将任意服务引用强制转型为 EchoService 即可使用。关于创建服务消费端的代理对象时，自动实现 <strong>EchoService</strong> 接口可以参考 <a href="https://gentryhuang.com/posts/1d1e42a8/#%E4%BB%A3%E7%90%86%E5%B7%A5%E5%8E%82%E6%8A%BD%E8%B1%A1%E5%AE%9E%E7%8E%B0%E7%B1%BB">回声探测接口实现</a> 。服务提供者是不实现 <strong>EchoService</strong> 接口，而是通过 <strong>EchoFilter</strong> 来处理回声探测请求。</p><h1 id="EchoFilter"><a href="#EchoFilter" class="headerlink" title="EchoFilter"></a>EchoFilter</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = Constants.PROVIDER, order = -<span class="number">110000</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是回声探测方法 $echo(message) ,直接返回方法参数。</span></span><br><span class="line">        <span class="comment">// 方名为 $echo,方法参数仅有一个  --&gt;  回声探测方法</span></span><br><span class="line">        <span class="keyword">if</span> (inv.getMethodName().equals(Constants.$ECHO) &amp;&amp; inv.getArguments() != <span class="keyword">null</span> &amp;&amp; inv.getArguments().length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(inv.getArguments()[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 非回声探测调用，继续走后面的流程</span></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;回声测试用于检测服务是否可用，回声测试按照正常请求流程执行，能够测试整个调用是否通畅，可用于监控。&lt;/p&gt;
&lt;h1 id=&quot;EchoServ
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Filter" scheme="https://gentryhuang.com/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo过滤器 - TimeoutFilter</title>
    <link href="https://gentryhuang.com/posts/8338833e/"/>
    <id>https://gentryhuang.com/posts/8338833e/</id>
    <published>2020-08-02T16:00:00.000Z</published>
    <updated>2021-02-19T01:57:04.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>服务提供端的超时过滤器，即如果服务调用超时，记录告警日志，不干涉服务的运行。</p><h1 id="TimeoutFilter"><a href="#TimeoutFilter" class="headerlink" title="TimeoutFilter"></a>TimeoutFilter</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = Constants.PROVIDER)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TimeoutFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 调用开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 执行服务调用逻辑</span></span><br><span class="line">        Result result = invoker.invoke(invocation);</span><br><span class="line">        <span class="comment">// 计算调用消耗时长</span></span><br><span class="line">        <span class="keyword">long</span> elapsed = System.currentTimeMillis() - start;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  注意：</span></span><br><span class="line"><span class="comment">         *  1 这里timeout 是服务提供者的配置，不同于服务消费者的配置。</span></span><br><span class="line"><span class="comment">         *  2 服务提供者执行服务即使超时了也不会取消执行，而消费者已经结束了调用，返回调用超时</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (invoker.getUrl() != <span class="keyword">null</span> &amp;&amp; elapsed &gt; invoker.getUrl().getMethodParameter(invocation.getMethodName(), <span class="string">"timeout"</span>, Integer.MAX_VALUE)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"invoke time out. method: "</span> + invocation.getMethodName()</span><br><span class="line">                        + <span class="string">" arguments: "</span> + Arrays.toString(invocation.getArguments()) + <span class="string">" , url is "</span></span><br><span class="line">                        + invoker.getUrl() + <span class="string">", invoke elapsed "</span> + elapsed + <span class="string">" ms."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><strong>TimeoutFilter</strong> 用于记录服务端执行逻辑超时日志，是对 Dubbo 框架中所有服务的监控。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;服务提供端的超时过滤器，即如果服务调用超时，记录告警日志，不干涉服务的运行。&lt;/p&gt;
&lt;h1 id=&quot;TimeoutFilter&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Filter" scheme="https://gentryhuang.com/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo过滤器 - TpsLimitFilter</title>
    <link href="https://gentryhuang.com/posts/f715f3aa/"/>
    <id>https://gentryhuang.com/posts/f715f3aa/</id>
    <published>2020-08-01T16:00:00.000Z</published>
    <updated>2021-02-19T01:35:33.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>TpsLimitFilter 是服务提供端对 TPS 限流的实现。该过滤器的限流是基于令牌的，本质上是计数器限流的实现方式，即一个时间段内只分配 N 个令牌，每个请求过来都会消耗一个令牌，耗完即止，后面再来的请求都会被拒绝。计数器算法简单粗暴，易于实现。但是缺点也是很大的，容易造成前一个时间段非常忙碌，下一时间段又非常空闲。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 每次发放 100 个令牌 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"tps"</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 令牌刷新的间隔是 1s，如果不配置则默认 60s --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"tps.interval"</span> <span class="attr">value</span>=<span class="string">"1000"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>将以上的配置项添加到 <code>&lt;dubbo:provider/&gt;</code> 或 <code>&lt;dubbo:service/&gt;</code> 或 <code>&lt;dubbo:protocol/&gt;</code> 中开启即可。</p><p>注意，目前 Dubbo Filter 的 SPI 配置文件中并没有配置 <strong>TpsLimitFilter</strong> ，如果需要使用则配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># com.alibaba.dubbo.rpc.Filter 文件</span><br><span class="line">tps&#x3D;com.alibaba.dubbo.rpc.filter.TpsLimitFilter</span><br></pre></td></tr></table></figure><h1 id="TpsLimitFilter"><a href="#TpsLimitFilter" class="headerlink" title="TpsLimitFilter"></a>TpsLimitFilter</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = Constants.PROVIDER, value = Constants.TPS_LIMIT_RATE_KEY)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TpsLimitFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限流器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TPSLimiter tpsLimiter = <span class="keyword">new</span> DefaultTPSLimiter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 根据tps限流规则判断是否限制此次调用，如果是就抛出异常。目前使用 TPSLimiter作为限流器的实现类</span></span><br><span class="line">        <span class="keyword">if</span> (!tpsLimiter.isAllowable(invoker.getUrl(), invocation)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(</span><br><span class="line">                    <span class="string">"Failed to invoke service "</span> +</span><br><span class="line">                            invoker.getInterface().getName() +</span><br><span class="line">                            <span class="string">"."</span> +</span><br><span class="line">                            invocation.getMethodName() +</span><br><span class="line">                            <span class="string">" because exceed max service tps."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TPSLimiter"><a href="#TPSLimiter" class="headerlink" title="TPSLimiter"></a>TPSLimiter</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TPSLimiter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 tps 限流规则判断是否限制此次调用</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * judge if the current invocation is allowed by TPS rule</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url        url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true allow the current invocation, otherwise, return false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAllowable</span><span class="params">(URL url, Invocation invocation)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认TPS限制器实现类，以服务为纬度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultTPSLimiter</span> <span class="keyword">implements</span> <span class="title">TPSLimiter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * StatItem 集合，即缓存每个接口的令牌数</span></span><br><span class="line"><span class="comment">     * key: 服务键，interface + group + version</span></span><br><span class="line"><span class="comment">     * value: StatItem</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, StatItem&gt; stats = <span class="keyword">new</span> ConcurrentHashMap&lt;String, StatItem&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否触发限流</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url        url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllowable</span><span class="params">(URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得 tps 配置项，即令牌数</span></span><br><span class="line">        <span class="keyword">int</span> rate = url.getParameter(Constants.TPS_LIMIT_RATE_KEY, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获得 tps.interval 周期配置项，默认60 秒，即令牌刷新时间间隔</span></span><br><span class="line">        <span class="keyword">long</span> interval = url.getParameter(Constants.TPS_LIMIT_INTERVAL_KEY, Constants.DEFAULT_TPS_LIMIT_INTERVAL);</span><br><span class="line">        <span class="comment">// 获得服务键</span></span><br><span class="line">        String serviceKey = url.getServiceKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果设置了令牌数，则开始限流处理</span></span><br><span class="line">        <span class="keyword">if</span> (rate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取服务键对应的 StatItem 对象</span></span><br><span class="line">            StatItem statItem = stats.get(serviceKey);</span><br><span class="line">            <span class="comment">// 不存在，则进行创建</span></span><br><span class="line">            <span class="keyword">if</span> (statItem == <span class="keyword">null</span>) &#123;</span><br><span class="line">                stats.putIfAbsent(serviceKey, <span class="keyword">new</span> StatItem(serviceKey, rate, interval));</span><br><span class="line">                statItem = stats.get(serviceKey);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据 tps 限流规则判断是否限制此次调用</span></span><br><span class="line">            <span class="keyword">return</span> statItem.isAllowable();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不进行限流</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 移除当前服务键关联的 StatItem</span></span><br><span class="line">            StatItem statItem = stats.get(serviceKey);</span><br><span class="line">            <span class="keyword">if</span> (statItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stats.remove(serviceKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TPSLimiter 接口中的核心是 isAllowable() 方法，在 DefaultTPSLimiter 实现中，使用 ConcurrentHashMap 为每个服务健维护了一个相应的 StatItem 对象。在 isAllowable() 方法实现中，会从 URL 中读取 tps 参数值（默认为 -1，即没有限流），对于需要限流的请求，会从 stats 集合中获取（或创建）相应 StatItem 对象，然后调用 StatItem 对象的isAllowable() 方法判断是否被限流。</p><h1 id="StatItem"><a href="#StatItem" class="headerlink" title="StatItem"></a>StatItem</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatItem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统计名，目前使用服务键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后重置时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastResetTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 令牌刷新时间间隔，即重置 token 值的时间周期，这样就实现了在 interval 时间段内能够通过 rate 个请求的效果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> interval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 令牌数,初始值为 rate 值，每通过一个请求 token 递减一，当减为 0 时，不再通过任何请求，实现限流的作用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger token;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一段时间内能通过的 TPS 上限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name     服务键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rate     限制大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interval 限制周期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    StatItem(String name, <span class="keyword">int</span> rate, <span class="keyword">long</span> interval) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.rate = rate;</span><br><span class="line">        <span class="keyword">this</span>.interval = interval;</span><br><span class="line">        <span class="comment">// 记录时间戳</span></span><br><span class="line">        <span class="keyword">this</span>.lastResetTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">this</span>.token = <span class="keyword">new</span> AtomicInteger(rate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限流规则判断是否限制此次调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAllowable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 周期性重置token</span></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (now &gt; lastResetTime + interval) &#123;</span><br><span class="line">            token.set(rate);</span><br><span class="line">            <span class="comment">// 记录最近一次重置token的时间戳</span></span><br><span class="line">            lastResetTime = now;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CAS，直到获得一个令牌，或者没有足够的令牌才结束</span></span><br><span class="line">        <span class="keyword">int</span> value = token.get();</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (value &gt; <span class="number">0</span> &amp;&amp; !flag) &#123;</span><br><span class="line">            flag = token.compareAndSet(value, value - <span class="number">1</span>);</span><br><span class="line">            value = token.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否允许访问 【取决是否能够拿到令牌】</span></span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getLastResetTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastResetTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> token.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StatItem 包装了令牌刷新的时间间隔、每次发放的令牌数等属性。它的核心是 isAllowable 方法，这也是整个 TPS 限流算法的核。</p><p><strong>它的主要逻辑如下：</strong></p><ol><li>判断上次发放令牌的时间点到现在是否超过令牌刷新的时间间隔，如果超过就重新发送令牌，之前没用完的不会叠加，而是重新设置令牌数。</li><li>通过 CAS 递减令牌，减掉后令牌数如果小于 0 则会触发限流。</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>TpsLimitFilter 中的限流算法是基于计数器，注意和令牌桶算法的区别。常见的限流算法有计数器、令牌桶、漏桶等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;TpsLimitFilter 是服务提供端对 TPS 限流的实现。该过滤器的限流是基于令牌的，本质上是计数器限流的实现方式，即一个时间段内只
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Filter" scheme="https://gentryhuang.com/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo过滤器 - ContextFilter &amp; ConsumerContextFilter</title>
    <link href="https://gentryhuang.com/posts/c72fde05/"/>
    <id>https://gentryhuang.com/posts/c72fde05/</id>
    <published>2020-07-30T16:00:00.000Z</published>
    <updated>2021-02-18T14:28:15.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>ContextFilter</strong> 和 <strong>ConsumerContextFilter</strong> 分别用来初始化服务提供端和消费端的上下文 <strong>RpcContext</strong>  。无论是消费端发起的调用，还是服务端收到的调用，从节点的角度看都是一次调用，都可能产生很多中间临时信息，我们不可能要求在每个方法的参数位置都加一个上下文参数，然后一路往下传。通常做法都是放在 <strong>ThreadLocal</strong> 中，作为一个全局参数，当前线程中的任何一个地方都可以直接操作上下文信息。</p><h1 id="RPC-上下文"><a href="#RPC-上下文" class="headerlink" title="RPC 上下文"></a>RPC 上下文</h1><p>RpcContext 是 Dubbo 的上下文信息，其定义如下：</p><blockquote><p>1 上下文中存放的是当前调用过程中所需的环境信息，如 Invoker信息，Invocation信息、地址信息等。<br>2 RpcContext 是一个 ThreadLocal 的临时状态记录器，该对象维护两个 InternalThreadLocal，分别记录 local 和 server 的上下文。每次收到或发起 RPC 调用的时候，上下文信息都会发生改变。比如：A 调用 B，B 再调用 C，则 B 机器上：在 B 调 C 之前，RpcContext 记录的是 A 调 B 的上下信息，在 B 开始调 C 时 ，RpcContext 记录的是 B 调 C 的上下文信息。发起调用的时候上下文是由 ConsumerContextFilter 实现的，ContextFilter 保存的是收到的请求的上下文。</p></blockquote><h2 id="服务消费方"><a href="#服务消费方" class="headerlink" title="服务消费方"></a>服务消费方</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远程调用</span></span><br><span class="line">xxxService.xxx();</span><br><span class="line"><span class="comment">// 本端是否为消费端，这里会返回true</span></span><br><span class="line"><span class="keyword">boolean</span> isConsumerSide = RpcContext.getContext().isConsumerSide();</span><br><span class="line"><span class="comment">// 获取最后一次调用的提供方IP地址</span></span><br><span class="line">String serverIP = RpcContext.getContext().getRemoteHost();</span><br><span class="line"><span class="comment">// 获取当前服务配置信息，所有配置信息都将转换为URL的参数</span></span><br><span class="line">String application = RpcContext.getContext().getUrl().getParameter(<span class="string">"application"</span>);</span><br><span class="line"><span class="comment">// 注意：每发起RPC调用，上下文状态会变化</span></span><br><span class="line">yyyService.yyy();</span><br></pre></td></tr></table></figure><h2 id="服务停供方"><a href="#服务停供方" class="headerlink" title="服务停供方"></a>服务停供方</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxServiceImpl</span> <span class="keyword">implements</span> <span class="title">XxxService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xxx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 本端是否为提供端，这里会返回true</span></span><br><span class="line">        <span class="keyword">boolean</span> isProviderSide = RpcContext.getContext().isProviderSide();</span><br><span class="line">        <span class="comment">// 获取调用方IP地址</span></span><br><span class="line">        String clientIP = RpcContext.getContext().getRemoteHost();</span><br><span class="line">        <span class="comment">// 获取当前服务配置信息，所有配置信息都将转换为URL的参数</span></span><br><span class="line">        String application = RpcContext.getContext().getUrl().getParameter(<span class="string">"application"</span>);</span><br><span class="line">        <span class="comment">// 注意：每发起RPC调用，上下文状态会变化</span></span><br><span class="line">        yyyService.yyy();</span><br><span class="line">        <span class="comment">// 此时本端变成消费端，这里会返回false</span></span><br><span class="line">        <span class="keyword">boolean</span> isProviderSide = RpcContext.getContext().isProviderSide();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ConsumerContextFilter"><a href="#ConsumerContextFilter" class="headerlink" title="ConsumerContextFilter"></a>ConsumerContextFilter</h1><p>在服务消费者中使用，负责发起调用时初始化 RpcContext 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = Constants.CONSUMER, order = -<span class="number">10000</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerContextFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        RpcContext.getContext()</span><br><span class="line">                <span class="comment">// 记录Invoker</span></span><br><span class="line">                .setInvoker(invoker)</span><br><span class="line">                <span class="comment">// 记录服务调用参数</span></span><br><span class="line">                .setInvocation(invocation)</span><br><span class="line">                <span class="comment">// 本地地址</span></span><br><span class="line">                .setLocalAddress(NetUtils.getLocalHost(), <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 远端地址</span></span><br><span class="line">                .setRemoteAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 RpcInvocation 对象的 invoker 属性</span></span><br><span class="line">        <span class="keyword">if</span> (invocation <span class="keyword">instanceof</span> RpcInvocation) &#123;</span><br><span class="line">            ((RpcInvocation) invocation).setInvoker(invoker);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RpcResult result = (RpcResult) invoker.invoke(invocation);</span><br><span class="line">            RpcContext.getServerContext().setAttachments(result.getAttachments());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 清理隐式参数集合</span></span><br><span class="line"><span class="comment">             * 注意：每次服务调用完成，RpcContext设置的隐式参数都会被清理</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            RpcContext.getContext().clearAttachments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ConsumerContextFilter</strong> 通常会和 <strong>ContextFilter</strong> 配合使用，因为在微服务环境中有很多链式调用。收到请求时，当前节点可以被看作一个服务提供者，由 <strong>ContextFilter</strong> 设置上下文。当发起请求调用其他服务，当前服务变成一个消费者，由 <strong>ConsumerContextFilter</strong> 设置上下文。</p><h1 id="ContextFilter"><a href="#ContextFilter" class="headerlink" title="ContextFilter"></a>ContextFilter</h1><p>在服务提供者中使用，负责被调用时初始化 RpcContext 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = Constants.PROVIDER, order = -<span class="number">10000</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建新的 attachments 集合，清理公用的隐式参数。公用的隐式参数，设置的地方如下：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> RpcInvocation#RpcInvocation(com.alibaba.dubbo.rpc.Invocation, com.alibaba.dubbo.rpc.Invoker)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, String&gt; attachments = invocation.getAttachments();</span><br><span class="line">        <span class="keyword">if</span> (attachments != <span class="keyword">null</span>) &#123;</span><br><span class="line">            attachments = <span class="keyword">new</span> HashMap&lt;String, String&gt;(attachments);</span><br><span class="line">            <span class="comment">// 清理 path</span></span><br><span class="line">            attachments.remove(Constants.PATH_KEY);</span><br><span class="line">            <span class="comment">// 清理 group</span></span><br><span class="line">            attachments.remove(Constants.GROUP_KEY);</span><br><span class="line">            <span class="comment">// 清理 version</span></span><br><span class="line">            attachments.remove(Constants.VERSION_KEY);</span><br><span class="line">            <span class="comment">// 清理 dubbo</span></span><br><span class="line">            attachments.remove(Constants.DUBBO_VERSION_KEY);</span><br><span class="line">            <span class="comment">// 清理 token</span></span><br><span class="line">            attachments.remove(Constants.TOKEN_KEY);</span><br><span class="line">            <span class="comment">// 清理 timeout</span></span><br><span class="line">            attachments.remove(Constants.TIMEOUT_KEY);</span><br><span class="line">            <span class="comment">// 清除异步属性，防止异步属性传到过滤器下一个环节</span></span><br><span class="line">            attachments.remove(Constants.ASYNC_KEY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里和 ConsumerContextFilter 不同，没有设置 remoteAddress 的值，做为服务端的过滤器，在收到请求的时候就已经设置了 remoteAddress 的值</span></span><br><span class="line">        <span class="comment">// @see com.alibaba.dubbo.remoting.exchange.support.ExchangeHandlerAdapter.reply</span></span><br><span class="line">        RpcContext.getContext()</span><br><span class="line">                .setInvoker(invoker)</span><br><span class="line">                .setInvocation(invocation)</span><br><span class="line"><span class="comment">//                .setAttachments(attachments)  // merged from dubbox</span></span><br><span class="line">                .setLocalAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mreged from dubbox</span></span><br><span class="line">        <span class="comment">// we may already added some attachments into RpcContext before this filter (e.g. in rest protocol)</span></span><br><span class="line">        <span class="keyword">if</span> (attachments != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (RpcContext.getContext().getAttachments() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                RpcContext.getContext().getAttachments().putAll(attachments);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                RpcContext.getContext().setAttachments(attachments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 RpcInvocation 对象的 'invoker' 属性</span></span><br><span class="line">        <span class="keyword">if</span> (invocation <span class="keyword">instanceof</span> RpcInvocation) &#123;</span><br><span class="line">            ((RpcInvocation) invocation).setInvoker(invoker);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用过滤器链的下一个节点</span></span><br><span class="line">            RpcResult result = (RpcResult) invoker.invoke(invocation);</span><br><span class="line">            <span class="comment">// 将 SERVER_LOCAL 这个 RpcContext 中的附加信息添加到 RpcResult 的 attachments 字段中，返回给 Consumer。</span></span><br><span class="line">            result.addAttachments(RpcContext.getServerContext().getAttachments());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清除上下文信息，当前线程处理下一个调用的时候，会创建新的 RpcContext</span></span><br><span class="line">            RpcContext.removeContext();</span><br><span class="line">            RpcContext.getServerContext().clearAttachments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 <strong>RpcContext</strong> 分别在服务提供端和服务消费端的初始化进行了介绍，初始化的时机是每次发起调用和每次被调用。有了 <strong>RpcContext</strong> 就不需要将调用相关信息通过方法依次传递了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;ContextFilter&lt;/strong&gt; 和 &lt;strong&gt;ConsumerContextFilter&lt;/strong
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Filter" scheme="https://gentryhuang.com/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo过滤器 - ClassLoaderFilter</title>
    <link href="https://gentryhuang.com/posts/3fc82a32/"/>
    <id>https://gentryhuang.com/posts/3fc82a32/</id>
    <published>2020-07-25T16:00:00.000Z</published>
    <updated>2021-02-18T09:53:39.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>ClassLoaderFilter</strong> 是服务提供端的一个 Filter 实现，用于切换当前工作线程的类加载器到接口的类加载器，以便和接口的类加载器的上下文一起工作。</p><h1 id="ClassLoaderFilter"><a href="#ClassLoaderFilter" class="headerlink" title="ClassLoaderFilter"></a>ClassLoaderFilter</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Activate(group = Constants.PROVIDER, order = -<span class="number">30000</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 获得当前线程的类加载器</span></span><br><span class="line">        ClassLoader ocl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="comment">// 切换当前线程的类加载器为服务接口的类加载器</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(invoker.getInterface().getClassLoader());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 继续过滤器链的下一个节点</span></span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 切换当前线程的类加载器为原来的类加载器</span></span><br><span class="line">            Thread.currentThread().setContextClassLoader(ocl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ClassLoaderFilter</strong> 的逻辑：首先获取当前线程关联的 ClassLoader，然后将其 ClassLoader 设置为 invoker.getInterface().getClassLoader()，也就是加载服务接口类的类加载器；之后执行 invoker.invoke() 方法，执行后续的 Filter 逻辑以及业务逻辑；最后，将当前线程关联的 ClassLoader 重置为原来的 ClassLoader ocl 。</p><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>如果 ClassA 和 ClassB 都是同一个类加载器加载的，则它们之间是可以相互访问的。如果 ClassA 和 ClassB 是不同的类加载器加载的，示例图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-filter-classloaderFilter-classLoader.jpg" alt></p><p>根据双亲委派模型，如果 ClassA 要访问 ClassB，大致流程如下：</p><ol><li>ClassA 会从 ClassLoaderA 中查找 ClassB，看是否已经加载。</li><li>没有找到 ClassB 则会继续往上层查找，看父类加载器 ParentClassLoader 是否可以查找到 ClassB，如果找不到会继续往上层父类加载器查找。</li><li>最终没有找到，会抛出 <strong>ClassNotFoundException</strong> 异常。</li></ol><p>如果要实现违反双亲委派模型来查找 Class，通常会使用上下文类加载器 <strong>ContextClassFilter</strong> 。</p><h1 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h1><p><strong>Q:</strong> ClassLoaderFilter 的具体作用？</p><p><strong>A:</strong> Dubbo 框架线程的类加载器可能和服务接口的类加载器不是同一个，而当前框架线程中又需要获取服务接口的类加载中的一些 Class，为了避免出现 ClassNotFoundException，此时只需要将框架线程的类加载器切换到加载了接口定义的类加载器，进而就能获得这个类加载中的 Class 。</p><p><strong>Extra:</strong> Dubbo 中进行序列化优化时，会根据 Invoker 中配置的 <code>optimizer</code> 参数获取扩展的自定义序列化处理类，这些外部引入的序列化类在框架的类加载器中肯定没有，因此需要使用 Invoker 的类加载器获取对应的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行序列化优化，注册需要优化的类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">optimizeSerialization</span><span class="params">(URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 获得 optimizer 序列化优化器 配置项</span></span><br><span class="line">        String className = url.getParameter(Constants.OPTIMIZER_KEY, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果系统中没有序列化优化器就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(className) || optimizers.contains(className)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"Optimizing the serialization process for Kryo, FST, etc..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据 序列化优化器名 加载 SerializationOptimizer 实现类。</span></span><br><span class="line">            <span class="comment">// 这里的当前线程的 ClassLoader 是处理过的，使用的是 Invoker 的类加载器</span></span><br><span class="line">            Class clazz = Thread.currentThread().getContextClassLoader().loadClass(className);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否是 SerializationOptimizer.class，或者 是SerializationOptimizer的子</span></span><br><span class="line">            <span class="keyword">if</span> (!SerializationOptimizer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"The serialization optimizer "</span> + className + <span class="string">" isn't an instance of "</span> + SerializationOptimizer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 SerializationOptimizer 对象</span></span><br><span class="line">            SerializationOptimizer optimizer = (SerializationOptimizer) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有要优化的类直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (optimizer.getSerializableClasses() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将要优化的类注册到 SerializableClassRegistry 中 （todo 在使用 Kryo,FST 等序列化算法时，会读取该集合中的类，完成注册）</span></span><br><span class="line">            <span class="keyword">for</span> (Class c : optimizer.getSerializableClasses()) &#123;</span><br><span class="line">                SerializableClassRegistry.registerClass(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 序列化优化器实现类名 加入到缓存中</span></span><br><span class="line">            optimizers.add(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Cannot find the serialization optimizer class: "</span> + className, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Cannot instantiate the serialization optimizer class: "</span> + className, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Cannot instantiate the serialization optimizer class: "</span> + className, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文件简单介绍了 Dubbo Filter 之 服务端的 ClassLoader 过滤器，它的作用就是用于切换当前工作线程的类加载器到接口的类加载器，以便和接口的类加载器的上下文一起工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;ClassLoaderFilter&lt;/strong&gt; 是服务提供端的一个 Filter 实现，用于切换当前工作线程的类加载器
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Filter" scheme="https://gentryhuang.com/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo过滤器 - ExecuteLimitFilter &amp; ActiveLimitFilter</title>
    <link href="https://gentryhuang.com/posts/bfcb5211/"/>
    <id>https://gentryhuang.com/posts/bfcb5211/</id>
    <published>2020-07-19T16:00:00.000Z</published>
    <updated>2021-02-17T06:01:12.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>ExecuteLimitFilter</strong> 是 Dubbo 在服务提供端限流的实现，用于限制每个服务中每个方法的最大并发数（或占用线程池线程数）。<strong>ActiveLimitFilter</strong> 是 Dubbo 在消费端的限流实现，用于限制一个消费者对一个服务端方法的并发调用量（或占用连接的请求数）。它们都支持接口级别和方法级别的配置。</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>Dubbo 在 2.6 和 2.7 版本的实现中有些许差异，下面我们分别对不同版本的实现进行说明。</p><h1 id="Dubbo-2-6-实现"><a href="#Dubbo-2-6-实现" class="headerlink" title="Dubbo 2.6 实现"></a>Dubbo 2.6 实现</h1><h2 id="ExecuteLimitFilter"><a href="#ExecuteLimitFilter" class="headerlink" title="ExecuteLimitFilter"></a>ExecuteLimitFilter</h2><p>服务端限流</p><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 接口级别配置，每个方法的并发执行数（或占用线程池线程数）不能超过 N 个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">executes</span>=<span class="string">"N"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 方法级别配置，sayHello方法的并发执行数（或占用线程池线程数）不能超过 N 个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"sayHello"</span> <span class="attr">executes</span>=<span class="string">"N"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，如果不设置，则默认不做限制，如果设置了小于等于0，那么同样是不做任何限制。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = Constants.PROVIDER, value = Constants.EXECUTES_KEY)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecuteLimitFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 获得URL</span></span><br><span class="line">        URL url = invoker.getUrl();</span><br><span class="line">        <span class="comment">// 获得方法名</span></span><br><span class="line">        String methodName = invocation.getMethodName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 信号量</span></span><br><span class="line">        Semaphore executesLimit = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 是否获得信号量</span></span><br><span class="line">        <span class="keyword">boolean</span> acquireResult = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得服务提供方当前方法最大可并发请求数</span></span><br><span class="line">        <span class="keyword">int</span> max = url.getMethodParameter(methodName, Constants.EXECUTES_KEY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大可并发请求数大于0</span></span><br><span class="line">        <span class="keyword">if</span> (max &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 基于 服务URL + 方法纬度，创建/获取 RpcStatus 计数器</span></span><br><span class="line">            RpcStatus count = RpcStatus.getStatus(url, invocation.getMethodName());</span><br><span class="line">            <span class="comment">// 创建/获取 RpcStatus 计数器对应的信号量</span></span><br><span class="line">            executesLimit = count.getSemaphore(max);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试获取信号量，获取失败则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (executesLimit != <span class="keyword">null</span> &amp;&amp; !(acquireResult = executesLimit.tryAcquire())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to invoke method "</span> + invocation.getMethodName() + <span class="string">" in provider "</span> + url + <span class="string">", cause: The service using threads greater than &lt;dubbo:service executes=\""</span> + max + <span class="string">"\" /&gt; limited."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">boolean</span> isSuccess = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计数器 +1</span></span><br><span class="line">        RpcStatus.beginCount(url, methodName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 服务调用</span></span><br><span class="line">            Result result = invoker.invoke(invocation);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 标记失败</span></span><br><span class="line">            isSuccess = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"unexpected exception when ExecuteLimitFilter"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 计数器-1  [调用失败/成功，看isSuccess的值]</span></span><br><span class="line">            RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, isSuccess);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放信号量</span></span><br><span class="line">            <span class="keyword">if</span> (acquireResult) &#123;</span><br><span class="line">                executesLimit.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExecuteLimitFilter 本质上是利用 RpcStatus 中维护的 <strong>Semaphore</strong> 进行并发控制，进而达到限流的目的。需要说明的是，ExecuteLimitFilter 虽然使用到了计数器，但是起到限流作用的并不是它，而是计数器对应的信号量 <strong>Semaphore</strong> 。在 Dubbo 2.7 版本中移除了信号量的实现，使用计数器的原子类操作和CAS机制实现限流。</p><h2 id="ActiveLimitFilter"><a href="#ActiveLimitFilter" class="headerlink" title="ActiveLimitFilter"></a>ActiveLimitFilter</h2><p>客户端限流</p><h3 id="配置方式-1"><a href="#配置方式-1" class="headerlink" title="配置方式"></a>配置方式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 接口级别配置，每个方法在每个客户端的并发调用数（占用连接的请求数）不能超过 N 个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">actives</span>=<span class="string">"N"</span>/&gt;</span> <span class="comment">&lt;!--在服务端配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span> <span class="attr">actives</span>=<span class="string">"N"</span>/&gt;</span> <span class="comment">&lt;!--在客户端配置--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 方法级别配置，sayHello方法在每个客户端的并发调用数（占用连接的请求数）不能超过 N 个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"sayHello"</span> <span class="attr">actives</span>=<span class="string">"N"</span>&gt;</span><span class="comment">&lt;!--在服务端配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.foo.BarService"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"sayHello"</span> <span class="attr">actives</span>=<span class="string">"N"</span>&gt;</span><span class="comment">&lt;!--在服务端配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，如果服务端侧和消费端侧都配置了 actives，则消费端侧优先。如果设置了 actives 小于等于 0，则不做并发限制。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = Constants.CONSUMER, value = Constants.ACTIVES_KEY)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveLimitFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取URL</span></span><br><span class="line">        URL url = invoker.getUrl();</span><br><span class="line">        <span class="comment">// 获取方法名</span></span><br><span class="line">        String methodName = invocation.getMethodName();</span><br><span class="line">        <span class="comment">// 获取当前方法在当前客户端的最大调用量</span></span><br><span class="line">        <span class="keyword">int</span> max = invoker.getUrl().getMethodParameter(methodName, Constants.ACTIVES_KEY, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 基于服务URL + 方法纬度， 获得 RpcStatus 对象</span></span><br><span class="line">        RpcStatus count = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName());</span><br><span class="line">        <span class="keyword">if</span> (max &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  获得超时时间 [注意：这里的超时值不占用调用服务的超时时间] ，是用来控制等待请求释放资源的时间，防止等待时间太久。</span></span><br><span class="line"><span class="comment">             *  在极端情况下，调用服务的时间几乎是 2 * timeout</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">long</span> timeout = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.TIMEOUT_KEY, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> remain = timeout;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前并发度</span></span><br><span class="line">            <span class="keyword">int</span> active = count.getActive();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果达到限流阈值，和服务提供者不一样，并不是直接抛出异常，而是先等待直到超时以等待并发度降低，因为请求是允许有超时时间的。</span></span><br><span class="line">            <span class="keyword">if</span> (active &gt;= max) &#123;</span><br><span class="line">                <span class="comment">// 并发控制</span></span><br><span class="line">                <span class="keyword">synchronized</span> (count) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * 循环获取当前并发数，如果大于限流阈值则等待</span></span><br><span class="line"><span class="comment">                     * 会有两种结果：</span></span><br><span class="line"><span class="comment">                     * 1 某个Invoker在调用结束后，并发把计数器原子-1并唤醒等待线程，会有一个等待状态的线程被唤醒并继续执行逻辑</span></span><br><span class="line"><span class="comment">                     * 2 wait等待超时都没有被唤醒，此时抛出异常</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">while</span> ((active = count.getActive()) &gt;= max) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 等待，直到超时，或者被唤醒</span></span><br><span class="line">                            count.wait(remain);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 是否超时，超时则抛出异常</span></span><br><span class="line">                        <span class="keyword">long</span> elapsed = System.currentTimeMillis() - start;</span><br><span class="line">                        remain = timeout - elapsed;</span><br><span class="line">                        <span class="keyword">if</span> (remain &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Waiting concurrent invoke timeout in client-side for service:  "</span></span><br><span class="line">                                    + invoker.getInterface().getName() + <span class="string">", method: "</span></span><br><span class="line">                                    + invocation.getMethodName() + <span class="string">", elapsed: "</span> + elapsed</span><br><span class="line">                                    + <span class="string">", timeout: "</span> + timeout + <span class="string">". concurrent invokes: "</span> + active</span><br><span class="line">                                    + <span class="string">". max concurrent invoke limit: "</span> + max);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 开始计数，并发原子数 + 1</span></span><br><span class="line">            RpcStatus.beginCount(url, methodName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用服务</span></span><br><span class="line">                Result result = invoker.invoke(invocation);</span><br><span class="line">                <span class="comment">// 结束计数（调用成功），并发原子数 - 1</span></span><br><span class="line">                RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException t) &#123;</span><br><span class="line">                <span class="comment">// 结束计数（调用失败），并发原子数 -1</span></span><br><span class="line">                RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">throw</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 唤醒等待的相同服务的相同方法的请求</span></span><br><span class="line">            <span class="keyword">if</span> (max &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (count) &#123;</span><br><span class="line">                    count.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActiveLimitFilter 依赖 RpcStatus 的 <strong>beginCount()</strong> 方法和 <strong>endCount()</strong> 方法来实现 <strong>RpcStatus.active</strong> 字段的增减来达到限流的目的。 此外，做为消费端的限流过滤器，达到限流的阈值时并不是直接抛出异常，而是充分利用请求超时时间，允许在请求超时时间内等待并发度降低。</p><h2 id="RpcStatus"><a href="#RpcStatus" class="headerlink" title="RpcStatus"></a>RpcStatus</h2><p>RpcStatus 做为 <strong>ExecuteLimitFilter</strong> 和 <strong>ActiveLimitFilter</strong> 实现限流的核心类，前者限流使用 RpcStatus 封装的信号量 <strong>Semaphore</strong> ，后者限流使用 RpcStatus 维护的原子类型的 <strong>AtomicInteger active</strong> 属性。下面我们对 RpcStatus 的核心代码实现进行分析。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcStatus</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务状态信息</span></span><br><span class="line"><span class="comment">     * key: URL</span></span><br><span class="line"><span class="comment">     * value: RpcStatus 计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;String, RpcStatus&gt; SERVICE_STATISTICS = <span class="keyword">new</span> ConcurrentHashMap&lt;String, RpcStatus&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务每个方法的状态信息</span></span><br><span class="line"><span class="comment">     * key1: URL</span></span><br><span class="line"><span class="comment">     * key2: 方法名</span></span><br><span class="line"><span class="comment">     * RpcStatus 计数器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, RpcStatus&gt;&gt; METHOD_STATISTICS = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, RpcStatus&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Object&gt; values = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前并发度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.filter.ActiveLimitFilter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger active = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总调用次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong total = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总调用失败次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger failed = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总调用时长，单位： 毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong totalElapsed = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总调用失败时长，单位：毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong failedElapsed = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有调用中最长的耗时，单位：毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong maxElapsed = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有失败调用中最长的耗时，单位：毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong failedMaxElapsed = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有成功调用中最长的耗时，单位：毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong succeededMaxElapsed = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Semaphore used to control concurrency limit set by `executes`</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 服务执行信号量【包含服务执行信号量大小】</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Semaphore executesLimit;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务执行信号量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> executesPermits;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RpcStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据服务URL为纬度的获得RpcStatus</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> status</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RpcStatus <span class="title">getStatus</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// URL的字符串</span></span><br><span class="line">        String uri = url.toIdentityString();</span><br><span class="line">        <span class="comment">// 是否存在</span></span><br><span class="line">        RpcStatus status = SERVICE_STATISTICS.get(uri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不存在则创建，并且放入缓存中</span></span><br><span class="line">        <span class="keyword">if</span> (status == <span class="keyword">null</span>) &#123;</span><br><span class="line">            SERVICE_STATISTICS.putIfAbsent(uri, <span class="keyword">new</span> RpcStatus());</span><br><span class="line">            status = SERVICE_STATISTICS.get(uri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 服务URL + 方法 获得RpcStatus</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> status</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RpcStatus <span class="title">getStatus</span><span class="params">(URL url, String methodName)</span> </span>&#123;</span><br><span class="line">        String uri = url.toIdentityString();</span><br><span class="line">        <span class="comment">// 获得方法集合</span></span><br><span class="line">        ConcurrentMap&lt;String, RpcStatus&gt; map = METHOD_STATISTICS.get(uri);</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">            METHOD_STATISTICS.putIfAbsent(uri, <span class="keyword">new</span> ConcurrentHashMap&lt;String, RpcStatus&gt;());</span><br><span class="line">            map = METHOD_STATISTICS.get(uri);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcStatus status = map.get(methodName);</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.putIfAbsent(methodName, <span class="keyword">new</span> RpcStatus());</span><br><span class="line">            status = map.get(methodName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务调用开始计数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url        URL 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName 方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beginCount</span><span class="params">(URL url, String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// SERVICE_STATISTICS -&gt; 基于服务URL的计数</span></span><br><span class="line">        beginCount(getStatus(url));</span><br><span class="line">        <span class="comment">// METHOD_STATISTICS -&gt; 基于服务URL + 方法的计数</span></span><br><span class="line">        beginCount(getStatus(url, methodName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计数 - 调用中的次数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> status</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beginCount</span><span class="params">(RpcStatus status)</span> </span>&#123;</span><br><span class="line">        status.active.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务调用结束的计数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url        URL对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName 方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elapsed    时长，毫秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> succeeded  是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endCount</span><span class="params">(URL url, String methodName, <span class="keyword">long</span> elapsed, <span class="keyword">boolean</span> succeeded)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// SERVICE_STATISTICS -&gt; 基于服务URL的计数</span></span><br><span class="line">        endCount(getStatus(url), elapsed, succeeded);</span><br><span class="line">        <span class="comment">// METHOD_STATISTICS -&gt; 基于服务URL + 方法的计数</span></span><br><span class="line">        endCount(getStatus(url, methodName), elapsed, succeeded);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束计数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elapsed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> succeeded</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endCount</span><span class="params">(RpcStatus status, <span class="keyword">long</span> elapsed, <span class="keyword">boolean</span> succeeded)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用的次数要递减</span></span><br><span class="line">        status.active.decrementAndGet();</span><br><span class="line">        <span class="comment">// 总调用次数递增</span></span><br><span class="line">        status.total.incrementAndGet();</span><br><span class="line">        <span class="comment">// 总调用时长递增</span></span><br><span class="line">        status.totalElapsed.addAndGet(elapsed);</span><br><span class="line">        <span class="comment">// 更新最大调用时长</span></span><br><span class="line">        <span class="keyword">if</span> (status.maxElapsed.get() &lt; elapsed) &#123;</span><br><span class="line">            status.maxElapsed.set(elapsed);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 是否调用成功</span></span><br><span class="line">        <span class="keyword">if</span> (succeeded) &#123;</span><br><span class="line">            <span class="comment">// 更新最大成功调用时长</span></span><br><span class="line">            <span class="keyword">if</span> (status.succeededMaxElapsed.get() &lt; elapsed) &#123;</span><br><span class="line">                status.succeededMaxElapsed.set(elapsed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用失败次数递增</span></span><br><span class="line">            status.failed.incrementAndGet();</span><br><span class="line">            <span class="comment">// 总调用失败时长</span></span><br><span class="line">            status.failedElapsed.addAndGet(elapsed);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新最大失败调用时长</span></span><br><span class="line">            <span class="keyword">if</span> (status.failedMaxElapsed.get() &lt; elapsed) &#123;</span><br><span class="line">                status.failedMaxElapsed.set(elapsed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        values.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> values.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get active.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> active</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> active.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get total.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> total</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total.longValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get total elapsed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> total elapsed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTotalElapsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalElapsed.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get failed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> failed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFailed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> failed.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get failed elapsed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> failed elapsed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getFailedElapsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> failedElapsed.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get succeeded.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> succeeded</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSucceeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getTotal() - getFailed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get succeeded elapsed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> succeeded elapsed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSucceededElapsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getTotalElapsed() - getFailedElapsed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get succeeded average elapsed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> succeeded average elapsed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSucceededAverageElapsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> succeeded = getSucceeded();</span><br><span class="line">        <span class="keyword">if</span> (succeeded == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getSucceededElapsed() / succeeded;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get succeeded max elapsed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> succeeded max elapsed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSucceededMaxElapsed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> succeededMaxElapsed.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取信号量</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Get the semaphore for thread number. Semaphore's permits is decided by &#123;<span class="doctag">@link</span> Constants#EXECUTES_KEY&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxThreadNum value of &#123;<span class="doctag">@link</span> Constants#EXECUTES_KEY&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> thread number semaphore</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Semaphore <span class="title">getSemaphore</span><span class="params">(<span class="keyword">int</span> maxThreadNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxThreadNum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若信号量不存在，或者信号量大小改变，则创建新的信号量</span></span><br><span class="line">        <span class="keyword">if</span> (executesLimit == <span class="keyword">null</span> || executesPermits != maxThreadNum) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (executesLimit == <span class="keyword">null</span> || executesPermits != maxThreadNum) &#123;</span><br><span class="line">                    <span class="comment">// 创建信号量</span></span><br><span class="line">                    executesLimit = <span class="keyword">new</span> Semaphore(maxThreadNum);</span><br><span class="line">                    executesPermits = maxThreadNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回信号量</span></span><br><span class="line">        <span class="keyword">return</span> executesLimit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Dubbo-2-7-实现"><a href="#Dubbo-2-7-实现" class="headerlink" title="Dubbo 2.7 实现"></a>Dubbo 2.7 实现</h1><h2 id="ExecuteLimitFilter-1"><a href="#ExecuteLimitFilter-1" class="headerlink" title="ExecuteLimitFilter"></a>ExecuteLimitFilter</h2><h3 id="配置方式-2"><a href="#配置方式-2" class="headerlink" title="配置方式"></a>配置方式</h3><p>配置方式同 Dubbo 2.6 版本实现。</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = CommonConstants.PROVIDER, value = EXECUTES_KEY)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecuteLimitFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span>, <span class="title">Filter</span>.<span class="title">Listener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXECUTE_LIMIT_FILTER_START_TIME = <span class="string">"execute_limit_filter_start_time"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取相关参数，为下面的逻辑做准备</span></span><br><span class="line">        URL url = invoker.getUrl();</span><br><span class="line">        String methodName = invocation.getMethodName();</span><br><span class="line">        <span class="keyword">int</span> max = url.getMethodParameter(methodName, EXECUTES_KEY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试增加active的值，当并发度达到executes配置指定的阈值，则直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!RpcStatus.beginCount(url, methodName, max)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.LIMIT_EXCEEDED_EXCEPTION,</span><br><span class="line">                    <span class="string">"Failed to invoke method "</span> + invocation.getMethodName() + <span class="string">" in provider "</span> +</span><br><span class="line">                            url + <span class="string">", cause: The service using threads greater than &lt;dubbo:service executes=\""</span> + max +</span><br><span class="line">                            <span class="string">"\" /&gt; limited."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置限流的开始时间，用于调用完成或调用异常后的消耗时间计算</span></span><br><span class="line">        invocation.put(EXECUTE_LIMIT_FILTER_START_TIME, System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"unexpected exception when ExecuteLimitFilter"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用结束 - Filter.Listener 接口实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Result appResponse, Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 减小 active 的值，同时完成对一次调用的统计</span></span><br><span class="line">        RpcStatus.endCount(invoker.getUrl(), invocation.getMethodName(), getElapsed(invocation), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用失败 - Filter.Listener 接口实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t, Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RpcException) &#123;</span><br><span class="line">            RpcException rpcException = (RpcException) t;</span><br><span class="line">            <span class="keyword">if</span> (rpcException.isLimitExceed()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 减小 active 的值，同时完成对一次调用的统计</span></span><br><span class="line">        RpcStatus.endCount(invoker.getUrl(), invocation.getMethodName(), getElapsed(invocation), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getElapsed</span><span class="params">(Invocation invocation)</span> </span>&#123;</span><br><span class="line">        Object beginTime = invocation.get(EXECUTE_LIMIT_FILTER_START_TIME);</span><br><span class="line">        <span class="keyword">return</span> beginTime != <span class="keyword">null</span> ? System.currentTimeMillis() - (Long) beginTime : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExecuteLimitFilter 依赖 RpcStatus 的 <strong>beginCount()</strong> 方法和 <strong>endCount()</strong> 方法来实现 <strong>RpcStatus.active</strong> 字段的增减来达到限流的目的，放弃了 Dubbo 2.6 的信号量限流实现。</p><h2 id="ActiveLimitFilter-1"><a href="#ActiveLimitFilter-1" class="headerlink" title="ActiveLimitFilter"></a>ActiveLimitFilter</h2><h3 id="配置方式-3"><a href="#配置方式-3" class="headerlink" title="配置方式"></a>配置方式</h3><p>配置方式同 Dubbo 2.6 版本实现。</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = CONSUMER, value = ACTIVES_KEY)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveLimitFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span>, <span class="title">Filter</span>.<span class="title">Listener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTIVELIMIT_FILTER_START_TIME = <span class="string">"activelimit_filter_start_time"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        URL url = invoker.getUrl();</span><br><span class="line">        String methodName = invocation.getMethodName();</span><br><span class="line">        <span class="comment">// 获取最大并发度</span></span><br><span class="line">        <span class="keyword">int</span> max = invoker.getUrl().getMethodParameter(methodName, ACTIVES_KEY, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 获取服务方法的 RpcStatus</span></span><br><span class="line">        <span class="keyword">final</span> RpcStatus rpcStatus = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试增加active的值，当并发度达到executes配置指定的阈值时，则根据超时时间进行等待重新获取</span></span><br><span class="line">        <span class="keyword">if</span> (!RpcStatus.beginCount(url, methodName, max)) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeout = invoker.getUrl().getMethodParameter(invocation.getMethodName(), TIMEOUT_KEY, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> remain = timeout;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (rpcStatus) &#123;</span><br><span class="line">                <span class="comment">// 再次尝试并发度加一</span></span><br><span class="line">                <span class="keyword">while</span> (!RpcStatus.beginCount(url, methodName, max)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 当前线程阻塞，等待并发度降低</span></span><br><span class="line">                        rpcStatus.wait(remain);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// ignore</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">long</span> elapsed = System.currentTimeMillis() - start;</span><br><span class="line">                    remain = timeout - elapsed;</span><br><span class="line">                    <span class="comment">// 超时了则抛出限流异常</span></span><br><span class="line">                    <span class="keyword">if</span> (remain &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.LIMIT_EXCEEDED_EXCEPTION,</span><br><span class="line">                                <span class="string">"Waiting concurrent invoke timeout in client-side for service:  "</span> +</span><br><span class="line">                                        invoker.getInterface().getName() + <span class="string">", method: "</span> + invocation.getMethodName() +</span><br><span class="line">                                        <span class="string">", elapsed: "</span> + elapsed + <span class="string">", timeout: "</span> + timeout + <span class="string">". concurrent invokes: "</span> +</span><br><span class="line">                                        rpcStatus.getActive() + <span class="string">". max concurrent invoke limit: "</span> + max);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置调用服务前的时间戳</span></span><br><span class="line">        invocation.put(ACTIVELIMIT_FILTER_START_TIME, System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用完成-Filter.Listener 接口实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Result appResponse, Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        String methodName = invocation.getMethodName();</span><br><span class="line">        URL url = invoker.getUrl();</span><br><span class="line">        <span class="keyword">int</span> max = invoker.getUrl().getMethodParameter(methodName, ACTIVES_KEY, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 减小 active 的值，同时完成对一次调用的统计</span></span><br><span class="line">        RpcStatus.endCount(url, methodName, getElapsed(invocation), <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 调用 notifyFinish() 方法唤醒阻塞在对应 RpcStatus 对象上的线程</span></span><br><span class="line">        notifyFinish(RpcStatus.getStatus(url, methodName), max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用失败 - Filter.Listener 接口实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t, Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        String methodName = invocation.getMethodName();</span><br><span class="line">        URL url = invoker.getUrl();</span><br><span class="line">        <span class="keyword">int</span> max = invoker.getUrl().getMethodParameter(methodName, ACTIVES_KEY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RpcException) &#123;</span><br><span class="line">            RpcException rpcException = (RpcException) t;</span><br><span class="line">            <span class="comment">// 限流异常不处理</span></span><br><span class="line">            <span class="keyword">if</span> (rpcException.isLimitExceed()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 减小 active 的值，同时完成对一次调用的统计</span></span><br><span class="line">        RpcStatus.endCount(url, methodName, getElapsed(invocation), <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 调用 notifyFinish() 方法唤醒阻塞在对应 RpcStatus 对象上的线程（所有阻塞等待的线程）</span></span><br><span class="line">        notifyFinish(RpcStatus.getStatus(url, methodName), max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getElapsed</span><span class="params">(Invocation invocation)</span> </span>&#123;</span><br><span class="line">        Object beginTime = invocation.get(ACTIVELIMIT_FILTER_START_TIME);</span><br><span class="line">        <span class="keyword">return</span> beginTime != <span class="keyword">null</span> ? System.currentTimeMillis() - (Long) beginTime : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 唤醒因限流导致阻塞等待的线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcStatus</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyFinish</span><span class="params">(<span class="keyword">final</span> RpcStatus rpcStatus, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (max &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (rpcStatus) &#123;</span><br><span class="line">                rpcStatus.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActiveLimitFilter 同样依赖 RpcStatus 的 beginCount() 方法和 endCount() 方法来实现 RpcStatus.active 字段的增减来达到限流的目的。</p><h2 id="RpcStatus-1"><a href="#RpcStatus-1" class="headerlink" title="RpcStatus"></a>RpcStatus</h2><p>同样地，RpcStatus 是服务端和消费端实现限流的核心实现，下面对该对象进行说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcStatus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务状态信息</span></span><br><span class="line"><span class="comment">     * key: URL</span></span><br><span class="line"><span class="comment">     * value: RpcStatus</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;String, RpcStatus&gt; SERVICE_STATISTICS = <span class="keyword">new</span> ConcurrentHashMap&lt;String, RpcStatus&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务每个方法的状态信息</span></span><br><span class="line"><span class="comment">     * key1: URL</span></span><br><span class="line"><span class="comment">     * key2: 方法名</span></span><br><span class="line"><span class="comment">     * value: RpcStatus</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, RpcStatus&gt;&gt; METHOD_STATISTICS = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, RpcStatus&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Object&gt; values = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前并发度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger active = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用的总数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong total = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败的调用数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger failed = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有调用的总耗时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong totalElapsed = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有失败调用的总耗时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong failedElapsed = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有调用中最长的耗时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong maxElapsed = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有失败调用中最长的耗时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong failedMaxElapsed = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有成功调用中最长的耗时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong succeededMaxElapsed = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RpcStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> status</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RpcStatus <span class="title">getStatus</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        String uri = url.toIdentityString();</span><br><span class="line">        <span class="keyword">return</span> SERVICE_STATISTICS.computeIfAbsent(uri, key -&gt; <span class="keyword">new</span> RpcStatus());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeStatus</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        String uri = url.toIdentityString();</span><br><span class="line">        SERVICE_STATISTICS.remove(uri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> status</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RpcStatus <span class="title">getStatus</span><span class="params">(URL url, String methodName)</span> </span>&#123;</span><br><span class="line">        String uri = url.toIdentityString();</span><br><span class="line">        ConcurrentMap&lt;String, RpcStatus&gt; map = METHOD_STATISTICS.computeIfAbsent(uri, k -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> map.computeIfAbsent(methodName, k -&gt; <span class="keyword">new</span> RpcStatus());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeStatus</span><span class="params">(URL url, String methodName)</span> </span>&#123;</span><br><span class="line">        String uri = url.toIdentityString();</span><br><span class="line">        ConcurrentMap&lt;String, RpcStatus&gt; map = METHOD_STATISTICS.get(uri);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.remove(methodName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beginCount</span><span class="params">(URL url, String methodName)</span> </span>&#123;</span><br><span class="line">        beginCount(url, methodName, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在远程调用开始之前执行，其中会获取 服务和服务方法 对应的 RpcStatus 对象，然后分别将它们的 active 字段+1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> max</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">beginCount</span><span class="params">(URL url, String methodName, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">        max = (max &lt;= <span class="number">0</span>) ? Integer.MAX_VALUE : max;</span><br><span class="line">        <span class="comment">// 获取服务对应的 RpcStatus</span></span><br><span class="line">        RpcStatus appStatus = getStatus(url);</span><br><span class="line">        <span class="comment">// 获取服务方法对应的 RpcStatus</span></span><br><span class="line">        RpcStatus methodStatus = getStatus(url, methodName);</span><br><span class="line">        <span class="comment">// 是否需要限流</span></span><br><span class="line">        <span class="keyword">if</span> (methodStatus.active.get() == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自旋 + CAS 更新服务方法的并发度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i; ; ) &#123;</span><br><span class="line">            i = methodStatus.active.get();</span><br><span class="line">            <span class="comment">// 并发度超过 max 上限，直接返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &gt; max) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (methodStatus.active.compareAndSet(i, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 服务的并发度+1</span></span><br><span class="line">        appStatus.active.incrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会对服务和服务方法两个维度的 RpcStatus 中的所有字段进行更新，完成统计.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elapsed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> succeeded</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endCount</span><span class="params">(URL url, String methodName, <span class="keyword">long</span> elapsed, <span class="keyword">boolean</span> succeeded)</span> </span>&#123;</span><br><span class="line">        endCount(getStatus(url), elapsed, succeeded);</span><br><span class="line">        endCount(getStatus(url, methodName), elapsed, succeeded);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">endCount</span><span class="params">(RpcStatus status, <span class="keyword">long</span> elapsed, <span class="keyword">boolean</span> succeeded)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 降低并发度</span></span><br><span class="line">        status.active.decrementAndGet();</span><br><span class="line">        <span class="comment">// 调用总次数增加</span></span><br><span class="line">        status.total.incrementAndGet();</span><br><span class="line">        <span class="comment">// 调用总耗时增加</span></span><br><span class="line">        status.totalElapsed.addAndGet(elapsed);</span><br><span class="line">        <span class="comment">// 更新最大耗时</span></span><br><span class="line">        <span class="keyword">if</span> (status.maxElapsed.get() &lt; elapsed) &#123;</span><br><span class="line">            status.maxElapsed.set(elapsed);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果此次调用成功，则会更新成功调用的最大耗时</span></span><br><span class="line">        <span class="keyword">if</span> (succeeded) &#123;</span><br><span class="line">            <span class="keyword">if</span> (status.succeededMaxElapsed.get() &lt; elapsed) &#123;</span><br><span class="line">                status.succeededMaxElapsed.set(elapsed);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果此次调用失败，则会更新失败调用的最大耗时</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            status.failed.incrementAndGet();</span><br><span class="line">            status.failedElapsed.addAndGet(elapsed);</span><br><span class="line">            <span class="keyword">if</span> (status.failedMaxElapsed.get() &lt; elapsed) &#123;</span><br><span class="line">                status.failedMaxElapsed.set(elapsed);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get active.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> active</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> active.get();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 省略其它代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><strong>ExecuteLimitFilter</strong> 和 <strong>ActiveLimitFilter</strong> 分别作为服务端和消费端的限流实现，之所以前者是针对服务端的后者是针对消费端的，因为过滤器设置的针对的对象不同而已。我们可以发现 Dubbo 2.7 中两者实现逻辑几乎一致，Dubbo 2.6 中服务端的限流实现借助了信号量，消费端限流实现同样是原子类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;ExecuteLimitFilter&lt;/strong&gt; 是 Dubbo 在服务提供端限流的实现，用于限制每个服务中每个方法的
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Filter" scheme="https://gentryhuang.com/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo过滤器 - AccessLogFilter</title>
    <link href="https://gentryhuang.com/posts/40c720c7/"/>
    <id>https://gentryhuang.com/posts/40c720c7/</id>
    <published>2020-07-18T16:00:00.000Z</published>
    <updated>2021-02-15T11:15:57.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>AccessLogFilter 是一个日志过滤器，在服务提供端生效，主要用于记录服务每一次的请求日志。虽然 AccessLogFilter 默认会被激活，但还是需要手动配置来开启日志的打印。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li>标签<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">accesslog</span>=<span class="string">"xxx"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">accesslog</span>=<span class="string">"xxx"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">accesslog</span>=<span class="string">"xxx"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>配置方式<blockquote><ol><li>accesslog = “true” 或 accesslog=”default” ： 向日志组件 Logger 中输出访问日志，如logbak，将日志输出到应用本身的 log 目录下。</li><li>accesslog = “文件路径” ：直接把访问日志输出到指定文件中。</li></ol></blockquote></li></ul><p><strong>日志打印规则：</strong><br>如果配置的是将日志输出到日志组件，则立即写入。如果配置的是将日志输出到文件中，则将日志放入内存日志集合中，并开启定时任务进行日志持久化。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(group = Constants.PROVIDER, value = Constants.ACCESS_LOG_KEY)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessLogFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AccessLogFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------- 使用日志组件输出相关属性 -------------------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志名前缀，用于获取日志组件。用于 accesslog = true，或 accesslog = default 的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACCESS_LOG_KEY = <span class="string">"dubbo.accesslog"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------- 配置输出到指定文件的相关属性 ---------------------/</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志的文件后缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILE_DATE_FORMAT = <span class="string">"yyyyMMdd"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间格式化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_DATE_FORMAT = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOG_MAX_BUFFER = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志输出频率，单位：毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> LOG_OUTPUT_INTERVAL = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志队列</span></span><br><span class="line"><span class="comment">     * key: 自定的 accesslog 的值，如： accesslog="accesslog.log"</span></span><br><span class="line"><span class="comment">     * value: 日志集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Set&lt;String&gt;&gt; logQueue = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Set&lt;String&gt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时任务线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService logScheduled = Executors.newScheduledThreadPool(<span class="number">2</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"Dubbo-Access-Log"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录日志任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ScheduledFuture&lt;?&gt; logFuture = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="invoke-方法"><a href="#invoke-方法" class="headerlink" title="invoke 方法"></a>invoke 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">+--- AccessLogFilter</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 记录访问日志的文件名</span></span><br><span class="line">            String accesslog = invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);</span><br><span class="line">            <span class="keyword">if</span> (ConfigUtils.isNotEmpty(accesslog)) &#123;</span><br><span class="line">                <span class="comment">// dubbo 上下文</span></span><br><span class="line">                RpcContext context = RpcContext.getContext();</span><br><span class="line">                <span class="comment">// 服务名</span></span><br><span class="line">                String serviceName = invoker.getInterface().getName();</span><br><span class="line">                <span class="comment">// 版本号</span></span><br><span class="line">                String version = invoker.getUrl().getParameter(Constants.VERSION_KEY);</span><br><span class="line">                <span class="comment">// 分组</span></span><br><span class="line">                String group = invoker.getUrl().getParameter(Constants.GROUP_KEY);</span><br><span class="line">                <span class="comment">// 拼接日志内容</span></span><br><span class="line">                StringBuilder sn = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                sn.append(<span class="string">"["</span>)</span><br><span class="line">                        <span class="comment">// 时间</span></span><br><span class="line">                        .append(<span class="keyword">new</span> SimpleDateFormat(MESSAGE_DATE_FORMAT).format(<span class="keyword">new</span> Date()))</span><br><span class="line">                        <span class="comment">// 调用方地址</span></span><br><span class="line">                        .append(<span class="string">"] "</span>).append(context.getRemoteHost()).append(<span class="string">":"</span>).append(context.getRemotePort())</span><br><span class="line">                        <span class="comment">// 本地地址</span></span><br><span class="line">                        .append(<span class="string">" -&gt; "</span>).append(context.getLocalHost()).append(<span class="string">":"</span>).append(context.getLocalPort())</span><br><span class="line">                        .append(<span class="string">" - "</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 分组</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != group &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    sn.append(group).append(<span class="string">"/"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 服务名</span></span><br><span class="line">                sn.append(serviceName);</span><br><span class="line">                <span class="comment">// 版本</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != version &amp;&amp; version.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    sn.append(<span class="string">":"</span>).append(version);</span><br><span class="line">                &#125;</span><br><span class="line">                sn.append(<span class="string">" "</span>);</span><br><span class="line">                <span class="comment">// 方法名</span></span><br><span class="line">                sn.append(inv.getMethodName());</span><br><span class="line">                sn.append(<span class="string">"("</span>);</span><br><span class="line">                <span class="comment">// 参数类型</span></span><br><span class="line">                Class&lt;?&gt;[] types = inv.getParameterTypes();</span><br><span class="line">                <span class="keyword">if</span> (types != <span class="keyword">null</span> &amp;&amp; types.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Class&lt;?&gt; type : types) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                            first = <span class="keyword">false</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            sn.append(<span class="string">","</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        sn.append(type.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sn.append(<span class="string">") "</span>);</span><br><span class="line">                <span class="comment">// 参数值</span></span><br><span class="line">                Object[] args = inv.getArguments();</span><br><span class="line">                <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    sn.append(JSON.toJSONString(args));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 日志信息字符串</span></span><br><span class="line">                String msg = sn.toString();</span><br><span class="line">                <span class="comment">// 设置 accesslog = true 或 accesslog=default，将日志输出到日志组件Logger，如 logback中</span></span><br><span class="line">                <span class="keyword">if</span> (ConfigUtils.isDefault(accesslog)) &#123;</span><br><span class="line">                    <span class="comment">// 写日志</span></span><br><span class="line">                    LoggerFactory.getLogger(ACCESS_LOG_KEY + <span class="string">"."</span> + invoker.getInterface().getName()).info(msg);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 异步输出到指定文件</span></span><br><span class="line">                    log(accesslog, msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception in AcessLogFilter of service("</span> + invoker + <span class="string">" -&gt; "</span> + inv + <span class="string">")"</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h2><p>仅用于设置日志写入到文件的情况下。</p><h3 id="写日志"><a href="#写日志" class="headerlink" title="写日志"></a>写日志</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--- AccessLogFilter</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加日志内容到日志队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accesslog  日志路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> logmessage 日志内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String accesslog, String logmessage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化任务</span></span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得日志队列</span></span><br><span class="line">        Set&lt;String&gt; logSet = logQueue.get(accesslog);</span><br><span class="line">        <span class="keyword">if</span> (logSet == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logQueue.putIfAbsent(accesslog, <span class="keyword">new</span> ConcurrentHashSet&lt;String&gt;());</span><br><span class="line">            logSet = logQueue.get(accesslog);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若未超过队列大小，添加到队列中</span></span><br><span class="line">        <span class="keyword">if</span> (logSet.size() &lt; LOG_MAX_BUFFER) &#123;</span><br><span class="line">            logSet.add(logmessage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="初始化任务"><a href="#初始化任务" class="headerlink" title="初始化任务"></a>初始化任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--- AccessLogFilter</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 双重检锁机制，防止重复初始化</span></span><br><span class="line">        <span class="keyword">if</span> (logFuture == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (logScheduled) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logFuture == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    logFuture = logScheduled.scheduleWithFixedDelay(<span class="keyword">new</span> LogTask(), LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="日志任务"><a href="#日志任务" class="headerlink" title="日志任务"></a>日志任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">+--- AccessLogFilter</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LogTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (logQueue != <span class="keyword">null</span> &amp;&amp; logQueue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 遍历日志队列</span></span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : logQueue.entrySet()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 获得日志文件路径</span></span><br><span class="line">                            String accesslog = entry.getKey();</span><br><span class="line">                            <span class="comment">// 获得日志集合</span></span><br><span class="line">                            Set&lt;String&gt; logSet = entry.getValue();</span><br><span class="line">                            <span class="comment">// 创建日志文件</span></span><br><span class="line">                            File file = <span class="keyword">new</span> File(accesslog);</span><br><span class="line">                            File dir = file.getParentFile();</span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">null</span> != dir &amp;&amp; !dir.exists()) &#123;</span><br><span class="line">                                dir.mkdirs();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                                logger.debug(<span class="string">"Append log to "</span> + accesslog);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 归档历史日志文件，例如：  xxx.20191217</span></span><br><span class="line">                            <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">                                String now = <span class="keyword">new</span> SimpleDateFormat(FILE_DATE_FORMAT).format(<span class="keyword">new</span> Date());</span><br><span class="line">                                String last = <span class="keyword">new</span> SimpleDateFormat(FILE_DATE_FORMAT).format(<span class="keyword">new</span> Date(file.lastModified()));</span><br><span class="line">                                <span class="keyword">if</span> (!now.equals(last)) &#123;</span><br><span class="line">                                    File archive = <span class="keyword">new</span> File(file.getAbsolutePath() + <span class="string">"."</span> + last);</span><br><span class="line">                                    file.renameTo(archive);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 输出日志到指定文件</span></span><br><span class="line">                            FileWriter writer = <span class="keyword">new</span> FileWriter(file, <span class="keyword">true</span>);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">for</span> (Iterator&lt;String&gt; iterator = logSet.iterator();</span><br><span class="line">                                     iterator.hasNext();</span><br><span class="line">                                     iterator.remove()) &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 写入一行日志</span></span><br><span class="line">                                    writer.write(iterator.next());</span><br><span class="line">                                    <span class="comment">// 换行</span></span><br><span class="line">                                    writer.write(<span class="string">"\r\n"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 刷盘</span></span><br><span class="line">                                writer.flush();</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                writer.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol><li>AccessLogFilter 中会开启一个定时线程池，该线程池只有在指定了输出的文件时才会用到，该定时线程池会定时将队列中的日志写入文件中。</li><li>如果用户配置了使用应用本身的日志组件，则直接通过封装的 LoggerFactory 打印日志。如果用户配置了日志要输出到自定义的文件中，则会把日志加入到Map缓存中，key 是定义的 accesslog 的值，value 是对应的日志集合。后续等待定时线程不断遍历Map缓存，把日志写入到对应的文件中。</li><li>如果是日志输入到文件的情况，会有两个问题：<ul><li>由于Set集合是无序的，因此日志输出到文件也是无序的 </li><li>由于是异步刷盘，如果服务突然宕机会导致一部分日志丢失</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;AccessLogFilter 是一个日志过滤器，在服务提供端生效，主要用于记录服务每一次的请求日志。虽然 AccessLogFilter 
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Filter" scheme="https://gentryhuang.com/tags/Filter/"/>
    
  </entry>
  
</feed>
