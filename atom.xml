<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gentryhuang‘s blog</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gentryhuang.com/"/>
  <updated>2021-04-06T08:37:27.429Z</updated>
  <id>https://gentryhuang.com/</id>
  
  <author>
    <name>gentryhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis原理 - 链表</title>
    <link href="https://gentryhuang.com/posts/2362a8ea/"/>
    <id>https://gentryhuang.com/posts/2362a8ea/</id>
    <published>2021-03-16T11:33:59.000Z</published>
    <updated>2021-04-06T08:37:27.429Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol><li><p>redis中的链表</p><p>链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置这中数据结构，所以redis构建了自己的链表实现。</p></li><li><p>redis链表节点的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">  <span class="comment">// 前置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="comment">// 后置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">// 节点的值 (可用于保存各种不同类型的值)</span></span><br><span class="line">  <span class="keyword">void</span> *value</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>redis链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数，用于复制链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数，用于释放链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数，用于对比链表节点所保存的值和其他值是否相等</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>redis链表的特点</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)</span><br><span class="line">- 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点</span><br><span class="line">- 带表头和表尾指针：使用list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)</span><br><span class="line">- 带链表长度计数器：程序使用list结构的len属性标记链表中节点的个数，程序获取链表中节点个数的复杂度为O(1)</span><br><span class="line">- 多态：链表可以保存各种不同类型的值</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>链表在redis中的应用</p><p>链表被广泛用于实现redis的各种功能，如：列表键、发布与订阅、慢查询、监视器，redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;redis中的链表&lt;/p&gt;
&lt;p&gt;链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis数据结构" scheme="https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - 简单动态字符串</title>
    <link href="https://gentryhuang.com/posts/aa1d8127/"/>
    <id>https://gentryhuang.com/posts/aa1d8127/</id>
    <published>2021-03-13T11:00:50.000Z</published>
    <updated>2021-04-06T08:37:12.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h3><ol><li><p>初识动态字符串</p><p>redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS作为redis的默认字符串表示。 <code>在redis中，c字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如日志。当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，redis就会使用SDS来表示字符串值。</code> 值的注意的是，对于redis中的key都是使用SDS来实现的。此外，SDS除了用来保存Redis数据库中的字符串值之外，SDS还被用作缓冲区（buffer）: AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区。</p></li><li><p>sds的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">  <span class="comment">// 记录buf数组中已使用字节的数量等价于sds所保存字符串的长度</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">  <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">  <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>sds遵循c字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在sds的len属性中，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由sds函数自动完成的。遵循空字符结尾的好处是，sds可以直接使用一部分C字符串函数库里面的函数。</p></li><li><p>sds与c字符串的区别</p><p>c语言使用的简单字符串表示方式，并不能满足redis对字符串在安全性、效率以及功能方面的要求。</p><p>3.1  常数复杂度获取字符串长度</p><blockquote><p>因为c字符串并不记录自身的长度信息，所以要获取长度就必须遍历整个字符串，故获取字符串长度的复杂度为O(N)。而redis的sds结构中通过len属性记录了sds的长度，故获取字符串长度的复杂度为O(1)。注意，设置和更新sds长度的工作是由sds的API在执行时自动完成的，使用sds无须进行任何手动修改长度的操作。</p></blockquote><p>3.2 避免缓冲区溢出</p><blockquote><p>c字符串不记录自身长度，很容易造成缓冲区溢出。与c字符串不同，sds的空间分配策略完全杜绝了发生缓冲区溢出的可能性，当sds api需要对sds进行修改时，api会先检查sds的空间是否满足需要，如果不满足的话，api会自动将sds的空间扩展至执行所需的大小，然后才执行实际的修改操作，因此使用sds既不需要手动修改sds的空间大小，也不会出现c字符串中可能出现的缓冲区溢出问题。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line">    <span class="comment">//追加时先进行扩容，后面详细说明</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//拼接字符串</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s:原数组     </span></span><br><span class="line"><span class="comment">//strlen(t) 需拼接的目标数组的长度</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>3.3 内存分配与释放</p><p>因为c字符串的长度和底层数组的长度之间存在着关联性，所以<code>每次增加或者缩短一个c字符串，程序都总要对保存这个c字符串的数字进行一次分配操作</code>，但是内存分配操作涉及到复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，为了避免c字符串的这种缺陷，sds通过未使用空间解除了字符串长度和底层数组长度之间的关联，通过未使用空间，sds实现了空间预分配和惰性空间释放两种优化策略。</p><ul><li><p>空间预分配</p><p>空间预分配用于优化sds的字符串增长操作：当sds的api对一个sds进行修改，并且需要对sds进行空间扩展的时候，程序不仅会为sds分配修改所必须要的空间，还会为sds分配额外的未使用空间。通过空间预分配策略，redis可以减少连续执行字符串增长操作所需的内存重新分配次数，在扩展sds空间之前，sds api 会先检查未使用空间是否足够，如果足够就直接使用未使用空间，而不需要执行内存重新分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis 扩容源码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，</span></span><br><span class="line"><span class="comment"> * buf 至少会有 addlen + 1 长度的空余空间</span></span><br><span class="line"><span class="comment"> * （额外的 1 字节是为 \0 准备的）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *  sds ：扩展成功返回扩展后的 sds</span></span><br><span class="line"><span class="comment"> *        扩展失败返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前的空余空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 最少需要的长度</span></span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class="line">        <span class="comment">// 那么为它分配两倍于所需长度的空间</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足，分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 sds 的空余长度</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 sds</span></span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额外分配未使用空间数量的计算策略：</p><blockquote><ol><li>对sds修改后，sds的长度（即len属性的值）小于1MB，那么程序分配和len属性同样大小的未使用空间，这时sds的len属性的值将和free属性的值相同。例如：修改后sds的len变成10字节，那么程序也会分配10字节的未使用空间，sds的buf数组的实际长度：10 + 10 + 1 = 21字节</li><li>对sds修改后，sds的长度大于等于1MB，那么程序会分配1MB的未使用空间。例如：修改后sds的len变成30MB，那么程序会分配1MB的未使用空间，sds的buf数组的时间长度：30MB + 1MB + 1byte</li></ol></blockquote></li><li><p>惰性空间释放</p><p>惰性空间释放用于优化sds的字符串缩短操作：当sds的api需要缩短sds保存的字符串时，程序并不立即使用内存重分配来回收缩短后多来的字节，而是使用free属性将这些字节的数量纪录起来，用于将来对sds进行增长操作时，这些未使用空间可能就派上用场了。注意，sds也提供了相应的api，可以真正地释放sds的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</p></li></ul><p>3.4 二进制安全</p><blockquote><p>c字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里不能包含空字符，否则在读取的时候会被默认为结束字符，这些限制使得c字符串只能保存文本数据，不能保存图片、音视频、压缩文件这类的二进制数据。sds的api都是二进制安全的，所有的sds api都会以<code>二进制的方式处理sds存放在buf数组里的数据</code>,程序不会对其中的数据做任何限制、过滤，数据写入时是什么样，它被读取时就是什么样。<code>这也是将sds的buf属性称为字节数组的原因，redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据</code>。</p></blockquote></li><li><p>c字符串和sds之间的区别</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         C字符串                                    SDS</span><br><span class="line">- 获取字符串长度的复杂度为O（n）                 获取字符串长度的复杂度O（1）</span><br><span class="line">- API是不安全的，可能造成缓冲区溢出                      API是安全的</span><br><span class="line">- 修改字符串长度N次，必然要执行N次内存重分配     修改字符长度N次，最多执行N次内存重分配</span><br><span class="line">- 只能保存文本数据                                 可以保存文本或者二进制数据</span><br><span class="line">- 可使用&lt;string.h&gt;库中的函数                   可使用一部分&lt;string.h&gt;库中的函数</span><br></pre></td></tr></table></figure></li><li><p>sds更多的api可参考源码</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简单动态字符串&quot;&gt;&lt;a href=&quot;#简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;简单动态字符串&quot;&gt;&lt;/a&gt;简单动态字符串&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初识动态字符串&lt;/p&gt;
&lt;p&gt;redis没有直接使用C语言传统的字符串表示（以空字
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis数据结构" scheme="https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 异步改造</title>
    <link href="https://gentryhuang.com/posts/c812f120/"/>
    <id>https://gentryhuang.com/posts/c812f120/</id>
    <published>2021-02-13T16:00:00.000Z</published>
    <updated>2021-04-06T08:30:21.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从 2.7.0 版本开始，Dubbo 的所有异步编程接口开始以 <code>CompletableFuture</code> 为基础，不仅支持了服务提供方的异步执行，而且对当前的异步调用功能进行了增强。异步改造引入了一些功能接口和实现，以及对部分逻辑进行了调整，但底层逻辑并没有改变，本篇文章将对 Dubbo 的异步演进进行介绍。</p><h1 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h1><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-invoke-model.jpg" alt></p><p><strong>Dubbo 的远程调用中大致可以分为以上 4 种调用方式：</strong></p><ul><li><strong>oneway:</strong> 客户端发送消息后，不需要接收响应。对于不需要关心服务响应结果的请求适合 oneway 通信。</li><li><strong>sync:</strong> Dubbo 默认的通信方式，即同步调用。</li><li><strong>async:</strong> 异步调用范畴，使用 Future 的方式获取结果。</li><li><strong>future:</strong> 异步调用范畴，使用 CompletableFuture 获取结果，也支持通过 Future 的方式获取结果。</li></ul><p><strong>注意：</strong> Dubbo 中的调用方式可以分为两大类，oneway 和 twoway ，对于 Dubbo 协议来说，会对这两种方式做分别处理，对于非 Dubbo 协议不会特别区分。</p><h1 id="Dubbo-2-6-x-异步实现"><a href="#Dubbo-2-6-x-异步实现" class="headerlink" title="Dubbo 2.6.x 异步实现"></a>Dubbo 2.6.x 异步实现</h1><p>Dubbo 2.6.x 的异步实现是针对消费端异步，只需指定调用方式为异步调用，并在需要结果的地方从 <strong>RpcContext</strong> 中取出 <strong>Future</strong> 获取结果即可。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>指定异步调用<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置 async = true，表示异步调用。默认是 false，同步调用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">async</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li>通过上下文取出 Future<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String hello = demoService.sayHello(<span class="string">"world"</span>); <span class="comment">// call remote method</span></span><br><span class="line">Future&lt;String&gt; future = RpcContext.getContext().getFuture();</span><br><span class="line">String result = future.get();</span><br></pre></td></tr></table></figure></li></ol><p>具体调用实现可以参考 <a href="https://gentryhuang.com/posts/26722deb/#%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8">Dubbo异步调用</a> 。</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>Dubbo 2.6.x 提供了一定的异步编程能力，但其异步方式存在以下问题：</p><ul><li>Future 获取方式不够直接，业务方需要从 RpcContext 中获取。如果同时进行多个异步调用，如果使用不当很容易造成上下文污染。</li><li>Future 接口无法实现自动回调，而且定义的 ResponseFure (2.7 已经废弃)虽然支持回调，但支持的异步场景有限，并且不支持 Future 间的相互协调。</li><li>不支持服务端异步。</li></ul><h1 id="Dubbo-2-7-x-异步实现"><a href="#Dubbo-2-7-x-异步实现" class="headerlink" title="Dubbo 2.7.x 异步实现"></a>Dubbo 2.7.x 异步实现</h1><p>Dubbo 2.7.x 异步改造是对 Dubbo 2.6.x 异步功能的增强，引入的 <code>CompletableFuture</code> 既支持 <code>Future</code> 又支持 <code>Callback</code> 的调用方式，使用方可以根据需要自行选择。</p><h2 id="基础模型"><a href="#基础模型" class="headerlink" title="基础模型"></a>基础模型</h2><p>Dubbo 2.7.x 对异步实现进行了改造，引入了相关的接口和实现类，异步实现需要这些相关的基础模型配合完成。下面我们先对基础模型进行介绍。</p><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Result 相关的继承关系如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-invoke-transform-result-uml.jpg" alt></p><p>在 Dubbo 2.6.x 中统一使用 <code>RpcResult</code> 表示调用结果，Dubbo 2.7.x 中废弃了 <code>RpcResult</code> ，采用以下三个对象表示结果状态。</p><ul><li>AsyncRpcResult<blockquote><p>表示的是一个异步的、未完成的RPC调用，是在调用链中实际传递的对象。</p></blockquote></li><li>AppResponse<blockquote><p>表示的是服务端返回的具体响应，相当于 Dubbo 2.6.x 中的 RpcResult 。其子类是 DecodeableRpcResult。</p></blockquote></li><li>CompletableFuture<blockquote><p>表示的是服务端返回的结果，由调用端创建，用于封装 AppResponse 对象。其中 DefaultFuture 继承该类。</p></blockquote></li></ul><p>三者关系：AppResponse -&gt; CompletableFuture -&gt; AsyncResult ，下面我们对其进行介绍。</p><h4 id="AppResponse"><a href="#AppResponse" class="headerlink" title="AppResponse"></a>AppResponse</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppResponse</span> <span class="keyword">implements</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6925924956850004727L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应结果</span></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的异常信息</span></span><br><span class="line">    <span class="keyword">private</span> Throwable exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的附加信息</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; attachments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppResponse</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppResponse</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exception = exception;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">recreate</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 1 异常处理</span></span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// fix issue#619</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// get Throwable class</span></span><br><span class="line">                Class clazz = exception.getClass();</span><br><span class="line">                <span class="keyword">while</span> (!clazz.getName().equals(Throwable<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">                    clazz = clazz.getSuperclass();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// get stackTrace value</span></span><br><span class="line">                Field stackTraceField = clazz.getDeclaredField(<span class="string">"stackTrace"</span>);</span><br><span class="line">                stackTraceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                Object stackTrace = stackTraceField.get(exception);</span><br><span class="line">                <span class="keyword">if</span> (stackTrace == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    exception.setStackTrace(<span class="keyword">new</span> StackTraceElement[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它方法 getter/setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AppResponse</code> 是调用的实际返回类型，相当于 Dubbo 2.6.x 中的 <code>RpcResult</code> ，理论上不需要实现 <code>Result</code> 接口，这样做是为了兼容。 </p><h4 id="DecodeableRpcResult"><a href="#DecodeableRpcResult" class="headerlink" title="DecodeableRpcResult"></a>DecodeableRpcResult</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeableRpcResult</span> <span class="keyword">extends</span> <span class="title">AppResponse</span> <span class="keyword">implements</span> <span class="title">Codec</span>, <span class="title">Decodeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(DecodeableRpcResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 通道</span></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">// 序列化类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> serializationType;</span><br><span class="line">    <span class="comment">// 序列化相关的输入流</span></span><br><span class="line">    <span class="keyword">private</span> InputStream inputStream;</span><br><span class="line">    <span class="comment">// 响应对象</span></span><br><span class="line">    <span class="keyword">private</span> Response response;</span><br><span class="line">    <span class="comment">// 调用信息</span></span><br><span class="line">    <span class="keyword">private</span> Invocation invocation;</span><br><span class="line">    <span class="comment">// 标志是否已经解码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasDecoded;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecodeableRpcResult</span><span class="params">(Channel channel, Response response, InputStream is, Invocation invocation, <span class="keyword">byte</span> id)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(channel, <span class="string">"channel == null"</span>);</span><br><span class="line">        Assert.notNull(response, <span class="string">"response == null"</span>);</span><br><span class="line">        Assert.notNull(is, <span class="string">"inputStream == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.response = response;</span><br><span class="line">        <span class="keyword">this</span>.inputStream = is;</span><br><span class="line">        <span class="keyword">this</span>.invocation = invocation;</span><br><span class="line">        <span class="keyword">this</span>.serializationType = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">+--- DecodeableRpcResult</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 没有解码，则进行解码</span></span><br><span class="line">        <span class="keyword">if</span> (!hasDecoded &amp;&amp; channel != <span class="keyword">null</span> &amp;&amp; inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 解码</span></span><br><span class="line">                decode(channel, inputStream);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Decode rpc result failed: "</span> + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                response.setStatus(Response.CLIENT_ERROR);</span><br><span class="line">                response.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                hasDecoded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">---</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            Thread thread = Thread.currentThread();</span><br><span class="line">            log.debug(<span class="string">"Decoding in thread -- ["</span> + thread.getName() + <span class="string">"#"</span> + thread.getId() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 确定序列化方式，用于反序列化</span></span><br><span class="line">        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">                .deserialize(channel.getUrl(), input);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 读取一个 byte 的标志位，其值可能有 6 种</span></span><br><span class="line">        <span class="keyword">byte</span> flag = in.readByte();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 根据标志位判断当前结果中包含的信息，并调用不同的方法进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE:</span><br><span class="line">                handleValue(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION:</span><br><span class="line">                handleException(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">                handleAttachment(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">                <span class="comment">// 根据 RpcInvocation 中记录的返回值类型读取返回结果，并设置到当前类的 result 字段</span></span><br><span class="line">                handleValue(in);</span><br><span class="line">                <span class="comment">// 读取附加信息并设置到当前类的 attachmetns 中</span></span><br><span class="line">                handleAttachment(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:</span><br><span class="line">                handleException(in);</span><br><span class="line">                handleAttachment(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unknown result flag, expect '0' '1' '2' '3' '4' '5', but received: "</span> + flag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) in).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">---</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleValue</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 返回结果类型</span></span><br><span class="line">            Type[] returnTypes;</span><br><span class="line">            <span class="keyword">if</span> (invocation <span class="keyword">instanceof</span> RpcInvocation) &#123;</span><br><span class="line">                returnTypes = ((RpcInvocation) invocation).getReturnTypes();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                returnTypes = RpcUtils.getReturnTypes(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2 根据返回结果类型获取结果</span></span><br><span class="line">            Object value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (ArrayUtils.isEmpty(returnTypes)) &#123;</span><br><span class="line">                <span class="comment">// This almost never happens?</span></span><br><span class="line">                value = in.readObject();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                value = in.readObject((Class&lt;?&gt;) returnTypes[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = in.readObject((Class&lt;?&gt;) returnTypes[<span class="number">0</span>], returnTypes[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3 设置结果 result</span></span><br><span class="line">            setValue(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            rethrow(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DecodeableRpcResult</code> 主要对响应结果进行解码，从字节流中获取数据对象。</p><h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p><code>CompletableFuture</code> 是 Java 8 提供的异步编程类，Dubbo 2.7.x 中的 <code>DefaultFuture</code> 继承了 CompletableFuture ，Dubbo 协议下对于 twoway 请求都会返回一个 <code>DefaultFuutre</code> 对象。此外，<code>DefaultFuture</code> 支持在请求的时候指定线程池，用来处理请求的响应，具体的我们会在下一篇文章中分析。</p><h4 id="AsyncRpcResult"><a href="#AsyncRpcResult" class="headerlink" title="AsyncRpcResult"></a>AsyncRpcResult</h4><p><code>AsyncRpcResult</code> 是在调用链中实际传递的对象，表示一个异步的，未完成的RPC调用。注意，它并不是实际的调用结果，<code>AppResponse</code> 才是业务结果。</p><h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncRpcResult</span> <span class="keyword">implements</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AsyncRpcResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当回调发生时，RpcContext 可能已经被更改。即执行 AsyncRpcResult 上添加的回调方法的线程可能先后处理过多个不同的 AsyncRpcResult 。</span></span><br><span class="line">    <span class="comment">// 因此，我们应该保留当前RpcContext实例的引用，并在回调执行之前恢复它。</span></span><br><span class="line">    <span class="keyword">private</span> RpcContext storedContext;</span><br><span class="line">    <span class="keyword">private</span> RpcContext storedServerContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此次 RPC 调用关联的线程池</span></span><br><span class="line">    <span class="keyword">private</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此次 RPC 调用关联的 Invocation 对象</span></span><br><span class="line">    <span class="keyword">private</span> Invocation invocation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求返回的对象 （由调用端创建）</span></span><br><span class="line">    <span class="keyword">private</span> CompletableFuture&lt;AppResponse&gt; responseFuture;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在构造方法中除了接收发送请求返回的 CompletableFuture&lt;AppResponse&gt; 对象，还会保存当前的 RPC 上下文</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncRpcResult</span><span class="params">(CompletableFuture&lt;AppResponse&gt; future, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.responseFuture = future;</span><br><span class="line">        <span class="keyword">this</span>.invocation = invocation;</span><br><span class="line">        <span class="keyword">this</span>.storedContext = RpcContext.getContext();</span><br><span class="line">        <span class="keyword">this</span>.storedServerContext = RpcContext.getServerContext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，<code>responseFuture</code> 属性不仅针对 Dubbo 协议，HTTP等协议调用返回结果也是 <code>CompletableFuture</code> 对象，都是由调用端创建。区别在于 Dubbo 协议一般返回的是 <code>DefaultFuture</code> 对象，而 HTTP 等协议会构造一个 <code>CompletableFuture</code> 对象，我们会在下面内容提到。</p><h5 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h5><p><code>AsyncRpcResult</code> 获取结果本质上需要先获取发送请求返回的 <code>CompletableFuture</code> ，也就是 <strong>responseFuture</strong> 属性，然后再从 <strong>responseFuture</strong> 中获取 <code>AppResponse</code> 对象，最后调用其对应的方法。</p><h6 id="获取-CompletableFuture"><a href="#获取-CompletableFuture" class="headerlink" title="获取 CompletableFuture"></a>获取 CompletableFuture</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">   <span class="function"><span class="keyword">public</span> CompletableFuture&lt;AppResponse&gt; <span class="title">getResponseFuture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="获取-AppResponse"><a href="#获取-AppResponse" class="headerlink" title="获取 AppResponse"></a>获取 AppResponse</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">getAppResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果完成，则获取 AppResponse</span></span><br><span class="line">            <span class="keyword">if</span> (responseFuture.isDone()) &#123;</span><br><span class="line">                <span class="keyword">return</span> responseFuture.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// This should not happen in normal request process;</span></span><br><span class="line">            logger.error(<span class="string">"Got exception when trying to fetch the underlying result from AsyncRpcResult."</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取默认的 AppResponse</span></span><br><span class="line">        <span class="keyword">return</span> createDefaultValue(invocation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法将始终在最大 timeout 等待之后返回：</span></span><br><span class="line"><span class="comment">     * 1. 如果value在超时前返回，则正常返回。</span></span><br><span class="line"><span class="comment">     * 2. 如果timeout之后没有返回值，则抛出TimeoutException。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">       <span class="comment">// 针对 ThreadlessExecutor 的特殊处理，这里调用 waitAndDrain() 等待响应</span></span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">            threadlessExecutor.waitAndDrain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseFuture.get(timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">            threadlessExecutor.waitAndDrain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseFuture.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中 <code>ThreadlessExecutor</code> 是一个特殊的线程池，主要用来解决同步调用模式下的响应，是对线程模型的优化，我们在下一篇文章中进行详细说明。</p><h6 id="获取结果-1"><a href="#获取结果-1" class="headerlink" title="获取结果"></a>获取结果</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">recreate</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation rpcInvocation = (RpcInvocation) invocation;</span><br><span class="line">        <span class="comment">//  1 如果是服务端的异步实现，则从上下文中取。</span></span><br><span class="line">        <span class="comment">// 为什么？ 因为接口返回的结果是 CompletableFuture,属于异步范畴（服务端的异步），和消费端异步类似。</span></span><br><span class="line">        <span class="keyword">if</span> (InvokeMode.FUTURE == rpcInvocation.getInvokeMode()) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcContext.getContext().getFuture();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 获取 AppResponse 中的结果</span></span><br><span class="line">        <span class="keyword">return</span> getAppResponse().recreate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AsyncRpcResult.recreate()</code> 方法是获取结果的方法，也就是从 <code>AppResponse</code> 中获取结果。</p><h6 id="添加回调"><a href="#添加回调" class="headerlink" title="添加回调"></a>添加回调</h6><p>回调是 Dubbo 2.7.x 异步改造的重要角色，<code>AsyncRpcResult</code> 支持添加回调方法，而这个回调方法会被包装一层并注册到 <strong>responseFuture</strong> 上，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">whenCompleteWithContext</span><span class="params">(BiConsumer&lt;Result, Throwable&gt; fn)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在responseFuture之上注册回调</span></span><br><span class="line">        <span class="keyword">this</span>.responseFuture = <span class="keyword">this</span>.responseFuture.whenComplete((v, t) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 将当前线程的 RpcContext 记录到临时属性中，然后将构造函数中存储的 RpcContext 设置到当前线程中，为后面的回调执行做准备</span></span><br><span class="line">            beforeContext.accept(v, t);</span><br><span class="line">            <span class="comment">// 执行回调 （使用的 RpcContext 是回调所属服务方法的调用线程的 RpcContext）</span></span><br><span class="line">            fn.accept(v, t);</span><br><span class="line">            <span class="comment">// 恢复线程原有的 RpcContext</span></span><br><span class="line">            afterContext.accept(v, t);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在添加回调时，需要使用 <strong>beforeContext</strong> 和 <strong>afterContext</strong> 来保证执行回调的线程的 RpcContext 是最初创建 <code>AsyncRpcResult</code> 对象的线程对应的 RpcContext，执行完回调后需要将执行回调的线程的 RpcContext 恢复到原有值。其中 <strong>beforeContext</strong> 用于保存执行回调线程的 RpcContext，并将最初创建 <code>AsyncRpcResult</code> 对象的线程的 RpcContext 临时设置到执行回调用线程中，为执行回调做准备。<strong>afterContext</strong> 用于恢复执行回调用的线程原有的 RpcContext 。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="keyword">private</span> RpcContext tmpContext;</span><br><span class="line">    <span class="keyword">private</span> RpcContext tmpServerContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BiConsumer&lt;Result, Throwable&gt; beforeContext = (appResponse, t) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 将当前线程的 RpcContext 记录到 tmpContext 中</span></span><br><span class="line">        tmpContext = RpcContext.getContext();</span><br><span class="line">        tmpServerContext = RpcContext.getServerContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将构造函数中存储的 RpcContext (也就是创建 AsyncRpcResult 线程的 RpcContext) 设置到当前线程中</span></span><br><span class="line">        RpcContext.restoreContext(storedContext);</span><br><span class="line">        RpcContext.restoreServerContext(storedServerContext);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BiConsumer&lt;Result, Throwable&gt; afterContext = (appResponse, t) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 将当前线程的 RpcContext 恢复到原始值</span></span><br><span class="line">        RpcContext.restoreContext(tmpContext);</span><br><span class="line">        RpcContext.restoreServerContext(tmpServerContext);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>如此一来，<code>AsyncRpcResult</code> 就可以随意添加回调，无需担心 RpcContext 被污染。</p><p><code>AsyncRpcResult</code> 整个是为异步请求设计的，但是 Dubbo 中默认的请求方式是同步的，那么 Dubbo 又是如何支持同步调用的呢？Dubbo 进行服务引用时，在 <code>AbstractProtocol.refer()</code> 方法中，Dubbo 会将 <code>AbstractProtocol.protocolBindingRefer()</code> 方法实现返回的 Invoker 对象使用 <code>AsyncToSyncInvoker</code> 封装一层，该对象中的调用逻辑会对同步调用专门处理，我们在下面的内容中进行介绍。相比较而言，Dubbo 2.6.x 在 Dubbo 协议做了异步转同步处理，就是在调用时拿到 <code>DefaultFuture</code> 后立即阻塞等待结果。HTTP 协议就没有异步调用支持，而 Dubbo 2.7.x 使用了 <code>AbstractInvoker</code> 对 <strong>Future</strong> 功能进行统一支持，也就是 HTTP 协议也基本上支持了调用异步。</p><h3 id="Invoker"><a href="#Invoker" class="headerlink" title="Invoker"></a>Invoker</h3><h4 id="AsyncToSyncInvoker"><a href="#AsyncToSyncInvoker" class="headerlink" title="AsyncToSyncInvoker"></a>AsyncToSyncInvoker</h4><p><code>AsyncToSyncInvoker</code> 描述了异步转同步的逻辑，是对 <code>AsyncRpcResult</code> 获取结果的补充，触发时机是在执行调用的时候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncToSyncInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 服务引用的 Invoker</span></span><br><span class="line">    <span class="keyword">private</span> Invoker&lt;T&gt; invoker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncToSyncInvoker</span><span class="params">(Invoker&lt;T&gt; invoker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.invoker = invoker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> invoker.getInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        Result asyncResult = invoker.invoke(invocation);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是同步调用，则调用 get() 方法，阻塞等待响应返回。</span></span><br><span class="line">            <span class="comment">// 调用的是 AsyncRpcResult.get 方法，其底层调用的是 CompletableFuture 的 get 方法</span></span><br><span class="line">            <span class="keyword">if</span> (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * NOTICE!</span></span><br><span class="line"><span class="comment">                 * must call &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get(long, TimeUnit)&#125; because</span></span><br><span class="line"><span class="comment">                 * &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get()&#125; 被证明有严重的性能下降。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Interrupted unexpectedly while waiting for remote result to return!  method: "</span> +</span><br><span class="line">                    invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> TimeoutException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> +</span><br><span class="line">                        invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RemotingException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> +</span><br><span class="line">                        invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.UNKNOWN_EXCEPTION, <span class="string">"Fail to invoke remote method: "</span> +</span><br><span class="line">                        invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非同步调用直接返回调用结果 AsyncRpcResult</span></span><br><span class="line">        <span class="keyword">return</span> asyncResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AsyncToSyncInvoker</code> 是 Invoker 的装饰器，负责将异步调用转换成同步调用，也就是调用 <code>AsyncRpcResult</code> 中的 <code>CompletableFuture.get</code> 方法实现同步等待。相比 Dubbo 2.6.x 还是有很大区别的，Dubbo 2.6.x 使用 <strong>Future.get</strong> 功能阻塞等待，业务线程将处于阻塞等待状态，返回结果时需要消费端 Dubbo 线程池将结果写到 DefaultFuture 中，业务线程才能取出并返回。Dubbo 2.7.x 彻底优化了这种线程模型，关于优化的背景和实现会在下一篇文章中进行介绍，这里先了解即可。</p><h4 id="AbstractProxyInvoker"><a href="#AbstractProxyInvoker" class="headerlink" title="AbstractProxyInvoker"></a>AbstractProxyInvoker</h4><p><code>AbstractProxyInvoker</code> 是 Dubbo 框架在服务暴露过程中创建的对象，由 <code>ProxyFactory.getInvoker</code> 创建，是对服务接口实现的封装。该过程对 Dubbo 中所有协议一致。</p><h4 id="AbstractInvoker"><a href="#AbstractInvoker" class="headerlink" title="AbstractInvoker"></a>AbstractInvoker</h4><p>Dubbo 在服务引用时会创建消费端的 <code>Invoker</code>，对于不同的协议创建的 <code>Invoker</code> 有所不同。下面我们对 <strong>Dubbo 协议</strong> 和 <strong>使用 HTTP 通信的协议</strong> 创建 <code>Invoker</code> 流程进行分析。其中每个协议创建的 <code>Invoker</code> 都会继承 <code>AbstractInvoker</code> 抽象类，该抽象类中定义了通用的执行逻辑，如调用模式的确定。</p><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 Invoker 对象封装的业务接口类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="comment">// 当前 Invoker 关联的 URL 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="comment">// 当前 Invoker 关联的一些附加信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attachment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标志 Invoker 的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> available = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractInvoker</span><span class="params">(Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(type, url, (Map&lt;String, Object&gt;) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractInvoker</span><span class="params">(Class&lt;T&gt; type, URL url, String[] keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(type, url, convertAttachment(url, keys));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractInvoker</span><span class="params">(Class&lt;T&gt; type, URL url, Map&lt;String, Object&gt; attachment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"service type == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"service url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.attachment = attachment == <span class="keyword">null</span> ? <span class="keyword">null</span> : Collections.unmodifiableMap(attachment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="invoke-方法"><a href="#invoke-方法" class="headerlink" title="invoke 方法"></a>invoke 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// if invoker is destroyed due to address refresh from registry, let's allow the current invoke to proceed</span></span><br><span class="line">        <span class="keyword">if</span> (destroyed.get()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Invoker for service "</span> + <span class="keyword">this</span> + <span class="string">" on consumer "</span> + NetUtils.getLocalHost() + <span class="string">" is destroyed, "</span></span><br><span class="line">                    + <span class="string">", dubbo version is "</span> + Version.getVersion() + <span class="string">", this invoker should not be used any longer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcInvocation invocation = (RpcInvocation) inv;</span><br><span class="line">        invocation.setInvoker(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(attachment)) &#123;</span><br><span class="line">            invocation.addObjectAttachmentsIfAbsent(attachment);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 从上下文中取出 附加信息</span></span><br><span class="line">        Map&lt;String, Object&gt; contextAttachments = RpcContext.getContext().getObjectAttachments();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(contextAttachments)) &#123;</span><br><span class="line">            invocation.addObjectAttachments(contextAttachments);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 设置调用模式  SYNC, ASYNC, FUTURE 。注意，oneway 调用方式</span></span><br><span class="line">        <span class="comment">// 根据以下方式确定调用模式：</span></span><br><span class="line">        <span class="comment">// 1) 根据返回值类型是否是 CompletableFuture ，或方法名是 $invokeAsync，则是 FUTURE 模式。这个属于服务端异步。</span></span><br><span class="line">        <span class="comment">// 2) 根据 async 属性，如果设置 async=true ，则是 ASYNC 模式</span></span><br><span class="line">        <span class="comment">// 3) 默认是 SYNC 模式</span></span><br><span class="line">        invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 如果是异步调用的模式，则给本次调用添加一个唯一id (FUTURE 模式不属于)</span></span><br><span class="line">        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">        AsyncRpcResult asyncResult;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 调用子类实现的 doInvoker() 方法</span></span><br><span class="line">            asyncResult = (AsyncRpcResult) doInvoke(invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对调用异常的处理</span></span><br><span class="line">            <span class="comment">// 4.1 创建 CompletableFuture 对象，使用该对象包装 AppResponse 对象</span></span><br><span class="line">            <span class="comment">// 4.2 使用 AppResponse 对象包装异常信息</span></span><br><span class="line">            <span class="comment">// 4.3 使用 AsyncRpcResult 最后包装 CompletableFuture 对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123; <span class="comment">// biz exception</span></span><br><span class="line">            Throwable te = e.getTargetException();</span><br><span class="line">            <span class="keyword">if</span> (te == <span class="keyword">null</span>) &#123;</span><br><span class="line">                asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (te <span class="keyword">instanceof</span> RpcException) &#123;</span><br><span class="line">                    ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);</span><br><span class="line">                &#125;</span><br><span class="line">                asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, te, invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.isBiz()) &#123;</span><br><span class="line">                asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 使用 FutureContext 保存 FutureAdapter，FutureAdapter 中会封装 AsyncRpcResult 中的 CompletableFuture 对象</span></span><br><span class="line">        RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter(asyncResult.getResponseFuture()));</span><br><span class="line">        <span class="keyword">return</span> asyncResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AbstractInvoker</code> 的 <strong>invoke</strong> 方法是调用服务的模版方法，具体调用细节交给具体子类实现。</p><ol><li>设置附加信息到调用信息 Invocation 中。</li><li>设置调用模式<ul><li><strong>FUTURE:</strong> 根据返回值类型是否是 <code>CompletableFuture</code> ，或方法名是否是 <code>$invokeAsync</code>，则是 FUTURE 模式。这个属于服务端异步。</li><li><strong>ASYNC:</strong> 根据 async 属性，如果设置 async=true ，则是 ASYNC 模式。</li><li><strong>SYNC:</strong> 默认调用模式。</li></ul></li><li>异步调用时，给本地调用添加一个唯一id，并设置到附加属性中。</li><li>调用具体子类 Invoker 对象的 <code>doInvoke</code> 方法，不管是哪个子类实现，调用的结果都是 <code>AsyncRpcResult</code> 类型。</li><li>如果调用异常，则对异常进行处理。</li><li>使用上下文保存 FutureAdapter ，其中 FutureAdapter 中会封装 AsyncRpcResult 中的 CompletableFuture 对象。在后续的链路中可以使用 <strong>Future</strong> 的异步功能。</li></ol><p><strong>注意:</strong></p><blockquote><p>相比 Dubbo 2.6.x，<code>AbstractInvoker</code> 的模版方法中实现了异步逻辑，也就是任何协议的服务调用都支持 <code>Future</code> 的异步功能。在 Dubbo 2.6.x 中非 Dubbo 协议大都不支持异步调用特性。</p></blockquote><h2 id="Dubbo协议异步实现"><a href="#Dubbo协议异步实现" class="headerlink" title="Dubbo协议异步实现"></a>Dubbo协议异步实现</h2><h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><p><code>DubboInvoker</code> 是 Dubbo 协议在消费端创建的 Invoker 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取此次调用的方法名</span></span><br><span class="line">        <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 向 Invocation 中添加附加信息，这里将 URL 的 path 和 version 添加到附加信息中</span></span><br><span class="line">        inv.setAttachment(PATH_KEY, getUrl().getPath());</span><br><span class="line">        inv.setAttachment(VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 选择一个 ExchangeClient 实例</span></span><br><span class="line">        ExchangeClient currentClient;</span><br><span class="line">        <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">            currentClient = clients[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4 判断是否是 oneway 调用，不关心服务端的响应结果。调用后直接返回一个空 AsyncRpcResult</span></span><br><span class="line">            <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            <span class="comment">// 根据调用方法名和配置，计算此次调用的超时时间</span></span><br><span class="line">            <span class="keyword">int</span> timeout = calculateTimeout(invocation, methodName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 request() 方法会相应创建 DefaultFuture 对象以及检测超时的定时任务，而 send() 方法则不会创建这些东西。</span></span><br><span class="line">            <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">                <span class="comment">// 是否等待底层 NIO 将请求发出，等待时间默认 1s，1s未发送则抛出异常</span></span><br><span class="line">                <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">                currentClient.send(inv, isSent);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回已完成状态的 AsynRpcResult 即 AsynRpcResult -&gt; CompletableFuture（已完成状态） -&gt; AppResponse（空结果）</span></span><br><span class="line">                <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(invocation);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 需要关注返回值的请求</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5 获取处理响应的线程池 </span></span><br><span class="line">                ExecutorService executor = getCallbackExecutor(getUrl(), inv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6 调用 ExchangeClient.request() 方法，将 Invocation 包装成 Request 请求发送出去，同时会创建相应的 DefaultFuture 返回。</span></span><br><span class="line">                CompletableFuture&lt;AppResponse&gt; appResponseFuture =</span><br><span class="line">                        <span class="comment">// currentClient.request 返回的是 DefaultFuture，DefaultFuture 继承了 CompletableFuture 。</span></span><br><span class="line">                        currentClient.request(inv, timeout, executor)</span><br><span class="line">                                <span class="comment">// 增加了一个回调，取出其中的 AppResponse 对象。</span></span><br><span class="line">                                <span class="comment">// thenApply 是一个回调,obj 是 上一个任务的结果。返回的 AppResponse 表示的是 服务端返回的具体响应。</span></span><br><span class="line">                                .thenApply(obj -&gt; (AppResponse) obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter</span></span><br><span class="line">                FutureContext.getContext().setCompatibleFuture(appResponseFuture);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7 这里将 CompletableFuture （其实是 DefaultFuture） 封装成 AsyncRpcResult 并返回</span></span><br><span class="line">                AsyncRpcResult result = <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, inv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 8 设置处理响应的线程池</span></span><br><span class="line">                result.setExecutor(executor);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 9 返回调用</span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DubboInvoker</code> 进行远程调用时，会分别对 <strong>oneway</strong> 和 <strong>twoway</strong> 进行处理。</p><ul><li>处理 <strong>oneway</strong> 调用方式<blockquote><p>不需要响应结果，直接使用客户端的 <strong>send</strong> 方法即可，该方法不会返回服务端的响应。<code>DubboInvoker</code> 会返回一个空结果的 <code>AsyncRpcResult</code> 对象给业务方。</p></blockquote></li><li>处理 <strong>twoway</strong> 调用方式<blockquote><p>需要响应结果，使用客户端的 <strong>request</strong> 方法发送请求，该方法会创建并返回本次调用的 DefaultFuture 对象，当服务端响应时会更新 DefaultFuture 中的结果信息。此外，Dubbo 对线程模型进行了优化，可以指定处理响应的线程池，特别是同步调用的线程池，这个我们在下一篇文章中详细介绍。</p></blockquote></li></ul><p>相比较 Dubbo 2.6.x 中的 <code>DefaultFuture</code>，引入了 <code>CompletableFuture</code> 可以支持多异步场景，并且支持 <code>Future</code> 间的相互协调，此外提供了良好的回调方法，避免等待响应而阻塞。这是对 <code>ExchangeClient</code> 的改造，将 Dubbo 2.6.x 中异步编程接口都替换成了 <code>CompletableFuture</code> 。介绍完消费端的异步实现后，下面我们来看看服务端的异步实现。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p><code>AbstractProxyInvoker</code> 是 Dubbo 协议在服务端创建的 Invoker，它封装的是服务接口实现。Dubbo 协议下的服务暴露会使用 <code>ProxyFactory#getInvoker</code> 将服务接口实现封装成 <code>AbstractProxyInvoker</code>。当收到请求时，通道处理器链上的每个处理器都会对该请求进行各自逻辑的处理，其中 <code>HeaderExchangeHandler#handleRequest</code> 会将请求交给 <code>DubboProtocol</code> 中的 <code>ExchangeHandler</code> 处理，Dubbo 协议下的服务端异步实现处理逻辑就在这三者中。在分析源码之前，我们先看服务端异步实现的例子：</p><h4 id="异步实现"><a href="#异步实现" class="headerlink" title="异步实现"></a>异步实现</h4><p>服务提供端异步执行将阻塞的业务从 Dubbo 内部线程池切换到业务自定义线程，在一定程度上避免 Dubbo 线程池的过度占用，有助于避免不同服务间的互相影响。</p><h5 id="定义-CompletableFuture-签名接口"><a href="#定义-CompletableFuture-签名接口" class="headerlink" title="定义 CompletableFuture 签名接口"></a>定义 <code>CompletableFuture</code> 签名接口</h5><ul><li>服务接口定义<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line">    <span class="function">CompletableFuture&lt;String&gt; <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>服务实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncServiceImpl</span> <span class="keyword">implements</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        RpcContext savedContext = RpcContext.getContext();</span><br><span class="line">        <span class="comment">// 建议为supplyAsync提供自定义线程池，避免使用JDK公用线程池</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"async response from provider."</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过 <code>return CompletableFuture.supplyAsync()</code> ，业务执行已从 Dubbo 线程切换到业务线程，避免了对 Dubbo 线程池的阻塞。</p><h5 id="服务消费方"><a href="#服务消费方" class="headerlink" title="服务消费方"></a>服务消费方</h5><p> <code>CompletableFuture</code> 签名接口是服务提供方的异步实现，消费端同普通消费一致，Dubbo 内部会根据调用的方法返回值类型等方式确定 <strong>调用模式</strong>，具体的在后面的源码部分介绍。</p><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p>Dubbo 2.7 虽然支持了服务端的异步，但 Dubbo 的线程模型本身就是异步处理的方式，因此服务端的异步特性相对还是有点鸡肋的。</p><p>了解了服务端异步实现后，下面我们从代码层面分析，Dubbo 如何就 <code>CompletableFuture</code> 签名服务接口方法实现异步的。</p><h4 id="HeaderExchangeHandler-处理请求"><a href="#HeaderExchangeHandler-处理请求" class="headerlink" title="HeaderExchangeHandler 处理请求"></a>HeaderExchangeHandler 处理请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+--- HeaderExchangeHandler</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">        <span class="comment">// 省略异常处理代码</span></span><br><span class="line"></span><br><span class="line">        Object msg = req.getData();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 使用上层通道处理器处理消息，其实就是 DubboProtocol 中的 ExchangeHandler </span></span><br><span class="line">            CompletionStage&lt;Object&gt; future = handler.reply(channel, msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 请求处理完成回调，将结果发送到对端</span></span><br><span class="line">            future.whenComplete((appResult, t) -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        res.setStatus(Response.OK);</span><br><span class="line">                        res.setResult(appResult);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">                        res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3 将处理后的结果发送到对端</span></span><br><span class="line">                    channel.send(res);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Send result to consumer failed, channel is "</span> + channel + <span class="string">", msg is "</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">            res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">            channel.send(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>相比较与 Dubbo 2.6.x 中的处理请求逻辑，这里使用了 <code>CompletableFuture</code> 的完成回调，避免了阻塞等待请求完成。这得益于对通道处理 ExchangeHandler 的异步方法的改造，也就是 DubboProtocol 中的 ExchangeHandler 的实现。</p><h4 id="DubboProtocol-的处理器"><a href="#DubboProtocol-的处理器" class="headerlink" title="DubboProtocol 的处理器"></a>DubboProtocol 的处理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"><span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line"></span><br><span class="line">            Invocation inv = (Invocation) message;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取暴露的 Invoker，这里是 AbstractProxyInvoker</span></span><br><span class="line">            Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">           </span><br><span class="line">            RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果服务端异步实现，这里返回的 result 是一个 AsyncRpcResult 类型对象，其中的 AppResonse 中的值并非 CompletableFuture 类型，而是 CompletableFuture 封装的 AppResponse</span></span><br><span class="line">            Result result = invoker.invoke(inv);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result.thenApply(Function.identity());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DubboProtocol 中的 ExchangeHandler 的请求处理方法返回的是 CompletableFuture 对象，这同样是 Dubbo 2.7.x 中的改造，服务方法的结果统一包装成 <code>CompletableFuture</code> 类型，在服务端的 Invoker 的执行逻辑中就可以体现这一点，下面我们就来看 <code>AbstractProxyInvoker</code> 。</p><h4 id="AbstractProxyInvoker-1"><a href="#AbstractProxyInvoker-1" class="headerlink" title="AbstractProxyInvoker"></a>AbstractProxyInvoker</h4><p>服务端的 Invoker，直接封装服务接口实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractProxyInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 执行服务方法，如 DemoService.sayHello </span></span><br><span class="line">            Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 将方法结果以 CompletableFuture 对象形式进行封装。</span></span><br><span class="line">            <span class="comment">// 注意：如果服务方法返回类型是 CompletableFuture ，则无需再使用 CompletableFuture 包装。这个针对服务端的异步实现。</span></span><br><span class="line">            CompletableFuture&lt;Object&gt; future = wrapWithFuture(value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 执行 future 逻辑</span></span><br><span class="line">            CompletableFuture&lt;AppResponse&gt; appResponseFuture = future.handle((obj, t) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4 使用 AppResponse 封装实际结果</span></span><br><span class="line">                AppResponse result = <span class="keyword">new</span> AppResponse();</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t <span class="keyword">instanceof</span> CompletionException) &#123;</span><br><span class="line">                        result.setException(t.getCause());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.setException(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.setValue(obj);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 统一包装成 AsyncRpcResult 对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (RpcContext.getContext().isAsyncStarted() &amp;&amp; !RpcContext.getContext().stopAsync()) &#123;</span><br><span class="line">                logger.error(<span class="string">"Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e.getTargetException(), invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to invoke remote proxy method "</span> + invocation.getMethodName() + <span class="string">" to "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AbstractProxyInvoker</code> 的执行逻辑主要有四点，下面进行总结：</p><ol><li>执行服务接口实例方法，如 demoService.sayhello 方法。</li><li>将服务实例方法的调用结果包装成 <code>CompletableFuture</code> ，<strong>如果是服务端异步实现（服务接口方法返回类型是 CompletableFuture），则无需对结果进行包装，直接使用返回的 <code>CompletableFuture</code></strong> 即可。</li><li>执行 <code>CompletableFuture</code> 的回调方法，将实际结果封装到 AppResponse 中。</li><li>将返回结果包装成 AsyncRpcResult 对象。</li></ol><h2 id="HTTP-协议实现"><a href="#HTTP-协议实现" class="headerlink" title="HTTP 协议实现"></a>HTTP 协议实现</h2><h3 id="消费端-1"><a href="#消费端-1" class="headerlink" title="消费端"></a>消费端</h3><p>Dubbo 中的 HTTP 协议在消费端创建的 Invoker 是一个 <code>AbstractInvoker</code> 匿名对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">+--- AbstractProxyProtocol</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">protocolBindingRefer</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; type, <span class="keyword">final</span> URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 调用子类实现的 doRefer() 方法返回一个目标服务接口的代理对象</span></span><br><span class="line">        <span class="comment">// 2 使用 ProxyFactory.getInvoker() 方法将服务接口的代理对象封装成一个 Invoker ，类型是 AbstractProxyInvoker。</span></span><br><span class="line">        <span class="keyword">final</span> Invoker&lt;T&gt; target = proxyFactory.getInvoker(doRefer(type, url), type, url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 创建 AbstractInvoker 的匿名对象</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = <span class="keyword">new</span> AbstractInvoker&lt;T&gt;(type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 4 调用 AbstractProxyInvoker.invoke 方法，返回的结果是 AsyncRpcResult</span></span><br><span class="line">                    Result result = target.invoke(invocation);</span><br><span class="line">                    <span class="comment">// FIXME result is an AsyncRpcResult instance.</span></span><br><span class="line">                    Throwable e = result.getException();</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Class&lt;?&gt; rpcException : rpcExceptions) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (rpcException.isAssignableFrom(e.getClass())) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> getRpcException(type, url, invocation, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.getCode() == RpcException.UNKNOWN_EXCEPTION) &#123;</span><br><span class="line">                        e.setCode(getErrorCode(e.getCause()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> getRpcException(type, url, invocation, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        invokers.add(invoker);</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Dubbo 协议下的服务调用不仅引入 CompletableFuture ，还对方法等进行改造，如 <code>HeaderExchangeClient.request</code> 方法。<strong>HTTP 协议下的服务调用异步改造力度相对不大</strong>，异步实现主要依赖引入的 CompletableFuture ，以及在 <code>AbstractInvoker</code> 中统一的 <code>Future</code> 异步功能。</p><p><strong>特别说明：</strong></p><blockquote><p>为什么将 <code>doRefer</code> 返回的代理对象通过 <code>ProxyFactory.getInvoker</code> 包装成 <code>AbstractProxyInvoker</code> 对象？因为此代理对象具备和远程服务通信的能力，原则上可以使用该代理对象调用服务接口方法，但是调用信息是存在 <code>Invocation</code> 中，将该代理对象包装成 <code>AbstractProxyInvoker</code> 可以根据 <code>Invocation</code> 中的信息动态选择目标服务方法。本质上和 DubboInvoker 类似，DubboInvoker 和远程服务通信需要使用 <code>ExchangeClient</code>，将调用信息 <code>Invocation</code> 交给它即可实现目标服务的调用，这里的代理对象就相当于 DubboInvoker 中的 <code>ExchangeClient</code> 。</p></blockquote><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p>使用 <code>JsonRpcServer</code> 暴露服务，具体过程可参考：<a href="https://gentryhuang.com/posts/c5a37c18/#%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2-2">HTTP协议服务暴露</a> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--- HttpProtocol.doExport</span><br><span class="line"><span class="comment">// 5 创建 JsonRpcServer，暴露服务</span></span><br><span class="line">JsonRpcServer skeleton = <span class="keyword">new</span> JsonRpcServer(impl, type);</span><br><span class="line">JsonRpcServer genericServer = <span class="keyword">new</span> JsonRpcServer(impl, GenericService<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中的具有服务能力的 <strong>impl</strong> 是 <code>ProxyFactory#getProxy(org.apache.dubbo.rpc.Invoker&lt;T&gt;, boolean)</code>  创建的代理对象，具体逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractProxyProtocol</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 省略无关代码</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String uri = serviceKey(invoker.getUrl());</span><br><span class="line">        Exporter&lt;T&gt; exporter = (Exporter&lt;T&gt;) exporterMap.get(uri);</span><br><span class="line">        <span class="keyword">if</span> (exporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// When modifying the configuration through override, you need to re-expose the newly modified service.</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(exporter.getInvoker().getUrl(), invoker.getUrl())) &#123;</span><br><span class="line">                <span class="keyword">return</span> exporter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其中的 invoker 是由 ProxyFactory#getInvoker 创建</span></span><br><span class="line">        <span class="keyword">final</span> Runnable runnable = doExport(proxyFactory.getProxy(invoker, <span class="keyword">true</span>), invoker.getInterface(), invoker.getUrl());</span><br><span class="line">        exporter = <span class="keyword">new</span> AbstractExporter&lt;T&gt;(invoker) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.unexport();</span><br><span class="line">                exporterMap.remove(uri);</span><br><span class="line">                <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        runnable.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        logger.warn(t.getMessage(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        exporterMap.put(uri, exporter);</span><br><span class="line">        <span class="keyword">return</span> exporter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不难看出最终处理请求的还是上面方法传入的 <code>invoker</code> 对象，该对象中包含真正的服务实例。而传入的 <code>invoker</code> 对象是由 <code>ProxyFactory#getInvoker</code> 创建的，对象类型是 <code>AbstractProxyInvoker</code> ，下面以 <code>JavassistProxyFactory</code> 工厂为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistProxyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Wrapper cannot handle this scenario correctly: the classname contains '$'</span></span><br><span class="line">        <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">'$'</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把前文的 <code>AbstractProxyInvoker</code> 的代码实现粘贴过来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractProxyInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 执行服务方法，如 DemoService.sayHello </span></span><br><span class="line">            Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 将方法结果以 CompletableFuture 对象形式进行封装。</span></span><br><span class="line">            <span class="comment">// 注意：如果服务方法返回类型是 CompletableFuture ，则无需再使用 CompletableFuture 包装。这个针对服务端的异步实现。</span></span><br><span class="line">            CompletableFuture&lt;Object&gt; future = wrapWithFuture(value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 执行 future 逻辑</span></span><br><span class="line">            CompletableFuture&lt;AppResponse&gt; appResponseFuture = future.handle((obj, t) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4 使用 AppResponse 封装实际结果</span></span><br><span class="line">                AppResponse result = <span class="keyword">new</span> AppResponse();</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t <span class="keyword">instanceof</span> CompletionException) &#123;</span><br><span class="line">                        result.setException(t.getCause());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.setException(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.setValue(obj);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 统一包装成 AsyncRpcResult 对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (RpcContext.getContext().isAsyncStarted() &amp;&amp; !RpcContext.getContext().stopAsync()) &#123;</span><br><span class="line">                logger.error(<span class="string">"Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e.getTargetException(), invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to invoke remote proxy method "</span> + invocation.getMethodName() + <span class="string">" to "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于使用 HTTP 协议的服务实现，更多的是在形式上保持统一，和 Dubbo 协议的服务实现类似。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Dubbo 2.6.x 及之前版本中使用 <code>Future</code> 实现异步功能，并且不支持服务端的异步，这在功能设计上存在一些问题，Dubbo 2.7.x 基于 <code>CompletableFuture</code> 对异步功能进行了增强，弥补了功能设计上的一些问题。由于 <code>CompletableFuture</code> 实现了 <code>CompletionStage</code> 和 <code>Future</code> 接口，因此仍然支持 Dubbo 2.6 中通过 <strong>get()</strong> 或者 <strong>isDone()</strong> 方法轮询结果。但是，不建议使用 <strong>get()</strong> 这样阻塞的方式获取结果，因为这样做的的话就丢失了异步操作带来的性能提升。<code>CompletableFuture</code> 提供了良好的回调支持，如 <strong>whenComplete()</strong> 等方法可以在逻辑完成后，执行回调逻辑。同时 <code>CompletableFuture</code> 支持 <code>Future</code> 间的相互协调，如 <strong>thenApply()</strong> 等方法。正是由于 <code>CompletableFuture</code> 强大的功能，我们可以更加流畅地使用回调而无需等待响应而阻塞调用线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;从 2.7.0 版本开始，Dubbo 的所有异步编程接口开始以 &lt;code&gt;CompletableFuture&lt;/code&gt; 为基础，不仅支
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 线程模型改造</title>
    <link href="https://gentryhuang.com/posts/13d5a11a/"/>
    <id>https://gentryhuang.com/posts/13d5a11a/</id>
    <published>2021-02-05T16:00:00.000Z</published>
    <updated>2021-04-06T08:30:05.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://gentryhuang.com/posts/c812f120/">异步改造</a> 中对 Dubbo 2.7.x 中异步调用和异步实现进行了详细说明。其中 Dubbo 协议下，在对异步调用进行分析时，我们发现 <code>ThreadlessExecutor</code> 被多次使用，此外 <code>ExchangeChannel#request</code> 方法支持设置处理响应的线程池。本篇文章我们将对 Dubbo 线程池模型优化进行介绍，其中消费端线程池模型优化就是从这两个方面进行改造的。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 协议下创建 NIO 服务器和客户端都会分别创建各自的线程池。2.7.x 之前版本的线程池的创建是由派发器 <code>Dispatcher</code> 创建的 <code>WrappedChannelHandler</code> 完成的。<code>Dispatcher</code> 和 <code>WrappedChannelHandler</code> 之间的关系可以参考 <a href="https://gentryhuang.com/posts/53cd7ee7/#WrappedChannelHandler">线程模型</a> 。2.7.x 新增了 <code>ExecutorRepository</code> 用于创建和管理线程池。 <code>WrappedChannelHandler</code> 的子类实现了消息派发功能，即决定了 Dubbo 以哪种线程模型处理收到的消息和事件。因为 NIO 服务器端和客户端都会初始化线程池，这意味着服务端和客户端都可能使用自己的线程池来处理本端收到的消息和事件，具体的策略由 <code>WrappedChannelHandler</code> 的子类决定。</p><h1 id="从-Issues-谈起"><a href="#从-Issues-谈起" class="headerlink" title="从 Issues 谈起"></a>从 Issues 谈起</h1><p>点这里：<a href="https://github.com/apache/dubbo/issues/1896" target="_blank" rel="noopener">消费者中建立了太多DubboClientHandler线程</a></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote><p>Dubbo Version: 2.5.3<br>我有一个非常大的provider 集群（30个实例）。然后我们发现在客户端，为每一个实例，都准备了一个独立线程池，所以我们看到有30个线程池以去发起消费请求，这个从jstack堆栈上可以证明，因为里面很多线程组的名字是类似DubboClientHandler-IP1-XXX，其中ip都是不一样的。</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>之所以我们提供如此大的服务集群，是因为我们希望最大化TPS，但现在集群是大了，但是消费者又因此导致巨大的线程消耗（高CPU）。我们能否通过配置改变这个线程的模型，例如用一个共享的线程池去处理所有的服务实例，这样最大的线程数便可控了。</p></blockquote><h2 id="待优化"><a href="#待优化" class="headerlink" title="待优化"></a>待优化</h2><blockquote><p>对 2.7.5 版本之前的 Dubbo 应用，在 <code>WrappedChannelHandler</code> 中会为 <strong>每个客户端连接启动一个线程池</strong>，因为不会根据 URL 复用线程池，这意味着每个消费端都浪费着一定的资源。此外，对于同步调用，业务线程发起调用后要阻塞等待响应，服务端返回响应后需要消费端线程池将结果保存起来然后通知业务线程，这个过程业务线程处于空闲状态，而接收响应却是消费端线程池完成，<strong>被阻塞的业务线程没有被有效利用</strong>。当面临需要消费大量服务且并发数比较大的大流量场景时（典型如网关类场景），经常会出现消费端线程数分配过多的问题。</p></blockquote><h1 id="Dubbo-2-6-x-线程模型"><a href="#Dubbo-2-6-x-线程模型" class="headerlink" title="Dubbo 2.6.x 线程模型"></a>Dubbo 2.6.x 线程模型</h1><p>这里以 Netty 实现为例，Mina 等 NIO 组件类似。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyServer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// ChannelHandlers.wrap方法，用来包装 ChannelHandler，实现Dubbo 线程模型的功能</span></span><br><span class="line">        <span class="comment">// 线程名前缀 DubboServerHandler</span></span><br><span class="line">        <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在创建、启动 Netty 服务时会通过 <code>ChannelHandlers.wrap</code> 方法为传入的 ChannelHandler 依次包装 <code>AllChannelHandler(默认)</code>、<code>HeartbeatHandler</code>以及 <code>MultiMessageHandler</code> 。其中 <code>AllChannelHanlder</code> 是消息派发处理器，其父类 <code>WrappedChannelHandler</code> 会开启一个线程池，也就是每启动一个服务器就创建对应的一个线程池。</p><h2 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyClient</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// wrapChannelHandler方法，包装ChannelHandler，其中实现了 Dubbo 线程模型的功能。</span></span><br><span class="line">        <span class="keyword">super</span>(url, wrapChannelHandler(url, handler));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> ChannelHandler <span class="title">wrapChannelHandler</span><span class="params">(URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 设置线程名前缀，即URL.threadname=xxx ，默认：DubboClientHandler</span></span><br><span class="line">        url = ExecutorUtil.setThreadName(url, CLIENT_THREAD_POOL_NAME);</span><br><span class="line">        <span class="comment">// 2 设置使用的线程池类型，即 URL.threadpool=xxx ，默认： cached。注意这个和Server的区别</span></span><br><span class="line">        url = url.addParameterIfAbsent(Constants.THREADPOOL_KEY, Constants.DEFAULT_CLIENT_THREADPOOL);</span><br><span class="line">        <span class="comment">// 3 包装通道处理器</span></span><br><span class="line">        <span class="keyword">return</span> ChannelHandlers.wrap(handler, url);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在创建、启动 Netty 客户端时会通过 <code>ChannelHandlers.wrap</code> 方法为传入的 ChannelHandler 依次包装 <code>AllChannelHandler(默认)</code>、<code>HeartbeatHandler</code>以及 <code>MultiMessageHandler</code> 。其中 <code>AllChannelHanlder</code> 是消息派发处理器，其父类 <code>WrappedChannelHandler</code> 会开启一个线程池，也就是每创建一个连接就创建对应的一个线程池。</p><h2 id="开启线程池"><a href="#开启线程池" class="headerlink" title="开启线程池"></a>开启线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+--- WrappedChannelHandler</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrappedChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 基于SPI机制创建线程池</span></span><br><span class="line">        executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>().<span class="title">getExecutor</span>(<span class="title">url</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String componentKey = Constants.EXECUTOR_SERVICE_COMPONENT_KEY;</span><br><span class="line">        <span class="comment">// 2 如果是消费端</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(Constants.SIDE_KEY))) &#123;</span><br><span class="line">            componentKey = Constants.CONSUMER_SIDE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 基于SPI机制创建线程池存储对象</span></span><br><span class="line">        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 添加线程池到 DataStore中</span></span><br><span class="line">        <span class="comment">// 注意： AbstractClient 或 AbstractServer 从 DataStore 获得线程池</span></span><br><span class="line">        dataStore.put(componentKey, Integer.toString(url.getPort()), executor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="缓存线程池"><a href="#缓存线程池" class="headerlink" title="缓存线程池"></a>缓存线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataStore 只有一个实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDataStore</span> <span class="keyword">implements</span> <span class="title">DataStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存已有的线程池</span></span><br><span class="line"><span class="comment">     * key1: 表示线程池属于服务端侧还是消费端侧</span></span><br><span class="line"><span class="comment">     * key2: 线程池关联服务的端口</span></span><br><span class="line"><span class="comment">     * value: 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt; data = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码层面上也说明了，在 <code>WrappedChannelHandler</code> 中会为每个连接启动一个线程池，并没有根据 URL 的信息对同一个线程池进行复用，而是直接通过 SPI 机制找到 ThreadPool 具体实现，然后创建线程池。注意，最终缓存的是最新的线程池。</p><h2 id="线程池模型"><a href="#线程池模型" class="headerlink" title="线程池模型"></a>线程池模型</h2><p>注意，创建 Dubbo 线程池都是强调消费端而没有强调服务端，因为一个节点部署 Dubbo 应用，一般只会创建一个 NIO 服务（以主机绑定的ip和port启动NIO服务），对应的线程池也只会初始化一个。</p><p>消费端同步请求的线程模型如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/consumer-threadpool-model-old.png" alt></p><p><strong>请求-响应流程如下：</strong></p><ol><li>业务线程发出请求，拿到一个 <strong>Future</strong> 实例。</li><li>业务线程紧接着调用 <strong>Future.get</strong> 阻塞等待请求结果返回。</li><li>当响应返回之后，交由连接关联的 Consumer 端线程池进行反序列化等处理。</li><li>待处理完成之后，通过 Future.set 方法将业务结果置回，然后通知业务线程取结果。</li></ol><p>当前版本的设计，消费端会维护一个线程池，而且<strong>线程池是按照连接隔离的</strong> ，也就是每个连接独享一个线程池。此外，当面临需要消费大量服务且并发数比较大的场景时，如 网关类场景，可能会导致消费端的线程数不断增加，最终引发CPU飙升、内存溢出。</p><h1 id="Dubbo-2-7-5-线程模型"><a href="#Dubbo-2-7-5-线程模型" class="headerlink" title="Dubbo 2.7.5 线程模型"></a>Dubbo 2.7.5 线程模型</h1><p>为了解决以上两个问题，Dubbo 2.7.5 对线程模型进行了改造，并且引入了 <code>ThreadlessExecutor</code>，以及 <code>ExchangeChannel#request</code> 方法支持设置处理响应的线程池，这样就可以通过 <strong>复用业务端被阻塞的线程，从而避免消费端线程池过度占用</strong>。</p><h2 id="ExecutorRepository"><a href="#ExecutorRepository" class="headerlink" title="ExecutorRepository"></a>ExecutorRepository</h2><p><code>ExecutorRepository</code> 负责创建并管理 Dubbo 中的线程池，该扩展接口只有一个实现。在 Dubbo 2.6.x 中之所以没有复用同一个线程池，很大原因就是没有一个管理 Dubbo 线程池的工具，它仅有一个缓存 Dubbo 线程池的工具。下面我们看看是怎么管理线程池的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultExecutorRepository</span> <span class="keyword">implements</span> <span class="title">ExecutorRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存已有的线程池</span></span><br><span class="line"><span class="comment">     * key1: 表示线程池属于服务端侧还是消费端侧</span></span><br><span class="line"><span class="comment">     * key2: 线程池关联服务的端口</span></span><br><span class="line"><span class="comment">     * value: 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;Integer, ExecutorService&gt;&gt; data = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当服务或客户端初始化时，根据 URL 参数创建相应的线程池并缓存在合适的位置</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">createExecutorIfAbsent</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 根据 URL 中的 side 参数值确定线程池缓存的第一层 key</span></span><br><span class="line">        String componentKey = EXECUTOR_SERVICE_COMPONENT_KEY;</span><br><span class="line">        <span class="keyword">if</span> (CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY))) &#123;</span><br><span class="line">            componentKey = CONSUMER_SIDE;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, ExecutorService&gt; executors = data.computeIfAbsent(componentKey, k -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 根据 URL 中的 port 值确定线程池缓存的第二层 key</span></span><br><span class="line">        Integer portKey = url.getPort();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取或创建线程池</span></span><br><span class="line">        ExecutorService executor = executors.computeIfAbsent(portKey, k -&gt; createExecutor(url));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 如果缓存中相应的线程池已经关闭，则创建新的线程池，并替换掉缓存中已关闭的线程池</span></span><br><span class="line">        <span class="keyword">if</span> (executor.isShutdown() || executor.isTerminated()) &#123;</span><br><span class="line">            executors.remove(portKey);</span><br><span class="line">            executor = createExecutor(url);</span><br><span class="line">            executors.put(portKey, executor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getExecutor</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 根据 URL 中的 side 参数值确定线程池缓存的第一层 key</span></span><br><span class="line">        String componentKey = EXECUTOR_SERVICE_COMPONENT_KEY;</span><br><span class="line">        <span class="keyword">if</span> (CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY))) &#123;</span><br><span class="line">            componentKey = CONSUMER_SIDE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 从缓存中获取线程池</span></span><br><span class="line">        Map&lt;Integer, ExecutorService&gt; executors = data.get(componentKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * It's guaranteed that this method is called after &#123;<span class="doctag">@link</span> #createExecutorIfAbsent(URL)&#125;, so data should already</span></span><br><span class="line"><span class="comment">         * have Executor instances generated and stored.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (executors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">"No available executors, this is not expected, framework should call createExecutorIfAbsent first "</span> +</span><br><span class="line">                    <span class="string">"before coming to here."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Integer portKey = url.getPort();</span><br><span class="line">        ExecutorService executor = executors.get(portKey);</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (executor.isShutdown() || executor.isTerminated()) &#123;</span><br><span class="line">                executors.remove(portKey);</span><br><span class="line">                executor = createExecutor(url);</span><br><span class="line">                executors.put(portKey, executor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 URL 创建线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ExecutorService <span class="title">createExecutor</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过 Dubbo SPI 查找 ThreadPool 接口的扩展实现，并调用 getExecutor() 方法创建线程池。默认使用 FixedThreadPool 扩展实现。</span></span><br><span class="line">        <span class="keyword">return</span> (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>().<span class="title">getExecutor</span>(<span class="title">url</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExecutorRepository</code> 会根据 URL 复用同一个线程，这解决了每个连接（连接同一个节点上服务）都启动一个线程池问题。</p><h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><p>当服务端和客户端启动时会初始化线程池，遵循先缓存后创建的原则。相比 Dubbo 2.6.x ，<code>WrappedChannelHandler</code> 不会在初始化时创建线程池，而是封装了公共的获取线程池的方法。</p><h2 id="获取线程池"><a href="#获取线程池" class="headerlink" title="获取线程池"></a>获取线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrappedChannelHandler</span> <span class="keyword">implements</span> <span class="title">ChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WrappedChannelHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrappedChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线程池，ThreadlessExecutor 或 共享线程池</span></span><br><span class="line"><span class="comment">     * 1. 使用 ThreadlessExecutor ，将回调直接委托给发起调用的线程</span></span><br><span class="line"><span class="comment">     * 2. 使用共享线程池执行回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getPreferredExecutorService</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是响应，尝试从 DefaultFuture 中取出线程池，没有的话再获取共享线程池</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">            Response response = (Response) msg;</span><br><span class="line">            DefaultFuture responseFuture = DefaultFuture.getFuture(response.getId());</span><br><span class="line">            <span class="keyword">if</span> (responseFuture == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> getSharedExecutorService();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果请求关联了线程池，则会获取相关的线程来处理响应</span></span><br><span class="line">                ExecutorService executor = responseFuture.getExecutor();</span><br><span class="line">                <span class="keyword">if</span> (executor == <span class="keyword">null</span> || executor.isShutdown()) &#123;</span><br><span class="line">                    executor = getSharedExecutorService();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> executor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 非响应，则直接使用共享线程池</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getSharedExecutorService();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前服务器或客户端的共享线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getSharedExecutorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从 ExecutorRepository 中获取线程池</span></span><br><span class="line">        ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>()</span>;</span><br><span class="line">        ExecutorService executor = executorRepository.getExecutor(url);</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor = executorRepository.createExecutorIfAbsent(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getExecutorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSharedExecutorService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是 <code>getPreferredExecutorService</code> 方法，如果请求在发送的时候指定了关联的线程池，则收到响应时会优先根据请求 ID 从 <code>DefaultFuture</code> 中取出对应的线程池，可能是 <code>ThreadlessExecutor</code>线程池或共享线程池。</p><h2 id="DefaultFuture"><a href="#DefaultFuture" class="headerlink" title="DefaultFuture"></a>DefaultFuture</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 DefaultFuture</span></span><br><span class="line"><span class="comment"> * 1. 初始化 DefaultFuture</span></span><br><span class="line"><span class="comment"> * 2. 超时检查</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel  channel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request  the request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout  timeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executor 线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new DefaultFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DefaultFuture <span class="title">newFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout, ExecutorService executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, request, timeout);</span><br><span class="line">    future.setExecutor(executor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadlessExecutor 需要持有本次请求关联的 DefaultFuture，主要用于当调用出现异常时（如调用超时），ThreadlessExecutor 可以及时更新 DefaultFuture 的调用状态，避免业务方一直傻傻地等待</span></span><br><span class="line">    <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">        ((ThreadlessExecutor) executor).setWaitingFuture(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为每次请求创建一个超时检查任务 </span></span><br><span class="line">    timeoutCheck(future);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timeoutCheck</span><span class="params">(DefaultFuture future)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 创建超时任务</span></span><br><span class="line">    TimeoutCheckTask task = <span class="keyword">new</span> TimeoutCheckTask(future.getId());</span><br><span class="line">    <span class="comment">// 2 将超时任务加入时间轮，到了指定的超时时间触发任务</span></span><br><span class="line">    future.timeoutCheckTask = TIME_OUT_TIMER.newTimeout(task, future.getTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DefaultFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    <span class="keyword">this</span>.request = request;</span><br><span class="line">    <span class="keyword">this</span>.id = request.getId();</span><br><span class="line">    <span class="keyword">this</span>.timeout = timeout &gt; <span class="number">0</span> ? timeout : channel.getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);</span><br><span class="line">    <span class="comment">// put into waiting map.</span></span><br><span class="line">    FUTURES.put(id, <span class="keyword">this</span>);</span><br><span class="line">    CHANNELS.put(id, channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，Dubbo 协议下 <strong>twoway</strong> 调用不仅会创建一个和本次调用的相关的 <code>DefaultFuture</code> 对象，还会为当前请求创建一个调用超时检测任务，该任务用于当调用超时时及时响应一个超时异常结果给调用方，尽可能减少业务方等待时间，不仅同步调用可以及时收到调用结果，异步调用也是，只是一般情况下异步调用不会立刻阻塞等待结果而已。Dubbo 2.6.x 没有使用时间轮，而是使用定时任务检测任务的超时，本质上是一样的。</p><h3 id="超时任务"><a href="#超时任务" class="headerlink" title="超时任务"></a>超时任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+--- DefaultFuture</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutCheckTask</span> <span class="keyword">implements</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  请求id</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Long requestID;</span><br><span class="line"></span><br><span class="line">        TimeoutCheckTask(Long requestID) &#123;</span><br><span class="line">            <span class="keyword">this</span>.requestID = requestID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 根据请求id取出对应的 DefaultFuture</span></span><br><span class="line">            DefaultFuture future = DefaultFuture.getFuture(requestID);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断 timeout 到了，结果是否返回，没有返回则请求超时了</span></span><br><span class="line">            <span class="keyword">if</span> (future == <span class="keyword">null</span> || future.isDone()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求超时需要响应一个超时结果</span></span><br><span class="line">            <span class="keyword">if</span> (future.getExecutor() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                future.getExecutor().execute(() -&gt; notifyTimeout(future));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                notifyTimeout(future);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyTimeout</span><span class="params">(DefaultFuture future)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 创建一个超时异常响应</span></span><br><span class="line">            Response timeoutResponse = <span class="keyword">new</span> Response(future.getId());</span><br><span class="line">            <span class="comment">// set timeout status.</span></span><br><span class="line">            timeoutResponse.setStatus(future.isSent() ? Response.SERVER_TIMEOUT : Response.CLIENT_TIMEOUT);</span><br><span class="line">            timeoutResponse.setErrorMessage(future.getTimeoutMessage(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理响应</span></span><br><span class="line">            DefaultFuture.received(future.getChannel(), timeoutResponse, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+--- DefaultFuture</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response, <span class="keyword">boolean</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DefaultFuture future = FUTURES.remove(response.getId());</span><br><span class="line">            <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Timeout t = future.timeoutCheckTask;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 请求没有超时，则取消超时任务</span></span><br><span class="line">                <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">                    <span class="comment">// decrease Time</span></span><br><span class="line">                    t.cancel();</span><br><span class="line">                &#125;</span><br><span class="line">                future.doReceived(response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"The timeout response finally returned at "</span></span><br><span class="line">                        + (<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>).format(<span class="keyword">new</span> Date()))</span><br><span class="line">                        + <span class="string">", response status is "</span> + response.getStatus()</span><br><span class="line">                        + (channel == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">", channel: "</span> + channel.getLocalAddress()</span><br><span class="line">                        + <span class="string">" -&gt; "</span> + channel.getRemoteAddress()) + <span class="string">", please check provider side for detailed result."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            CHANNELS.remove(response.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Response res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"response cannot be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常响应结果</span></span><br><span class="line">        <span class="keyword">if</span> (res.getStatus() == Response.OK) &#123;</span><br><span class="line">            <span class="keyword">this</span>.complete(res.getResult());</span><br><span class="line">            <span class="comment">// 超时异常</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123;</span><br><span class="line">            <span class="keyword">this</span>.completeExceptionally(<span class="keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()));</span><br><span class="line">            <span class="comment">// 其它异常</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.completeExceptionally(<span class="keyword">new</span> RemotingException(channel, res.getErrorMessage()));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 已经有了请求结果，但可能是超时异常结果，这种情况下应该通知在 ThreadlessExecutor.queue 上等待的线程，避免其一直等待。</span></span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 通知在 ThreadlessExecutor.queue 上等待的线程返回</span></span><br><span class="line">            <span class="keyword">if</span> (threadlessExecutor.isWaiting()) &#123;</span><br><span class="line">                threadlessExecutor.notifyReturn(<span class="keyword">new</span> IllegalStateException(<span class="string">"The result has returned, but the biz thread is still waiting"</span> +</span><br><span class="line">                        <span class="string">" which is not an expected state, interrupt the thread manually by returning an exception."</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DefaultFuture</code> 处理响应分为两种情况，一种是正常响应结果，另一种是异常响应结果。如果是异常结果，则还需要判断处理响应的线程池类型，如果是 <code>ThreadlessExecutor</code> 且其状态是等待状态，则需要通知阻塞的业务线程返回。此外，如果因为调用超时而返回异常结果时，也会将本次调用相关的 <code>DefaultFuture</code> 移除，当服务提供方返回响应（超时是针对消费端的，服务端不受影响）时是找不到对应的 DefaultFuture 对象的。</p><p>相比较 Dubbo 2.6.x , <code>DefaultFuture</code> 新维护了一个 <code>ExecutorService</code> 线程池，作为处理响应的线程池，可以参考 <code>WrappedChannelHandler.getPreferredExecutorService</code> 方法中的逻辑。</p><h2 id="ThreadlessExecutor"><a href="#ThreadlessExecutor" class="headerlink" title="ThreadlessExecutor"></a>ThreadlessExecutor</h2><p><code>ThreadlessExecutor</code> 是一种特殊类型的线程池，它并不会管理任何线程，以线程池的身份作为一个中间容器使用。其中维护了一个阻塞队列 <strong>queue</strong> 和一个共享线程池 <strong>shareExecutor</strong> 。阻塞队列用来存储响应任务，最终会将响应任务交给等待的业务线程处理。共享线程池主要用于当业务线程不再等待响应时，会由该线程池处理任务。整个核心逻辑在 <strong>execute()</strong> 方法和 <strong>waitAndDrain()</strong> 方法。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadlessExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ThreadlessExecutor<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞队列，用来在 IO线程和业务线程之间传递任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadlessExecutor 底层关联的共享线程池。当业务线程已经不再等待响应时，会由该共享线程执行提交任务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService sharedExecutor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向请求对应的 DefaultFuture</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CompletableFuture&lt;?&gt; waitingFuture;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * finished 和 waiting 字段控制着等待任务的处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> waiting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadlessExecutor</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 判断业务线程是否还在等待响应，不等待则直接交给共享线程池处理</span></span><br><span class="line">            <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">                sharedExecutor.execute(runnable);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 业务线程还在等待，则将任务写入队列，最终由业务线程自己执行（业务线程在 waitAndDrain 方法上等待任务）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.add(runnable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ThreadlessExecutor</code> 重写了 <code>execute(Runnable)</code> 方法，通过该方法提交给这个执行器的任务不会被调度到特定的线程。如果业务线程在等待响应则将任务放入阻塞队列，最终业务线程自己执行。如果业务线程没有等待（可能业务线程已经执行了响应任务），则直接交给共享线程池处理。</p><h3 id="任务等待"><a href="#任务等待" class="headerlink" title="任务等待"></a>任务等待</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadlessExecutor</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitAndDrain</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 检测当前 ThreadlessExecutor 状态</span></span><br><span class="line">        <span class="keyword">if</span> (finished) &#123; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取阻塞队列中的任务</span></span><br><span class="line">        Runnable runnable = queue.take();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 修改waiting 状态</span></span><br><span class="line">            waiting = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果阻塞队列还有其它任务，则需要一起执行</span></span><br><span class="line">        runnable = queue.poll();</span><br><span class="line">        <span class="keyword">while</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.info(t);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            runnable = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记 ThreadlessExecutor 是完成状态，无业务线程等待</span></span><br><span class="line">        finished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法一般与一次 RPC 调用绑定，只会执行一次。存储在阻塞队列中的任务，只有当线程调用该方法时才会执行，执行任务的线程和调用该方法的线程是同一个线程。</p><h3 id="关联-DefaultFuture"><a href="#关联-DefaultFuture" class="headerlink" title="关联 DefaultFuture"></a>关联 DefaultFuture</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWaitingFuture</span><span class="params">(CompletableFuture&lt;?&gt; waitingFuture)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.waitingFuture = waitingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为 <code>ThreadlessExecutor</code> 设置本次调用相关的 <code>DefaultFuture</code> 对象，主要用于同步调用异常（如超时异常）时，可以更新 <code>DefaultFuture</code> 的调用状态，即使用 <code>notifyReturn</code> 方法。</p><h3 id="异常任务通知"><a href="#异常任务通知" class="headerlink" title="异常任务通知"></a>异常任务通知</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知阻塞 &#123;<span class="doctag">@link</span> #waitAndDrain()&#125; 的线程返回，避免调用出现异常还傻傻地等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyReturn</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// an empty runnable task.</span></span><br><span class="line">    execute(() -&gt; &#123;</span><br><span class="line">        waitingFuture.completeExceptionally(t);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h2><h3 id="AsyncToSyncInvoker"><a href="#AsyncToSyncInvoker" class="headerlink" title="AsyncToSyncInvoker"></a>AsyncToSyncInvoker</h3><p>前面已经对该 Invoker 进行了介绍，在服务引用时会使用该类对消费端的 Invoker 进行包装，负责将异步调用转换成同步调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       Result asyncResult = invoker.invoke(invocation);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 如果是同步调用，则调用 get() 方法，阻塞等待响应返回。</span></span><br><span class="line">           <span class="comment">// 调用的是 AsyncRpcResult.get 方法，其底层调用的是 CompletableFuture 的 get 方法</span></span><br><span class="line">           <span class="keyword">if</span> (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * NOTICE!</span></span><br><span class="line"><span class="comment">                * must call &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get(long, TimeUnit)&#125; because</span></span><br><span class="line"><span class="comment">                * &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get()&#125; 被证明有严重的性能下降。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 省略异常处理逻辑</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> asyncResult;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>业务线程进行 Invoker 调用时，会执行到 <code>AsyncToSyncInvoker.invoke</code> 方法，执行完调用后会返回一个 <code>AsyncRpcResult</code> 对象，如果是 SYNC 同步调用模式，则会调用其 <strong>get</strong> 方法，本质上是调用 <code>ThreadlessExecutor</code> 的 <strong>waitAndDrain()</strong> 方法阻塞等待响应任务。 </p><p>Dubbo 2.6.x 的异步转同步是通过 <strong>等待通知机制</strong> 实现的，使用的是 <code>Lock</code> 和 <code>Condition</code> 的组合。Dubbo 2.7.x 的异步转同步也是通过 <strong>等待通知机制</strong> 实现的，等待部分使用的是 <code>LinkedBlockingQueue.take()</code> 方法实现的，通知部分使用的是 <code>LinkedBlockingQueue.add(Runnable)</code> 实现的，由于 <code>LinkedBlockingQueue</code> 底层的实现机制也是基于 <code>Lock</code> 和 <code>Condition</code> 的组合，因此本质上实现机制是一致的。</p><h3 id="AsyncRpcResult"><a href="#AsyncRpcResult" class="headerlink" title="AsyncRpcResult"></a>AsyncRpcResult</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">            threadlessExecutor.waitAndDrain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseFuture.get(timeout, unit);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里可能会有疑问，业务线程调用 <strong>threadlessExecutor.waitAndDrain()</strong> 方法阻塞等待结果时并没有时间限制，那怎么知道调用是否超时呢？这个就是前文介绍的，在创建请求相关的 <code>DefaultFuture</code> 时还会创建一个超时检测任务，当请求超时时会立即返回一个超时异常结果，并且会通知阻塞等待的业务线程。</p><h3 id="DubboInvoker"><a href="#DubboInvoker" class="headerlink" title="DubboInvoker"></a>DubboInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboInvoker</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此次调用的方法名称</span></span><br><span class="line">        <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向 Invocation 中添加附加信息，这里将 URL 的 path 和 version 添加到附加信息中</span></span><br><span class="line">        inv.setAttachment(PATH_KEY, getUrl().getPath());</span><br><span class="line">        inv.setAttachment(VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择一个 ExchangeClient 实例</span></span><br><span class="line">        ExchangeClient currentClient;</span><br><span class="line">        <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">            currentClient = clients[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 是否是 oneway 调用 （不需要返回值）</span></span><br><span class="line">            <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            <span class="comment">// 根据调用方法名和配置，计算此次调用的超时时间</span></span><br><span class="line">            <span class="keyword">int</span> timeout = calculateTimeout(invocation, methodName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不需要关注返回值的请求</span></span><br><span class="line">            <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">              <span class="comment">// 省略调用逻辑</span></span><br><span class="line">               </span><br><span class="line">                <span class="comment">// 需要关注返回值的请求</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1 对于同步请求会使用 ThreadlessExecutor （SYNC 模式）， 对于异步请求，则会使用共享的线程池 （ASYNC 和 FUTURE 模式 ）</span></span><br><span class="line">                ExecutorService executor = getCallbackExecutor(getUrl(), inv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 使用上面选出的 ExchangeClient 执行 request() 方法将请求发出去，并传入线程池 executor。该线程池会作为处理响应的线程池，将保存到 DefaultFuture 中</span></span><br><span class="line">                CompletableFuture&lt;AppResponse&gt; appResponseFuture =</span><br><span class="line">                        <span class="comment">// currentClient.request 返回的是 DefaultFuture，DefaultFuture 继承了 CompletableFuture 。</span></span><br><span class="line">                        currentClient.request(inv, timeout, executor)</span><br><span class="line">                                <span class="comment">// 增加了一个回调，取出其中的 AppResponse 对象。</span></span><br><span class="line">                                <span class="comment">// thenApply 是一个回调,obj 是 上一个任务的结果。返回的 AppResponse 表示的是 服务端返回的具体响应。</span></span><br><span class="line">                                .thenApply(obj -&gt; (AppResponse) obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter</span></span><br><span class="line">                FutureContext.getContext().setCompatibleFuture(appResponseFuture);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3 这里将 CompletableFuture （其实是 DefaultFuture） 封装成 AsyncRpcResult 并返回</span></span><br><span class="line">                AsyncRpcResult result = <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, inv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置处理结果的线程池</span></span><br><span class="line">                result.setExecutor(executor);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>DubboInvoker 在发起调用之前，会先通过 getCallbackExecutor 方法根据调用模式获取不同的线程池实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractInvoker</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ExecutorService <span class="title">getCallbackExecutor</span><span class="params">(URL url, Invocation inv)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 从 ExecutorRepository 中获取线程池</span></span><br><span class="line">        ExecutorService sharedExecutor = ExtensionLoader.getExtensionLoader(ExecutorRepository<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>().<span class="title">getExecutor</span>(<span class="title">url</span>)</span>;</span><br><span class="line">        <span class="comment">// 2 如果是同步请求，则使用 ThreadlessExecutor 线程池，它会对共享线程池进行封装</span></span><br><span class="line">        <span class="keyword">if</span> (InvokeMode.SYNC == RpcUtils.getInvokeMode(getUrl(), inv)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadlessExecutor(sharedExecutor);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 非同步请求，则使用共享线程池</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sharedExecutor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h2><p>端点收到数据时（这里假设是响应数据）先由 IO 线程从二进制流中解码出响应，然后调用 <code>WrappedChannelHandler.received</code> 方法的实现，下面我们以 <code>AllChannelHandler</code> 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- AllChannelHandler</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前端点收到数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取线程池，如果是响应消息则优先获取发送请求时指定的关联线程池</span></span><br><span class="line">        ExecutorService executor = getPreferredExecutorService(message);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2 将消息封装成ChannelEventRunnable任务，提交到第 1 步获取的线程池中</span></span><br><span class="line">            executor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 3 如果线程池满了，请求会被拒绝，这里会根据请求配置决定是否返回一个说明性的响应</span></span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request &amp;&amp; t <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</span><br><span class="line">                sendFeedback(channel, (Request) message, t);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(message, channel, getClass() + <span class="string">" error when process received event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>符合以下条件 <code>getPreferredExecutorService</code> 方法获取的线程池就是 <code>ThreadlessExecutor</code>，否则一律使用共享线程池</strong></p><ol><li>收到的是响应消息。</li><li>响应对应的请求调用模式是 SYNC 同步调用。</li></ol><p><code>ThreadlessExecutor</code> 执行 <strong>execute</strong> 方法时，会将任务提交到阻塞队列中，处于阻塞的业务线程会从阻塞队列中获取任务并执行。</p><h2 id="线程池模型-1"><a href="#线程池模型-1" class="headerlink" title="线程池模型"></a>线程池模型</h2><p>通过复用业务端被阻塞的线程，解决了消费端线程池过度占用问题。同步调用优化后的线程模型如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/consumer-threadpool-model-new.png" alt></p><ol><li>业务线程发出请求后，拿到一个 Future 对象。</li><li>业务线程会调用 <code>ThreadlessExecutor.waitAndDrain()</code> 方法，该方法会使业务线程在阻塞队列上等待，直到队列中被加入任务。</li><li>当收到响应时，IO 线程会生成一个任务并放入 <code>ThreadlessExecutor</code> 阻塞队列中。</li><li>处于阻塞的业务线程将第 3 步添加的任务取出，并在本线程中执行。得到结果之后，调用 <code>Future.set</code> 方法进行设置，然后业务线程从 <strong>waitAndDrain()</strong> 方法返回。</li><li>业务线程继续执行，最后拿到结果值。</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章主要对 Dubbo 的线程模型改造进行了介绍，首先解决了以连接维度的消费端线程池，根据 URL 复用线程池即合理地缓存线程池实现。接着解决了消费端线程池过度占用问题，通过引入 <code>ThreadlessExecutor</code> 复用业务端被阻塞的线程实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/c812f120/&quot;&gt;异步改造&lt;/a&gt; 中对 Dubbo 
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Java基础 - JDK动态代理</title>
    <link href="https://gentryhuang.com/posts/d38b32e5/"/>
    <id>https://gentryhuang.com/posts/d38b32e5/</id>
    <published>2021-01-03T12:30:35.000Z</published>
    <updated>2021-03-17T05:00:26.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java 中代理分为两大类，一类是静态代理，另一类是动态代理。静态代理是针对需要被代理的类在编译之前就已经写好了对应的代理类，也就是说代理关系在编译之前就确立了。动态代理是针对目标类在程序运行期间自动生成的代理类，细分为有接口的代理类和无接口的代理类。JDK动态代理支持目标类有接口的情况，目标类没有接口无法为其生成代理类，能够为没有接口生成代理类的工具如 CGLIB 等。本篇文章将对JDK动态代理实现原理进行介绍。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPrintf</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintfImpl</span> <span class="keyword">implements</span> <span class="title">IPrintf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"print: "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IPrintf PRINTF = <span class="keyword">new</span> PrintfImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDK 生成代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> $Proxy0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPrintf <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> (IPrintf) Proxy.newProxyInstance(</span><br><span class="line">                <span class="comment">// 类加载器，在程序运行时将生成的代理类加载到JVM中</span></span><br><span class="line">                PRINTF.getClass().getClassLoader(),</span><br><span class="line">                <span class="comment">// 被代理类的所有接口信息，用来确定生成的代理类可以具有哪些方法</span></span><br><span class="line">                PRINTF.getClass().getInterfaces(),</span><br><span class="line">                <span class="comment">// 调用处理器，每个代理对象都具有一个关联的调用处理器，用于指定动态生成的代理类需要完成的具体操作。</span></span><br><span class="line">                <span class="comment">// 该接口中有一个 invoke 方法，代理对象调用任何目标接口的方法时都会调用该 invoke 方法，该方法中会通过反射调用目标方法。</span></span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method 代理对象当前调用的方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span> 方法执行的结果（无返回值则为 null）</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable 异常</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">// 前置逻辑</span></span><br><span class="line">                        System.out.println(<span class="string">"before action ... "</span>);</span><br><span class="line">                        <span class="comment">// 将方法派发给目标方法</span></span><br><span class="line">                        Object result = method.invoke(PRINTF, args);</span><br><span class="line">                        <span class="comment">// 后置逻辑</span></span><br><span class="line">                        System.out.println(<span class="string">"after action ... "</span>);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IPrintf proxy = Client.getProxy();</span><br><span class="line">        proxy.print(<span class="string">"hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印结果"><a href="#打印结果" class="headerlink" title="打印结果"></a>打印结果</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/java-base-proxy-test.jpg" alt></p><h2 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h2><p>通过阿里开源 Java 应用诊断工具 Arthas 反编译代理类，结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decompiled with CFR.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.code.proxy.IPrintf;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy4</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Proxy</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">IPrintf</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态属性，每个属性对应接口中的一个方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，入参类型为 InvocationHandler</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy4(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="comment">// 调用父类 Proxy 的构造方法</span></span><br><span class="line">        <span class="keyword">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块中通过反射初始化Method属性</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="comment">// Object 中的三大方法</span></span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 目标类的接口中的方法</span></span><br><span class="line">            m3 = Class.forName(<span class="string">"com.code.proxy.IPrintf"</span>).getMethod(<span class="string">"print"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(noSuchMethodException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(classNotFoundException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;object&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m2, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m0, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标类的打印方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// this.h 是 Proxy 中的属性，即调用 Proxy.newProxyInstance 方法传入的 InvocationHandler 对象</span></span><br><span class="line">            <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;string&#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过上面反编译后的代理类代码不难看出，JDK 动态代理实现具有以下特点：</strong></p><ol><li>生成的代理类继承了 <strong>Proxy</strong> 类且实现了 <strong>目标类的接口</strong>，有参构造方法的参数类型是 <strong>InvocationHandler</strong> ，反射创建代理对象执行的就是该构造方法。</li><li>代理类通过反射为目标接口（接口列表）中的每个方法都映射一个 <strong>Method</strong> 对象。</li><li>代理类对接口中方法的实现逻辑都是通过 <strong>InvocationHandler.invoke</strong> 方法派发执行的，代理对象调用任何目标接口的方法时都会调用这个<strong>invoke</strong>方法，该方法中进行目标类的目标方法的调用，即每个方法执行逻辑都由第 2 步中的 <strong>Method</strong> 对象执行。</li></ol><p>关于 JDK 动态代理使用就介绍完毕了，下面我们对底层实现原理进行说明。实现原理中的部分描述信息会引用到上述代码片段。</p><h1 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h1><p>Java 中需要在运行期动态的生成一个类并创建其对象，一般需要使用字节码技术和反射机制。JDK 动态代理通过<code>java.lang.reflect.Proxy</code>提供了一种原生的动态代理模式，其底层通过<strong>对字节码的操作</strong>和<strong>反射的使用</strong>组装代理类，如前文中的 <strong>$Proxy4</strong>，最后通过反射创建代理对象。</p><p>JDK通过调用静态方法 <code>Proxy.newProxyInstance()</code> 创建动态代理，该方法需要三个参数：</p><ol><li>类加载器<br>通常可以从已经被加载的对象中获取其类加载器。</li><li>接口列表<br>预期代理实现的接口列表。</li><li><strong>InvocationHandler</strong> 接口的实现<br>作为动态代理对象的调用处理器，即动态代理可以将所有调用派发到该调用处理器。因此，通常会向调用处理器的构造器中传入一个目标对象的引用，从而使得调用处理器在执行中介任务时可以将请求转发。</li></ol><p>介绍完代理相关的概念和使用方式后，下面我们对 JDK 动态代理实现原理进行说明。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+--- java.lang.reflect.Proxy</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法参数类型，就是 InvocationHandler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams = &#123;InvocationHandler<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类的缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">            proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理对象调用的处理器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prohibits instantiation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供生成的动态代理类调用，也就是 Proxy 的子类。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h 用于代理对象的调用处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy 中有 3 个核心属性，下面简单介绍：</p><ol><li><strong>constructorParams</strong><br>Proxy 中的有参构造器的参数，是个固定值即调用处理器 <code>InvocationHandler</code>，生成的代理类都会调用 <code>Proxy</code> 这个父类的构造方法。</li><li><strong>proxyClassCache</strong><br>缓存生成的代理类，用于提高效率。需要注意的是，KeyFactory 和 ProxyClassFactory 都是 Proxy 的内部类，前者用于返回接口对应的弱引用，后者根据指定的类加载器和接口列表生成代理类。</li><li><strong>h</strong><br>调用处理器，该处理器会将代理对象的方法调用派发给目标方法。</li></ol><h3 id="内部类-KeyFactory"><a href="#内部类-KeyFactory" class="headerlink" title="内部类 KeyFactory"></a>内部类 KeyFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyFactory</span></span></span><br><span class="line">        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回接口对应的弱引用信息。Key1、Key2 以及 KeyX 都持有 WeakReference</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">apply</span><span class="params">(ClassLoader classLoader, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (interfaces.length) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Key1(interfaces[<span class="number">0</span>]); <span class="comment">// the most frequent</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Key2(interfaces[<span class="number">0</span>], interfaces[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> key0;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> KeyX(interfaces);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KeyFactory 就一个工作，返回接口对应的弱引用信息，KeyN 继承了 <code>WeakReference</code> 类。</p><h3 id="内部类-ProxyClassFactory"><a href="#内部类-ProxyClassFactory" class="headerlink" title="内部类 ProxyClassFactory"></a>内部类 ProxyClassFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">           implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 代理类名称前缀，具体名称为： $Proxy + Num</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 生成代理名称的序号，是自增原子类</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 生成代理类的逻辑</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> loader     类加载器</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> interfaces 接口集合</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> 代理类</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">           Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">           <span class="comment">// 遍历接口集合</span></span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 1 验证类加载器是否将当前接口名称解析为相同的类对象</span></span><br><span class="line">               Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                           intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 2 判断是否是接口</span></span><br><span class="line">               <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                           interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 3 验证接口是否重复加载</span></span><br><span class="line">               <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                           <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 4 代理所在包的名称</span></span><br><span class="line">           String proxyPkg = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 5 记录非public类型的接口，如果是非public类型的接口，则会将代理类定义在该对应的包中。当且仅当所有非public类型的接口都在一个包中才行，否则不合法</span></span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">               <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">               <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                   accessFlags = Modifier.FINAL;</span><br><span class="line">                   String name = intf.getName();</span><br><span class="line">                   <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                   String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                   <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       proxyPkg = pkg;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                               <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 6 如果接口是public类型的，则使用固定的包名： com.sun.proxy</span></span><br><span class="line">           <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">               proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 7 组装代理类名称，格式：proxyPkg + $Proxy + Num</span></span><br><span class="line">           <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">           String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 8 根据代理类名和接口列表使用 ProxyGenerator 生成指定的代理类，可能返回null （配置了虚拟机参数，将代理类字节信息输出到文件）</span></span><br><span class="line">           <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 9 调用native方法，返回代理类</span></span><br><span class="line">               <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 排除代理类生成代码中的bug，提供给代理类创建的参数存在其他问题(例如超出了虚拟机限制)。</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>ProxyClassFactory 完成生成字节码的操作，是生成代理类的完整流程，具体工作如下：</strong></p><ol><li>根据目标类的接口类型确定生成代理类全路径名</li><li>执行 <strong>ProxyGenerator.generateProxyClass</strong> 方法，根据代理类名和接口生成代理类字节码数组或文件形式</li><li>调用 <strong>native</strong> 方法将代理类字节码数据转化为代理类 Class</li></ol><h2 id="ProxyGenerator"><a href="#ProxyGenerator" class="headerlink" title="ProxyGenerator"></a>ProxyGenerator</h2><p><strong>ProxyClassFactory.apply</strong> 通过调用 <strong>ProxyGenerator.generateProxyClass</strong> 方法组装代理类，对接口的 <code>Class</code> 对象、<code>Method</code> 对象进行拆解、封装进而生成字节码层面的方法、构造方法以及静态代码块。</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"></span><br><span class="line">  <span class="comment">// JVM参数，是否将生成的代理类保存到文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles = (Boolean) AccessController.doPrivileged(<span class="keyword">new</span> GetBooleanAction(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object 三大方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method hashCodeMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method equalsMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method toStringMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理类全路径名</span></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="comment">// 接口数组</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] interfaces;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> accessFlags;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ProxyGenerator 中的常量池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ProxyGenerator.ConstantPool cp = <span class="keyword">new</span> ProxyGenerator.ConstantPool();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录方法标识，用于生成代理类中的方法的属性。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ProxyGenerator.FieldInfo&gt; fields = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成的方法信息集合，包括构造方法、静态代码块。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ProxyGenerator.MethodInfo&gt; methods = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法签名到方法代理对象的映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;ProxyGenerator.ProxyMethod&gt;&gt; proxyMethods = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> proxyMethodCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 反射获取三大方法对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hashCodeMethod = Object.class.getMethod("hashCode");</span><br><span class="line">            equalsMethod = Object.class.getMethod("equals", Object.class);</span><br><span class="line">            toStringMethod = Object.class.getMethod("toString");</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var1.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var1 代理类名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var2 目标类接口集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ProxyGenerator</span><span class="params">(String var1, Class&lt;?&gt;[] var2, <span class="keyword">int</span> var3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = var1;</span><br><span class="line">        <span class="keyword">this</span>.interfaces = var2;</span><br><span class="line">        <span class="keyword">this</span>.accessFlags = var3;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>JDK 动态代理涉及到的基础类先介绍到这里，下面我们从 <code>Proxy.newProxyInstance</code> 入口出发，根据调用链逐步分析源代码。</p><h2 id="newProxyInstance"><a href="#newProxyInstance" class="headerlink" title="newProxyInstance"></a>newProxyInstance</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">+--- Proxy</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader     代理类的加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces 目标类的接口列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h          代理对象方法调用都会分派给该调用处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用处理器是必传参数</span></span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接口列表</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 查找或生成指定的代理类。</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 对生成的代理类进行安全检查</span></span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 获取代理类的指定构造方法，即参数类型为 InvocationHandler 的构造方法</span></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 保证代理类的构造方法 cons 具有访问权限，便于后续反射创建代理对象</span></span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 反射创建代理对象，注意参数为 InvocationHandler</span></span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong><code>Proxy.newProxyInstance</code> 方法是生成代理对象的入口，下面对该方法的逻辑进行简单说明：</strong></p><ol><li>调用 <code>getProxyClass0</code> 方法根据指定的类加载器和接口列表获取代理类。这一步是整个代理逻辑的核心实现。</li><li>反射获取参数为 <code>InvocationHandler</code>的代理类的构造方法，并保证该构造方法是可访问的。</li><li>通过 <strong>newInstance</strong> 方法反射创建代理对象，参数类型为 <code>InvocationHandler</code> 。</li></ol><p>第 2、3 步都很容易理解，下面我们重点来分析获取代理类的 <code>getProxyClass0</code> 方法。</p><h2 id="getProxyClass0"><a href="#getProxyClass0" class="headerlink" title="getProxyClass0"></a>getProxyClass0</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--- Proxy</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成代理类。在调用此方法之前，必须调用checkProxyAccess方法来执行权限检查。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取代理类：</span></span><br><span class="line"><span class="comment">         * 1. 如果代理类存在则返回缓存的副本。</span></span><br><span class="line"><span class="comment">         * 2. 不存在，则通过 ProxyClassFactory 创建代理类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前文中有提到代理类缓存属性 <code>WeakCache proxyClassCache</code> ，它的主要作用就是先查找对应的代理类缓存，没有的话就通过 <code>java.lang.reflect.Proxy.ProxyClassFactory#apply</code> 方法创建代理类，该方法在前文中已经详细说明。下面我们对 <strong><code>ProxyGenerator.generateProxyClass</code> 根据代理类名和接口生成代理类字节码数组或文件形式</strong> 这一步骤进行说明。</p><h2 id="generateProxyClass"><a href="#generateProxyClass" class="headerlink" title="generateProxyClass"></a>generateProxyClass</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成代理类-字节码形式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var0 代理类名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var1 目标类接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line"></span><br><span class="line">        ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">        <span class="comment">// 生成目标类的接口信息的字节码</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加JVM 参数 sun.misc.ProxyGenerator.saveGeneratedFiles ，则保存到文件</span></span><br><span class="line">        <span class="keyword">if</span> (saveGeneratedFiles) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> var1 = var0.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                        Path var2;</span><br><span class="line">                        <span class="keyword">if</span> (var1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 创建目录</span></span><br><span class="line">                            Path var3 = Paths.get(var0.substring(<span class="number">0</span>, var1).replace(<span class="string">'.'</span>, File.separatorChar));</span><br><span class="line">                            Files.createDirectories(var3);</span><br><span class="line"></span><br><span class="line">                            var2 = var3.resolve(var0.substring(var1 + <span class="number">1</span>, var0.length()) + <span class="string">".class"</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            var2 = Paths.get(var0 + <span class="string">".class"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 保存到文件</span></span><br><span class="line">                        Files.write(var2, var4, <span class="keyword">new</span> OpenOption[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var4x) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"I/O exception saving generated file: "</span> + var4x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var4;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>generateProxyClass 方法用于根据代理类名称和接口列表生成预期的代理类的字节码（数组）信息，最后通过 JDK 的本地方法转化为具体的代理类。该方法支持通过配置<strong>JVM参数</strong>将目标代理类输出到文件中。</p><p>在分析 <code>ProxyGenerator.generateClassFile</code> 方法之前，我们先对涉及的核心类和方法进行简单说明。注意该方法整个流程比较复杂，本文只对整体逻辑进行说明，具体细节可以参考源代码。</p><h2 id="ProxyMethod"><a href="#ProxyMethod" class="headerlink" title="ProxyMethod"></a>ProxyMethod</h2><p>方法代理类，用于拆解、封装 <strong>Method</strong> 的信息，作为后续方法字节码生成的数据来源。</p><h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyMethod</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法名</span></span><br><span class="line">        <span class="keyword">public</span> String methodName;</span><br><span class="line">        <span class="comment">// 参数类型</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line">        <span class="comment">// 返回值类型</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; returnType;</span><br><span class="line">        <span class="comment">// 异常类型</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt;[] exceptionTypes;</span><br><span class="line">        <span class="comment">// 方法所在接口</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; fromClass;</span><br><span class="line">        <span class="comment">// 当前方法对应的序列号，如 m0</span></span><br><span class="line">        <span class="keyword">public</span> String methodFieldName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ProxyMethod</span><span class="params">(String var2, Class&lt;?&gt;[] var3, Class&lt;?&gt; var4, Class&lt;?&gt;[] var5, Class&lt;?&gt; var6)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.methodName = var2;</span><br><span class="line">            <span class="keyword">this</span>.parameterTypes = var3;</span><br><span class="line">            <span class="keyword">this</span>.returnType = var4;</span><br><span class="line">            <span class="keyword">this</span>.exceptionTypes = var5;</span><br><span class="line">            <span class="keyword">this</span>.fromClass = var6;</span><br><span class="line">            <span class="keyword">this</span>.methodFieldName = <span class="string">"m"</span> + ProxyGenerator.<span class="keyword">this</span>.proxyMethodCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其它代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="generateMethod"><a href="#generateMethod" class="headerlink" title="generateMethod"></a>generateMethod</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyMethod</span><br><span class="line"> <span class="keyword">private</span> ProxyGenerator.<span class="function">MethodInfo <span class="title">generateMethod</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">// 方法签名 如：toString 方法的描述信息 Ljava/lang/reflect/Method;  void print(String message) 描述信息 (Ljava/lang/String;)V</span></span><br><span class="line">            String var1 = ProxyGenerator.getMethodDescriptor(<span class="keyword">this</span>.parameterTypes, <span class="keyword">this</span>.returnType);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 MethodInfo 对象，同时会初始化 ByteArrayOutputStream 对象</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 方法名 + 方法签名</span></span><br><span class="line">            ProxyGenerator.MethodInfo var2 = ProxyGenerator.<span class="keyword">this</span>.<span class="keyword">new</span> MethodInfo(<span class="keyword">this</span>.methodName, var1, <span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 方法参数</span></span><br><span class="line">            <span class="keyword">int</span>[] var3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.parameterTypes.length];</span><br><span class="line">            <span class="keyword">int</span> var4 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var3.length; ++var5) &#123;</span><br><span class="line">                var3[var5] = var4;</span><br><span class="line">                var4 += ProxyGenerator.getWordsPerType(<span class="keyword">this</span>.parameterTypes[var5]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span> var7 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过字节输出流 ByteArrayOutputStream 写入方法的二进制信息，即 MethodInfo 中的输出流中</span></span><br><span class="line">            DataOutputStream var9 = <span class="keyword">new</span> DataOutputStream(var2.code);</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.code_aload(<span class="number">0</span>, var9);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 写入接口方法的 InvocationHandler.invoke 处理逻辑</span></span><br><span class="line">            var9.writeByte(<span class="number">180</span>);</span><br><span class="line">            var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getFieldRef(<span class="string">"java/lang/reflect/Proxy"</span>, <span class="string">"h"</span>, <span class="string">"Ljava/lang/reflect/InvocationHandler;"</span>));</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.code_aload(<span class="number">0</span>, var9);</span><br><span class="line">            var9.writeByte(<span class="number">178</span>);</span><br><span class="line">            var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getFieldRef(ProxyGenerator.dotToSlash(ProxyGenerator.<span class="keyword">this</span>.className), <span class="keyword">this</span>.methodFieldName, <span class="string">"Ljava/lang/reflect/Method;"</span>));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.parameterTypes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ProxyGenerator.<span class="keyword">this</span>.code_ipush(<span class="keyword">this</span>.parameterTypes.length, var9);</span><br><span class="line">                var9.writeByte(<span class="number">189</span>);</span><br><span class="line">                var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/Object"</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> var10 = <span class="number">0</span>; var10 &lt; <span class="keyword">this</span>.parameterTypes.length; ++var10) &#123;</span><br><span class="line">                    var9.writeByte(<span class="number">89</span>);</span><br><span class="line">                    ProxyGenerator.<span class="keyword">this</span>.code_ipush(var10, var9);</span><br><span class="line">                    <span class="keyword">this</span>.codeWrapArgument(<span class="keyword">this</span>.parameterTypes[var10], var3[var10], var9);</span><br><span class="line">                    var9.writeByte(<span class="number">83</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var9.writeByte(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            var9.writeByte(<span class="number">185</span>);</span><br><span class="line">            var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getInterfaceMethodRef(<span class="string">"java/lang/reflect/InvocationHandler"</span>, <span class="string">"invoke"</span>, <span class="string">"(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;"</span>));</span><br><span class="line">            var9.writeByte(<span class="number">4</span>);</span><br><span class="line">            var9.writeByte(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 返回类型</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.returnType == Void.TYPE) &#123;</span><br><span class="line">                var9.writeByte(<span class="number">87</span>);</span><br><span class="line">                var9.writeByte(<span class="number">177</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.codeUnwrapReturnValue(<span class="keyword">this</span>.returnType, var9);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 写入方法处理异常字节信息</span></span><br><span class="line">            <span class="keyword">short</span> var6;</span><br><span class="line">            <span class="keyword">short</span> var8 = var6 = (<span class="keyword">short</span>) var2.code.size();</span><br><span class="line">            List var13 = ProxyGenerator.computeUniqueCatchList(<span class="keyword">this</span>.exceptionTypes);</span><br><span class="line">            <span class="keyword">if</span> (var13.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Iterator var11 = var13.iterator();</span><br><span class="line">                <span class="keyword">while</span> (var11.hasNext()) &#123;</span><br><span class="line">                    Class var12 = (Class) var11.next();</span><br><span class="line">                    var2.exceptionTable.add(<span class="keyword">new</span> ProxyGenerator.ExceptionTableEntry(var7, var8, var6, ProxyGenerator.<span class="keyword">this</span>.cp.getClass(ProxyGenerator.dotToSlash(var12.getName()))));</span><br><span class="line">                &#125;</span><br><span class="line">                var9.writeByte(<span class="number">191</span>);</span><br><span class="line">                var6 = (<span class="keyword">short</span>) var2.code.size();</span><br><span class="line">                var2.exceptionTable.add(<span class="keyword">new</span> ProxyGenerator.ExceptionTableEntry(var7, var8, var6, ProxyGenerator.<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/Throwable"</span>)));</span><br><span class="line">                ProxyGenerator.<span class="keyword">this</span>.code_astore(var4, var9);</span><br><span class="line">                var9.writeByte(<span class="number">187</span>);</span><br><span class="line">                var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/UndeclaredThrowableException"</span>));</span><br><span class="line">                var9.writeByte(<span class="number">89</span>);</span><br><span class="line">                ProxyGenerator.<span class="keyword">this</span>.code_aload(var4, var9);</span><br><span class="line">                var9.writeByte(<span class="number">183</span>);</span><br><span class="line">                var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/reflect/UndeclaredThrowableException"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"(Ljava/lang/Throwable;)V"</span>));</span><br><span class="line">                var9.writeByte(<span class="number">191</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var2.code.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"code size limit exceeded"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var2.maxStack = <span class="number">10</span>;</span><br><span class="line">                var2.maxLocals = (<span class="keyword">short</span>) (var4 + <span class="number">1</span>);</span><br><span class="line">                var2.declaredExceptions = <span class="keyword">new</span> <span class="keyword">short</span>[<span class="keyword">this</span>.exceptionTypes.length];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> var14 = <span class="number">0</span>; var14 &lt; <span class="keyword">this</span>.exceptionTypes.length; ++var14) &#123;</span><br><span class="line">                    var2.declaredExceptions[var14] = ProxyGenerator.<span class="keyword">this</span>.cp.getClass(ProxyGenerator.dotToSlash(<span class="keyword">this</span>.exceptionTypes[var14].getName()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> var2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>generateMethod 方法根据 <code>ProxyMethod</code> 信息，按照方法的构造组装代表字节码信息的 <code>MethodInfo</code>，最终将该信息写入到输出流中。</p><h2 id="MethodInfo"><a href="#MethodInfo" class="headerlink" title="MethodInfo"></a>MethodInfo</h2><p>ProxyMethod 对象经过解析后会组装成 MethodInfo 对象，该对象封装了代理类中方法的字节码信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> accessFlags;</span><br><span class="line">        <span class="comment">// 方法名</span></span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="comment">// 方法签名</span></span><br><span class="line">        <span class="keyword">public</span> String descriptor;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">short</span> maxStack;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">short</span> maxLocals;</span><br><span class="line">        <span class="comment">// 输出流，方法字节码会写入到该流中</span></span><br><span class="line">        <span class="keyword">public</span> ByteArrayOutputStream code = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">public</span> List&lt;ProxyGenerator.ExceptionTableEntry&gt; exceptionTable = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">short</span>[] declaredExceptions;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MethodInfo</span><span class="params">(String var2, String var3, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = var2;</span><br><span class="line">            <span class="keyword">this</span>.descriptor = var3;</span><br><span class="line">            <span class="keyword">this</span>.accessFlags = var4;</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(var2);</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(var3);</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(<span class="string">"Code"</span>);</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(<span class="string">"Exceptions"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略写入输出流逻辑</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="FieldInfo"><a href="#FieldInfo" class="headerlink" title="FieldInfo"></a>FieldInfo</h2><p>FieldInfo 用于封装方法在代理类中的静态属性信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> accessFlags;</span><br><span class="line">        <span class="comment">// m + N，方法在代理类中的字段名</span></span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="comment">// 固定值 Ljava/lang/reflect/Method;</span></span><br><span class="line">        <span class="keyword">public</span> String descriptor;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FieldInfo</span><span class="params">(String var2, String var3, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = var2;</span><br><span class="line">            <span class="keyword">this</span>.descriptor = var3;</span><br><span class="line">            <span class="keyword">this</span>.accessFlags = var4;</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(var2);</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(var3);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入输出流</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutputStream var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            var1.writeShort(<span class="keyword">this</span>.accessFlags);</span><br><span class="line">            var1.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(<span class="keyword">this</span>.name));</span><br><span class="line">            var1.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(<span class="keyword">this</span>.descriptor));</span><br><span class="line">            var1.writeShort(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>介绍完必要的前置概念和类信息后，我们回到 <code>ProxyGenerator.generateClassFile</code> 方法，继续接着流程往下分析。</p><h2 id="generateClassFile"><a href="#generateClassFile" class="headerlink" title="generateClassFile"></a>generateClassFile</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</span><br><span class="line">        <span class="comment">// 1. 将 Object 中的三大方法对象Method拆解，组装成 ProxyMethod 对象</span></span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(hashCodeMethod, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(equalsMethod, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(toStringMethod, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将目标类的接口中的方法对象Method拆解，组装成 ProxyMethod 对象</span></span><br><span class="line">        Class[] var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">        <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line">        <span class="keyword">int</span> var3;</span><br><span class="line">        Class var4;</span><br><span class="line">        <span class="comment">// 2.1 遍历接口</span></span><br><span class="line">        <span class="keyword">for</span> (var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            var4 = var1[var3];</span><br><span class="line">            <span class="comment">// 2.3 获取接口中的方法列表</span></span><br><span class="line">            Method[] var5 = var4.getMethods();</span><br><span class="line">            <span class="keyword">int</span> var6 = var5.length;</span><br><span class="line">            <span class="comment">// 2.4 遍历当前接口中的方法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> var7 = <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">                Method var8 = var5[var7];</span><br><span class="line">                <span class="comment">// 2.5 对接口中的方法拆解、组装成 ProxyMethod 对象，然后加入缓存 proxyMethods 中</span></span><br><span class="line">                <span class="keyword">this</span>.addProxyMethod(var8, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取缓存的方法代理对象 ProxyMethod 集合</span></span><br><span class="line">        Iterator var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line">        <span class="comment">// 校验相同方法签名的返回类型</span></span><br><span class="line">        List var12;</span><br><span class="line">        <span class="keyword">while</span> (var11.hasNext()) &#123;</span><br><span class="line">            var12 = (List) var11.next();</span><br><span class="line">            checkReturnTypes(var12);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator var15;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 生成构造方法字节码信息并加入到 methods 缓存起来</span></span><br><span class="line">            <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateConstructor());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 遍历方法代理对象列表，生成方法字节码信息并缓存到 methods 中</span></span><br><span class="line">            var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line">            <span class="keyword">while</span> (var11.hasNext()) &#123;</span><br><span class="line">                var12 = (List) var11.next();</span><br><span class="line">                var15 = var12.iterator();</span><br><span class="line">                <span class="keyword">while</span> (var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod) var15.next();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.1 生成方法的 FieldInfo 并加入到 fields 集合中，即代理类中方法Method的字段属性</span></span><br><span class="line">                    <span class="keyword">this</span>.fields.add(<span class="keyword">new</span> ProxyGenerator.FieldInfo(var16.methodFieldName, <span class="string">"Ljava/lang/reflect/Method;"</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.2 生成方法的 MethodInfo 并加入到 methods 集合中，注意 MethodInfo 中的 ByteArrayOutputStream</span></span><br><span class="line">                    <span class="keyword">this</span>.methods.add(var16.generateMethod());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 生成静态代码块字节码信息（根据 proxyMethods 中的信息）</span></span><br><span class="line">            <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateStaticInitializer());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"unexpected I/O Exception"</span>, var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 方法数量限制</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.methods.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"method limit exceeded"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.fields.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"field limit exceeded"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 代理类字节码组装</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.1. 处理代理类 和 Proxy 的全路径类，并入放入常量池 cp 中</span></span><br><span class="line">            <span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className));</span><br><span class="line">            <span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/Proxy"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.2. 处理代理类的接口，并放入常量池 cp 中</span></span><br><span class="line">            var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">            var2 = var1.length;</span><br><span class="line">            <span class="keyword">for</span> (var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                var4 = var1[var3];</span><br><span class="line">                <span class="keyword">this</span>.cp.getClass(dotToSlash(var4.getName()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.cp.setReadOnly();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.3. 字节类型数据的输出流，内存操作流</span></span><br><span class="line">            ByteArrayOutputStream var13 = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            DataOutputStream var14 = <span class="keyword">new</span> DataOutputStream(var13);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var14.writeInt(-<span class="number">889275714</span>);</span><br><span class="line">                var14.writeShort(<span class="number">0</span>);</span><br><span class="line">                var14.writeShort(<span class="number">49</span>);</span><br><span class="line">                <span class="keyword">this</span>.cp.write(var14);</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.accessFlags);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7.3.1 写入代理类名称信息</span></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className)));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7.3.2 写入Proxy名称信息</span></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/Proxy"</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7.3.4 写入接口列表</span></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.interfaces.length);</span><br><span class="line">                Class[] var17 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">                <span class="keyword">int</span> var18 = var17.length;</span><br><span class="line">                <span class="comment">// 遍历接口列表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> var19 = <span class="number">0</span>; var19 &lt; var18; ++var19) &#123;</span><br><span class="line">                    Class var22 = var17[var19];</span><br><span class="line">                    <span class="comment">// 写入接口信息</span></span><br><span class="line">                    var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(var22.getName())));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/// 7.3.5 写入字段信息，即接口方法的标识，如 m1、m2</span></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.fields.size());</span><br><span class="line">                var15 = <span class="keyword">this</span>.fields.iterator();</span><br><span class="line">                <span class="keyword">while</span> (var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo) var15.next();</span><br><span class="line">                    var20.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7.3.6 写入方法，包括构造方法、静态代码块</span></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.methods.size());</span><br><span class="line">                var15 = <span class="keyword">this</span>.methods.iterator();</span><br><span class="line">                <span class="keyword">while</span> (var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo) var15.next();</span><br><span class="line">                    var21.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line">                var14.writeShort(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4 返回字节数组信息</span></span><br><span class="line">                <span class="keyword">return</span> var13.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"unexpected I/O Exception"</span>, var9);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>generateClassFile 方法逻辑还是比较复杂的，下面对主要流程进行说明：</strong></p><ol><li>将 Object 中的三大方法对象解析、组装成 ProxyMethod 对象。</li><li>将目标类的接口中的方法对象解析、组装成 ProxyMethod 对象。</li><li>生成构造方法字节码信息并封装到 MethodInfo 对象中。</li><li>将第 1、2 步骤中组装的 ProxyMethod 对象进行解析，生成代表该方法字段标识的 FieldInfo 对象并缓存起来，解析为该方法的字节码信息的 MethodInfo 对象并缓存起来。</li><li>根据第 1、2 步骤中组装的 ProxyMethod 对象生成静态代码块字节码信息并封装到 MethodInfo 对象中并缓存起来。</li><li>对代理类中的方法数量做限制。</li><li>依次将代理类相关类路径、接口路径、代理类名、Proxy名、接口名、FieldInfo信息、MehodInfo信息写入到字节输出流中。</li><li>生成代理类字节码数组</li></ol><p>整个过程介绍完毕，下面对该过程中涉及的核心方法进行说明。</p><h3 id="addProxyMethod"><a href="#addProxyMethod" class="headerlink" title="addProxyMethod"></a>addProxyMethod</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将方法对象拆解，组装成 ProxyMethod 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var1 方法对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var2 方法所在接口/类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addProxyMethod</span><span class="params">(Method var1, Class&lt;?&gt; var2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 方法名</span></span><br><span class="line">        String var3 = var1.getName();</span><br><span class="line">        <span class="comment">// 2 方法参数类型</span></span><br><span class="line">        Class[] var4 = var1.getParameterTypes();</span><br><span class="line">        <span class="comment">// 3 方法返回类型</span></span><br><span class="line">        Class var5 = var1.getReturnType();</span><br><span class="line">        <span class="comment">// 4 方法异常类型</span></span><br><span class="line">        Class[] var6 = var1.getExceptionTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 方法签名，如 hashCode()、equals(Ljava/lang/Object;)，最为缓存的 key</span></span><br><span class="line">        String var7 = var3 + getParameterDescriptors(var4);</span><br><span class="line"></span><br><span class="line">        Object var8 = (List) <span class="keyword">this</span>.proxyMethods.get(var7);</span><br><span class="line">        <span class="keyword">if</span> (var8 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator var9 = ((List) var8).iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (var9.hasNext()) &#123;</span><br><span class="line">                ProxyGenerator.ProxyMethod var10 = (ProxyGenerator.ProxyMethod) var9.next();</span><br><span class="line">                <span class="keyword">if</span> (var5 == var10.returnType) &#123;</span><br><span class="line">                    ArrayList var11 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                    collectCompatibleTypes(var6, var10.exceptionTypes, var11);</span><br><span class="line">                    collectCompatibleTypes(var10.exceptionTypes, var6, var11);</span><br><span class="line">                    var10.exceptionTypes = <span class="keyword">new</span> Class[var11.size()];</span><br><span class="line">                    var10.exceptionTypes = (Class[]) var11.toArray(var10.exceptionTypes);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var8 = <span class="keyword">new</span> ArrayList(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">this</span>.proxyMethods.put(var7, var8);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 ProxyMethod 对象，并保存到 proxyMethods 中</span></span><br><span class="line">        ((List) var8).add(<span class="keyword">new</span> ProxyGenerator.ProxyMethod(var3, var4, var5, var6, var2));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述方法用于将 <code>Method</code> 对象拆解、组装为 <code>ProxyMethod</code> 对象，为后续组装代理类的方法字节码做准备。</p><h3 id="generateConstructor"><a href="#generateConstructor" class="headerlink" title="generateConstructor"></a>generateConstructor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line">    <span class="keyword">private</span> ProxyGenerator.<span class="function">MethodInfo <span class="title">generateConstructor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建构造方法字节码的 MethodInfo</span></span><br><span class="line">        ProxyGenerator.MethodInfo var1 = <span class="keyword">new</span> ProxyGenerator.MethodInfo(<span class="string">"&lt;init&gt;"</span>, <span class="string">"(Ljava/lang/reflect/InvocationHandler;)V"</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入 MethodInfo 的输出流中</span></span><br><span class="line">        DataOutputStream var2 = <span class="keyword">new</span> DataOutputStream(var1.code);</span><br><span class="line">        <span class="keyword">this</span>.code_aload(<span class="number">0</span>, var2);</span><br><span class="line">        <span class="keyword">this</span>.code_aload(<span class="number">1</span>, var2);</span><br><span class="line">        var2.writeByte(<span class="number">183</span>);</span><br><span class="line">        var2.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/reflect/Proxy"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"(Ljava/lang/reflect/InvocationHandler;)V"</span>));</span><br><span class="line">        var2.writeByte(<span class="number">177</span>);</span><br><span class="line">        var1.maxStack = <span class="number">10</span>;</span><br><span class="line">        var1.maxLocals = <span class="number">2</span>;</span><br><span class="line">        var1.declaredExceptions = <span class="keyword">new</span> <span class="keyword">short</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> var1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>generateConstructor 方法用于生成构造方法的字节码信息。</p><h3 id="generateStaticInitializer"><a href="#generateStaticInitializer" class="headerlink" title="generateStaticInitializer"></a>generateStaticInitializer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"> <span class="keyword">private</span> ProxyGenerator.<span class="function">MethodInfo <span class="title">generateStaticInitializer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ProxyGenerator.MethodInfo var1 = <span class="keyword">new</span> ProxyGenerator.MethodInfo(<span class="string">"&lt;clinit&gt;"</span>, <span class="string">"()V"</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">byte</span> var2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> var4 = <span class="number">0</span>;</span><br><span class="line">        DataOutputStream var6 = <span class="keyword">new</span> DataOutputStream(var1.code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法列表</span></span><br><span class="line">        Iterator var7 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line">        <span class="comment">// 根据方法信息初始化对应的字段</span></span><br><span class="line">        <span class="keyword">while</span> (var7.hasNext()) &#123;</span><br><span class="line">            List var8 = (List) var7.next();</span><br><span class="line">            Iterator var9 = var8.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (var9.hasNext()) &#123;</span><br><span class="line">                ProxyGenerator.ProxyMethod var10 = (ProxyGenerator.ProxyMethod) var9.next();</span><br><span class="line">                <span class="comment">// 方法字段初始化</span></span><br><span class="line">                var10.codeFieldInitialization(var6);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        var6.writeByte(<span class="number">177</span>);</span><br><span class="line">        <span class="keyword">short</span> var3;</span><br><span class="line">        <span class="keyword">short</span> var5 = var3 = (<span class="keyword">short</span>) var1.code.size();</span><br><span class="line">        var1.exceptionTable.add(<span class="keyword">new</span> ProxyGenerator.ExceptionTableEntry(var4, var5, var3, <span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/NoSuchMethodException"</span>)));</span><br><span class="line">        <span class="keyword">this</span>.code_astore(var2, var6);</span><br><span class="line">        var6.writeByte(<span class="number">187</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/NoSuchMethodError"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">89</span>);</span><br><span class="line">        <span class="keyword">this</span>.code_aload(var2, var6);</span><br><span class="line">        var6.writeByte(<span class="number">182</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/Throwable"</span>, <span class="string">"getMessage"</span>, <span class="string">"()Ljava/lang/String;"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">183</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/NoSuchMethodError"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"(Ljava/lang/String;)V"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">191</span>);</span><br><span class="line">        var3 = (<span class="keyword">short</span>) var1.code.size();</span><br><span class="line">        var1.exceptionTable.add(<span class="keyword">new</span> ProxyGenerator.ExceptionTableEntry(var4, var5, var3, <span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/ClassNotFoundException"</span>)));</span><br><span class="line">        <span class="keyword">this</span>.code_astore(var2, var6);</span><br><span class="line">        var6.writeByte(<span class="number">187</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/NoClassDefFoundError"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">89</span>);</span><br><span class="line">        <span class="keyword">this</span>.code_aload(var2, var6);</span><br><span class="line">        var6.writeByte(<span class="number">182</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/Throwable"</span>, <span class="string">"getMessage"</span>, <span class="string">"()Ljava/lang/String;"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">183</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/NoClassDefFoundError"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"(Ljava/lang/String;)V"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">191</span>);</span><br><span class="line">        <span class="keyword">if</span> (var1.code.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"code size limit exceeded"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var1.maxStack = <span class="number">10</span>;</span><br><span class="line">            var1.maxLocals = (<span class="keyword">short</span>) (var2 + <span class="number">1</span>);</span><br><span class="line">            var1.declaredExceptions = <span class="keyword">new</span> <span class="keyword">short</span>[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> var1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>generateStaticInitializer 方法用于生成代理类的静态代码块信息。</p><p>至此，JDK 动态代理的整个流程介绍完毕。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JDK 动态代理是针对接口做的代理，目标类没有实现接口是无法通过这个方式创建代理对象。通过拼接字节码生成类是十分灵活的，理论上不管是有接口的类还是普通类都是可以实现代理的，CGLIB 就是通过拼接字节码来实现非接口类的代理逻辑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Java 中代理分为两大类，一类是静态代理，另一类是动态代理。静态代理是针对需要被代理的类在编译之前就已经写好了对应的代理类，也就是说代理关
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="代理" scheme="https://gentryhuang.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>并发 - 线程池工具类</title>
    <link href="https://gentryhuang.com/posts/9e3a7d05/"/>
    <id>https://gentryhuang.com/posts/9e3a7d05/</id>
    <published>2020-12-09T16:00:00.000Z</published>
    <updated>2020-12-24T13:19:46.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章 <a href="https://gentryhuang.com/posts/d7cef21d/">线程池</a> 对线程池的原理进行了说明，并对线程池的源码进行了深入分析，本篇文章对线程工具类 Executors 进行分析，需要说明的是 Executors 中除了并行计算的 WorkStealingPool 线程池，其它的都是直接基于 ThreadPoolExecutor 来实现的。本篇文章主要说明 Executors 基于 ThreadPoolExecutor 创建的线程池。</p><h1 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h1><p>FixedThreadPool 属于固定线程数的线程池，使用 Executors.newFixedThreadPool()  方法创建。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li>指定线程数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建固定数量的线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nThreads 核心线程数 = 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>指定线程数和线程工厂<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建固定数量的线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nThreads      核心线程数 = 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory 线程工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">            threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>核心线程数和最大线程数一致，并且使用的任务队列为无界队列。线程池中的线程数随着任务的提交会从 0 增加到核心线程数 nThreads，完成预热之后，线程池中的线程数将会保持 nThreads，之后的任务提交一律放入任务队列中，由空闲的核心线程从队列取出并执行。如果有工作线程退出，线程池将会创建新的工作线程以补足执行的数目 nThreads 。此外，由于使用的是无界队列，隐藏的默认拒绝策略是无效的，并且默认情况下线程池是不会回收核心线程数内的线程，keepAliveTime 同样是个无效参数。</p><h2 id="运行示意图"><a href="#运行示意图" class="headerlink" title="运行示意图"></a>运行示意图</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/concurrent-threadpool-fixed.jpg" alt></p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>适用于为了满足资源管理的需求，而需要限制线程数量的应用场景。</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>由于使用了无界的任务队列，当大量的任务提交到线程池，可能会造成任务堆积，而线程池的拒绝策略又处于失效状态，从而导致 OOM 。</p><h1 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h1><p>SingleThreadExecutor 属于固定线程数的线程池，使用 Executors.newSingleThreadExecutor()  方法创建。</p><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建单个线程的线程池</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">             <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">             <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建单个线程的线程池</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> threadFactory 线程工厂</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">             <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">             <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">             threadFactory));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>SingleThreadExecutor 和 FixedThreadPool 基本一致，区别在于前者的核心线程数和最大线程数固定为 1 ，并且是一个包装 ThreadPoolExecutor 的线程池，支持调用 finalize() 方法通知垃圾收集器时关闭线程池。</p><h2 id="运行示意图-1"><a href="#运行示意图-1" class="headerlink" title="运行示意图"></a>运行示意图</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/concurrent-threadpool-single.jpg" alt></p><h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><p>保证了所有任务都是被顺序执行，任意时间点最多会有一个任务处于活动状态。</p><h2 id="存在问题-1"><a href="#存在问题-1" class="headerlink" title="存在问题"></a>存在问题</h2><p>和 FixedThreadPool 是一样的问题，使用了无界的任务队列，当大量的任务提交到线程池，可能会造成任务堆积，而线程池的拒绝策略又处于失效状态，从而导致 OOM 。</p><h1 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h1><p>CachedThreadPool 属于缓冲线程池，会根据需要创建新线程。使用 Executors.newCachedThreadPool()  方法创建。</p><h2 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">            <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">            <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">            threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><p>核心线程数为 0 ，最大线程数为 <strong>Integer.MAX_VALUE</strong>，可以认为是无界的。使用的任务队列是没有容量的 <strong>SynchronousQueue</strong> ，即线程池使用这个队列意味着每次都要创建新的线程来处理任务。 keepAliveTime 被设置为 60L，单位为 TimeUnit.SECONDS ，意味着 CachedThreadPool 中的空闲线程等待任务的最大时长为 60s 。</p><p>CachedThreadPool 总体上有以下几个特点：</p><ol><li>无核心线程数，且最大的线程数是 <strong>Integer.MAX_VALUE</strong> 。</li><li>任务队列并不会存储任务，如果有空闲线程则队列会把任务交给空闲线程执行，如果没有空闲线程则迫使线程池尝试创建一个新的线程执行任务。这个特点是任务队列 <strong>SynchronousQueue</strong> 提供的。</li><li>由于 keepAliveTime 被设置为 60L，因此会在该时间内缓存线程，被缓存的线程会等待 <strong>SynchronousQueue</strong> 队列中的任务。</li><li>线程池长时间闲置得话也不会消耗什么资源，因为线程池中的线程都是可回收的，和固定线程数的线程池不同，核心线程会不断轮询任务（不开启回收核心线程）。</li></ol><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>一个比较特殊的阻塞队列，其本身不存储元素。每个插入操作必须等待另一个线程执行移除操作，反之亦然。如果使用该阻塞队列，只有当两个线程执行相反模式的操作才能配对成功，否则先执行的一方只能等待。下图是对线程池使用该队列处理任务过程的描述：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-syncronousqueue.jpg" alt></p><h2 id="运行示意图-2"><a href="#运行示意图-2" class="headerlink" title="运行示意图"></a>运行示意图</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/concurrent-threadpool-cacheed.jpg" alt></p><h2 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h2><p>处理大量短时间任务，或者负载较轻的服务器。</p><h2 id="存在问题-2"><a href="#存在问题-2" class="headerlink" title="存在问题"></a>存在问题</h2><p>由于允许创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程最终超过了操作系统的上限而无法创建新线程，容易导致 CPU 飙升和 OOM。</p><h1 id="Executors-创建线程问题"><a href="#Executors-创建线程问题" class="headerlink" title="Executors 创建线程问题"></a>Executors 创建线程问题</h1><p>Executors 工具类创建的线程池都会存在一定的风险，相比较而言手动创建线程池更加合理，因为可以根据不同的场景对线程池进行定制，来提升程序的性能和减少资源消耗。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>无论是使用 Executors 工具类还是定制线程池，都应该避免任务大量堆积，否则可能出现 OOM ；还应该避免过度创建新线程，否则可能由于创建大量线程导致系统崩溃。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇文章 &lt;a href=&quot;https://gentryhuang.com/posts/d7cef21d/&quot;&gt;线程池&lt;/a&gt; 对线程池的原
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>并发 - 线程池</title>
    <link href="https://gentryhuang.com/posts/d7cef21d/"/>
    <id>https://gentryhuang.com/posts/d7cef21d/</id>
    <published>2020-12-02T16:00:00.000Z</published>
    <updated>2021-03-12T06:10:39.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最初的时候并没有线程池的概念，而是先有线程。每个任务都需要对应一个线程，任务少的情况没有太大问题，任务过多就出现了各种性能和资源开销问题，更重要的是可创建线程的数量是有上限的，不可能无限的创建。在并发环境下，系统不能够确定在某一时刻有多少任务需要执行，有多少资源需要投入。</p><p>针对上述问题，于是诞生了线程池，用来平衡线程与系统资源之间的关系。<strong>线程池解决问题思路</strong>如下：</p><ol><li>对于反复创建线程开销问题，线程池采用固定数量的线程一直保持工作状态并能反复执行任务。</li><li>对于创建过多线程占用太多资源问题，线程池会根据需要创建线程，灵活地控制线程数量，避免使用过多资源。</li></ol><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>线程池是一种<strong>管理线程和任务的工具</strong>，是应用场景最多的并发框架之一，几乎所有需要异步或并发执行任务的应用程序都可以使用线程池，合理地使用线程池可以带来可观得性能提升和响应速度。具体好处如下：</p><ul><li>解耦：线程的创建与任务执行完全分开。</li><li>降低资源消耗：线程的复用降低了线程创建和销毁带来的资源消耗。</li><li>提高响应速度：大多情况下（线程池预热后），到达的任务可以不需要等待线程创建就能立即执行，消除了线程创建所带来的延迟，提升了响应速度。</li><li>便于线程管理：线程是稀缺资源，不能无限制地创建，使用线程池可以对线程进行统一分配、调优和监控。</li></ul><p>关于线程池的概述就介绍这么多，本篇文章介绍的线程池核心是 JDK 中提供的 <code>ThreadPoolExecutor</code> 类，具体涉及的接口和实现类如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-threadpoolexecutor-base-uml.jpg" alt></p><p>需要说明的是，关于<strong>Scheduled类型</strong>的线程池继承体系本篇文章没有介绍到，它是基于本篇文章着重介绍的 <strong>ThreadPoolExecutor</strong> 的扩展实现，支持时间纬度执行任务。</p><h1 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h1><p>线程池的设计没有办法直接采用一般意义上池化资源方案，而是采用<strong>生产者 - 消费者</strong>模式，将任务和线程解耦并不直接关联，从而良好的缓冲任务、复用线程，缓冲任务通过阻塞队列实现，工作线程从阻塞队列中获取任务以实现线程复用。线程池的使用方是生产者，线程池本身是消费者。至于为什么线程池没有采用一般意义上池化资源的设计方法，这个取决于线程对象的特殊性，线程有着特殊的生命周期，一旦一个线程启动执行任务就不能再次启动了。</p><h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><p>任务的执行不一定非要通过开启新线程，任务在线程执行之前它也是一个实现类，也有对应的方法。因此我们可以定义出方法级别调用和线程级别调用。</p><h3 id="线程级别调用"><a href="#线程级别调用" class="headerlink" title="线程级别调用"></a>线程级别调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">      &#125;).start();</span><br></pre></td></tr></table></figure><h3 id="方法级别调用"><a href="#方法级别调用" class="headerlink" title="方法级别调用"></a>方法级别调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((Runnable) () -&gt; &#123;</span><br><span class="line">          <span class="comment">//..</span></span><br><span class="line">        &#125;).run();</span><br></pre></td></tr></table></figure><p>线程池对任务的处理最终是通过方法级别调用的来完成，在后面分析源码的时候我们可以看到。</p><h2 id="Executor-框架"><a href="#Executor-框架" class="headerlink" title="Executor 框架"></a>Executor 框架</h2><p>Executor 是一个异步任务的框架，根据一组执行策略进行调用、调度、执行和控制，目的是提供一种将<strong>任务提交</strong>和<strong>任务执行</strong>分离的机制。 </p><h3 id="两级调度模型"><a href="#两级调度模型" class="headerlink" title="两级调度模型"></a>两级调度模型</h3><p>最早 Java 的线程既是任务体也是执行机制，从 JDK5 开始，把任务体和执行机制进行了分离。任务体包括 Runnable 和 Callable，而执行机制由 Executor 框架提供，即 <strong>Executor是 Runnable 和 Callable 的调度容器</strong>。</p><p>Java 线程会被一对一映射为操作系统线程，在 Java 线程启动时创建对应的操作系统线程，同样地，当该 Java 线程终止时对应的操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的 CPU 。对于计算复杂的应用，我们通常会将其拆解为若干个任务并交给 Java 多个线程，这个动作是由用户级别的调度器 Executor 框架完成的，它会将这若干个任务映射为对应数量的线程。在底层，操作系统内核将这些线程映射到硬件处理器上。由此可见，创建一个线程远比创建一个对象要复杂得多，不仅要在 JVM 堆中分配内存，还需要调用操作系统内核 API 来为线程分配资源，因此应该避免频繁创建和销毁。</p><p>这个过程属于两级调度模型，对应的示意图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-executor.jpg" alt></p><p>从示意图可看出，应用程序通过 Executor 框架控制上层的调度。而下层的调度由操作系统内核控制，应用程序是无法控制的。</p><h3 id="Executor-框架结构"><a href="#Executor-框架结构" class="headerlink" title="Executor 框架结构"></a>Executor 框架结构</h3><p>Executor 框架主要由三大部分组成，具体如下：</p><ul><li>任务体<br>包括 Runnable 接口和 Callable 接口及其实现。</li><li>任务的执行<br>包括任务执行机制的核心接口 Executor，继承 Executor 的 ExecutorService 接口和它的实现们。</li><li>异步计算结果<br>包括核心接口 Future 以及对应的实现们，特别是 FutureTask 实现类。是对具体 Runnable 或者 Callable 任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作。</li></ul><h3 id="Executor-框架成员"><a href="#Executor-框架成员" class="headerlink" title="Executor 框架成员"></a>Executor 框架成员</h3><p>Executor 框架是线程池实现的基础，它的主要成员有 <code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code>、<code>Executors</code>、<code>Runnable</code>、<code>Callable</code> 以及 <code>Future</code> 。</p><p>下面正式进入到代码层面的介绍，定时任务实现类 <code>ScheduledThreadPoolExecutor</code> 继承自 <code>ThreadPoolExecutor</code> ，用于实现定时执行，本文暂不介绍它的实现。</p><h3 id="Executor-接口"><a href="#Executor-接口" class="headerlink" title="Executor 接口"></a>Executor 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Runable 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executor 接口仅定义了一个方法，参数是 Runnable 类型，该方法的目的是<strong>将任务提交和任务执行细节解耦</strong>。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需将任务提交到执行器 Executor 中，由执行器完成线程的调配和任务的执行。需要注意的是，该接口是没有返回值的，也就意味着无法判断提交的任务是否被线程池执行成功。</p><h3 id="ExecutorService-接口"><a href="#ExecutorService-接口" class="headerlink" title="ExecutorService 接口"></a>ExecutorService 接口</h3><p>ExecutorService 接口继承自 Executor 接口，一般我们自定义线程池时使用的就是这个接口，该接口中定义的方法加上继承过来的 <strong>execute</strong> 方法在很多场景中已经可以满足需求了。</p><p>该接口中的方法如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-executorservice-method.jpg" alt></p><p>上图中的方法大致分类如下：</p><ol><li>向线程池提交任务方法<blockquote><p><strong>submit</strong> 方法和前文中的 <strong>Executor</strong> 接口中的 <strong>execute</strong> 方法有所不同，虽然也是向线程池提交任务，但是有返回值 Future ，并且参数类型不仅支持 <strong>Runnable</strong> 类型还支持 Callable 类型。</p></blockquote></li><li>执行任务方法<blockquote><p><strong>invokeAll</strong> 方法用于执行多个任务，同时支持设置超时时间。<strong>invokeAny</strong> 方法用于执行多个方法中的一个即可，任务执行完成就可以返回，同样支持设置超时时间。这两类方法的底层需要依赖 execute 方法。</p></blockquote></li><li>关闭线程池方法<blockquote><p><strong>shutdown</strong> 和 <strong>shutdownNow</strong> 方法用于关闭线程池。</p></blockquote></li><li>判断线程池是否关闭<blockquote><p><strong>isShutdown</strong> 判断线程池是否已经开始了关闭工作，即是否执行了 shutdown 或者 shutdownNow 方法。注意，该方法返回 true 并不代表线程池此时已经彻底关闭了，仅说明线程池开始了关闭的流程，此时线程池中可能依然有线程在执行任务，队列中仍有等待被执行的任务。</p></blockquote></li><li>判断线程池是否终止方法<blockquote><p><strong>isTerminated</strong> 和 <strong>awaitTermination</strong> 方法用于判断线程池是否终止。只有在调用关闭方法后才有调用的意义。</p></blockquote></li></ol><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future 的继承体系如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-future-hierarchy.jpg" alt></p><p>由上图的UML可知，FutureTask 通过 RunnableFuture 间接实现了 Runnable 接口，因此 <code>Executor.execute</code> 方法支持将 FutureTask 提交到线程池。接下来介绍 AbstractExecutorService 抽象实现类就能很清晰看出 FutureTask 的作用。</p><h3 id="AbstractExecutorService-实现"><a href="#AbstractExecutorService-实现" class="headerlink" title="AbstractExecutorService 实现"></a>AbstractExecutorService 实现</h3><p>AbstractExecutorService 抽象类实现自 ExecutorService 接口，在其基础上实现了几个常用的方法，这些方法供子类进行调用。<strong>将执行任务的流程串联起来，保证下层的实现（如 ThreadPoolExecutor）只需关注执行任务的方法即可</strong>。具体方法如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-abstract-method.jpg" alt></p><p>由于 <strong>invokeAll</strong> 方法和 <strong>invokeAny</strong> 方法更多的是执行将任务提交给线程池前的工作，它们并没有将任务提交给线程池，需要通过 Executor 中的 execute 方法实现，而 execute 方法最终要交给具体子类实现。因此，不再对这两类方法展开说明。下面重点介绍下 <strong>newTaskFor</strong> 方法和 <strong>submit</strong> 方法。</p><h4 id="newTaskFor-方法"><a href="#newTaskFor-方法" class="headerlink" title="newTaskFor 方法"></a>newTaskFor 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractExecutorService</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 Runnable 包装成 FutureTask</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value    任务执行成功的返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 Callable 包装成 FutureTask</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，<strong>newTaskFor</strong>  方法用于将 Runnable 和 Callable 类型的任务统一包装成 FutureTask ，FutureTask 又间接继承了 Runnable 接口。我们知道，Runnable 的 <strong>void run()</strong> 方法是没有返回值的， 而 Callable 的 <strong>V call()</strong> 方法是有返回值的，但 Executor 中的 <strong>void execute(Runnable command)</strong>方法是不关心返回结果的，它只负责处理 Runnable 类型的任务。综上，不难看出 <strong>newTaskFor</strong> 方法就是为了屏蔽不同类型任务的差异，以达到统一交给 <strong>Executor.execute</strong> 执行的目的。下面我们继续看提交任务的另外一种方式。</p><h4 id="submit-提交任务"><a href="#submit-提交任务" class="headerlink" title="submit 提交任务"></a>submit 提交任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractExecutorService</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交 Runnable 任务，不需要返回结果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交 Runnable 任务，任务执行成功的返回结果为 result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交 Callable 任务，任务执行成功返回结果是Callable#call 方法返回值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Runnable 的 <strong>void run()</strong> 方法没有返回值，但是有的时候我们需要返回值，这个时候 <strong>submit</strong> 方法就可以实现，只需在该方法的第二个参数传入预期结果，当任务执行完成后会自动返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span></span><br></pre></td></tr></table></figure><p>此外，我们可以看出 <strong>submit</strong> 方法提交任务的能力是通过 <strong>execute</strong> 方法实现的。定义于最上层接口 Executor 中的 <strong>void execute(Runnable command)</strong> 方法不会返回执行结果，想要执行结果就需要通过 FutureTask 包装任务，然后将包装后的任务 <strong>FutureTask</strong> 交给 <strong>Executor.execute</strong> 方法执行，执行后的结果也会保存到 <strong>FutureTask</strong> 中。关于 Future 的继承体系不展开分析，下面概述下 submit 提交任务的原理。</p><ol><li>调用 newTaskFor 方法将 Runnable 和 Callable 类型的任务统一包装成 FutureTask 对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callable</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;      </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Runnable</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将 Runnable 适配成 Callable</span></span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Runnable task;</span><br><span class="line">        <span class="keyword">final</span> T result;</span><br><span class="line">        RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务执行还是调用 run 方法，返回结果是传入的预期值</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            task.run();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>包装的本质是将任务统一适配为Callable类型，因为Callable类型任务可以通过call方法返回执行结果。</li><li>当任务执行的时候，FutureTask 中的 run 方法会执行，这个过程是最关键的一步。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">           !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                        <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Callable&lt;V&gt; c = callable;</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">               V result;</span><br><span class="line">               <span class="keyword">boolean</span> ran;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 被适配的Runnable 和 Callable 方法级别调用</span></span><br><span class="line">                   result = c.call();</span><br><span class="line">                   ran = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                   result = <span class="keyword">null</span>;</span><br><span class="line">                   ran = <span class="keyword">false</span>;</span><br><span class="line">                   setException(ex);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (ran)</span><br><span class="line">                   <span class="comment">// 将执行结果保存到 FutureTask 中</span></span><br><span class="line">                   set(result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">           <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">           runner = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">           <span class="comment">// leaked interrupts</span></span><br><span class="line">           <span class="keyword">int</span> s = state;</span><br><span class="line">           <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">               handlePossibleCancellationInterrupt(s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>通过FutureTask#get方法从 FutureTask 中取出任务执行结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> s = state;</span><br><span class="line">      <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">          s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">      <span class="comment">// 从 FutureTask 中取出任务执行结果</span></span><br><span class="line">      <span class="keyword">return</span> report(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">int</span> s = state;</span><br><span class="line">      <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">          (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">     <span class="comment">// 从 FutureTask 中取出任务执行结果</span></span><br><span class="line">      <span class="keyword">return</span> report(s);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="提交任务方式"><a href="#提交任务方式" class="headerlink" title="提交任务方式"></a>提交任务方式</h4><p>最上层接口 Executor 中的 <strong>void execute(Runnable)</strong> 不需要获取结果，不会使用 FutureTask 包装任务。抽象实现类 AbstractExecutorService 中的 <strong>Future&lt;?&gt; submit()</strong> 需要获取结果，因此使用了 FutureTask 包装任务。</p><blockquote><p>需要获取任务结果用 submit 方法，不需要获取结果用 execute 方法。</p></blockquote><h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-principle.jpg" alt></p><p>上图展示了线程池的运行机制，线程池运行机制主要分成两个部分，线程管理和任务管理。下面对线程池的主要处理流程进行说明：</p><ol start="0"><li>主线程提交任务到线程池。</li><li>如果当前线程池中的线程少于核心线程数，则创建新的线程来执行任务。</li><li>如果线程池中的线程达到或超过核心线程数，则将任务加入到阻塞队列中。</li><li>如果在第 2 步中无法将任务加入阻塞队列，则依据最大线程数创建新的线程来处理任务。</li><li>如果在第 3 步创建新线程会使线程池中线程数超出最大线程数，任务将被拒绝并使用饱和策略处理（拒绝策略）。</li><li>处理完任务的线程会自旋获取新的任务去执行，当线程获取不到任务时，线程会被回收（一般针对非核心线程）。</li></ol><p>其中第 1 步和第 3 步涉及到创建线程，该过程需要获取全局锁，因为关闭线程池也需要获取这个全局锁。当线程池完成了<strong>预热</strong>即核心线程数创建完毕，在一定程度上就不需要频繁创建线程，也就降低了获取全局锁的频次，对于线程池来说全局锁是一个严重的可伸缩瓶颈。关于流程中的概念下文会陆续说明。</p><h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>线程池核心实现就在 <strong>ThreadPoolExecutor</strong> 实现类中，该类实现了线程池所需的各个方法，包括最核心的 <strong>execute</strong> 方法。开发者可以基于该实现类来进行功能上的扩展，定时任务实现类 <code>ScheduledThreadPoolExecutor</code> 就是基于 <code>ThreadPoolExecutor</code> 扩展的功能。</p><p>在详细介绍 <code>ThreadPoolExecutor</code> 运行机制之前，我们先对其核心概念，属性、方法等进行简单介绍。</p><h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // 核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize, // 最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime, // 空闲线程存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit, // 空闲线程存活时间的单位</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory, // 线程工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                           RejectedExecutionHandler handler // 饱和策略</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;<span class="comment">//...&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>corePoolSize</strong><blockquote><p>核心线程数，线程池的基本大小。当提交一个任务到线程池时，线程池会创建一个基本线程来执行任务，即使其它空闲的基本线程能够执行新任务也会创建线程，只有线程池预热完毕（线程池中线程数达到核心线程数）才不再创建核心线程。</p></blockquote></li></ul><p><strong>特别说明：</strong></p><ol><li>核心线程并不是特指某一个或某几个线程，而是针对设置的核心线程数而言，任何一个线程都可以是核心线程。</li><li>corePoolSize 表示的是线程池的常驻线程数，如果设置为 0 则表示在没有任何任务时需要销毁线程池。如果大于 0 ，即使没有任务时也会保证线程池的线程数等于此值。</li><li>关于此值设置的合理性，如果设置的较小，则会频繁的创建和销毁线程（非核心线程）；设置过大，则会浪费资源。</li></ol><ul><li><p><strong>maximumPoolSize</strong></p><blockquote><p>最大线程数，线程池允许创建的最大线程数，最大线程数 = 核心线程数 + 非核心线程数。此值只有在任务比较多且阻塞队列放不下时才会用到。</p></blockquote></li><li><p><strong>keepAliveTime</strong></p><blockquote><p>空闲线程存活时间，线程池中的线程空闲时间超过该值也没任务可做那么就需要回收销毁。如果设置为 0，表示一旦空闲立即回收。该参数一般只会对非核心线程起作用，核心线程不会因为空闲太长时间而被关闭，当最大线程数等于核心线程数时，那么线程池在空闲的时候也不会销毁任何线程。但是可通过调用 <strong>allowCoreThreadTimeOut(true)</strong> 方法使核心线程数内的线程也可以被回收。</p></blockquote></li><li><p><strong>unit</strong></p><blockquote><p>和 keepAliveTime 参数一起使用，是时间单位。如：天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）等。</p></blockquote></li><li><p><strong>workQueue</strong></p><blockquote><p>用于存放等待执行的任务的阻塞队列，是 BlockingQueue 接口的实现。当线程池中的线程数大于等于核心线程数时才会用到该队列，注意和有没有空闲核心线程无关。</p></blockquote></li><li><p><strong>threadFactory</strong></p><blockquote><p>线程工厂，线程池中的线程就由它创建。如果没有设置就使用默认的线程工厂。</p></blockquote></li><li><p><strong>handler</strong></p><blockquote><p>饱和策略（拒绝策略），当阻塞队列和线程池都满了，说明线程池处于饱和状态，需要采取一种策略处理提交的新任务，默认是直接抛出异常。</p></blockquote></li></ul><p><strong>通过配置不同的参数，就可以创建出行为不同的线程池，这也是线程池高度灵活性的基础。</strong></p><h2 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">--- ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">     <span class="comment">//======= 约定使用32位表示线程池状态和数量，高3位表示状态 ，低29位表示数量 =============/</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池初始化状态码，状态为 RUNNING，线程数为 0</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * COUNT_BITS 为 29 (0001 1101)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池允许最大线程池临界值，1 * 2^29 = 536870912</span></span><br><span class="line"><span class="comment">      * 过程：（1）001 （2）左移29位得到001后跟29个0 -&gt; 0010 0000 0000 0000 0000 0000 0000 0000 （3）减去1得0001 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 运行状态：111 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 关闭状态：000 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN = <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 停止状态：001 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 整理状态：010 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING = <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 终止状态：011 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 获取线程池的状态。将整数 c 的低 29 位置为 0 就得到了线程池的状态</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &amp; ~CAPACITY;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 用于计算线程池中线程数量。将整数 c 的高 3 位置为 0，就得到了线程池中的线程数</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 获取线程池状态码</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> rs | wc;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 比较状态</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &lt; s;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 当前线程池是否处于运行状态</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 增加线程池中的线程数量</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndIncrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 减少线程池中的线程数量</span></span><br><span class="line"><span class="comment">      * Attempts to CAS-decrement the workerCount field of ctl.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndDecrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementWorkerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">         &#125; <span class="keyword">while</span> (!compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池阻塞队列</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池全局锁</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 1.用于保存和移除线程池创建的Worker，用来控制线程的生命周期。</span></span><br><span class="line"><span class="comment">      * 2.对于垃圾回收来说，即使Worker中封装的thread完成了任务的执行（包括异常情况），但是如果Worker不被回收那么thread仍然被强引用着。</span></span><br><span class="line"><span class="comment">      * 3.该Hash表是线程不安全的，操作时需要加全局锁</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 全局锁条件 - 条件队列</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 追踪线程池最大值，仅在获取到全局锁条件下执行</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池完成任务数量</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程工厂</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 饱和策略</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 保活时间，即最大允许空闲时间</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 是否允许核心线程被回收</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 核心线程池数，不会被回收，即 workers的最小值。除非设置 allowCoreThreadTimeOut 。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 最大线程数</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 默认的饱和策略，直接抛出异常</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> AbortPolicy();</span><br></pre></td></tr></table></figure><p>上面的属性都很重要，其中还包含了部分属性的操作方法，这些都会在下面的源码分析中不断出现。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Public constructors and methods 构造方法们</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">              Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">              threadFactory, defaultHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">              <span class="comment">// 当没有指定线程工厂时，使用默认的线程创建工厂</span></span><br><span class="line">              Executors.defaultThreadFactory(), handler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">              maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">              maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">              keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">              <span class="keyword">null</span> :</span><br><span class="line">              AccessController.getContext();</span><br><span class="line">      <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">      <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">      <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">      <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">      <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">      <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>创建线程池时如果不指定线程工厂则会使用默认的线程工厂，默认线程工厂创建的线程都属于同一个线程组，拥有相同的优先级，并且都是非守护线程，具体代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">--- Executors</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            <span class="comment">// 线程组</span></span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">"-thread-"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 创建线程</span></span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 设置为非守护线程</span></span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 设置优先级</span></span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>线程池采用的是 <strong>Integer.SIZE</strong> 32 位的整数来存放线程池的<strong>状态</strong>和池中的<strong>线程数</strong>，其中高 3 位表示线程池状态即可以表示 7 种状态，低 29 位表示线程数即可以存放 5 亿多个线程。这种设计思想对整数赋予了双重角色，通过高低位的不同，既表示线程池状态，又表示工作线程数目，这是一个典型的高效优化。要知道用一个变量存储两个值，可以避免在做相关决策时出现不一致的情况，省去了占用锁资源去维护两个变量的一致性。这种方式在其它框架中也多有使用，如 Dubbo 协议就使用 16 个字节共 128 位，每一位用来表示不同意义的数值。</p><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>线程池的状态表示如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-threadpoolexecutor-ctl.jpg" alt></p><p>注意，<strong>线程池的状态并非用户显示配置（用户调用关闭方法除外），而是随着线程池的运行由内部自行维护，和线程的执行密切相关</strong>，下面分别说明线程池的状态及其状态流转。</p><h4 id="RUNNING"><a href="#RUNNING" class="headerlink" title="RUNNING"></a>RUNNING</h4><ul><li><strong>状态说明</strong><br>线程池处于 RUNNING 状态允许接受新的任务，处理任务队列中的任务。</li><li><strong>状态转换</strong><br>线程池一旦被创建就处于 RUNNING 状态，并且线程池中的线程数为 0 。</li></ul><h4 id="SHUTDOWN"><a href="#SHUTDOWN" class="headerlink" title="SHUTDOWN"></a>SHUTDOWN</h4><ul><li><strong>状态说明</strong><br>线程池处于 SHUTDOWN 状态时，不再接收新任务，但能处理任务队列中的任务。</li><li><strong>状态转换</strong><br>调用线程池的shutdown()方法时，线程池由RUNNING -&gt; SHUTDOWN 。</li></ul><h4 id="STOP"><a href="#STOP" class="headerlink" title="STOP"></a>STOP</h4><ul><li><strong>状态说明</strong><br>线程池处在 STOP 状态时，不能接收新任务，也不处理任务队列中的任务，并且会<strong>中断</strong>正在处理任务的线程。</li><li><strong>状态转换</strong><br>调用线程池的shutdownNow()方法时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP 。</li></ul><h4 id="TIDYING"><a href="#TIDYING" class="headerlink" title="TIDYING"></a>TIDYING</h4><ul><li><strong>状态说明</strong><br>所有的任务已终止，线程池中线程数为 0 ，线程池会变为TIDYING状态（线程池内部自动更新状态）。当线程池变为TIDYING状态后，会紧接着执行钩子方法terminated()。若用户需要在线程池变为TIDYING时，进行相应的处理，可以通过重写terminated()方法来实现。 </li><li><strong>状态转换</strong><br>当线程池在 SHUTDOWN 状态下时，阻塞队列为空并且线程池中线程数为 0 时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在 STOP 状态下，线程池中线程数为 0 时，就会由STOP -&gt; TIDYING。</li></ul><h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><ul><li><strong>状态说明</strong><br>线程池彻底终止，就变成 TERMINATED 状态。</li><li><strong>状态转换</strong><br>线程池处在TIDYING状态时，执行完 terminated() 方法之后，就会由 TIDYING -&gt; TERMINATED。</li></ul><p>下面进行小结，线程池状态及流转（线程池的生命周期）如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-status.jpg" alt></p><h2 id="任务执行机制"><a href="#任务执行机制" class="headerlink" title="任务执行机制"></a>任务执行机制</h2><h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>任务调度是线程池的主要入口，所有任务的调度都是由<strong>execute方法</strong>完成的，当用户提交了一个任务后，任务调度阶段将决定如何执行该任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 任务体不允许为 null</span></span><br><span class="line">     <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取线程池的状态码,该值包含了线程池的状态和线程数</span></span><br><span class="line">     <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 1 如果当前线程数少于核心线程数，则创建一个 Worker 来执行任务，即创建一个线程并将 command 作为该线程的第一个任务</span></span><br><span class="line">     <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">         <span class="comment">// 返回 false 说明线程池不允许创建线程，可能原因：（1）线程池关闭（2）当前线程数已经达到临界值</span></span><br><span class="line">         <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         <span class="comment">// 创建失败，重读线程池状态码</span></span><br><span class="line">         c = ctl.get();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2 如果线程池处于运行状态，则尝试将任务添加到阻塞队列 workQueue 中</span></span><br><span class="line">     <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">         <span class="comment">// 再次获取线程池状态码</span></span><br><span class="line">         <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">         <span class="comment">// 双重检查，再次判断线程池状态。如果线程状态变了（非运行状态）就需要从阻塞队列移除任务，同时执行拒绝策略。防止线程池关闭。</span></span><br><span class="line">         <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">             reject(command);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 如果线程池状态仍然是运行状态，并且线程池为空则创建一个非核心线程来执行任务，防止线程提交到阻塞队列后线程都关闭了。</span></span><br><span class="line">             <span class="comment">// 一般这种情况是设置核心线程数为 0 </span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">             addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 3 如果任务队列满了，则根据 maximumPoolSize 创建非核心线程。如果创建失败，说明当前线程数已经达到 maximumPoolSize 或线程池关闭，需要执行拒绝策略</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">         reject(command);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>execute 方法逻辑体现了提交任务到线程池的流程</strong>，上面代码已经详细注释。需要强调的是，符合将任务加入阻塞队列中的情况，会进行双重检查线程池的状态，因为是直接将任务入队，和前后两种情况不一样，即使任务成功排队，也有可能出现线程池关闭或线程池为空的情况。</p><p>下面通过一张图进行阐述正常流（不考虑线程池关闭等情况）的流程：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-process.jpg" alt></p><h3 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h3><p>任务缓冲是线程池管理任务的核心部分，通过一个阻塞队列来实现。<strong>线程池的本质是对任务和线程的管理</strong>，而做到这一点关键的思想是将任务和线程解耦，阻塞队列缓冲任务，工作线程自旋从阻塞队列中获取任务。</p><p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。</p><p>线程池中的阻塞队列参数非常重要，<strong>不同的阻塞队列对线程池有不同影响</strong>，下面对线程池常用的阻塞队列进行说明。</p><ul><li><p><strong>ArrayBlockingQueue</strong><br>基于数组结构的有界阻塞队列，该队列按照先进先出原则对元素进行排序。</p></li><li><p><strong>LinkedBlockingQueue</strong><br>基于链表结构的无界阻塞队列，该队列按照先进先出规则对元素进行排序。此队列的默认长度为 <strong>Integer.MAX_VALUE</strong>，使用该队列作为任务队列有容量危险。</p></li><li><p><strong>SynchronousQueue</strong><br>一个比较特殊的阻塞队列，其本身不存储元素。每个插入操作必须等待另一个线程执行移除操作，反之亦然。如果使用该阻塞队列，只有当两个线程执行相反模式的操作才能配对成功，否则先执行的一方只能等待。下图是对线程池使用该队列处理任务过程的描述：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-syncronousqueue.jpg" alt></p></li><li><p><strong>PriorityBlockingQueue</strong><br>支持优先级排序的无界阻塞队列，默认自然排序规则，不能保证同优先级元素的顺序。</p></li><li><p><strong>DelayQueue</strong><br>一个实现 PriorityBlockingQueue 实现延迟获取的无界队列，在创建元素时可以指定多久才能从队列中移除，只有延时期满后才能从队列中获取元素。</p></li><li><p><strong>LinkedBlockingDeque</strong><br>一个由链表结构构成的双向阻塞队列。队列头部和尾部都可以添加和移除元素。</p></li></ul><h3 id="任务申请"><a href="#任务申请" class="headerlink" title="任务申请"></a>任务申请</h3><p>任务执行有两种情况，一种是任务直接交给新创建的线程执行。另一种是线程执行 <strong>getTask</strong> 方法从任务队列中获取任务并执行，执行完任务的线程会继续尝试从任务队列中申请任务再去执行。第一种情况仅出现在用户提交任务到线程池，线程池为该任务创建线程的时候。第二种情况是线程执行任务最多的情况，包括线程池存在的线程执行任务，创建的非核心线程执行任务。</p><p>任务申请的核心方法 <strong>getTask</strong> 是配合 <strong>Worker线程</strong> 工作的，用于 <strong>Worker线程</strong> 拉取任务队列，下面对该方法进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 返回null 表示可以对当前线程进行回收</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取线程池状态码</span></span><br><span class="line">         <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">         <span class="comment">// 获取线程池状态</span></span><br><span class="line">         <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 线程池状态为SHUTDOWN且队列为空 或 线程池状态为 STOP，应该回收线程。这个条件不仅可以回收非核心线程，也可以回收核心线程。todo 核心线程唯一回收条件</span></span><br><span class="line">         <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">             <span class="comment">// 减少线程池中的线程数</span></span><br><span class="line">             decrementWorkerCount();</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 线程池中的线程数</span></span><br><span class="line">         <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 是否需要进行超时控制。即允许核心线程数内的线程回收，或线程池中的线程数超过了核心线程数，那么有可能发生超时关闭</span></span><br><span class="line">         <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 控制线程池中线程数的关键</span></span><br><span class="line">         <span class="comment">//1. wc &gt; maximumPoolSize ，可能是在此方法执行阶段同时执行 setMaximumPoolSize 方法修改了最大值。</span></span><br><span class="line">         <span class="comment">//2. timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，且线程上一轮获取任务超时</span></span><br><span class="line">         <span class="comment">//3. 结果：如果线程池中的线程数大于最大线程数或获取任务超时（不设置 allowCoreThreadTimeOut，核心线程没有超时概念），并且（线程数 &gt; 1 或 任务队列为空），则应该回收当前线程。</span></span><br><span class="line">         <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">             <span class="comment">// 减少工作线程数</span></span><br><span class="line">             <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 根据timed来判断：</span></span><br><span class="line">             <span class="comment">// 1. 如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务则返回null</span></span><br><span class="line">             <span class="comment">// 2. 否则通过take方法获取任务，如果队列为空则take方法会阻塞直到队列不为空</span></span><br><span class="line">             Runnable r = timed ?</span><br><span class="line">                     <span class="comment">// 超时获取任务，因为线程超时要被回收。如果线程在等待的过程发生了中断，会抛出中断异常</span></span><br><span class="line">                     workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                     <span class="comment">// 不需要超时，如果线程在等待的过程发生了中断，会抛出中断异常</span></span><br><span class="line">                     workQueue.take();</span><br><span class="line">             <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                 <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 如果 r == null ，说明获取任务超时</span></span><br><span class="line">             timedOut = <span class="keyword">true</span>;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">             <span class="comment">// 获取任务时当前线程发生中断，重置超时标记并重试</span></span><br><span class="line">             timedOut = <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述方法用于从任务队列中<strong>不断</strong>拉取待执行的任务，具体执行流程如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-gettask-process.jpg" alt></p><p>下面对主要逻辑进行说明：</p><ol><li>该方法返回 null 时，表示当前线程可以被回收了，包括核心线程。这也是该方法多次判断的原因，控制线程池中线程数量，进而控制线程池的状态。</li><li>在没有设置 allowCoreThreadTimeOut 时，核心线程数的线程会阻塞等待任务，不会被回收。</li><li>超时回收，在 keepAliveTime 对应的具体时间内都没有任务，应该回收非核心线程。</li><li>以下情况需要返回 null，回收当前线程。<ul><li>线程池处于 STOP 状态。</li><li>线程池处于 SHUTDOWN 状态，且阻塞队列为空。</li><li>线程池中的线程数大于最大线程数。</li><li>线程获取任务超时再次重试时，仍为可回收线程。</li></ul></li></ol><p>getTask 方法还是比较复杂的，整个逻辑中进行了多次判断，目的是控制线程的数量，进而维护线程池的状态。需要特殊说明的是，当线程获取任务超时时并没有立刻回收该线程，而是让线程重试，这么做是为了防止该线程可能会成为核心线程，避免误回收，如果误回收在后续流程中还需要重新创建线程，因此重试一次代价会小一些。</p><h3 id="任务执行-1"><a href="#任务执行-1" class="headerlink" title="任务执行"></a>任务执行</h3><p>任务执行是 <strong>Worker线程</strong> 的工作，我们会在下面详细介绍。 </p><h3 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h3><h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>线程池的拒绝策略属于一种限流保护机制，防止线程池崩溃。线程池拒绝任务的时机如下：</p><ol><li>执行关闭方法后线程池处于关闭状态及以上状态</li><li>线程池处于运行状态，但是没有能力（阻塞队列已满，线程数达到最大值）处理新提交的任务了。</li></ol><p>JDK 内置了 4 种拒绝策略，默认使用 AbortPolicy 策略。拒绝策略如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-rejectedexecutionhandler.jpg" alt></p><h4 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 丢弃任务并抛出异常（默认策略）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 直接抛出异常</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> e te</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                   <span class="string">" rejected from "</span> +</span><br><span class="line">                   e.toString());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>AbortPolicy 策略是线程池默认的拒绝策略，在任务不能再提交到线程池时抛出异常，能够及时反馈程序的运行状态。对于比较核心的业务推荐使用此拒绝策略，因为当系统不能承载更大的并发流量时，业务方能够及时地通过异常发现。</p><h4 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 由提交任务的线程自己来执行任务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 只要线程池没有被关闭，就由提交任务的线程自己来执行这个任务。</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 线程池没有关闭</span></span><br><span class="line">          <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">              <span class="comment">// 方法级别调用</span></span><br><span class="line">              r.run();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>CallerRunsPolicy 策略是由提交任务的线程处理任务，此策略适合让所有任务都执行完毕。</p><h4 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 直接忽略任务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 直接忽略</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>DiscardPolicy 策略会直接丢弃任务，并且不会抛出异常。此策略会导致业务方无法发现异常，不建议核心业务采用此策略。</p><h4 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将阻塞队列头的任务扔掉，然后将当前任务提交到线程池尝试执行。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将队列都任务移除，并将当前任务提交到线程池</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">               e.getQueue().poll();</span><br><span class="line">               e.execute(r);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>DiscardOldestPolicy 策略会丢弃队列最前面的任务，然后重新提交被拒绝的任务。这种策略存在丢失任务的风险。</p><p>自定义拒绝策略只需要实现 RejectedExecutionHandler 接口，重写 rejectedExecution 方法即可。如果不自定义拒绝策略，线程池将使用默认的拒绝策略。</p><h1 id="Worker线程管理"><a href="#Worker线程管理" class="headerlink" title="Worker线程管理"></a>Worker线程管理</h1><p>前文在介绍任务执行机制的时候涉及到 Worker线程，线程池维护的线程模块其实就是一组 <strong>Worker对象</strong> ，下面我们就来看看 ThreadPoolExecutor 的内部类 Worker 。</p><h2 id="Worker线程"><a href="#Worker线程" class="headerlink" title="Worker线程"></a>Worker线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker持有的线程，即任务执行的真正线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主线程提交任务到线程池，任务就会存放到这里。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于存放当前线程完成的任务数。注意和 completedTaskCount 的区别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker 唯一的构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask 任务，可能为 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// 设置状态值为 -1，防止在启动线程之前，线程就被中断。因为AQS中默认的 state 为 0，Worker中实现的 tryAcquire 方法内存值就是 0，修改值为 1</span></span><br><span class="line">        setState(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 使用工厂创建线程，注意创建出来的线程的任务体就是 Worker 本身。这意味着当线程启动时，Worker#run方法就会执行</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker 实现了 Runnable 接口，重写了run() 方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里调用了外部类的 runWorker 方法</span></span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------- Worker继承了AQS类，下面的核心方法是重写了AQS的方法，使用独占锁获得执行权，不支持锁的重入 -----------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 独占式获取资源。AQS 中默认的 state 为 0。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * unlock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中断线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池在创建线程时，会将线程封装成工作线程Worker，目的是<strong>管理线程的状态并维护线程的生命周期</strong>。</p><p><strong>工作线程Worker 比较特别，下面对其关键点进行说明：</strong></p><ul><li>继承了 AQS ，实现了一套独占锁机制。<blockquote><p>1.Worker 并没有直接使用可重入锁 ReentrantLock ，而是通过继承 AQS 实现了不可重入的独占锁，目的就是通过不可重入的特性判断 Worker 中封装线程的执行状态。<br>2.在线程执行任务期间会加 Worker非重入锁，表示当前线程正在执行任务中，并不是处于空闲状态，不应该中断该线程。<br>3.如果线程不是独占锁的状态则表明该线程处于空闲状态，可以对该线程进行中断</p></blockquote></li></ul><ol start="2"><li><p>实现了 Runnable 接口，它是一个任务体并重写的 run 方法，该方法是线程池执行任务的关键。</p><blockquote><p>在创建 Worker 成功后，紧接着就会启动 Worker 封装的真实 Thread ，启动成功后 Worker 中的 run 方法就会执行。</p></blockquote></li><li><p>内部封装了实际执行任务的线程。 </p><blockquote><p>内部封装的线程是线程池的工厂创建出来的，它的使命就是执行 Worker 中的 run 方法中的任务。那业务任务谁来执行？ 同样地，也是该线程执行，只不过它使用的是方法级别的调用。</p></blockquote></li><li><p>内部封装了初始化任务体</p><blockquote><p>Worker 使用 firstTask 保存传入的第一个任务，该任务允许为null。如果该任务非空，那么线程就会在启动后优先执行这个任务，一般对应于核心线程的创建；如果该任务为空，对应于非核心线程的创建，用于去执行任务队列中的任务。</p></blockquote></li><li><p>线程复用</p><blockquote><p>一个 Worker 对应线程池中的一个线程，线程复用的逻辑实现是在 Worker 类中的 run 方法中执行 runWorker 方法。由上面的第 2、3 两个说明，很容易得出，当 Worker 中的线程启动后会执行 Worker 这个任务体的 run 方法，进而该线程就会执行 runWorker 方法，然后进入到 while 自旋，实现线程的复用。</p></blockquote></li><li><p>线程回收</p><blockquote><p>线程池管理着线程的生命周期，需要对长时间空闲的线程、启动失败的线程以及执行任务出现异常的线程进行回收。线程池使用了HashSet这个Hash表去持有Worker的引用，这样可以通过添加引用和移除引用的操作来控制线程的生命周期。</p></blockquote></li></ol><p>前文对线程池的任务执行机制进行了介绍，下图是 <strong>Worker</strong> 执行任务的模型：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-worker-process-simple.jpg" alt></p><h2 id="新增线程"><a href="#新增线程" class="headerlink" title="新增线程"></a>新增线程</h2><p>如果说 <strong>execute</strong> 方法逻辑体现了提交任务到线程池的流程，那么 <strong>addWorker</strong> 方法则体现了线程池执行任务的开端，即接收任务、创建线程、启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//-------------------------------  1 创建线程前的检测工作 -------------------------------------/</span></span><br><span class="line">     <span class="comment">// for 跳出标志</span></span><br><span class="line">     retry:</span><br><span class="line">     <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//------------------------- 1.1 创建线程前，对线程池状态和队列进行检查，判断是否还可以创建线程 ----------------------/</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取线程池状态码</span></span><br><span class="line">         <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取线程池状态</span></span><br><span class="line">         <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          * 如果线程池状态范围是：[SHUTDOWN，TERMINATED]，出现下列任一种情况都不允许创建Worker:</span></span><br><span class="line"><span class="comment">          * 1 firstTask != null</span></span><br><span class="line"><span class="comment">          * 2 workQueue 为空</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          *小结：</span></span><br><span class="line"><span class="comment">          * 1 线程池处于 SHUTDOWN 状态时，不允许提交任务，但是已经存在的任务需要继续执行。</span></span><br><span class="line"><span class="comment">          *  1.1 当 firstTask == null 时且阻塞队列不为空，说明非提交任务创建线程，执行阻塞队列中的任务，允许创建 Worker</span></span><br><span class="line"><span class="comment">          *  1.2 当 firstTask == null 但阻塞队列为空，不能创建 Worker</span></span><br><span class="line"><span class="comment">          *  1.3 当 firstTask ！= null 时，不能创建</span></span><br><span class="line"><span class="comment">          * 2 线程池状态大于 SHUTDOWN 状态时，不允许提交任务，且中断正在执行的任务。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                 !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">//---------------------------- 2 创建线程前，对线程池中线程数检查，判断是否还可以创建线程 ---------------------/</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">             <span class="comment">// 获取线程池线程数</span></span><br><span class="line">             <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 判断线程池线程数是否达到边界值：1 临界值 2 核心线程数或最大线程数</span></span><br><span class="line">             <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 增加线程池中线程数如果成功，则表示创建 Worker 前的校验工作完成，可以进行创建 Worker 流程了。</span></span><br><span class="line">             <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                 <span class="keyword">break</span> retry;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 增加线程数失败，说明可能其它线程也在尝试创建Worker，就需要回到起点，重新校验。</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">//并发影响，需要重新获取线程池状态码</span></span><br><span class="line">             c = ctl.get();</span><br><span class="line"></span><br><span class="line">             <span class="comment">//线程池状态是否改变，改变了则需要重头校验，否则只需要再次校验线程数即可</span></span><br><span class="line">             <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                 <span class="keyword">continue</span> retry;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//----------------------------------   创建 Worker 流程     ------------------------------------/</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// Worker 中的线程是否启动的标志</span></span><br><span class="line">     <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Worker 是否添加到 workers 集合中的标志</span></span><br><span class="line">     <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     Worker w = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 创建 Worker，将任务传入。注意，如果是非提交任务创建Worker的话，firstTask 为null</span></span><br><span class="line">         w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将创建的Worker中的线程临时保存到 t，这个是真正的线程，Worker 只是对线程进行了包装。</span></span><br><span class="line">         <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Worker 中的线程创建成功</span></span><br><span class="line">         <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 加锁，注意这个锁的粒度是全局的。也就是说，当这里获取到锁，线程池不能关闭，因为线程池关闭也需要锁。</span></span><br><span class="line">             <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">             mainLock.lock();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 再次获取线程池状态</span></span><br><span class="line">                 <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 如果线程池是运行状态，或者是关闭状态且传入的任务为null(不接收新任务，但是会继续执行任务队列中的任务)，符合条件。</span></span><br><span class="line">                 <span class="comment">// 此外都不符合条件，线程池不会维护当前创建的Worker线程，该Worker线程由于没有被引用最后会被JVM回收</span></span><br><span class="line">                 <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 提前检查新创建的Worker中的线程是否是启动状态</span></span><br><span class="line">                     <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 将新创建的 Worker 加入到 workers 集合，意味着线程池持有当前 Worker 的引用，当前 Worker 不会被 GC。</span></span><br><span class="line">                     workers.add(w);</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 更新 largestPoolSize 的值，该值用于追踪线程池中出现过的最大线程数量</span></span><br><span class="line">                     <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                     <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                         largestPoolSize = s;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 更新标记值</span></span><br><span class="line">                     workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="comment">// 全局锁释放，注意全局锁释放的时机</span></span><br><span class="line">                 mainLock.unlock();</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// Worker线程只有添加到Worker集合后才能启动线程</span></span><br><span class="line">             <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                 <span class="comment">// 启动Worker中的线程，这一步的意义重大</span></span><br><span class="line">                 t.start();</span><br><span class="line">                 <span class="comment">// 标记线程启动成功</span></span><br><span class="line">                 workerStarted = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 线程加入线程池失败或启动失败，需要清理工作</span></span><br><span class="line">         <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">             addWorkerFailed(w);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> workerStarted;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>线程池通过上述方法增加线程，该方法仅完成创建线程并使它运行，最后返回是否成功。至于是哪种情况下增加线程，该方法并不关心。下图是新增Worker线程的流程图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-addworker-process.jpg" alt></p><p>还需要强调一点，该方法只是创建并启动线程，线程还没有执行任务。再分析执行任务逻辑之前，先来看看创建 Worker 的异常流程，<code>addWorkerFailed</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得全局锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 从 workers 缓存中移除启动失败的 Worker</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少线程池中线程数，因为在此之前递增了</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试终止线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法名非常直观，就是执行 addWorker 失败的处理方法。该方法主要做了以下工作：</p><ol><li>从 Worker 缓存集合中移除启动失败的 Worker 便于 GC 。</li><li>递减线程池中线程数，在校验是否允许创建 Worker 流程中递增了线程数，这里需要递减。</li><li>尝试终止线程池，新增线程失败的原因可能是线程池状态处于[SHUTDOWN,TERMINATED]，这种情况下要尝试更新线程池的状态为终止状态。</li></ol><h2 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h2><p>Worker 中的线程启动成功后，其 run 方法会调用 <strong>runWorker</strong> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Worker 实现了 Runnable 接口，重写了run() 方法。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里调用了外部类的 runWorker 方法</span></span><br><span class="line">     runWorker(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>runWorker 方法是执行提交任务和阻塞队列中等待任务的核心实现，接下来我们分析它的具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 当前线程，即 w 中的线程</span></span><br><span class="line">      Thread wt = Thread.currentThread();</span><br><span class="line">      <span class="comment">// 获取该线程的第一个任务，可能没有。如果有的话，优先执行该任务。</span></span><br><span class="line">      Runnable task = w.firstTask;</span><br><span class="line">      w.firstTask = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将 state 值由由 -1 设置为 0，这样就可以允许中断了 。</span></span><br><span class="line">      w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 循环调用getTask() 方法从任务队列中获取任务并执行</span></span><br><span class="line">          <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123; </span><br><span class="line"></span><br><span class="line">              <span class="comment">// 申请Worker非重入锁，标志着自己处于工作状态。</span></span><br><span class="line">              w.lock();</span><br><span class="line"></span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * 该if判断保证了：如果线程池正在停止，需要确保当前线程是中断状态，否则要保证当前线程不是中断状态。</span></span><br><span class="line"><span class="comment">               *</span></span><br><span class="line"><span class="comment">               * 出现以下任何一种情况都需要中断线程：</span></span><br><span class="line"><span class="comment">               * 1 如果线程池状态大于等于 STOP，并且当前线程没有被中断</span></span><br><span class="line"><span class="comment">               * 2 如果当前线程被中断了并且线程池状态大于等于 STOP 状态（恢复中断标识）</span></span><br><span class="line"><span class="comment">               * 使用interrupted()方法判断线程是否被中断，该方法会清除中断标志位，既确保了在线程RUNNING或者SHUTDOWN状态时线程是非中断状态的，又支持了线程池是STOP状态下的判断</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">              <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                      (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                  <span class="comment">// 中断当前线程，进行中断标志复位</span></span><br><span class="line">                  wt.interrupt();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// ThreadPoolExecutor 的扩展方法</span></span><br><span class="line">                  beforeExecute(wt, task);</span><br><span class="line"></span><br><span class="line">                  Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 执行目标任务,方法级别调用。</span></span><br><span class="line">                      task.run();</span><br><span class="line"></span><br><span class="line">                  &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                      thrown = x;</span><br><span class="line">                      <span class="keyword">throw</span> x;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                      thrown = x;</span><br><span class="line">                      <span class="keyword">throw</span> x;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                      thrown = x;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      <span class="comment">// ThreadPoolExecutor 的扩展方法</span></span><br><span class="line">                      afterExecute(task, thrown);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="comment">// 置空 task,为下一个任务做准备</span></span><br><span class="line">                  task = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">// 更新Worker线程完成任务数量</span></span><br><span class="line">                  w.completedTasks++;</span><br><span class="line">                  <span class="comment">// 释放 Worker非重入锁</span></span><br><span class="line">                  w.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// while 循环没有出现异常，completedAbruptly 才会被设置为 false</span></span><br><span class="line">          completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 线程退出 while 循环后需要进行回收，可能情况如下：</span></span><br><span class="line"><span class="comment">           * 1 任务队列中已经没有要执行的任务了</span></span><br><span class="line"><span class="comment">           * 2 任务执行过程出现异常</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          processWorkerExit(w, completedAbruptly);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>线程执行任务的流程如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-runworker-process.jpg" alt></p><p>执行任务逻辑已经详细注释，下面对该方法简要分析：</p><ol><li>线程执行任务有两个途径，通过取 Worker 的 firstTask 或者调用 getTask 方法从任务队列中取出待执行的任务。</li><li>线程复用得益于对线程的封装，封装后的线程不再局限于执行当前任务，而是while循环不断地通过getTask()方法获取任务，然后执行任务，从而实现了线程的复用。</li><li><strong>线程在执行任务前会先申请对应 Worker 独占锁，标志自己处于工作状态，不应该中断该线程</strong>，这是对线程封装的好处。</li><li>当线程池状态大于等于 STOP 状态，要保证当前线程是中断状态，否则要保证当前线程不是中断状态。</li><li>线程通过调用任务的 <strong>run</strong> 方法来执行对应的任务，而不是启动线程，这个正是前文特别说明的<strong>方法级别调用</strong>。 </li><li>当 Worker 封装的线程退出循环后，执行 <strong>processWorkerExit()</strong> 方法对该线程进行回收。</li><li>可以通过重写 beforeExecute() 和 afterExecute() 方法来实现 ThreadPoolExecutor 的扩展功能。</li></ol><h3 id="再谈线程复用"><a href="#再谈线程复用" class="headerlink" title="再谈线程复用"></a>再谈线程复用</h3><p>线程池会使用一定数量的线程去执行任务，通常线程数量远小于任务数量，针对这种情况线程池通过线程复用的方式让同一个线程去执行不同的任务。我们知道线程池是将线程和任务解耦，摆脱了一个任务必须一个线程的限制，这也是线程复用的必要条件。线程池使用<strong>Worker</strong>对线程的封装，也就是<strong>Worker线程</strong>，线程启动后会去执行一个<strong>循环任务</strong>，该任务可以执行线程的<strong>首个任务</strong>和<strong>轮询任务队列中的任务</strong>，线程通过调用任务的 <strong><code>run</code></strong> 方法实现任务的执行。</p><p>线程复用的逻辑主要在 runWorker 方法中，该方法是 Worker 类的 run 方法中的逻辑，Worker 中封装的线程启动后会执行 Worker 的 run 方法进而执行 runWorker 方法。整个逻辑简化后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">runWorker(Worker w) &#123;</span><br><span class="line">    <span class="comment">// 线程首个任务</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    <span class="comment">// 轮询任务队列中的任务</span></span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 线程执行任务的 run 方法，即方法级别的调用</span></span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            task = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程回收"><a href="#线程回收" class="headerlink" title="线程回收"></a>线程回收</h2><p>线程池中线程的销毁依赖JVM自动回收，Worker 线程结束任务或异常退出后，Worker 会主动清除自身在线程池中的引用，这意味着线程池可以回收该线程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 线程执行任务抛出了异常</span></span><br><span class="line">       <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">           <span class="comment">// 减少线程池中线程数量</span></span><br><span class="line">           decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取全局锁</span></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">       mainLock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 累计线程池完成的任务数量</span></span><br><span class="line">           completedTaskCount += w.completedTasks;</span><br><span class="line">           <span class="comment">// 将线程引用移出线程池</span></span><br><span class="line">           workers.remove(w);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 释放全局锁</span></span><br><span class="line">           mainLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 尝试终止线程池</span></span><br><span class="line">       tryTerminate();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果线程池状态小于 STOP 状态，说明还可以处理任务</span></span><br><span class="line">       <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 1. 当前线程处理任务没有出现异常</span></span><br><span class="line">           <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">               <span class="comment">// 获取核心线程数，如果设置了允许回收核心线程数，则返回 0，否则取核心线程数</span></span><br><span class="line">               <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 1.1 如果 allowCoreThreadTimeOut=true，并且任务队列中有任务，至少保留一个worker线程</span></span><br><span class="line">               <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; !workQueue.isEmpty())</span><br><span class="line">                   min = <span class="number">1</span>;</span><br><span class="line">              </span><br><span class="line">               <span class="comment">// 1.2 如果 allowCoreThreadTimeOut=false，线程池中线程数不能少于 corePoolSize</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// 线程池中线程数大于等于 min ，说明无需创建线程。</span></span><br><span class="line">               <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                   <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 执行到这里的可能情况：</span></span><br><span class="line">           <span class="comment">// 1 线程池中没有线程执行任务队列中的任务，需要创建线程取执行。（核心线程数设置为 0 或 允许回收核心线程）</span></span><br><span class="line">           <span class="comment">// 2 线程池中线程数小于核心线程数，需要创建线程补充核心线程数。（核心线程数 &gt; 0）</span></span><br><span class="line">           <span class="comment">// 3 当前线程执行任务过程出现异常，而且当前线程被回收了，为了确保有线程执行任务，这里需要创建线程。</span></span><br><span class="line">           addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>线程回收流程如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-worker-exit.jpg" alt></p><p>需要注意的是，线程销毁工作不是只有 <code>processWorkerExit</code> 方法才能完成，前文介绍的新增Worker线程逻辑中对异常流处理的 <code>addWorkerFailed</code> 方法也可以做到。这两者销毁线程的时机不同，前者是线程执行任务的逻辑中销毁，后者是创建线程后启动失败的处理。</p><p>上述 <code>processWorkerExit</code> 方法在将Worker线程移除线程池后也就完成了线程的回收工作，但由于执行该方法的原因很多，线程正常退出<code>getTask</code>方法或者执行任务异常都会执行该方法，因此在该方法中需要额外完成两个工作。一是使线程池自适应当前状态，另一个是根据需要创建线程。</p><p>至此，<code>processWorkerExit</code> 执行完之后Worker线程被销毁，该线程的整个生命周期结束。下面对整个过程使用流程图的形式进行总结，流程图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-worker-process.jpg" alt></p><h1 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h1><p>调用线程池的 <code>shutdown</code> 或 <code>shutdownNow</code> 方法来关闭线程池，两者的原理有点差异，下面我们分别说明这两个方法。</p><h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 全局锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">     mainLock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         checkShutdownAccess();</span><br><span class="line">         <span class="comment">// 设置线程池状态为 SHUTDOWN</span></span><br><span class="line">         advanceRunState(SHUTDOWN);</span><br><span class="line">         <span class="comment">// 尝试中断线程池所有中闲置的线程</span></span><br><span class="line">         interruptIdleWorkers();</span><br><span class="line">         <span class="comment">// hook</span></span><br><span class="line">         onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         mainLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 尝试终止线程池</span></span><br><span class="line">     tryTerminate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>shutdown() 方法可以安全地关闭一个线程池，体现在下面几个方面：</strong></p><ol><li>只是将线程池的状态置为 SHUTDOWN ，这意味着线程池不能接收新的任务，再有新的任务被提交则根据拒绝策略进行处理。</li><li>会执行完正在执行的任务和队列中等待的任务，任务全部结束后才会彻底关闭线程池。</li><li>尝试中断线程池中所有闲置的线程。</li><li>调用tryTerminate尝试终止线程池，用于将线程池的状态更新为 TERMINATED 。</li></ol><h2 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     List&lt;Runnable&gt; tasks;</span><br><span class="line">     <span class="comment">// 全局锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">     mainLock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         checkShutdownAccess();</span><br><span class="line">         <span class="comment">// 设置线程池状态为 STOP</span></span><br><span class="line">         advanceRunState(STOP);</span><br><span class="line">         <span class="comment">// 尝试中断线程池中所有启动状态的线程</span></span><br><span class="line">         interruptWorkers();</span><br><span class="line">         <span class="comment">// 将阻塞队列中正在等待的所有任务进行备份，然后清空阻塞队列并返回备份。有了这个备份，可以根据需要做补救措施。</span></span><br><span class="line">         tasks = drainQueue();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         mainLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 尝试终止线程池</span></span><br><span class="line">     tryTerminate();</span><br><span class="line">     <span class="keyword">return</span> tasks;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>shutdownNow() 方法表示立即关闭线程池，工作如下：</p><ol><li>将线程池状态置为 STOP 状态。</li><li>中断所有Worker线程，包括空闲和非空闲。</li><li>清空阻塞队列并返回等待执行的任务备份。</li><li>调用tryTerminate尝试终止线程池，用于将线程池的状态更新为 TERMINATED 。</li></ol><h2 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate()"></a>tryTerminate()</h2><p>对于 <strong>tryTerminate()</strong> 方法的调用，前文中的<strong>新增线程失败逻辑、线程退出while逻辑以及两种关闭线程池的方法</strong>都会调用了该方法，下面我们来看看这个方法的具体逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 线程池状态码</span></span><br><span class="line">          <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 以下几种情况不能终止线程池，直接返回（STOP 状态可不会直接返回）</span></span><br><span class="line">           <span class="comment">//1. 线程池是运行状态 RUNNING</span></span><br><span class="line">           <span class="comment">//2. 大于等于 TIDYING 状态，此时线程池中已经没有正在运行的线程了</span></span><br><span class="line">           <span class="comment">//3. SHUTDOWN 状态且阻塞队列非空，这种情况需要执行完任务队列中的任务</span></span><br><span class="line">          <span class="keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 执行到这里，说明已经具备终止线程池的条件，只差线程回收了。</span></span><br><span class="line">          <span class="comment">// 线程池中线程数量不为 0，向任意空闲线程发出中断信号，所有被阻塞的线程（执行poll/take）最终都会被一个个唤醒，回收。</span></span><br><span class="line">          <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">              <span class="comment">// 这里既不是中断所有线程，也不是中断所有空闲线程，而是中断任意一个空闲线程，原因如下：</span></span><br><span class="line">              <span class="comment">// 1. tryTerminate() 方法多处被调用，需要中断线程逻辑在上层已经进行了处理，如 shutdown 方法调用时会中断所有空闲线程</span></span><br><span class="line">              <span class="comment">// 2. interruptIdleWorkers(ONLY_ONE) 方法用在 tryTerminate() 方法中主要为了唤醒 getTask()方法中存在执行workQueue.take()等待的线程，防止一直等待造成线程无法回收。</span></span><br><span class="line">              <span class="comment">//    即使有多个线程阻塞等待，唤醒任意一个也足够了，被唤醒的线程在退出while循环后会再次调用tryTerminate()方法，继续中断阻塞等待线程。此外线程退出后进入到processWorkerExit()方法中</span></span><br><span class="line">              <span class="comment">//    会要申请全局锁的，如果全部唤醒会出现竞争锁的情况。</span></span><br><span class="line">              interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 全局锁</span></span><br><span class="line">          <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 终止线程池时加全局锁，保证CAS执行成功，即线程池状态依次更新为 TIDYING 和 TERMINATED 。</span></span><br><span class="line">          <span class="comment">// 这里可能发生并发问题，如两个线程都通过了 workerCountOf(c) != 0 条件，执行到这里就需要加锁。</span></span><br><span class="line">          mainLock.lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 设置线程池状态码为 TIDYING</span></span><br><span class="line">              <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">// 状态设置成功后执行 terminated() 钩子方法</span></span><br><span class="line">                      terminated();</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 设置线程池状态码为 TERMINATED 终止状态</span></span><br><span class="line">                      ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                      termination.signalAll();</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              mainLock.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// else retry on failed CAS</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>tryTerminate() 方法主要根据线程池状态判断是否终止线程池，下面进行简单总结：</strong></p><ol><li>判断线程池是否可以终止，原则是线程池处于关闭状态、队列中没有任务的情况下可以终止。</li><li>interruptIdleWorkers()方法的执行表示线程池具备终止条件，向任意空闲线程发送中断信号<strong>防止 <code>getTask</code> 方法中存在核心线程执行 <code>workQueue.take()</code>时一直阻塞，导致线程无法回收</strong>。</li><li>符合终止线程池的条件时，先获取全局锁，然后先将线程池状态置为 TIDYING 状态，设置成功后会执行 terminated() 钩子方法，最后将线程池状态设置为 TERMINATED 状态，完成线程池状态更新后释放全局锁。</li></ol><p>下面我们来简单分析一下<code>interruptIdleWorkers</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中断所有闲置的Worker</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyOne 是否仅中断一个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">// 全局锁，涉及到 workers 操作线程池都会加该锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历 workers ，对每个非中断线程进行中断操作。</span></span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">                Thread t = w.thread;</span><br><span class="line">                <span class="comment">// 如果线程非中断状态，且能 tryLock() 成功，说明该线程闲置，需要进行中断</span></span><br><span class="line">                <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        w.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前文也进行了说明，Worker 继承了AQS，在Worker线程处理任务时会申请Worker独占锁，<code>interruptIdleWorkers</code> 在进行中断时会使用 <strong>tryLock()</strong> 来判断该Worker线程是否正在处理任务，如果 <strong>tryLock()</strong> 返回true，说明该Worker线程处于空闲状态，可以被中断。</p><p><strong>注意事项：</strong></p><ol><li>线程池中多处执行 <code>tryTerminate</code> 方法的目的是将符合条件的线程池终止，前文也提到线程池的状态是内部自行维护的，并非人为设置。如用户执行 <code>shutdown</code> 和 <code>shutdownNow</code> 方法只是将线程池的状态设置为 <strong>SHUTDOWN</strong> 和 <strong>STOP</strong> ，后续的 <strong>TIDYING</strong> 和 <strong>TERMINATED</strong> 状态的设置就在于此。</li><li><code>tryTerminate</code> 方法中的 <code>interruptIdleWorkers(ONLY_ONE)</code> 的作用是防止线程池在终止的过程中 <code>getTask</code> 方法中存在执行 <code>workQueue.take()</code> 阻塞的线程，因为此时线程池不允许再有新的任务添加到阻塞队列中，这样一来线程将一直阻塞下去，线程池永远都终止不了。</li></ol><p>线程池中虽然多处使用中断来期望中断任务的执行，但由于 <strong>Java 中不推荐强行停止线程的机制的限制，因为强制的让一个线程被动的退出是很不安全的，内部的数据不一致会对程序造成不可预知的后果</strong>。即使调用了 shutdownNow 方法，如果被中断的线程对于中断信号不敏感，那么依然有可能导致任务不会停止。</p><h1 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h1><p>线程池太大或太小都会导致麻烦，选择一个合适的线程池是非常有必要的。调整线程池中的数量是为了充分并合理地使用 CPU 和内存资源，从而最大限度地提高程序性能。通常我们需要根据任务执行的性质来选择对应的策略。</p><h2 id="CPU-密集型任务"><a href="#CPU-密集型任务" class="headerlink" title="CPU 密集型任务"></a>CPU 密集型任务</h2><p>如果任务主要进行大量复杂的计算，例如加密、解密、压缩等，那么意味着 CPU 的处理能力是稀缺的资源，应当分配较少的线程，通常按照 CPU 核数 或者 CPU 核数 + 1 进行设置。 计算任务会占用大量的 CPU 资源，CPU 的每个核工作基本都是高负荷的，如果设置过多的线程，每个线程都会尝试抢占 CPU 资源，这就造成了不必要的上下文切换（CPU并没有太多空闲），性能反而由于线程数量过多导致性能下降。</p><h2 id="IO-密集型任务"><a href="#IO-密集型任务" class="headerlink" title="IO 密集型任务"></a>IO 密集型任务</h2><p>I/O 操作比较多的任务，如数据库操作、文件读写、网络通信等，一般不会消耗太多 CPU 资源，但是普遍需要较长时间的等待，对于这类任务可以配置适当多的线程，如 CPU 核数 * 2 。由于 IO 读写速度相比于 CPU 的速度是比较慢的，设置过少的线程数是不能充分利用 CPU 资源。</p><h2 id="合适线程数"><a href="#合适线程数" class="headerlink" title="合适线程数"></a>合适线程数</h2><p>Brain Goetz 推荐的计算方法如下：</p><blockquote><p>线程数 = CPU核数 × 目标CPU利用率 ×（1 + 平均等待时间/平均工作时间）</p></blockquote><p>通过上面的公式可以大致计算出一个合理的线程数（核心线程数和最大线程数统称）。如果任务平均等待时间长则线程数就应该多，对应于 IO 密集型任务。如果平均工作时间长则线程数就应该少，对应于 CPU 密集型任务。</p><p>线程数太少可能会使得程序整体性能降低，线程数太多可能会消耗内存资源以及造成不必要的上下文切换。想用准确定制线程池需要做的工作很多，除了考虑线程数还可以合理使用线程池的阻塞队列实现任务的调度，还可以根据业务等纬度实现线程池隔离。</p><h1 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h1><p>线程池提供了一些用于获取属性的方法，这些属性可以用来对线程池进行监控。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-monitor-method.jpg" alt></p><p>线程池还提供了一些用于设置核心属性的方法，使用方可以通过这些方法动态设置线程池的核心策略，线程池内部会处理好当前状态并做到平滑修改。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-dynamic-method.jpg" alt></p><h2 id="动态设置核心线程数"><a href="#动态设置核心线程数" class="headerlink" title="动态设置核心线程数"></a>动态设置核心线程数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="comment">// 计算核心线程数变化值</span></span><br><span class="line">        <span class="keyword">int</span> delta = corePoolSize - <span class="keyword">this</span>.corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 覆盖原来的corePoolSize</span></span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池的线程数大于变更的核心线程数，说明有多余的worker线程，此时会向空闲的worker线程发起中断请求以实现回收</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 核心线程数大于原来值，尝试增加核心线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取 任务数和 delta 两者的最小值</span></span><br><span class="line">            <span class="keyword">int</span> k = Math.min(delta, workQueue.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 预先创建足够多的新Worker以达到核心线程数，并处理队列中的任务。队列空了则停止</span></span><br><span class="line">            <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (workQueue.isEmpty())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="动态设置最大线程数"><a href="#动态设置最大线程数" class="headerlink" title="动态设置最大线程数"></a>动态设置最大线程数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaximumPoolSize</span><span class="params">(<span class="keyword">int</span> maximumPoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 覆盖原来的 maximumPoolSize</span></span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是设置小了的话，此时会向空闲的worker线程发起中断请求以实现回收</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; maximumPoolSize)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="动态设置空闲时间"><a href="#动态设置空闲时间" class="headerlink" title="动态设置空闲时间"></a>动态设置空闲时间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeepAliveTime</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (time == <span class="number">0</span> &amp;&amp; allowsCoreThreadTimeOut())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Core threads must have nonzero keep alive times"</span>);</span><br><span class="line">        <span class="comment">// 计算超时时间</span></span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = unit.toNanos(time);</span><br><span class="line">        <span class="comment">// 计算差值</span></span><br><span class="line">        <span class="keyword">long</span> delta = keepAliveTime - <span class="keyword">this</span>.keepAliveTime;</span><br><span class="line">        <span class="comment">// 覆盖原来的 keepAliveTime</span></span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = keepAliveTime;</span><br><span class="line">        <span class="comment">// 如果时间设置比原来小，则向空闲的worker线程发起中断请求以实现回收</span></span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="允许核心线程超时回收"><a href="#允许核心线程超时回收" class="headerlink" title="允许核心线程超时回收"></a>允许核心线程超时回收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allowCoreThreadTimeOut</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 核心线程必须要有保活时间</span></span><br><span class="line">        <span class="keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Core threads must have nonzero keep alive times"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value != allowCoreThreadTimeOut) &#123;</span><br><span class="line">            allowCoreThreadTimeOut = value;</span><br><span class="line">            <span class="comment">// 允许回收则立即中断空闲线程</span></span><br><span class="line">            <span class="keyword">if</span> (value)</span><br><span class="line">                interruptIdleWorkers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对线程池核心点进行了详细分析，先是简单介绍了线程池产生的背景，接着说明了线程池的优势，最后对线程池源码进行了分析。从任务提交到线程池，到线程池创建线程并处理任务，到最后线程被回收，最后简单介绍了线程池的配置以及线程池的监控。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最初的时候并没有线程池的概念，而是先有线程。每个任务都需要对应一个线程，任务少的情况没有太大问题，任务过多就出现了各种性能和资源开销问题，更
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>并发 - Java并发工具类</title>
    <link href="https://gentryhuang.com/posts/37f29896/"/>
    <id>https://gentryhuang.com/posts/37f29896/</id>
    <published>2020-11-05T16:00:00.000Z</published>
    <updated>2020-12-24T13:49:23.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 JDK 的并发包中提供了几个非常有用的并发工具类。 <code>CountDownLatch</code>、<code>CyclicBarrier</code> 和 <code>Semaphore</code> 工具类提供了并发流程控制的手段，它们都是对 AQS 应用。本篇文章将介绍其简单使用以及内部原理。</p><table><thead><tr><th align="left">工具类</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td align="left">Semaphore</td><td>信号量，通过控制 ‘许可证’ 的数量来协调各个线程，以保证合理的使用公共资源。</td><td>线程只有拿到 ‘许可证’ 才能继续运行</td></tr><tr><td align="left">CyclicBarrier</td><td>循环栅栏，让一组线程到达一个栅栏（同步点）时被阻塞，直到最后一个线程到达栅栏时，被栅栏拦截的线程才会继续运行。</td><td>强调一组线程都到达同步点才会继续往下执行</td></tr><tr><td align="left">CountDownLatch</td><td>门栓，等待多线程完成</td><td>强调一个或多个线程等待其它线程完成操作</td></tr></tbody></table><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><p><strong>场景</strong></p><blockquote><p>加工厂生产产品，产品需要三道工序进行检测，只有三道工序检测通过才能进入下一个环节。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定线程数线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品质量检测</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要3个工人进行检测，就用3来初始化一个 CountDownLatch</span></span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> no = i;</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 检测</span></span><br><span class="line">                            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                            log.info(<span class="string">"No."</span> + no + <span class="string">" 完成检测。"</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">// 调用 countDown() 代表完成。这里指某个员工完成检测任务</span></span><br><span class="line">                            latch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"产品质量检测中....."</span>);</span><br><span class="line">        <span class="comment">// 调用await() 代表线程阻塞等待其它线程完成，即同步状态 state 减为 0。这里指产品等待检测完成</span></span><br><span class="line">        latch.await();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"产品质量检测完毕，进入下一个环节。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[main] INFO com.code.juc.tool.CountDownLatchDemo - 产品质量检测中.....</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.CountDownLatchDemo - No.2 完成检测。</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.CountDownLatchDemo - No.3 完成检测。</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CountDownLatchDemo - No.1 完成检测。</span><br><span class="line">[main] INFO com.code.juc.tool.CountDownLatchDemo - 产品质量检测完毕，进入下一个环节。</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>以上例子中，main 线程调用了 <code>latch.await()</code> 进行阻塞等待，即它阻塞在门栓上（叫啥无所谓，中文是门栓、栅栏），只有当条件满足时（其它线程调用 <code>latch.countDown()</code> 递减 state 为0）它才能通过这个门栓。这个例子比较简单，只有一个线程调用 <code>await</code> 方法等待其它线程完成，这属于 <code>一对多</code> 关系。CountDownLatch 还可以实现复杂的 <code>多对多</code> 关系的场景，有 m 个线程在门栓上等待 n 个线程完成任务，直到 n 个线程都完成任务，这 m 个线程才能同时通过门栓。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-1.jpg" alt></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>根据 CountDownLatch 的使用例子分析源码，按照执行流程逐一分析。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Synchronization control For CountDownLatch. // 继承AQS的内部类</span></span><br><span class="line"><span class="comment">     * Uses AQS state to represent count. // 使用 AQS 的状态表示 数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 有参构造方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> count 数量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="comment">// 调用父类方法，设置状态值</span></span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取数量</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 调用父类方法，获取状态值</span></span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 覆写父类方法 （获取同步状态（这里表示数量） - 共享方式）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 覆写父类方法（释放同步状态（这里表示数量） - 共享方式）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> releases 没有意义的参数，用不到</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="comment">// 执行递减数量时，如果数量已经是 0 ，则直接返回 false，说明状态已经被其它线程递减为 0 了，当前线程无需唤醒 await() 阻塞的线程（们）</span></span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> nextc = c - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，需要一个 &gt;= 0 的整数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count the number of times &#123;<span class="doctag">@link</span> #countDown&#125; must be invoked</span></span><br><span class="line"><span class="comment">     *              before threads can pass through &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> count&#125; is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch 类是对 AQS 共享模式的使用。既然是使用 AQS 框架，那么就是一个固定的模式，AQS 已经处理好了同步状态的获取与释放以及阻塞与唤醒，自定义组件只需继承 AQS 以及根据同步状态获取方式（独占/共享）实现模版方法即可。前面也说了，AQS 准备好了一切，只需要条件触发就可以执行对应的任务，而实现的模版方法正是触发条件。</p><p>CountDownLatch 主要有两个核心方法，<code>await</code> 和 <code>countDown</code> 。<code>countDown</code> 方法每次调用都会将 <code>state</code> 减 1 ，直到 <code>state</code> 的值为 0。<code>await</code> 方法可以被多个线程调用，调用 <code>await</code> 方法的线程进入 AQS 的阻塞队列中并挂起，当且仅当 <code>state</code> 为 0 时，线程会从阻塞队列中依次被唤醒过来。</p><h4 id="await-等待"><a href="#await-等待" class="headerlink" title="await 等待"></a>await 等待</h4><p>await 方法是一个阻塞方法，当且仅当同步状态 state 减至 0，该方法才会返回，否则调用该方法的线程将阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--- CountDownLatch</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 可中断获取同步状态</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="comment">// 中断则抛出中断异常</span></span><br><span class="line">      <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// main 线程调用 await 时，state = 3，条件成立 </span></span><br><span class="line">      <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 接下来就是 AQS 的工作了，共享方式可中断获取同步状态</span></span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch 的 await 方法简单，直接传入数量值为 1 尝试获取同步状态（其实传入值是没有意义的，用不到）。CountDownLatch 覆写了模版方法即条件，条件成立则 AQS 完成阻塞任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 入队 ，即当前线程加入阻塞队列，共享方式</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 尝试获取前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// CountDownLatch 实现的条件，state != 0 时，返回 -1</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 找大哥，找到大哥就挂起自己，然后等待大哥唤醒自己。没有找到则继续找，直到找到或其前驱节点是 head 节点，找到则挂起等待，是 head 则尝试获取同步状态。</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="comment">// 线程被中断则抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch 的 await 方法到此就结束了，下面总结下该方法的核心步骤。</p><ul><li><p>main 线程没有获取到同步状态会进入阻塞队列<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-2.jpg" alt><br>main 线程对应的节点入队完成，如上图。需要注意的是，因为 main 线程对应节点入队时阻塞队列为空，因此需要构建阻塞队列，使用一个虚节点作为 head 。如果节点在入队时已经存在阻塞队列，那么直接挂到阻塞队列尾部即可。</p></li><li><p>尝试获取同步状态<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-3.jpg" alt><br>入队后进入for 循环，此时main线程对应的节点的前驱节点是 head，但 tryAcquireShared 返回 -1,此时进入 <code>找大哥</code> 的流程中。<code>找大哥</code> 就是将当前节点的<strong>有效</strong>前驱节点等待状态 waitStatus 设置为 -1。这里是将 main 线程对应节点的前驱节点 head 的 waitStatus 设置为 -1。</p></li><li><p>挂起，等待前置节点唤醒<br>找到大哥后挂起自己，等待大哥（有效前置节点）唤醒自己。</p></li></ul><br>以上是 main 线程获取同步状态失败后，进入阻塞队列等待唤醒的过程。需要说明的是，CountDownLatch 可以有多个线程等待其它线程完成，例子中只是使用一个线程等待而已。<h4 id="countDown-唤醒"><a href="#countDown-唤醒" class="headerlink" title="countDown 唤醒"></a>countDown 唤醒</h4><p>countDown 方法每次调用都会将同步状态 state 减 1，直到减少至 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">--- CountDownLatch</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放同步状态</span></span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有当 state 减到 0 时， tryReleaseShared 方法才返回 true，否则仅是将 state 减 1 并返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            <span class="comment">// state == 0 时，唤醒阻塞的线程。 注意，这里是 t1 线程唤醒阻塞的线程即 main 线程</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// t1 线程执行到这里，唤醒阻塞队列中等待的 main 线程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">            <span class="comment">// 将当前 head 保存起来，因为其它线程可能会占领它，此时是虚节点</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="comment">// main 线程入队时已经把 head 当作大哥了，即 将 head 的 waitStatus 设置为 -1 (Node.SIGNAL)</span></span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                     <span class="comment">// cas 将 head 的 waitStatus 设置 为 0。</span></span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 唤醒 head 下一个有效节点。这里是 main 线程对应的节点</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">            </span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面代码只是正常情况下一个完整流程，即 main 线程加入阻塞队列并挂起后，t2、t3、t1 分别执行 <code>countDown</code> 方法递减 <code>state</code> 的值，到了 t1 调用该方法时，刚好 <code>state</code> 的值被减至 0 ，然后线程 t1 执行唤醒阻塞队列中的线程逻辑。下面对该过程进行总结。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-4.jpg" alt></p><p>至此，唤醒条件已经具备，即 <code>state = 0</code> ，下面我们回到之前线程挂起的代码处，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 尝试获取前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// CountDownLatch 实现的条件，state != 0 时，返回 -1</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 2 main 占据 head 并继续唤醒后置阻塞的线程</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// 1 线程 t1 唤醒阻塞的 main 线程，该方法返回，即 main 线程继续执行尝试再次获取同步状态</span></span><br><span class="line">                    parkAndCheckInterrupt())  </span><br><span class="line">                    <span class="comment">// 如果线程被中断则抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>main 线程被唤醒后从 parkAndCheckInterrupt 方法返回，如果没有被中断，则继续尝试获取同步状态，此时可以获取到同步状态（r &gt;= 0 成立）。接下来 main 线程会进入到 setHeadAndPropagate 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将当前 head 保存起来，因为其它线程可能会占领它</span></span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below </span></span><br><span class="line">        <span class="comment">// node 节点占领 head，即 main 线程占领 head</span></span><br><span class="line">        setHead(node); </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里条件判断对应的场景比较多，毕竟是 AQS 统一处理方法，因此考虑的情况比较全面。对于 CountDownLatch ，就是唤醒 node 之后的有效节点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点的后置节点</span></span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="comment">// 如果为 null 或者 是共享方式的节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                <span class="comment">// 接着唤醒阻塞线程 （共享式）。注意，这里是醒来的阻塞线程继续唤醒后置还在阻塞的线程。</span></span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 占领 head </span></span><br><span class="line"><span class="comment">     * Sets head of queue to be node, thus dequeuing. Called only by</span></span><br><span class="line"><span class="comment">     * acquire methods.  Also nulls out unused fields for sake of GC</span></span><br><span class="line"><span class="comment">     * and to suppress unnecessary signals and traversals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>setHeadAndPropagate 方法主要做了两件事，node 占领 head 并唤醒 node 后置的<strong>有效</strong>节点。由于例子中只有 main 线程进入了阻塞队列，它后面没有等待唤醒的线程节点，但为了研究源码我们假设 main 线程对应节点后面还有一个 线程 t 节点等待唤醒，那么 main 线程会执行 doReleaseShared 方法来唤醒线程 t ，此时 head 是 main 线程对应的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 将当前 head 保存起来，因为其它线程可能会占领它</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//  h == null 说明阻塞队列为空，h == tail 说明头节已经是最后一个节点或者是刚刚初始化的节点，这对应 CountDownLatch 来说都应该结束。</span></span><br><span class="line">        <span class="comment">//  按照例子走到这里，head 就 main线程对应的节点，同时 tail 也是 main 线程对应的节点。不过我们假设了 线程 t ，因此条件是成立的</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="comment">// h 的状态，即 main 线程对应节点状态，由入队方法可知，t 线程对应节点会把 main 线程对应节点作为 大哥节点，即 waitStatus 设置为 -1（Node.SIGNAL)</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 可能会失败</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唤醒 h 的后置节点，也就是阻塞队列中的第一个节点。这里是线程 t 对应的节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; </span><br><span class="line">                          <span class="comment">// todo 这里可能会失败 </span></span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">          &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 线程执行到这里，如果唤醒的线程已经占领了 head，此时 h != head，当前线程继续循环。如果 h == head ，说明，唤醒的线程还没有占领 head，当前线程退出循环</span></span><br><span class="line">        <span class="comment">// 这里可能 main 线程执行到这里时，main 线程唤醒的线程 t 已经占领了 head ,此时 h != head </span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setHeadAndPropagate 方法和 doReleaseShared 方法配合，依次唤醒阻塞的线程，即 执行 doReleaseShared 方法的线程唤醒它的后置阻塞线程，醒来的线程会再次尝试获取同步状态然后进入到 setHeadAndPropagate 方法中先占领 head，然后调用 doReleaseShared 方法继续唤醒它的后置阻塞节点。需要说明的是，AQS 的 <code>doReleaseShared</code> 方法极端场景还是挺多的，这里结合 CountDownLatch 来说明。</p><p>我们抛开给出的例子，根据以下场景分析几个特殊的情况</p><blockquote><p>要进行体能测试，每组三个同学进行短跑，在体育老师发出起跑指令前，这三个同学都要在起跑线待着，当体育老师准备完毕后会发出开始跑的指令，那这三个同学就会一起跑向终点的测试仪。这里 CountDownLatch 的数量 为 1，即同步状态为 1 。</p></blockquote><ul><li><p><strong>h != head 的情况</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-5.jpg" alt><br>当 t1 被唤醒后，唤醒 t1 的线程 t 执行到上图中的代码处，还没有退出循环，t1 已经占领了 head（此时图中的 head 要指向 t1 线程对应的节点，且 t1 线程节点 thread 置空，prev 置空。图中没有体现出来），此时 head != h ，线程 t 将会进行下一轮循环。</p></li><li><p><strong>compareAndSetWaitStatus(h, Node.SIGNAL, 0) 失败</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-6.jpg" alt><br>线程 t 进行第二轮循环时，刚好被唤醒的线程 t1 也进入该循环，此时两个线程并发执行，假设线程 t CAS 操作成功，然后退出循环，线程 t1 失败，将会进行下一轮循环。注意，此时虚节点的 next 指针还存在，因为我们假设的是 t1 线程失败了，t 线程成功退出了，t 线程不属于阻塞队列中的线程，它不会维护阻塞队列节点关系，如果是 t1 线程成功并退出循环就会清除它上一个节点的 next ，这里就是虚节点。</p></li><li><p><strong>执行 else if (ws == 0 &amp;&amp;..) 分支</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-7.jpg" alt><br>t1 线程第二次循环时，唤醒的 t2 线程还没有占领 head，此时的 head 还是 t1 线程对应的节点，但是 waitStatus 被之前的 t 线程通过 CAS 设置为 0 了，因此进入到 else if 分支，然后再次把节点 watiStatus 设置为 -3 。执行到 h == head 判断处时，假设 t2 还是没有占领 head ，此时 t1 退出循环，然后清除其前置节点的 next 指针，即虚节点。</p></li><li><p><strong>compareAndSetWaitStatus(h, 0, Node.PROPAGATE) 失败</strong><br>进入这个方法的前提是 ws == 0，即 head 的 waitStatus 出现了 0，此时如果 CAS 失败，一般有两种可能，一种是线程并发执行 CAS 只有一个会成功，另一种是其它的线程把该节点的 waitStatus 值修改了，此时能改 head 的状态值的很可能是节点入队引起的修改，因为新节点要把有效的前驱节点状态值设置为 -1 。在 CountDownLatch 中一般不会发生第二种可能，因为一旦唤醒条件成立，就不会再有节点需要入队阻塞了。</p></li></ul><p>剩下的 t2 线程、t3 线程依次会被唤醒，需要注意的是 t3 线程被唤醒占领头节点后也会进入到 doReleaseShared 方法的循环中，此时它对应的节点既是 head 又是 tail，就直接退出循环，结束整个流程了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>CountDownLatch 的构造函数需要一个 int 类型的参数作为数量（用来计数），如果想等待 N 个任务完成（N 个线程执行完任务），就需要传入 N 。CountDownLatch 的 countDown 方法用于将 N 减 1 ,await 方法会阻塞当前调用线程（阻塞在门栓上，门栓是一个同步点的概念），直到 N 减至 0 被阻塞的线程才会继续往下执行。此外，CountDownLatch 还提供了一个带有指定时间的 await 方法，用于等待超时的场景，超过等待时间就不会再等，被阻塞线程继续往下执行。这个方法很简单，就是在 await 方法的基础上增加了超时判断，下面粘贴下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">--- CountDownLatch</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">            doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared timed mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanosTimeout max wait time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 计算出等待的最迟时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 计算出等待剩余时间</span></span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="comment">// 超过等待时间，则不再等待，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// 执行挂起的最小时间粒度</span></span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    <span class="comment">// 挂起 nanosTimeout 时间后自动醒来</span></span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意，N 值必须 大于等于 0，如果 N 等于 0 ，调用 await 方法时当前线程不会被阻塞，此外 CountDownLatch 不支持重新初始化，也不支持修改数量的值。</p></blockquote><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="使用例子-1"><a href="#使用例子-1" class="headerlink" title="使用例子"></a>使用例子</h3><p><strong>场景</strong></p><blockquote><p>某个公司部门举办团建活动，需要员工自行拼车前往目的地，司机会在指定的地点等待拼车的 4 个人到齐后才发车。我们假设该部门某个团队有 8 个人，那么就需要拼 2 辆车前往目的地。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定线程数线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要等待 4 个同学到齐，到齐后发车，因此这里初始化一个带有 Runnable 参数的 CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, () -&gt; log.info(<span class="string">"4人已到齐，请系好安全带，现在出发赶往目的地 !"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8个人，需要 2 辆车。这里会循环使用 CyclicBarrier</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 赶往拼车地点</span></span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">                    log.info(<span class="string">"到达指定拼车地点 !"</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                   </span><br><span class="line">                    <span class="comment">// 一组人员全部到达后，才能出发。 即 一组线程全部到达栅栏后，被阻塞的线程才能继续执行</span></span><br><span class="line">                    log.info(<span class="string">"出发了 !"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException exception) &#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CyclicBarrierDemo - 4人已到齐，请系好安全带，现在出发赶往目的地 !</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-8] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-7] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-7] INFO com.code.juc.tool.CyclicBarrierDemo - 4人已到齐，请系好安全带，现在出发赶往目的地 !</span><br><span class="line">[pool-1-thread-7] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-8] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>以上例子中，使用循环体和线程池模拟 8 个线程执行任务，其中每 4 个线程为一组，只有这 4 个线程都到达栅栏，例子中是到达指定拼车点，才能继续往下执行，否则都会阻塞在栅栏上等待其它线程到达栅栏。到达栅栏的定义是 线程调用 await 方法。一组线程都到达栅栏后，由最后到达的线程执行及时任务，没有任务则不执行。CyclicBarrier 是可循环使用的栅栏，当一组线程都到齐后，CyclicBarrier 进行下一个循环，下一组线程进行同样的操作。</p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>CyclicBarrier 的字面意思是可循环使用的栅栏，因为它的栅栏可以重复使用（通过重置关键属性）。它要做的事情是，让一组线程到达一个栅栏（是一个同步点）时被阻塞，直到最后一个线程到达栅栏时，栅栏才会打开，所有被栅栏拦截的线程才能继续运行。它的功能是通过组合 <code>ReentrantLock</code> 和 <code>Condition</code> 来达到的。我们还是基于使用例子来分析源码。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cb-1.jpg" alt></p><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栅栏所处的代。栅栏上阻塞的线程被唤醒或者栅栏被重置，就开启新的一代</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 栅栏是否被打破，默认为 false</span></span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁对应的条件，阻塞线程在栅栏或者唤醒阻塞在栅栏上的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栅栏要拦截的线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一组线程都到达栅栏后优先执行的任务，即如果设置这个这个任务，那么被阻塞在栅栏上的线程要等这个任务结束后才能被唤醒。注意，这个任务是被最后到达的线程执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前栅栏所处的代，如果第一次就是 1 代，如果第2次使用就是 2 代</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 还要等待的线程数，即还没有到栅栏的线程数。这个初始值 是 parties 值，每个线程到栅栏就减 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CyclicBarrier 高级构造函数，支持优先执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CyclicBarrier 默认的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier 默认的构造方法的参数表示栅栏拦截的线程数，每个线程调用 await 方法都会告诉 CyclicBarrier 我已经到达栅栏，此时栅栏要把拦截的线程数减 1 ，然后阻塞当前线程，直到要拦截的线程都到达栅栏时，栅栏才会打开，即最后到达的线程唤醒阻塞在栅栏上的线程，然后这组线程都从 await 方法处继续往下执行。 CyclicBarrier 还提供一个高级构造函数，用于在最后一个线程到达栅栏时，优先执行的任务，便于处理复杂的业务场景。注意，<strong>执行优先任务先于唤醒阻塞线程</strong> ，代码中所有体现。</p><h4 id="下一代栅栏"><a href="#下一代栅栏" class="headerlink" title="下一代栅栏"></a>下一代栅栏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---CyclicBarrier</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启下一代栅栏</span></span><br><span class="line"><span class="comment">     * 1 唤醒阻塞在上一代栅栏上的线程</span></span><br><span class="line"><span class="comment">     * 2 重置 count 和 generation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// signal completion of last generation</span></span><br><span class="line">        trip.signalAll();</span><br><span class="line">        <span class="comment">// set up next generation</span></span><br><span class="line">        count = parties;</span><br><span class="line">        generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>开启下一代栅栏很好理解，因为要开启下一代栅栏了，当前代栅栏上阻塞的线程需要被唤醒，同时初始化好下一代栅栏。</p><h4 id="打破栅栏"><a href="#打破栅栏" class="headerlink" title="打破栅栏"></a>打破栅栏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---CyclicBarrier</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 打破栅栏</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 设置栅栏已破标志</span></span><br><span class="line">          generation.broken = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">// 重置 count</span></span><br><span class="line">          count = parties;</span><br><span class="line">          <span class="comment">// 唤醒阻塞在栅栏上的线程</span></span><br><span class="line">          trip.signalAll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打破栅栏需要标记当前代的栅栏不可用，并且要唤醒阻塞在这个不可用的栅栏上的线程，因为这里不进行唤醒的话，阻塞的线程将一直挂起。这里重制 count 不明白是干嘛的。</p><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">--- CyclicBarrier</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不带超时机制的方法，例子中使用的就是这个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// false , 0</span></span><br><span class="line">            <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 带有超时机制的方法，如果超过等待时间，当前线程没有被唤醒则 抛出 TimeoutException</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">               BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier 提供了 await 两个重载方法，一个是不带超时机制的方法，另一个是带有超时机制的方法。下面我们分析 CyclicBarrier 核心代码 <code>dowait</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">--- CyclicBarrier</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用可重入锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取标志着当前栅栏的 代</span></span><br><span class="line">            <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查当前代的栅栏是否被打破，如果当前代的栅栏被打破需要 抛出 BrokenBarrierException 异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查当前线程中断状态，如果被中断了，则要抛出 InterruptedException 异常，并且打破栅栏</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递减 count 的值</span></span><br><span class="line">            <span class="keyword">int</span> index = --count;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果 count 递减后的值为 0 ，说明当前代的栅栏要拦截的最后一个线程也到达栅栏</span></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 标志优先任务是否失败，默认是 false</span></span><br><span class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果指定了优先任务，就交给最后到达的线程执行</span></span><br><span class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 设置标志</span></span><br><span class="line">                    ranAction = <span class="keyword">true</span>;</span><br><span class="line">                   </span><br><span class="line">                    <span class="comment">// 唤醒当前代的栅栏上阻塞的任务，并开启下一代 （栅栏可以重复使用）</span></span><br><span class="line">                    nextGeneration();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果执行优先任务失败，则打破栅栏</span></span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// ---------------------- 执行到这里的线程不是最后一个线程，因此需要阻塞，等待最后一个线程到来并唤醒自己 ---------------/</span></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 不带超时机制</span></span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        <span class="comment">// 释放锁，加入等待队列 (ConditionObject)</span></span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="comment">// 带超时机制，并且超时时间 &gt; 0</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        <span class="comment">// 释放锁，加入等待队列 (ConditionObject)，如果到时间还没有被唤醒则不再阻塞</span></span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 执行到这里说明，线程进入等待队列后被中断了</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="comment">// 栅栏仍是进入等待队列的前的栅栏，此时应该打破栅栏，并且抛出中断异常</span></span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 1 g != generation，说明新一代的栅栏生成了，即最后一个线程也到达了栅栏，此时只需复位被中断线程的中断标志</span></span><br><span class="line">                        <span class="comment">// 2 栅栏被打破了（一定要抛出异常），被打破异常交由后续逻辑处理，此时只需复位被中断线程的中断标志</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 线程被唤醒后，还没从 await 方法返回栅栏就被打破了，直接抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 这个方法很重要，被唤醒后的线程正常逻辑都会从该方法返回出去</span></span><br><span class="line"><span class="comment">                 * 1 最后一个线程到达后会做三件事：执行优先任务、唤醒当前代的栅栏上阻塞的线程、开启栅栏的下一代</span></span><br><span class="line"><span class="comment">                 * 2 当前所在的方法是加了 ReentrantLock 锁的，因此我们要知道以下信息：</span></span><br><span class="line"><span class="comment">                 *   1）最后一个到达线程在没有执行完三件事前，是不会释放锁的</span></span><br><span class="line"><span class="comment">                 *   2）唤醒的阻塞线程并不能马上从 await 方法返回，它需要先去竞争锁，获取锁后才能从 await 方法返回</span></span><br><span class="line"><span class="comment">                 *   3）即使最后一个线程开启了栅栏的下一代，在它没有释放锁前，其它组的线程也要阻塞，比如例子中的后四个线程</span></span><br><span class="line"><span class="comment">                 * 3 被最后一个线程唤醒的线程执行到这里时，新一代的栅栏一定已经存在了。注意，这里说的是被最后一个线程唤醒的线程，并不是由于超时机制醒来的线程</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 超时机制醒来的线程，如果发现已经超时了，则打破栅栏，抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>涉及到的源码已经分析过了，下面结合使用例子简单分析下过程</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cb-2.jpg" alt></p><p>CyclicBarrier 整个过程还是挺清晰的，没有使用 CAS 重试等机制，因为栅栏等待线程的 await 方法直接使用了ReentrantLock 锁，线程要到达栅栏必须拿到锁才行，整个过程是串行化的。分析完核心方法后，我们再看下其它几个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">--- CyclicBarrier</span><br><span class="line">    <span class="comment">// 重置栅栏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">            nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在栅栏上等待线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parties - count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断栅栏是否被打破</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generation.broken;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>CyclicBarrier 和 CountDownLatch 还是有点像的，前者强调的是一组线程到达同步点即栅栏，后者强调的是阻塞在同步点的线程等待其它线程完成任务。具体区别如下：</p><ul><li>作用不同<br>CyclicBarrier 要等固定数量线程到达同步点，CountDownLatch 等待的不是线程而是同步状态state递减为 0。前者针对线程，后者针对事件/任务（根据需要调用 countDown 方法）。</li><li>重用性不同<br>CyclicBarrier 可以重复使用，上一代使用完后自动初始化下一代，也可以调用 reset 方法重置。 CountDownLatch 只能使用一次，在同步状态减为 0 后门栓打开后，就不能再次使用，想要使用需要新建实例。</li><li>唤起任务数不同<br>CyclicBarrier 只能唤醒一个任务，CountDownLatch 可以唤醒多个任务</li></ul><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="使用例子-2"><a href="#使用例子-2" class="headerlink" title="使用例子"></a>使用例子</h3><p><strong>场景</strong></p><blockquote><p>有一些加工厂是对环境有很大污染的，如果要生产产品必须要有关机构申请生产许可证，拿到许可证后才可以生产，完成一定规模后需要归还许可证，便于其它工厂可以申请。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定线程数线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有 3 个许可证书，每个加工厂公平获取。</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有 6 个加工厂想要获取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取许可证</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    log.info(<span class="string">"拿到了许可证"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理任务</span></span><br><span class="line">                    log.warn(<span class="string">"凭借许可证处理任务..."</span>);</span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log.info(<span class="string">"归还许可证"</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-1] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-2] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-3] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-4] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-5] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-6] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>以上例子中，使用循环体和线程池模拟 6 个线程，即 6 个加工厂获取生产许可证。Semaphore 的许可证数量为 3，即监管部门目前只有 3 个生产许可证，此时 6 个工厂只能有其中三个可以获取到，另外 3 个工厂只能等待生产许可证的归还，如果不归还将一直等着。</p><h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><p>Semaphore 是用来控制同时访问特定资源的线程数量，它通过协调各个线程来保证合理的使用有限的公共资源。Semaphore 也是对 AQS 共享模式的使用，因此套路也是一样的。它接收一个整形的数字 permits，也是 AQS 的 state，表示可用的许可证数量，即允许 permits 个线程获取许可证，也就是最大并发数是 permits。因为是共享模式的使用，因此需要重写对应的模版方法 <code>tryAcquireShared</code> 和 <code>tryReleaseShared</code> ，前者用来判断能否获取到许可证，后者用来判断能否归还许可整（总是返回true）。此外，Semaphore 在此基础上增加了公平和非公平获取同步状态的功能。Semaphore 的用法很简单，它的 <code>acquire</code> 方法获取许可证，<code>release</code> 方法归还许可证，获取不到许可证的线程就加入阻塞队列中，等待其它线程释放许可证。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-1.jpg" alt></p><h4 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h4><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-2.jpg" alt></p><p>前面也提到了，Semaphore 是对 AQS 共享模式的使用，并且支持公平和非公平的状态管理方式，即对同步状态 state 的操作。通过上图的 UML 类图更加清晰，Semaphore 既可以公平实现方式创建对象，又能以非公平方式创建对象。</p><h4 id="Sync-内部类"><a href="#Sync-内部类" class="headerlink" title="Sync 内部类"></a>Sync 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 AQS 的内部类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信号量的同步实现。使用 AQS 的同步状态 state 表示许可证。分为 公平和非公平两种实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法，设置 AQS 的同步状态 state。对于 Semaphore 来说表示许可证</span></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取同步状态，即许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非公平实现，共享式获取许可证。返回剩余许可证数量</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式释放同步状态方法，即归还许可证。该方法总是返回 true</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="comment">// 归还 releases 个许可证 (注意，如果不获取先释放的话，许可证会变多的)</span></span><br><span class="line">                <span class="keyword">int</span> next = current + releases;</span><br><span class="line">                <span class="comment">// 这里判断归还数量不能小于 0</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                <span class="comment">// CAS 更新 state （AQS 中的方法 ）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync 内部类首先对同步状态 state 进行了初始化，先确定同步状态 state 的值，即表示的意义，这里指许可证。第二个是获取同步状态 - tryAcquireShared，这里指获取许可证，Sync 中没有进行实现而是交给了两个子类。第三个是释放同步状态 - tryReleaseShared，这里指归还许可证，Sync 中统一实现了这个逻辑。下面我们分别看下其子类实现。</p><h4 id="NonfairSync-内部类"><a href="#NonfairSync-内部类" class="headerlink" title="NonfairSync 内部类"></a>NonfairSync 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 AQS 的内部类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信号量的同步实现。使用 AQS 的同步状态 state 表示许可证。分为 公平和非公平两种实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法，设置 AQS 的同步状态 state。对于 Semaphore 来说表示许可证</span></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取同步状态，即许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非公平实现要执行的方法，共享式获取许可证。返回剩余许可证数量</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式释放同步状态方法，即归还许可证。该方法总是返回 true</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="comment">// 归还 releases 个许可证 (注意，如果不获取先释放的话，许可证会变多的)</span></span><br><span class="line">                <span class="keyword">int</span> next = current + releases;</span><br><span class="line">                <span class="comment">// 这里判断归还数量不能小于 0</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                <span class="comment">// CAS 更新 state （AQS 中的方法 ）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式获取同步状态的方法，这里是非公平方式获取许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NonfairSync 内部类只做了一件事情，重写 AQS 的 tryAcquireShared 方法，需要注意它的非公平性，也就是不关心阻塞队列中有没有还在等待的线程，直接尝试获取许可证。</p><h4 id="FairSync-内部类"><a href="#FairSync-内部类" class="headerlink" title="FairSync 内部类"></a>FairSync 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 AQS 的内部类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信号量的同步实现。使用 AQS 的同步状态 state 表示许可证。分为 公平和非公平两种实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法，设置 AQS 的同步状态 state。对于 Semaphore 来说表示许可证</span></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取同步状态，即许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非公平实现，共享式获取许可证。返回剩余许可证数量</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式释放同步状态方法，即归还许可证。该方法总是返回 true</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="comment">// 归还 releases 个许可证 (注意，如果不获取先释放的话，许可证会变多的)</span></span><br><span class="line">                <span class="keyword">int</span> next = current + releases;</span><br><span class="line">                <span class="comment">// 这里判断归还数量不能小于 0</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                <span class="comment">// CAS 更新 state （AQS 中的方法 ）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式获取同步状态的方法，这里是非公平方式获取许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式获取同步状态的方法， 这里是 公平方式获取许可证。返回剩余许可证数</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="comment">// 是否有线程在排队等待许可证</span></span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FairSync 内部类同样只做了一件事情，重写 AQS 的 tryAcquireShared 方法，以公平的方式实现，也就是线程在获取许可证之前，先判断阻塞队列中是否还有等待的线程，有的话就直接返回 -1 进入阻塞队列中等待。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 以非公平方式创建 Semaphore</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">     sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 可选择公平/非公平方式创建 Semaphore</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">     sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>和 ReentrantLock 有点类似，实现了公平和非公平方式，默认使用非公平实现。</p><h4 id="acquire-系列方法"><a href="#acquire-系列方法" class="headerlink" title="acquire 系列方法"></a>acquire 系列方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">--- Semaphore</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可响应中断地获取许可证（获取一个许可证）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 的方法</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">       <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- Semaphore</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取许可证（获取一个许可证），对中断不敏感</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 的方法</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 内部会调用 doReleaseShared 方法</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- Semaphore</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 Semaphore 获取给定数量的许可证，不够就阻塞等待，对中断敏感</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        sync.acquireSharedInterruptibly(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 Semaphore 获取给定数量的许可证，不够就阻塞等待，对中断不敏感</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        sync.acquireShared(permits);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过 acquire 方法也可以看出，AQS 框架在实现共享式获取同步状态时，当且仅当同步状态处理结果小于 0 时，线程才会走入队流程。因为都是共享式实现，AQS 底层处理是一样的，因此后续的入队、找有效前驱节点以及挂起操作和 CountDownLatch 是一样的，就不再分析了。继续看它的释放同步状态的方法。</p><h4 id="release-系列方法"><a href="#release-系列方法" class="headerlink" title="release 系列方法"></a>release 系列方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">--- Semaphore</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归还许可证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 方法</span></span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归还给定数量的许可证到 Semaphore</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">         <span class="comment">// AQS 方法</span></span><br><span class="line">        sync.releaseShared(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Semaphore 实现的释放同步状态方法</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过 release 系列方法也可以看出，AQS 框架在实现共享式释放同步状态时，当且仅当同步状态处理结果为 true 时，才会唤醒阻塞队列的线程。因为都是共享式实现，AQS 底层处理是一样的，因此唤醒的流程和 CountDownLatch 是一样的。</p><h4 id="例子流程"><a href="#例子流程" class="headerlink" title="例子流程"></a>例子流程</h4><ul><li><p>Semaphore 初始化 3 个 许可证<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-3.jpg" alt><br>同一个JVM进程中，某一时刻对 resource 访问的最大并发请求数为3</p></li><li><p>某一时刻t1、t2、t3获取到许可证，t4进入阻塞队列等待<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-4.jpg" alt><br>线程t1、t2、t3拿到许可证去访问资源，此时 Semaphore 中已经没有可用的许可证了，t4只能加入阻塞队列等待许可证的释放。这里 t4 要入队。</p></li><li><p>t3 访问资源后归还许可证，t4 获取到获取到许可证<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-5.jpg" alt><br>这个过程可能会有多种情况，如，t4 在没有挂起之前，t3 已经归还了许可证，此时 t4 直接就可以拿到。如果 t4 不太幸运的话，会挂起然后等待t3来唤醒。Semaphore 的一些特殊情况可以参考 CountDownLatch。</p></li><li><p>其它线程获取许可证依次类推</p></li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Semaphore 使用的注意事项：</p><ol><li>获取和释放的许可证数量必须一致，否则随着许可证的获取和归还流程推进，最后会导致许可证数量不够，将出现程序卡死。</li><li>在初始化 Semaphore 的时候可以设置释放公平，这个可以根据情景选择，一般设置为 true 更合理，因为 Semaphore 本身就是限制同时请求量的，不针对某个请求的。</li><li>获取和释放许可证不一定非要同一个线程来完成，可以是 线程 A 获取，线程 B 释放，逻辑合理即可。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是 ReentrantLock，还是 CountDownLatch、CyclicBarrier、Semaphore 等 ，它们都是对 AQS 应用，至于是实现锁的功能，还是实现同步组件根据具体场景进行设计。本质上都离不开同步状态 <code>state</code>、独占方式 <code>tryAcquire-tryRelease</code> 获取与释放方法，共享方式 <code>tryAcquireShared-tryReleaseShared</code> 获取与释放方法，此外 AQS 也支持自定义同步组件同时实现独占和共享两种方式，以及公平和非公平实现，不同组件表示的意义是不同的。AQS 还提供了 <code>等待队列</code> 机制，ReentrantLock 就基于该机制实现了等待与唤醒机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 JDK 的并发包中提供了几个非常有用的并发工具类。 &lt;code&gt;CountDownLatch&lt;/code&gt;、&lt;code&gt;CyclicBa
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
      <category term="AQS" scheme="https://gentryhuang.com/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>AQS 原理分析 - Condition实现原理</title>
    <link href="https://gentryhuang.com/posts/40e44c1f/"/>
    <id>https://gentryhuang.com/posts/40e44c1f/</id>
    <published>2020-10-26T13:45:45.000Z</published>
    <updated>2021-01-04T08:50:29.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在 JUC 之前，Java 实现等待/通知模式是通过定义在 Object 中的一组监视器方法 <code>wait方法</code>、<code>notify()</code>以及 <code>notifyAll()</code> 与 <code>synchronized</code> 关键配合完成。在 JUC 中单独提供了一套等待/通知模式的实现方式，具体实现是 <code>Condition</code> 接口与 <code>Lock</code> 接口配合完成。</p><p><code>Condition</code> 接口提供了类似 Object 的监视器方法，但该接口中定义的方法功能上更强大。比如，<code>Condition</code> 支持响应/不响应中断以及等待超时等接口。</p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>生产者-消费者是 Condition 其中的一个经典使用场景，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notFull Condition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * notEmpty Condition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组，大小为 100</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分别为添加的下标、移除的下标和数组当前数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产</span></span><br><span class="line"><span class="comment">     * 如果数组满了，则添加线程进入等待状态，直到有空位才能生产</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x item</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 元素数量等于数组长度，线程等待</span></span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加元素</span></span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="comment">// 添加下标 putptr 递增，和移除的下标 takeptr 对应。</span></span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 数组元素个数递增</span></span><br><span class="line">            ++count;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生产后通知消费</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费</span></span><br><span class="line"><span class="comment">     * 如果数组为空，则消费线程进入等待状态，直到数组中有元素才能继续消费</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> item</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 数组为空，线程等待</span></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出元素</span></span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            <span class="comment">// 移除下标递增</span></span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 数组元素个数递减</span></span><br><span class="line">            --count;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消费后通知生产</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上述示例中，BoundedBuffer 实现了生产者-消费者模式，下面进行简单概述：</strong></p><ol><li>使用 Condition 时先获取相应的 Lock 锁，和 Object 类中的方法类似，需要先获取某个对象的监视器锁才能执行等待、通知方法。</li><li>生产和消费方法中判断数组状态使用的是 while 自旋而非 if 判断，目的是防止过早或意外的通知，当且仅当条件满足才能从 await() 返回。</li></ol><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>Condition 结合 Lock 实现的等待通知机制包括两部分内容即等待和通知，分别依赖单向链表和双向链表。Condition 接口的实现类是 AQS 内部类 ConditionObject，它内部维护的队列称为条件队列，基于单向链表实现。Lock 是基于 AQS 实现的，它内部维护的队列称为同步队列，基于双向链表实现。Condition 对象是由 Lock 对象创建出来的，并且一个 Lock 对象可以创建多个 Condition 对象，每个 Condition 对象共享 Lock 这个外部资源。</p><p>获取到同步状态（锁）的线程调用 <code>await</code> 方法进行等待时，会先将自己打包成一个节点并加入到对应的条件队列中，加入成功后会<strong>完全释放同步状态</strong>，释放同步状态成功后会在该条件队列的尾部等待，于此同时该线程在同步队列中的节点也会被移除。在某个 Condition 上（条件队列）等待的线程节点被<code>signal</code> 或 <code>signalAll</code> 后，对应的线程节点会被转到外部类的同步队列中，这意味着该节点有了竞争同步状态的机会，线程需要获取到同步状态才能继续后续的逻辑。需要说明的是，一个锁对象可以同时创建 N 个 Condition 对象（对应 N 个条件队列），这表明获取到同步状态的线程可以有选择地加入条件队列并在该队列中等待，其它获取到同步状态的线程可以有选择地唤醒某个条件队列中的等待的线程。但不管有多少个条件队列，竞争同步状态的线程节点需要统一转到外部类的同步队列中，也就是 Lock 维护的双向链表，此后就是竞争同步状态的逻辑了。</p><p>下图简单描述了 Condition 的工作原理：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-condition-process.jpg" alt></p><p>以上就是 Condition 实现的等待-通知机制。需要说明的是，上述描述没有涉及过多的细节，如异常流的处理。接下来我们通过对代码层面的解析来全面了解 Condition 的机制。</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-condition-method.jpg" alt></p><p>Condition 接口中定义的方法和 Object 中的监视器方法类似，区别在于前者支持响应中断和超时等待。下面对该接口中定义的方法进行简单说明：</p><ol><li><strong>void await() throws InterruptedException 方法</strong><blockquote><p>响应中断的等待方法，线程进入条件队列挂起，直到被通知或中断。</p></blockquote></li><li><strong>void awaitUninterruptibly() 方法</strong><blockquote><p>不响应中断的等待方法，不会抛出中断异常，仅仅复位中断标志，线程进入条件队列挂起，直到被通知或中断。</p></blockquote></li><li><strong>long awaitNanos(long nanosTimeout) throws InterruptedException 方法</strong><blockquote><p>在 await() 基础上增加了超时功能，线程进入条件队列挂起直到被通知、中断或超时，如果在 nanosTimeout 内返回，那么返回值就是 nanosTimeout - 实际耗时，如果返回值是 0 或者负数，表示超时了。</p></blockquote></li><li><strong>boolean awaitUntil(Date deadline) throws InterruptedException 方法</strong><blockquote><p>在 await() 基础上增加了超时功能，线程进入条件队列挂起直到被通知、中断或者到某个时间。如果没有到指定时间就通知，返回 true，否则表示超时。</p></blockquote></li><li><strong>boolean await(long time, TimeUnit unit) throws InterruptedException 方法</strong><blockquote><p>和 awaitUntil(Date deadline) 方法几乎一致，前者是绝对时间，后者是时间粒度。</p></blockquote></li><li><strong>void signal() 方法</strong><blockquote><p>将条件队列中的头节点转到同步队列中，以等待竞争同步状态。</p></blockquote></li><li><strong>void signalAll() 方法</strong><blockquote><p>将条件队列中的所有节点依次转到同步队列中，以等待竞争同步状态。此时条件队列进入下一个周期。</p></blockquote></li></ol><p>在 JUC 中 Condition 主要基于 <code>ReentrantLock</code> 和 <code>ReentrantReadWriteLock</code> 实现的，在语义中就是我们说的锁概念，而锁又是基于 AQS 实现的。总的来说，Condition 依赖 Lock，Lock 实现是基于 AQS 的。下面以 <code>ReentrantLock</code> 作为 Condition 的实现进行说明。</p><h2 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h2><p><code>ConditionObject</code>实现了 Condition 接口，同时作为<code>AbstractQueuedSynchronizer</code>的内部类，因为 Condition 的操作需要获取到同步状态，因此其实现类作为<code>AbstractQueuedSynchronizer</code>的内部类是比较合理的，这意味着<code>ConditionObject</code>可以访问外部资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractQueuedSynchronizer</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 条件队列 - 头节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 条件队列 - 尾节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates a new &#123;<span class="doctag">@code</span> ConditionObject&#125; instance.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>每个 ConditionObject 对象内部维护了一个基于单向链表的条件队列</strong>，该队列是 Condition 实现等待-通知机制的关键。既然是链表，其中的节点定义是什么呢？ConditionObject 没有重新定义链表节点，而是直接使用外部类 AbstractQueuedSynchronizer 定义的 Node ，这也是合理的。下面我们简单看下该 Node 的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractQueuedSynchronizer</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 共享类型节点，表明节点在共享模式下等待</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 独占类型节点，表明节点在独占模式下等待</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态 - 取消（线程已经取消）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态 - 通知（后继线程需要被唤醒）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态 - 条件等待（线程在 Condition 上等待）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态 - 传播（无条件向后传播唤醒动作）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 等待状态，初始值为 0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同步队列中使用，前驱节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同步队列中使用，后继节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 节点中封装的线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 条件队列中使用，后置节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>条件队列和同步队列共同使用上述的 <strong>Node</strong> 节点构建队列，区别在于前者底层数据结构是双向链表，节点的维护使用 <strong>prev</strong> 和 <strong>next</strong> 属性，后者底层数据结构是单向链表，节点维护使用 <strong>nextWaiter</strong> 属性，两者中的节点等待状态都是使用 <strong>waitStatus</strong> 属性。</p><p><code>ReentrantLock</code> 对象和 <code>ReentrantReadWriteLock</code> 对象可以创建多个 ConditionObject 对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>下面对 <code>ReentrantLock</code> 和 <code>ConditionObject</code> 的关联关系进行说明：</strong></p><ol><li>ConditionObject 维护的条件队列和 ReentrantLock 维护的同步队列的节点都是 Node 的实例，条件队列的线程节点需要移动到同步队列中以参与竞争同步状态。</li><li>ReentrantLock 对象与 ConditionObject 对象的比例关系为： 1 : N ，每个 ConditionObject 都能直接访问 ReentrantLock 这个外部类资源。</li><li>一个同步队列对应 N 个条件队列，同步队列中的线程（获取到同步状态）可以选择性地进入不同的条件队列进行等待，而多个条件队列中的线程节点要参与竞争同步状态就需要进入同一个同步队列。</li></ol><p>接下来对等待和通知的核心代码进行分析，根据主要流程分别说明。</p><h2 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h2><p><code>ConditionObject</code> 中实现了几种不同功能的等待方法，在介绍 <code>Condition</code> 接口时已经详细说明，下面先对 <code>await()</code> 的方法实现进行分析。</p><p>当获取同步状态的线程调用 <code>await()</code> 方法时，相当于同步队列的头节点中的线程（获取了同步状态的节点）进入到 Condition 的条件队列中，完全释放同步状态后同步队列将会移除该线程对应的节点。需要说明的是，下图中的第 2 步中释放同步状态失败的情况是针对没有获取到同步状态就执行 <code>await</code> 方法的情况，获取到同步状态的线程在释放状态的时候一般是不会出释放同步状态失败的情况。值得一提的是，同步队列中头节点的线程是先释放同步状态然后才会占领头节点进而去唤醒后继等待的线程，也就是同步队列中的头节点就是供持有同步状态的线程占领，进而唤醒后继等待线程。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-condition-await-process.jpg" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 响应中断</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 将当前线程封装到节点中，并将节点加入到条件队列尾部</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 保存并完全释放同步状态，注意是完全释放，因为允许可重入锁。如果没有持锁会抛出异常，也就是释放同步状态失败</span></span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="comment">// 记录中断模式</span></span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *3. 判断上述加入到条件队列的线程节点是否被移动到了同步队列中，不在则挂起线程（曾经获取到锁的线程）。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 循环结束的条件：</span></span><br><span class="line"><span class="comment">         * 1. 其它线程调用 signal/signalAll 方法，将当前线程节点移动到同步队列中，节点对应的线程将会在竞争同步状态的过程被前驱节点唤醒。</span></span><br><span class="line"><span class="comment">         * 2. 其它线程中断了当前线程，当前线程会自行尝试进入同步队列中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="comment">// 挂起线程，直到被唤醒或被中断</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 检测中断模式：</span></span><br><span class="line"><span class="comment">             * 在线程从 park 中返回时，需要判断是被唤醒返回还是被中断返回。</span></span><br><span class="line"><span class="comment">             * 1). 如果线程没有被中断，则返回 0，此时需要重试循环继续判断当前线程节点是否在同步队列中。</span></span><br><span class="line"><span class="comment">             * 2). 如果线程被中断</span></span><br><span class="line"><span class="comment">             *   - 中断发生在被唤醒之前，当前线程（线程节点）会尝试自行进入同步队列并返回 THROW_IE，后续需要抛出中断异常。todo</span></span><br><span class="line"><span class="comment">             *   - 中断发生在被唤醒之后，即当前线程（线程节点）尝试自行进入同步队列失败（说明其它线程调用过了 signal/signalAll 唤醒线程并尝试将线程节点转到同步队列），</span></span><br><span class="line"><span class="comment">             *     返回 REINTERRUPT ，后续需要重新中断线程，向后传递中断标志。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 醒来后，被移动到同步队列的节点 node 重新尝试获取同步状态成功，且获取同步状态的过程中如果被中断，接着判断中断模式非 THROW_IE 的情况会更新为 REINTERRUPT</span></span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5. 清理取消节点。正常情况下 signal/signalAll 将节点转到同步队列的同时会将节点的 nextWaiter 置空，这里主要对自行进入到同步队列中的节点进行处理。</span></span><br><span class="line">        <span class="comment">// 1） 中断模式为 THROW_IE 的情况下 nextWaiter 不会被置空，且等待状态为 0 ，这种情况下节点应该从条件队列中移除。</span></span><br><span class="line">        <span class="comment">// 2） fullyRelease 方法出现异常，nextWaiter 不会被置空，且等待状态为 CANCELLED，清理任务会由后继的节点完成。</span></span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">            <span class="comment">// 清理条件队列中取消的节点（重组链表）</span></span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6. 如果线程发生过中断则根据 THROW_IE 或 REINTERRUPT 分别抛出异常或者重新中断。 todo 最终都要抛出异常还获取个球球的锁</span></span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>下面对上述整个等待流程进行概述：</strong></p><ol><li>将获取到同步状态的线程封装到节点中并加入到条件队列。</li><li>完全释放同步状态，并记录获取到的同步状态，为后面重新竞争同步状态做准备。</li><li>在条件队列中等待被唤醒，或者被中断。</li><li>再次竞争挂起等待前的同步状态。</li><li>对中断情况的处理，抛出异常或重新中断线程以复位中断标志。</li></ol><p>以上对整个等待流程进行了总体描述，需要注意的是，<strong>当线程从<code>await()</code>方法返回时，当前线程一定获取了<code>Condition</code>相关联的锁</strong>。下面对其中的分支流进行说明。</p><h3 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h3><p>将当前线程封装到节点中，然后加入到当前 Condition 对象维护的条件队列的尾部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 条件队列尾节点</span></span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选出条件队列中有效尾节点。这里主要处理 fullyRelease 方法出现异常的情况。</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        <span class="comment">// 如果需要，清理条件队列中取消的节点（重组链表）</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        <span class="comment">// 重读尾节点，可能为 null</span></span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点封装当前线程，节点状态为 CONDITION</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化条件队列，firstWaiter 更新为当前节点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前节点加入到条件队列尾</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新条件队列尾指针指向</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="comment">// 返回当前线程关联的节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特别说明：</strong></p><p>addConditionWaiter() 方法不一定是线程安全的，没有获取到锁就调用 <strong>await</strong> 方法就是不安全操作。虽然没有获取到锁的线程执行 <strong>await</strong> 方法最终会抛出异常，遗留在条件队列的节点也会被后继节点清理，但是如果持锁和不持锁的两个线程同时调用 <strong>await</strong> 方法就可能会产生并发问题，使 ConditionObject 维护的条件队列中节点产生覆盖，这是一种破坏行为，最终会导致有些成功调用 await 方法的线程可能永远没有办法被唤醒(非正常唤醒除外，如中断)，更没有机会再次获取锁，因为条件队列中并没有记录它们，记录的是非法调用的线程节点。</p><p>上述过程涉及到清理无效节点的逻辑，该逻辑由 <code>unlinkCancelledWaiters()</code> 方法完成，下面我们来分析该方法。</p><h3 id="unlinkCancelledWaiters"><a href="#unlinkCancelledWaiters" class="headerlink" title="unlinkCancelledWaiters"></a>unlinkCancelledWaiters</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 从首节点开始进行节点检测</span></span><br><span class="line">            Node t = firstWaiter;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录上一个非取消状态节点，参照节点是当前遍历节点</span></span><br><span class="line">            Node trail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历链表</span></span><br><span class="line">            <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 保存当前节点的下一个节点，在当前节点处于取消状态时进行替换</span></span><br><span class="line">                Node next = t.nextWaiter;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果节点的等待状态不是 CONDITION，表明这个节点被取消了。</span></span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                    <span class="comment">// 取消状态的节点要断开和链表的关联</span></span><br><span class="line">                    t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 重组链表，保证链条为空或者所有节点都是非取消状态</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * trail == null，表明 next 之前的节点的等待状态均为取消状态，此时更新 firstWaiter 引用指向</span></span><br><span class="line"><span class="comment">                     * trail != null，表明 next 之前有节点的等待状态为 CONDITION ，此时只需 trail.nextWaiter 指向 next 节点</span></span><br><span class="line"><span class="comment">                     * 注意：</span></span><br><span class="line"><span class="comment">                     * 1 firstWaiter 一定指向链表第一个非取消节点，或者为 null</span></span><br><span class="line"><span class="comment">                     * 2 trail 第一次赋值的话一定和 firstWaiter 一样的值</span></span><br><span class="line"><span class="comment">                     * 3 firstWaiter 一旦被赋予非 null 的值后就不会再变动，后续的节点连接就看 trail 的表演：</span></span><br><span class="line"><span class="comment">                     *   - 如果当前节点是取消节点，就 trail.nextWaiter 指向 next 节点</span></span><br><span class="line"><span class="comment">                     *   - 如果当前节点是非取消节点，trail 跟着节点走</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                        firstWaiter = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        trail.nextWaiter = next;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前节点没有后继则遍历结束，此时当前节点是无效节点，因此将 lastWaiter 回退即更新为上一个非取消节点</span></span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                        lastWaiter = trail;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前节点处于等待状态</span></span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    trail = t;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 下一个节点</span></span><br><span class="line">                t = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>unlinkCancelledWaiters() 方法用于清理取消节点，重新构造链表，主要处理因中断自行加入同步队列和释放同步状态异常的情况。<strong>取消节点的定义是线程节点挂起时被中断或释放同步状态失败。</strong></p><p>线程节点加入到条件队列后就可以执行完全释放同步状态操作，下面我们看具体的逻辑。</p><h3 id="fullyRelease"><a href="#fullyRelease" class="headerlink" title="fullyRelease"></a>fullyRelease</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取同步状态（拿到同步状态的线程）</span></span><br><span class="line">            <span class="keyword">int</span> savedState = getState();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放指定数量的同步状态</span></span><br><span class="line">            <span class="comment">// java.util.concurrent.locks.ReentrantLock.Sync.tryRelease ，没有持有锁会抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 返回同步状态，释放之前的值</span></span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放同步状态失败，需要将节点状态设置为取消状态，后续会被清理</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法用于完全释放同步状态，属于 <code>AbstractQueuedSynchronizer</code> 中定义的方法，上文也提到 <code>ConditionObject</code> 是 <code>AbstractQueuedSynchronizer</code> 的内部类，因此可以共享外部资源。注意，该方法是完全释放同步状态，一般情况下为了避免死锁的产生，锁的实现上一般支持重入功能。</p><p>需要特别说明的是，如果线程没有获取到同步状态就执行 <code>await()</code> 方法，该线程关联的节点能进入到条件队列中，但是进入条件队列后需要调用 <code>fullyRelease</code> 方法执行同步状态释放逻辑，由于没有获取到同步状态在执行到 <code>ReentrantLock.tryRelease</code> 方法时会抛出异常，进而 finally 块中将节点状态进行更新 <code>node.waitStatus = Node.CANCELLED</code> ，这个已经入队到条件队列的节点会被<strong>后续节点</strong>清理出去，也即执行 <code>unlinkCancelledWaiters</code> 方法。</p><p>释放持有的同步状态后会进入自旋等待逻辑，该过程会对通知和中断进行不同的处理。</p><h3 id="等待转入同步队列"><a href="#等待转入同步队列" class="headerlink" title="等待转入同步队列"></a>等待转入同步队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">   <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 挂起线程，直到被唤醒或被中断</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检测中断模式：</span></span><br><span class="line"><span class="comment">         * 在线程从 park 中返回时，需要判断是被唤醒返回还是被中断返回。</span></span><br><span class="line"><span class="comment">         * 1. 如果线程没有被中断，则返回 0，此时需要重试循环继续判断当前线程节点是否在同步队列中。</span></span><br><span class="line"><span class="comment">         * 2. 如果线程被中断</span></span><br><span class="line"><span class="comment">         *   - 中断发生在被唤醒之前，当前线程（线程节点）会尝试自行进入同步队列并返回 THROW_IE，后续需要抛出中断异常。</span></span><br><span class="line"><span class="comment">         *   - 中断发生在被唤醒之后，即当前线程（线程节点）尝试自行进入同步队列失败（说明其它线程调用过了 signal/signalAll 唤醒线程并尝试将线程节点转到同步队列），</span></span><br><span class="line"><span class="comment">         *     返回 REINTERRUPT ，后续需要重新中断线程，向后传递中断标志，由后续代码去处理中断。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">          <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>以上自旋等待逻辑主要包括两部分工作，检查节点是否在同步队列中和处理中断。下面我们分别来看这两个逻辑。</p><h3 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue"></a>isOnSyncQueue</h3><p>检查节点是否已经转到同步队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractQueuedSynchronizer</span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 同步队列中的节点状态可能为 0、SIGNAL = -1、PROPAGATE = -3、CANCELLED = 1，但不会是 CONDITION = -2</span></span><br><span class="line"><span class="comment">         * 2 node.prev 仅会在节点获取同步状态后，调用 setHead 方法将自己设为头结点时被设置为 null，所以只要节点在同步队列中，node.prev 一定不会为 null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 条件队列中节点是使用 nextWaiter 指向后继节点，next 均为 null 。同步队列中节点是使用 next 指向后继节点。</span></span><br><span class="line"><span class="comment">         * 2 node.next != null 代表当前节点 node 一定在同步队列中。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * node.next == null 也不能说明节点 node 一定不在同步队列中，因为同步队列入队方法不是同步的而是自旋方式，</span></span><br><span class="line"><span class="comment">         * 是先设置 node.prev，后设置 node.next，CAS 失败时 node 可能已经在同步队列上了，所以这里还需要进一步查找。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从同步队列尾部开始搜索，查找是否存在 node 节点。</span></span><br><span class="line"><span class="comment">     * 为什么不从头开始搜索？因为节点的 prev 可能会为 null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if present</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t == node)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            t = t.prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="checkInterruptWhileWaiting"><a href="#checkInterruptWhileWaiting" class="headerlink" title="checkInterruptWhileWaiting"></a>checkInterruptWhileWaiting</h3><p>检查在线程挂起期间是否发生中断，若发生中断则需要进行特殊处理，即尝试自行进入同步队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                 (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                 <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>方法逻辑如下：</strong></p><blockquote><ol><li>线程未被中断，则返回 0</li><li>线程被中断且自行入同步队列成功，则返回 THROW_IE，这种情况下后续需要抛出中断异常</li><li>线程被中断且未能自行入同步队列（其它线程已经执行 signal/signalAll 方法，节点状态已被更改），则返回 REINTERRUPT ，这种情况下后续需要重新中断线程以恢复中断标志</li></ol></blockquote><h3 id="transferAfterCancelledWait"><a href="#transferAfterCancelledWait" class="headerlink" title="transferAfterCancelledWait"></a>transferAfterCancelledWait</h3><p>取消等待（中断）后的转移节点操作，即线程被中断优先尝试自行加入同步队列，如果在中断之前已经执行过加入操作就等待加入同步队列完成。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-condition-Interrupt-signal.jpg" alt></p><p><strong>注意：</strong></p><ol><li><strong>由于中断尝试自行加入同步队列的线程节点并没有与条件队列断开连接，该节点会在后续的逻辑中进行清除。</strong></li><li><strong>即使发生了中断，节点依然会转到到同步队列中。</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 中断如果发生在 节点被转到同步队列前，应该尝试自行将节点转到同步队列中，并返回 true</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">           <span class="comment">// 将节点转到同步队列中</span></span><br><span class="line">           enq(node);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 如果上面的CAS失败，则表明已经有线程调用 signal/signalAll 方法更新过节点状态（CONDITION -&gt; 0 ），并调用 enq 方法尝试将节点转到同步队列中。</span></span><br><span class="line"><span class="comment">         * 2. 这里使用 while 进行判断节点是否已经在同步队列上的原因是，signal/signalAll 方法可能仅设置了等待状态，还没有完成将线程节点转到同步队列中，所以这里用自旋的</span></span><br><span class="line"><span class="comment">         * 方式等待线程节点加入到同步队列，否则会影响后续重新获取同步状态（调用 acquireQueued() 方法，该方法需要线程节点入同步队列才能调用，否则会抛出np异常）。这种情况表明了中断发生在节点被转移到同步队列期间。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">           <span class="comment">// 让出 CPU</span></span><br><span class="line">           Thread.yield();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 中断在节点被转到同步队列期间或之后发生，返回 false</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><strong>判断中断发生的时机：</strong></p><blockquote><ol><li>中断在节点被转到同步队列前发生，此时返回 true</li><li>中断在节点被转到同步队列过程或之后发生，此时返回 false</li></ol></blockquote><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>在解析通知源码之前我们先回到线程挂起等待源码处，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">   <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 挂起线程，直到被唤醒或被中断</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 有中断情况，进进行处理</span></span><br><span class="line">       <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>线程释放同步状态成功后会挂起等待其它线程唤醒自己（同步队列中的线程节点），或者被其它线程中断。关于线程挂起等待时被中断的处理逻辑前文已经解析，主要是确保被中断的线程也能加入到同步队列中。下图对通知流程进行了简单地描述。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-condition-signal.jpg" alt></p><p><strong>下面对通知流程进行说明：</strong></p><ol><li>将条件队列中头节点转到同步队列中。</li><li>根据情况决定是否唤醒对应的线程，不唤醒则在同步队列中等待，唤醒则准备竞争同步状态。</li></ol><p>下面我们解析正常通知逻辑。</p><h3 id="通知单个节点"><a href="#通知单个节点" class="headerlink" title="通知单个节点"></a>通知单个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将条件队列中的头节点转到同步队列中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查线程是否获取了独占锁，未获取独占锁调用 signal 方法是不合法的</span></span><br><span class="line">         <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 条件队列的头节点</span></span><br><span class="line">         Node first = firstWaiter;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将条件队列的头节点转到同步队列中</span></span><br><span class="line">         <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">            doSignal(first);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="comment">// 因为条件队列的 firstWaiter 要出队转到同步队列中，因此使用 firstWaiter 后继节点占领 firstWaiter。</span></span><br><span class="line">            <span class="keyword">if</span> ((firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">              <span class="comment">// 只有一个节点的话，尾节点指向设置为 null</span></span><br><span class="line">              lastWaiter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 断开 first 与条件队列的连接</span></span><br><span class="line">              first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 transferForSignal 方法将节点移到同步队列中，如果转到同步队列失败，则对后面的节点进行操作，依次类推</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="通知所有节点"><a href="#通知所有节点" class="headerlink" title="通知所有节点"></a>通知所有节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 检查线程是否获取了独占锁，未获取独占锁调用 signalAll 方法是不合法的</span></span><br><span class="line">   <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 条件队列的头节点</span></span><br><span class="line">     Node first = firstWaiter;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">          doSignalAll(first);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 置空条件队列的头、尾指针，因为当前队列元素要全部出队，避免将新入队的节点误唤醒</span></span><br><span class="line">     lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 将条件队列中所有的节点都转到同步队列中。</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">         </span><br><span class="line">          Node next = first.nextWaiter;      </span><br><span class="line">          <span class="comment">// 将节点从条件队列中移除</span></span><br><span class="line">          first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">          <span class="comment">// 将节点转到同步队列中</span></span><br><span class="line">          transferForSignal(first);</span><br><span class="line">             </span><br><span class="line">          first = next;</span><br><span class="line">         &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="加入同步队列"><a href="#加入同步队列" class="headerlink" title="加入同步队列"></a>加入同步队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果更新节点的等待状态由 CONDITION 到 0 失败，则说明该节点已经被取消（如被中断），也就不需要再转到同步队列中了。</span></span><br><span class="line"><span class="comment">     * 由于整个 signal /signalAll 都需要拿到锁才能执行，因此这里不存在线程竞争的问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 enq 方法将 node 加入到同步队列中尾，并返回 node 的前驱节点</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取前驱节点的等待状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1 如果前驱节点的等待状态 ws &gt; 0，说明前驱节点已经被取消了，此时应该唤醒 node 对应的线程去尝试获取同步状态，准确的应该是先找大哥，找大哥过程会剔除它的无效前驱节点。</span></span><br><span class="line"><span class="comment">     *    注意，这里只是入队并没有执行剔除取消节点的逻辑，虽然AQS唤醒操作支持从尾节点向前寻找最前的有效节点并唤醒，但还是应该主动唤醒 node 对应的线程，以更新大哥节点。</span></span><br><span class="line"><span class="comment">     * 2 如果前驱节点的等待状态 ws &lt;= 0 ，通过 CAS 操作将 node 的前驱节点 p 的等待状态设置为 SIGNAL，当节点 p 释放同步状态后会唤醒它的后继节点 node。</span></span><br><span class="line"><span class="comment">     *   如果 CAS 设置失败（可能节点 p 在此期间被取消了），则应该立即唤醒 node 节点对应的线程，原因和 1 一致。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加入同步队列主要逻辑如下：</strong></p><ol><li>由于执行 signal/signalAll 方法需要持有同步状态，因此 transferForSignal 方法是不存在并发问题的。</li><li>对条件队列中的非 CONDITION 状态的节点不执行转入同步队列操作。</li><li>将符合条件的节点加入到同步队列中，并返回前驱节点。</li><li>正常情况下不会执行 <code>LockSupport.unpark(node.thread)</code> 唤醒线程，而是节点进入同步队列然后方法返回 true，transferForSignal 方法结束。</li><li>同步队列中 node 的前驱节点取消等待，或者 CAS 等待状态失败，需要唤醒线程，这个属于异常流。</li></ol><p>注意，执行 <code>signal</code> 或 <code>signalAll</code> 方法仅仅让线程节点具备竞争同步状态的机会，确切地说是将条件队列的节点移动到同步队列中，仅此而已。至于能不能获取到同步状态需要看具体竞争结果，要知道不仅条件队列中线程节点阻塞等待，同步队列中可能也有大量的线程节点在等待唤醒，况且条件队列中的线程节点需要移动到同步队列中才有资格参与同步状态的竞争。</p><p>通过下面的伪代码可以推演出多种可能情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认使用的是非公平锁，意味着即使同步队列中有等待唤醒的节点，锁还是有可能被其它线程获取。</span></span><br><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// business</span></span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// business</span></span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从等待中醒来"><a href="#从等待中醒来" class="headerlink" title="从等待中醒来"></a>从等待中醒来</h2><p>线程节点移动到同步队列后被唤醒，线程从等待中醒来，继续从 <code>LockSupport.park(this)</code> 向后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionObject</span><br><span class="line">   <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 挂起线程，直到被唤醒或被中断</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 检测中断模式</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="检查中断模式"><a href="#检查中断模式" class="headerlink" title="检查中断模式"></a>检查中断模式</h3><p>线程从挂起返回后会检查中断状态，检查中断逻辑前文已经说明，这里不再重复介绍。</p><p>以下情况会使 <code>LockSupport.park(this)</code> 返回：</p><ol><li>线程节点被同步队列中其它节点唤醒，不仅仅是它的前驱节点，还可能是头节点（头节点线程进行 signal 时，线程节点的前驱节点取消了或更新前驱节点状态失败）。</li><li>线程在挂起时被中断。</li><li>虚假唤醒，和 Object.wait() 存在同样的问题，一般使用自旋避免。</li></ol><h3 id="竞争同步状态"><a href="#竞争同步状态" class="headerlink" title="竞争同步状态"></a>竞争同步状态</h3><p>线程节点转入同步队列后，就可以尝试竞争同步状态了，注意预获取同步状态是之前释放锁前的值，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//醒来后，被移动到同步队列的节点 node 重新尝试获取同步状态成功，且获取同步状态的过程中如果被中断，接着判断中断模式非 THROW_IE 的情况会更新为 REINTERRUPT</span></span><br><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br></pre></td></tr></table></figure><p>这里回到了竞争同步状态的逻辑，获取到同步状态则继续向后执行，也意味着可以从 <strong>await</strong> 方法返回，没能获取到同步状态则继续在同步队列中等待。</p><h3 id="处理中断"><a href="#处理中断" class="headerlink" title="处理中断"></a>处理中断</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">     <span class="comment">// 中断线程，复位中断标志</span></span><br><span class="line">     selfInterrupt();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>await() 方法返回之前会对中断进行处理，因为它支持响应中断，关于中断模式前文已经说明，会对被中断的线程进行特殊处理，保证被中断的线程也要转到同步队列中。</p><h2 id="超时等待"><a href="#超时等待" class="headerlink" title="超时等待"></a>超时等待</h2><p>这里以超时时间粒度的等待方法为例简单介绍超时等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 加入条件队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 完全释放同步状态</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="comment">// 过期时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">// 中断模式</span></span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时的话，自行转入到同步队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 超时时间到，跳出自旋等待</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">            transferAfterCancelledWait(node);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自旋还是挂起</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查中断模式</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算超时时间</span></span><br><span class="line">        nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 竞争同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时等待是在 <code>await()</code> 方法的基础上增加了等待的超时时间，如果超过超时时间则不再等待其它线程唤醒，自行加入到同步队列中并退出自旋等待，然后尝试竞争同步状态。</p><h2 id="忽略中断"><a href="#忽略中断" class="headerlink" title="忽略中断"></a>忽略中断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加入条件队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 完全释放同步状态</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="comment">// 中断模式</span></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自旋等待</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 竞争同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">        <span class="comment">// 发生中断需要复位中断标志</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法和 <code>await()</code> 方法最大的区别是对中断不做特别处理，如果有中断发生复位中断标志即可，不会抛出中断异常。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="和对象监视器的联系"><a href="#和对象监视器的联系" class="headerlink" title="和对象监视器的联系"></a>和对象监视器的联系</h2><ol><li>Condition 定义的方法和对象监视器方法类似。</li><li>对象监视器方法需要和 <code>synchronized</code> 关键字一起使用，且必须先拿到锁才能执行监视器方法。Condition 对象需要和 Lock 对象绑定，同样需要先获取到锁才能执行 Condition 的方法。</li></ol><h2 id="和对象监视器的区别"><a href="#和对象监视器的区别" class="headerlink" title="和对象监视器的区别"></a>和对象监视器的区别</h2><ol><li>Condition 接口中定义的方法功能更加完善，如忽略中断、等待超时。</li><li>Condition 是代码层面上的实现，对象监视器是JVM指令层面上的实现。</li><li>Condition 与 Lock 结合拥有一个同步队列和多个条件队列，而对象监视器模型上有一个同步队列和一个条件队列。</li><li>Condition 支持唤醒特定线程，对象监视器方法唤醒线程是随机的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在 JUC 之前，Java 实现等待/通知模式是通过定义在 Object 中的一组监视器方法 &lt;code&gt;wait方法&lt;/code&gt;、&lt;co
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
      <category term="AQS" scheme="https://gentryhuang.com/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 优雅停机</title>
    <link href="https://gentryhuang.com/posts/ef4cfe7a/"/>
    <id>https://gentryhuang.com/posts/ef4cfe7a/</id>
    <published>2020-10-21T16:00:00.000Z</published>
    <updated>2021-04-06T08:35:47.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>优雅停机仅存在于服务重启、下线这样的部署阶段，优雅停机是一个应用生命周期的一部分，它保障了应用的健壮性。dubbo是通过jdk的ShutdownHook来完成优雅停机的，所以如果用户使用 kill -9 pid 等强制关闭指令，是不会执行优雅停机的，只有通过 kill pid 即正常退出进程，才会执行。</p><h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><ul><li>优雅停机的服务端有正在处理中的请求，不能被停机指令中断，除非超时</li><li>优雅停机的消费端不应该再发起新的请求</li><li>消费端不应该请求已经下线的服务提供者</li></ul><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>应用的重新启动、停机等操作，避免了对业务的连续性造成影响，如：集群中的某个应用存在逻辑上的bug，需要修改程序，这时候就可以使用优雅停机平滑下线，不会造成调用方异常问题。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/shutdownhook.png" alt></p><p><font color="#c7254e"> dubbo中实现优雅停机主要包含以下步骤 </font></p><ol><li>收到kill 9 进程退出信号时，spring容器会触发容器销毁事件  (其实是spring注册的jvm钩子程序执行的，后面会看到)</li><li>provider端会取消注册服务元数据信息</li><li>consumer端会收到最新地址列表（准备停机地址不在该地址列表中）</li><li>dubbo协议会发送readonly事件报文通知consumer服务不可用</li><li>服务端等待已经执行的任务结束并不再处理新的请求</li></ol><p><strong>说明</strong></p><ul><li>上图中的流程是使用spring构建的dubbo应用</li><li>上图中的流程没有体现出优雅停机的消费端角色，该角色做的工作相对简单，主要是不再发起新的调用请求和等待响应返回，超时才会强制关闭</li><li>注册中心已经通知了最新服务列表，发送readonly事件主要考虑到注册中心推送服务有网络延迟以及客户端计算服务列表也需要时间。消费端收到后会设置对应的provider为不可用状态，下次负载均衡就不会调用这个下线的服务</li></ul><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>dubbo对优雅停机的实现在不同的版本中有所差异，下面从2.5.x、2.6.x以及2.7.x这三个版本分别分析。</p><h4 id="2-5-x的优雅停机"><a href="#2-5-x的优雅停机" class="headerlink" title="2.5.x的优雅停机"></a>2.5.x的优雅停机</h4><p>注册shutdown hook</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 省略其它代码    </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Run shutdown hook now."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 销毁资源</span></span><br><span class="line"><span class="comment">                     * 1 注册中心数据销毁： 删除注册中心中本节点对应的提供者地址以及订阅数据</span></span><br><span class="line"><span class="comment">                     * 2 协议流程数据销毁： 取消该协议所有已经暴露和引用的服务，释放协议所占用的所有资源，比如连接和端口</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    ProtocolConfig.destroyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"DubboShutdownHook"</span>));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p> ProtocolConfig.destroyAll()方法是用来释放资源的，由于dubbo支持多注册中心和多协议，因此具体销毁实现细节取决于具体的注册中心和具体的协议，这里不再展开说明。</p><h4 id="2-6-x的优雅停机"><a href="#2-6-x的优雅停机" class="headerlink" title="2.6.x的优雅停机"></a>2.6.x的优雅停机</h4><p> spring也依赖shutdown hook完成优雅停机，其注册jvm钩子的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a shutdown hook with the JVM runtime, closing this context</span></span><br><span class="line"><span class="comment"> * on JVM shutdown unless it has already been closed at that time.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Delegates to &#123;<span class="doctag">@code</span> doClose()&#125; for the actual closing procedure.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Runtime#addShutdownHook</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #close()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doClose()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No shutdown hook registered yet.</span></span><br><span class="line"><span class="keyword">this</span>.shutdownHook = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (startupShutdownMonitor) &#123;</span><br><span class="line">doClose();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// 注册jvm钩子</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">this</span>.shutdownHook);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring的shutdownhook具体任务如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Actually performs context closing: publishes a ContextClosedEvent and</span></span><br><span class="line"><span class="comment">  * destroys the singletons in the bean factory of this application context.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;Called by both &#123;<span class="doctag">@code</span> close()&#125; and a JVM shutdown hook, if any.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> org.springframework.context.event.ContextClosedEvent</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #destroyBeans()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #close()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #registerShutdownHook()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.active.get() &amp;&amp; <span class="keyword">this</span>.closed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Closing "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LiveBeansView.unregisterApplicationContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Publish shutdown event   // 注意容器关系事件的发布</span></span><br><span class="line">publishEvent(<span class="keyword">new</span> ContextClosedEvent(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception thrown from ApplicationListener handling ContextClosedEvent"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop all Lifecycle beans, to avoid delays during individual destruction.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleProcessor != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.lifecycleProcessor.onClose();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception thrown from LifecycleProcessor on context close"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy all cached singletons in the context's BeanFactory.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close the state of this context itself.</span></span><br><span class="line">closeBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let subclasses do some final clean-up if they wish...</span></span><br><span class="line">onClose();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.active.set(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dubbo2.6.x支持使用spring构建dubbo应用时，能够安全使用优雅停机。由于dubbo注册了jvm停止的钩子，<font color="#c7254e"> spring可能 </font> 也注册了jvm停机的钩子，这种情况下两个并发执行的线程可能引用已经销毁的资源，导致优雅停机失效。比如，dubbo正在执行的任务需要引用spring中的bean，但此时spring钩子已经关闭spring上下文，导致访问spring资源都会报错。因此对于这种情况，dubbo在2.6.3中新增ShutdownHookListener 类用来解决并发问题，该类实现了ApplicationListener接口，当进程退出时jvm钩子会被触发，此时spring和dubbo注册的jvm钩子都会被回调，spring注册的jvm钩子程序中spring发出容器关闭事件，ShutdownHookListener接收到关闭事件后执行dubbo的jvm钩子程序进行资源的释放，这样就避免使用无效spring bean的问题，从而完成优雅停机。</p><p><font color="#c7254e"> ShutdownHookListener </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHookListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            <span class="comment">// 使用spring框架时也不应该删除dubbo shutdown hook，因为spring可能没有注册ContextClosed 事件</span></span><br><span class="line">            DubboShutdownHook shutdownHook = DubboShutdownHook.getDubboShutdownHook();</span><br><span class="line">            shutdownHook.destroyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#c7254e"> AbstractConfig中依然保留JVM停止钩子 </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 省略无关代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.name"</span>, <span class="string">"dubbo.service.protocol"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.host"</span>, <span class="string">"dubbo.service.server.host"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.port"</span>, <span class="string">"dubbo.service.server.port"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.threads"</span>, <span class="string">"dubbo.service.max.thread.pool.size"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.consumer.timeout"</span>, <span class="string">"dubbo.service.invoke.timeout"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.consumer.retries"</span>, <span class="string">"dubbo.service.max.retry.providers"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.consumer.check"</span>, <span class="string">"dubbo.service.allow.no.provider"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.service.url"</span>, <span class="string">"dubbo.service.address"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this is only for compatibility</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Dubbo 的优雅停机 ShutdownHook 在 AstractConfig 的静态代码块中，这保证了ShutdownHook能够给被初始化。</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 1 Dubbo 是 通过 JDK的ShutdownHook来完成优雅停机的</span></span><br><span class="line"><span class="comment">         * 2 ShutdownHook本质上是一个线程，任务体在对应的run方法中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><font color="#c7254e">DubboShutdownHook </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboShutdownHook</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DubboShutdownHook<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShutdownHook,类属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DubboShutdownHook dubboShutdownHook = <span class="keyword">new</span> DubboShutdownHook(<span class="string">"DubboShutdownHook"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DubboShutdownHook <span class="title">getDubboShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dubboShutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Has it already been destroyed or not?</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 是否已经被销毁标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean destroyed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DubboShutdownHook</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShutdownHook的任务体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Run shutdown hook now."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        destroyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Destroy all the resources, including registries and protocols.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 销毁所有的资源，包括 Registry相关 和 Protocol相关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果已经销毁则忽略</span></span><br><span class="line">        <span class="keyword">if</span> (!destroyed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁所有的 Registry,取消应用程序中的服务提供者和消费者的订阅与注册</span></span><br><span class="line">        AbstractRegistryFactory.destroyAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 销毁所有的 Protocol</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 这里的Protocol比较多，大体上可以分两类：</span></span><br><span class="line"><span class="comment">         * 1 和Registry相关的Protocol，RegistryProtocol关注服务的注册</span></span><br><span class="line"><span class="comment">         * 2 具体协议，如 DubboProtocol、httpProtocol等,关注服务的暴露和引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (String protocolName : loader.getLoadedExtensions()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Protocol protocol = loader.getLoadedExtension(protocolName);</span><br><span class="line">                <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    protocol.destroy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#c7254e">DubboShutdownHook与protocol、registry的关系图 </font></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/shutdownhook-process.jpg" alt></p><p><font color="#c7254e"> 图解(以dubbo协议和zookeeper注册中心为例) <font></font></font></p><p><font color="#c7254e"> Registry相关 <font></font></font></p><ul><li>AbstractRegistryFactory#destroyAll方法，遍历所有的Registry并调用Registry#destroy方法。然后清空Registry缓存集合。</li><li>AbstractRegistry 实现了公用的销毁逻辑：取消注册和订阅。服务提供者和消费者都会执行注册和订阅，因此都需要进行取消。</li><li>FailbackRegistry实现销毁公用的重试任务</li><li>ZookeeperRegistry销毁其对应的客户端连接</li></ul><p><font color="#c7254e"> Protocol相关 <font></font></font></p><ul><li>AbstractProtocol#destroy方法，销毁协议对应的服务消费者拥有的Invoker， 销毁协议对应的服务提供者的所有Exporter。</li><li>DubboProtocol销毁所有通信 ExchangeClient 和 ExchangeServer</li></ul><p><strong>小结</strong></p><ul><li>dubbo2.6.3在spring环境中注册两个钩子的情况，ShutdownHookListener解决了并发执行问题</li><li>使用ShutdownHookListener也不能移除调dubbo注册的jvm钩子，因为不能保证应用中一定会注册spring的shutdown hook</li></ul><h4 id="2-7-x优雅停机"><a href="#2-7-x优雅停机" class="headerlink" title="2.7.x优雅停机"></a>2.7.x优雅停机</h4><p>从dubbo的2.6.3版本开始，解决了使用spring构建的dubbo可能发生优雅停机并发执行shutdown hook的问题。但是还是存在一个问题，那就是如果在spring环境下没有注册spring的jvm钩子，虽然没有大问题，但是还是有不完整的。dubbo2.7.x进行显示地注册spring的jvm钩子，并且移除dubbo的jvm钩子，解决了当前问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ApplicationContext&gt; CONTEXTS = <span class="keyword">new</span> ConcurrentHashSet&lt;ApplicationContext&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ApplicationListener SHUTDOWN_HOOK_LISTENER = <span class="keyword">new</span> ShutdownHookListener();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addApplicationContext</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        CONTEXTS.add(context);</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ConfigurableApplicationContext) &#123;</span><br><span class="line">            <span class="comment">// 显示注册spring的jvm钩子</span></span><br><span class="line">            ((ConfigurableApplicationContext) context).registerShutdownHook();</span><br><span class="line">            <span class="comment">// 显示移除dubbo的jvm钩子</span></span><br><span class="line">            DubboShutdownHook.getDubboShutdownHook().unregister();</span><br><span class="line">        &#125;</span><br><span class="line">        BeanFactoryUtils.addApplicationListener(context, SHUTDOWN_HOOK_LISTENER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHookListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">                DubboShutdownHook shutdownHook = DubboShutdownHook.getDubboShutdownHook();</span><br><span class="line">                shutdownHook.doDestroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>dubbo2.7.x优雅停机的实现，解决了spring环境下两个钩子并发的问题，并且显示注册spring的jvm钩子。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优雅停机并不是java中的概念，也不是只有dubbo框架进行了扩展实现，springboot、docker等都有涉及到优雅停机。dubbo中的优雅停机是不断优化的，2.5.x中的存在一定的问题，2.6.x在一般场景下是没有问题的，2.7.x是对之前版本的完善和优化。如果 ShutdownHook 不能生效，可以在需要的时机自行调用DubboShutdownHook.destroyAll()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;优雅停机仅存在于服务重启、下线这样的部署阶段，优雅停机是一个应用生命周期的一部分，它保障了应用的健壮性。dubbo是通过jdk的Shutdo
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Spring" scheme="https://gentryhuang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 本地暴露</title>
    <link href="https://gentryhuang.com/posts/751c0982/"/>
    <id>https://gentryhuang.com/posts/751c0982/</id>
    <published>2020-10-14T16:00:00.000Z</published>
    <updated>2021-04-06T08:35:09.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有了前面一系列文章铺垫，再来看服务暴露与服务引用就简单很多了。本地暴露需要配置、SPI、动态代理、协议等知识，其中协议部分会在后面的文章中着重分析。</p><h2 id="配置承载"><a href="#配置承载" class="headerlink" title="配置承载"></a>配置承载</h2><p>无论是服务暴露还是服务引用，Dubbo 框架都会根据配置覆盖策略对配置项进行聚合处理，配置覆盖策略参见<a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/xml.html" target="_blank" rel="noopener">官网</a> 。Dubbo 支持动态添加配置项即服务治理，其中不允许 Provider 端配置项透传到客户端的都会进行特殊处理. </p><h2 id="服务暴露配置"><a href="#服务暴露配置" class="headerlink" title="服务暴露配置"></a>服务暴露配置</h2><ul><li>仅本地暴露<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"local"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li>仅远程暴露<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"remote"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li>本暴露和远程暴露<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在不配置 scope 的情况下，默认两种方式都暴露</span><br></pre></td></tr></table></figure></li><li>不暴露<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"none"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="服务暴露机制"><a href="#服务暴露机制" class="headerlink" title="服务暴露机制"></a>服务暴露机制</h2><p>Dubbo 服务暴露分为两部分，先将持有的服务信息（服务对象，服务接口，服务 URL信息）通过动态代理工厂转换成 Invoker ，再把 Invoker 通过具体的协议转成 Exporter（注意，这里涉及到多协议的知识后面文章会详细分析） 。Dubbo 框架在进行服务暴露时，无论是 API 配置、XML 配置还是注解配置，最终都会转成 ServiceBean，它继承自 ServiceConfig ，注意这里是指使用 Spring 环境时，如果仅使用 Dubbo API 配置的话，会转成 ServiceConfig 。因为 Spring 是主流，下面没有特别说明都是在 Spring 环境下。</p><h2 id="服务暴露方式"><a href="#服务暴露方式" class="headerlink" title="服务暴露方式"></a>服务暴露方式</h2><p>Dubbo 支持两种服务暴露方式，分为延迟暴露和立即暴露。延迟暴露的入口是 ServiceBean 的 afterPropertiesSet 方法，立即暴露的入口是 ServiceBean 的 onApplicationEvent 方法。</p><h3 id="Spring支持的-Dubbo-IOC"><a href="#Spring支持的-Dubbo-IOC" class="headerlink" title="Spring支持的 Dubbo IOC"></a>Spring支持的 Dubbo IOC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="comment">// 为Spring拓展工厂注入上下文 ,用于Dubbo IOC</span></span><br><span class="line">        SpringExtensionFactory.addApplicationContext(applicationContext);</span><br><span class="line">        <span class="keyword">if</span> (applicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SPRING_CONTEXT = applicationContext;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method method = applicationContext.getClass().getMethod(<span class="string">"addApplicationListener"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;ApplicationListener<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">// backward compatibility to spring 2.0.1</span></span><br><span class="line">                method.invoke(applicationContext, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">                <span class="comment">// 当前Spring容器是否支持上下文监听</span></span><br><span class="line">                supportedApplicationListener = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (applicationContext <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Method method = AbstractApplicationContext.class.getDeclaredMethod("addListener", new Class&lt;?&gt;[]&#123;ApplicationListener.class&#125;); // backward compatibility to spring 2.0.1</span><br><span class="line">                        <span class="keyword">if</span> (!method.isAccessible()) &#123;</span><br><span class="line">                            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(applicationContext, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">                        supportedApplicationListener = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean#setApplicationContext 方法用于将 Spring 的上下文设置设置到 SpringExtensionFactory 中，这样 Dubbo IOC 就可以使用 Spring 管理的对象了。</p><h3 id="延迟暴露"><a href="#延迟暴露" class="headerlink" title="延迟暴露"></a>延迟暴露</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务暴露的入口，非延迟暴露 。收到 Spring 容器的刷新事件执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否有延迟暴露 &amp;&amp; 是否已暴露 &amp;&amp; 是不是已被取消暴露</span></span><br><span class="line">        <span class="keyword">if</span> (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"The service ready on spring started. service: "</span> + getInterface());</span><br><span class="line">            &#125;</span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 delay</span></span><br><span class="line">        Integer delay = getDelay();</span><br><span class="line">        ProviderConfig provider = getProvider();</span><br><span class="line">        <span class="keyword">if</span> (delay == <span class="keyword">null</span> &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果前面获取的 delay 为空，这里继续获取</span></span><br><span class="line">            delay = provider.getDelay();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 判断 delay 是否为空，或者等于 -1，当 delay 为空，或者等于-1时，该方法返回 true，而不是 false</span></span><br><span class="line"><span class="comment">         * 2 supportedApplicationListener 变量用于表示当前的 Spring 容器是否支持 ApplicationListener，这个值初始为 false。</span></span><br><span class="line"><span class="comment">         * 在 Spring 容器将自己设置到 ServiceBean 中时，ServiceBean 的 setApplicationContext 方法会检测 Spring 容器是否支持 ApplicationListener,若支持，则将 supportedApplicationListener 置为 true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> supportedApplicationListener &amp;&amp; (delay == <span class="keyword">null</span> || delay == -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置项</span></span><br><span class="line">        <span class="keyword">return</span> delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的 isDelay 方法，当方法返回 true 时，表示无需延迟导出。返回 false 时，表示需要延迟导出，与字面意思是相反的。</p><h3 id="立即暴露"><a href="#立即暴露" class="headerlink" title="立即暴露"></a>立即暴露</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务暴露的入口，延迟暴露</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"deprecation"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getProvider() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Map&lt;String, ProviderConfig&gt; providerConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (providerConfigMap != <span class="keyword">null</span> &amp;&amp; providerConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> ((protocolConfigMap == <span class="keyword">null</span> || protocolConfigMap.size() == <span class="number">0</span>)</span><br><span class="line">                        &amp;&amp; providerConfigMap.size() &gt; <span class="number">1</span>) &#123; <span class="comment">// backward compatibility</span></span><br><span class="line">                    List&lt;ProviderConfig&gt; providerConfigs = <span class="keyword">new</span> ArrayList&lt;ProviderConfig&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() != <span class="keyword">null</span> &amp;&amp; config.isDefault().booleanValue()) &#123;</span><br><span class="line">                            providerConfigs.add(config);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!providerConfigs.isEmpty()) &#123;</span><br><span class="line">                        setProviders(providerConfigs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ProviderConfig providerConfig = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate provider configs: "</span> + providerConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                            &#125;</span><br><span class="line">                            providerConfig = config;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        setProvider(providerConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getApplication() == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getApplication() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (applicationConfigMap != <span class="keyword">null</span> &amp;&amp; applicationConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ApplicationConfig applicationConfig = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (ApplicationConfig config : applicationConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate application configs: "</span> + applicationConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        applicationConfig = config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    setApplication(applicationConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getModule() == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getModule() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (moduleConfigMap != <span class="keyword">null</span> &amp;&amp; moduleConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ModuleConfig moduleConfig = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (ModuleConfig config : moduleConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate module configs: "</span> + moduleConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        moduleConfig = config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    setModule(moduleConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((getRegistries() == <span class="keyword">null</span> || getRegistries().isEmpty())</span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getRegistries() == <span class="keyword">null</span> || getProvider().getRegistries().isEmpty())</span><br><span class="line">                &amp;&amp; (getApplication() == <span class="keyword">null</span> || getApplication().getRegistries() == <span class="keyword">null</span> || getApplication().getRegistries().isEmpty())) &#123;</span><br><span class="line">            Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (registryConfigMap != <span class="keyword">null</span> &amp;&amp; registryConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                List&lt;RegistryConfig&gt; registryConfigs = <span class="keyword">new</span> ArrayList&lt;RegistryConfig&gt;();</span><br><span class="line">                <span class="keyword">for</span> (RegistryConfig config : registryConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        registryConfigs.add(config);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (registryConfigs != <span class="keyword">null</span> &amp;&amp; !registryConfigs.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">super</span>.setRegistries(registryConfigs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getMonitor() == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getMonitor() == <span class="keyword">null</span>)</span><br><span class="line">                &amp;&amp; (getApplication() == <span class="keyword">null</span> || getApplication().getMonitor() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Map&lt;String, MonitorConfig&gt; monitorConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (monitorConfigMap != <span class="keyword">null</span> &amp;&amp; monitorConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                MonitorConfig monitorConfig = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (MonitorConfig config : monitorConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (monitorConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate monitor configs: "</span> + monitorConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        monitorConfig = config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (monitorConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    setMonitor(monitorConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((getProtocols() == <span class="keyword">null</span> || getProtocols().isEmpty())</span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getProtocols() == <span class="keyword">null</span> || getProvider().getProtocols().isEmpty())) &#123;</span><br><span class="line">            Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (protocolConfigMap != <span class="keyword">null</span> &amp;&amp; protocolConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                List&lt;ProtocolConfig&gt; protocolConfigs = <span class="keyword">new</span> ArrayList&lt;ProtocolConfig&gt;();</span><br><span class="line">                <span class="keyword">for</span> (ProtocolConfig config : protocolConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        protocolConfigs.add(config);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (protocolConfigs != <span class="keyword">null</span> &amp;&amp; !protocolConfigs.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">super</span>.setProtocols(protocolConfigs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getPath() == <span class="keyword">null</span> || getPath().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; beanName.length() &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; getInterface() != <span class="keyword">null</span> &amp;&amp; getInterface().length() &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; beanName.startsWith(getInterface())) &#123;</span><br><span class="line">                setPath(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟暴露</span></span><br><span class="line">        <span class="keyword">if</span> (!isDelay()) &#123;</span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean#afterPropertiesSet 的方法不仅支持延迟暴露，还会在 Spring 生命周期内把 Dubbo 的核心配置承载对象设置到 ServiceBean 中（或其父类中）。ServiceBean 配置继承关系如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>AbstractConfig</span><br><span class="line"><span class="bullet">  - </span>AbstractMethodConfig</span><br><span class="line"><span class="bullet">    - </span>AbstractInterfaceConfig</span><br><span class="line"><span class="bullet">      - </span>AbstractServiceConfig</span><br><span class="line"><span class="bullet">        - </span>ServiceConfig</span><br><span class="line"><span class="bullet">          - </span>ServiceBean</span><br></pre></td></tr></table></figure><p>关于配置在之前的文章中应详细介绍，可以参考 <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 。</p><h2 id="服务暴露过程"><a href="#服务暴露过程" class="headerlink" title="服务暴露过程"></a>服务暴露过程</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-local.jpg" alt></p><p>上图是服务本地暴露的主要流程，配置检查和初始化完成后，生成 URL，然后将服务导出到 JVM 中。配置加载及配置承载对象的初始对应的三种方式在前面的文章中已经详细分析过，可以参考 <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 、<a href="https://gentryhuang.com/posts/a8d76a91/">XML配置</a> 、<a href="https://gentryhuang.com/posts/1a889dcd/">注解配置</a> 。下面分析具体源码。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>以延迟暴露的方式进行分析，默认情况下就是延迟暴露的方式。ServiceBean 是 Dubbo 框架与 Spring 框架进行整合的关键，可以看做是两个框架之间的桥梁。ReferenceBean 具有同样的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类 ServiceConfig 的 export 方法进行服务暴露</span></span><br><span class="line">        <span class="keyword">super</span>.export();</span><br><span class="line">        <span class="comment">// 发布服务暴露完成的事件</span></span><br><span class="line">        publishExportEvent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publishExportEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceBeanExportedEvent exportEvent = <span class="keyword">new</span> ServiceBeanExportedEvent(<span class="keyword">this</span>);</span><br><span class="line">        applicationEventPublisher.publishEvent(exportEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean 中的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">213195494150089726L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">transient</span> ApplicationContext SPRING_CONTEXT;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo 服务注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> Service service;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String beanName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否支持 Spring 上下文监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">boolean</span> supportedApplicationListener;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 事件发布对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.service = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceBean</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(service);</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getSpringContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SPRING_CONTEXT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入事件发布对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationEventPublisher</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.6.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在服务暴露之前，Dubbo 需要检查配置，或者补充缺省配置。配置检查完毕后，会根据配置组装 URL 。在 Dubbo 中，URL 十分重要，详细参见 <a href="https://gentryhuang.com/posts/46f95e97/">URL统一模型</a> 。</p><h4 id="检查配置"><a href="#检查配置" class="headerlink" title="检查配置"></a>检查配置</h4><p>我们继续从入口看起，ServiceBean 的父类 ServiceConfig 类，下面我们先看下这个类中的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3033787999037024738L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应 Protocol 实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应 ProxyFactory 实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; RANDOM_PORT_MAP = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时暴露线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService delayExportExecutor = Executors.newSingleThreadScheduledExecutor(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboServiceDelayExporter"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务URL集合</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务配置暴露的Exporter:</span></span><br><span class="line"><span class="comment">     * URL: Exporter 不一定是 1:1 的关系，需要看scope的值：</span></span><br><span class="line"><span class="comment">     * 1 scope 未设置时，会暴露Local + Remote两个，也就是URL : Exporter = 1:2</span></span><br><span class="line"><span class="comment">     * 2 scope设置为空时，不会暴露，也就是URL:Exporter = 1:0</span></span><br><span class="line"><span class="comment">     * 3 scope甚至为local 或 Remote 任一个时，会暴露对应的，也就是URL:Exporter = 1:1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Exporter&lt;?&gt;&gt; exporters = <span class="keyword">new</span> ArrayList&lt;Exporter&lt;?&gt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非配置，通过interfaceName 通过反射获得</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; interfaceClass;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口的实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T ref;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法配置对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;MethodConfig&gt; methods;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供者配置对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ProviderConfig provider;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exported;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否未暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> unexported;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String generic;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceConfig</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        appendAnnotation(Service<span class="class">.<span class="keyword">class</span>, <span class="title">service</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们从 ServiceConfig#export 方法继续进行分析，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 暴露服务入口，加jvm锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 当export 或者 delay 未配置时，从ProviderConfig对象读取</span></span><br><span class="line">       <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (export == <span class="keyword">null</span>) &#123;</span><br><span class="line">               export = provider.getExport();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (delay == <span class="keyword">null</span>) &#123;</span><br><span class="line">               delay = provider.getDelay();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 不暴露服务(export = false),则不进行暴露服务逻辑</span></span><br><span class="line">       <span class="keyword">if</span> (export != <span class="keyword">null</span> &amp;&amp; !export) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 延迟暴露的话，就是使用任务线程池ScheduledExecutorService处理</span></span><br><span class="line">       <span class="keyword">if</span> (delay != <span class="keyword">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           delayExportExecutor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   doExport();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           doExport();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果我们只是想本地启动服务进行一些调试工作，这个时候我们并不希望把本地启动的服务暴露出去，此时，我们就可以通过配置 export 禁止服务暴露，如：</p><blockquote><p>&lt;dubbo:provider export=”false” /&gt;</p></blockquote><p>我们继续跟进 doExport 方法，该方法主要进行配置的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 服务暴露，jvm锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 检查是否可以暴露，若可以，标记已经暴露然后执行服务暴露逻辑</span></span><br><span class="line">       <span class="keyword">if</span> (unexported) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already unexported!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果已经暴露了直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (exported) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 标记已经暴露过了</span></span><br><span class="line">       exported = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">// 校验interfaceName 是否合法，即接口名非空</span></span><br><span class="line">       <span class="keyword">if</span> (interfaceName == <span class="keyword">null</span> || interfaceName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"&lt;dubbo:service interface=\"\" /&gt; interface not allow null!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 校验provider是否为空(为空则新建一个)并拼接属性配置（环境变量 + .properties文件中的 属性）到ProviderConfig对象</span></span><br><span class="line">       checkDefault();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检测application，module等核心配置类对象是否为空，若为空则尝试从其他配置类对象中获取对应的实例。即： 从ProviderConfig 对象中，读取application,module,registries,monitor,protocols配置对象</span></span><br><span class="line">       <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (application == <span class="keyword">null</span>) &#123;</span><br><span class="line">               application = provider.getApplication();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">module</span> = provider.getModule();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">               registries = provider.getRegistries();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               monitor = provider.getMonitor();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (protocols == <span class="keyword">null</span>) &#123;</span><br><span class="line">               protocols = provider.getProtocols();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 从ModuleConfig 对象中，读取registries,monitor配置对象</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">               registries = <span class="keyword">module</span>.getRegistries();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               monitor = <span class="keyword">module</span>.getMonitor();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 从ApplicationConfig 对象中，读取registries,monitor配置对象</span></span><br><span class="line">       <span class="keyword">if</span> (application != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">               registries = application.getRegistries();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               monitor = application.getMonitor();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检测ref是否泛化接口的实现</span></span><br><span class="line">       <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> GenericService) &#123;</span><br><span class="line">           <span class="comment">// 设置 interfaceClass 为 GenericService.class</span></span><br><span class="line">           interfaceClass = GenericService<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isEmpty(generic)) &#123;</span><br><span class="line">               <span class="comment">// 设置 generic = "true"</span></span><br><span class="line">               generic = Boolean.TRUE.toString();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 普通接口的实现</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 通过反射获取对应的接口的Class</span></span><br><span class="line">               interfaceClass = Class.forName(interfaceName, <span class="keyword">true</span>, Thread.currentThread()</span><br><span class="line">                       .getContextClassLoader());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 检验接口和方法 （接口非空，方法都在接口中定义）</span></span><br><span class="line">           checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 校验引用ref是否实现了当前接口</span></span><br><span class="line">           checkRef();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 标记为非泛化实现</span></span><br><span class="line">           generic = Boolean.FALSE.toString();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** 处理服务接口客户端本地代理,即本地存根。目前已经废弃，此处主要用于兼容，使用stub属性. todo 服务端没有意义 &#123;<span class="doctag">@link</span> StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125; */</span></span><br><span class="line">       <span class="keyword">if</span> (local != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果local属性设置为ture，表示使用缺省代理类名，即：接口名 + Local 后缀</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="string">"true"</span>.equals(local)) &#123;</span><br><span class="line">               local = interfaceName + <span class="string">"Local"</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           Class&lt;?&gt; localClass;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 获取本地存根类</span></span><br><span class="line">               localClass = ClassHelper.forNameWithThreadContextClassLoader(local);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法</span></span><br><span class="line">           <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(localClass)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The local implementation class "</span> + localClass.getName() + <span class="string">" not implement interface "</span> + interfaceName);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** 处理服务接口客户端本地代理(stub 属性)相关，即本地存根。目的：想在客户端【服务消费方】执行需要的逻辑，不局限服务提供的逻辑。本地存根类编写方式是固定。todo 服务端没有意义 &#123;<span class="doctag">@link</span> StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125;*/</span></span><br><span class="line">       <span class="keyword">if</span> (stub != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果stub属性设置为ture，表示使用缺省代理类名，即：接口名 + Stub 后缀</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="string">"true"</span>.equals(stub)) &#123;</span><br><span class="line">               stub = interfaceName + <span class="string">"Stub"</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           Class&lt;?&gt; stubClass;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 获取本地存根类</span></span><br><span class="line">               stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 判断interfaceClass 是否是 stubClass 的接口，即 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法</span></span><br><span class="line">           <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(stubClass)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The stub implementation class "</span> + stubClass.getName() + <span class="string">" not implement interface "</span> + interfaceName);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 校验ApplicationConfig配置</span></span><br><span class="line">       checkApplication();</span><br><span class="line">       <span class="comment">// 校验RegistryConfig配置</span></span><br><span class="line">       checkRegistry();</span><br><span class="line">       <span class="comment">// 校验ProtocolConfig配置数组</span></span><br><span class="line">       checkProtocol();</span><br><span class="line">       <span class="comment">// 读取环境变量和properties配置到ServiceConfig对象（自己）</span></span><br><span class="line">       appendProperties(<span class="keyword">this</span>);</span><br><span class="line">       <span class="comment">// 校验Stub和Mock相关的配置</span></span><br><span class="line">       checkStubAndMock(interfaceClass);</span><br><span class="line">       <span class="comment">// 服务路径，缺省是接口名</span></span><br><span class="line">       <span class="keyword">if</span> (path == <span class="keyword">null</span> || path.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           path = interfaceName;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 暴露服务</span></span><br><span class="line">       doExportUrls();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 1 ProviderModel 表示服务提供者模型，此对象中存储了和服务提供者相关的信息，比如服务的配置信息，服务实例等。每个被导出的服务对应一个 ProviderModel</span></span><br><span class="line"><span class="comment">        * 2 ApplicationModel 持有所有的 ProviderModel</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       ProviderModel providerModel = <span class="keyword">new</span> ProviderModel(getUniqueServiceName(), <span class="keyword">this</span>, ref);</span><br><span class="line">       ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以上就是配置检查的相关分析，下面对配置检查的主要逻辑进行简单的总结，如下：</p><ol><li>检测 <a href="dubbo:service">dubbo:service</a> 标签的 interface 属性合法性，不合法则抛出异常</li><li>检测 ProviderConfig、ApplicationConfig 等核心配置类对象是否为空，若为空，则尝试创建或从其他配置类对象中获取相应的实例。</li><li>检测并处理泛化服务和普通服务类</li><li>检测本地存根配置，并进行相应的处理</li><li>对 ApplicationConfig、RegistryConfig 等配置类进行检测，并读取环境变量和properties配置到配置承载对象中</li></ol><p>设置配置到配置承载对象在之前的文章中详细说明了，可以参见 <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 。</p><h4 id="多协议多注册中心暴露"><a href="#多协议多注册中心暴露" class="headerlink" title="多协议多注册中心暴露"></a>多协议多注册中心暴露</h4><p>Dubbo 允许使用不同的协议暴露服务，也支持向多个注册中心注册服务，Dubbo 在 ServiceConifg#doExportUrls 中对多协议，多注册中心进行了支持，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 加载注册中心URL 数组 【协议已经处理过，不再是配置的注册中心协议 如：zookeeper ,而是统一替换成了registry】</span></span><br><span class="line">       List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">// 遍历协议集合，支持多协议暴露。</span></span><br><span class="line">       <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">           doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面代码比较简单，首先是通过 loadRegistries 加载注册中心URL，然后再遍历 ProtocolConfig 集合使用具体的协议导出每个服务。并在导出服务的过程中，将服务注册到注册中心。下面，我们先来看一下 loadRegistries 方法的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 加载注册中心URL数组</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> provider 是否是服务提供者</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> URL数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> List&lt;URL&gt; <span class="title">loadRegistries</span><span class="params">(<span class="keyword">boolean</span> provider)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 校验RegistryConfig 配置数组，不存在会抛出异常，并且该方法会初始化RegistryConfig的配置属性【见API与属性配置】</span></span><br><span class="line">       checkRegistry();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建注册中心URL数组</span></span><br><span class="line">       List&lt;URL&gt; registryList = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">       <span class="keyword">if</span> (registries != <span class="keyword">null</span> &amp;&amp; !registries.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 遍历RegistryConfig 数组</span></span><br><span class="line">           <span class="keyword">for</span> (RegistryConfig config : registries) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 获取注册中心的地址</span></span><br><span class="line">               String address = config.getAddress();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 地址为空就使用 0.0.0.0 任意地址</span></span><br><span class="line">               <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                   address = Constants.ANYHOST_VALUE;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 如果配置了启动参数的注册中心地址，它的优先级最高，就进行覆盖</span></span><br><span class="line">               String sysaddress = System.getProperty(<span class="string">"dubbo.registry.address"</span>);</span><br><span class="line">               <span class="keyword">if</span> (sysaddress != <span class="keyword">null</span> &amp;&amp; sysaddress.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   address = sysaddress;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 选择有效的注册中心地址</span></span><br><span class="line">               <span class="keyword">if</span> (address.length() &gt; <span class="number">0</span> &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 创建参数集合map,用于 URL的构建</span></span><br><span class="line">                   Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 将应用配置对象和注册中心配置对象的属性添加到参数集合map中</span></span><br><span class="line">                   appendParameters(map, application);</span><br><span class="line">                   <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 需要注意的是：RegistryConfig 的 getAddress方法上使用了 <span class="doctag">@Parameter</span>(excluded = true)注解，因此它的address属性不会加入到参数集合map中</span></span><br><span class="line"><span class="comment">                    *  <span class="doctag">@Parameter</span>(excluded = true)</span></span><br><span class="line"><span class="comment">                    *  public String getAddress() &#123;return address;&#125;</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   appendParameters(map, config);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 添加 path,dubbo,timestamp,pid 到参数集合map中</span></span><br><span class="line">                   map.put(<span class="string">"path"</span>, RegistryService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>; <span class="comment">// 这里的path要和服务暴露逻辑中的path区分，注册中心的URL中的path为RegistryService的全路径名</span></span><br><span class="line">                   map.put(<span class="string">"dubbo"</span>, Version.getProtocolVersion());</span><br><span class="line">                   map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                   <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 参数集合map中不存在 protocol 参数【以上配置对象的属性中没有有效的协议protocol参数】，就默认 使用 dubbo 作为 协议protocol的值</span></span><br><span class="line">                   <span class="keyword">if</span> (!map.containsKey(<span class="string">"protocol"</span>)) &#123;</span><br><span class="line">                       <span class="comment">// todo remote扩展实现已经不存在了，不需考虑这种情况</span></span><br><span class="line">                       if (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension("remote")) &#123;</span><br><span class="line">                           map.put(<span class="string">"protocol"</span>, <span class="string">"remote"</span>);</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           map.put(<span class="string">"protocol"</span>, <span class="string">"dubbo"</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 解析地址，创建 URL数组，注意address可能包含多个注册中心ip, 【数组大小可能为一】</span></span><br><span class="line">                   List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 循环 dubbo Register url</span></span><br><span class="line">                   <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                       <span class="comment">// 设置 registry=$&#123;protocol&#125;参数,设置到注册中心的 URL的参数部分的位置上，并且是追加式的添加</span></span><br><span class="line">                       url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());</span><br><span class="line">                       <span class="comment">// 重置 URL中的 protocol属性为 'registry',即将URL的协议头设置为'registry'</span></span><br><span class="line">                       url = url.setProtocol(Constants.REGISTRY_PROTOCOL);</span><br><span class="line">                       <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        * 通过判断条件，决定是否添加url到registryList中，条件如下：</span></span><br><span class="line"><span class="comment">                        * 1 如果是服务提供者,是否只订阅不注册，如果是就不添加到注册中心URL数组中</span></span><br><span class="line"><span class="comment">                        * 2 如果是服务消费者，是否是只注册不订阅，如果是就不添加到注册中心URL数组中</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                       <span class="keyword">if</span> ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class="keyword">true</span>)) || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, <span class="keyword">true</span>))) &#123;</span><br><span class="line">                           registryList.add(url);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> registryList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析注册中心地址，创建 URL数组</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> address</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> defaults</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;URL&gt; <span class="title">parseURLs</span><span class="params">(String address, Map&lt;String, String&gt; defaults)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 判断注册中心地址的有效性</span></span><br><span class="line">       <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 注册中心地址address 可以使用"|"或";"作为分割符，设置多个注册中心分组。注意：一个注册中心集群是一个分组而不是多个。</span></span><br><span class="line">       String[] addresses = Constants.REGISTRY_SPLIT_PATTERN.split(address);</span><br><span class="line">       <span class="keyword">if</span> (addresses == <span class="keyword">null</span> || addresses.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//here won't be empty</span></span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;URL&gt; registries = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">       <span class="comment">// 遍历注册中心分组</span></span><br><span class="line">       <span class="keyword">for</span> (String addr : addresses) &#123;</span><br><span class="line">           registries.add(parseURL(addr, defaults));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> registries;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析单个 URL，将defaults属性集合 里的参数合并到 注册中心地址address中，合并逻辑：</span></span><br><span class="line"><span class="comment">    * 使用 defaults 集合对注册中心urL的属性 进行 '查漏补缺', 即 将defaults集合中不在 注册中心url上的属性 设置到url上，存在则忽略</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> address  注册中心地址</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> defaults 参数集合</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> Dubbo URL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> URL <span class="title">parseURL</span><span class="params">(String address, Map&lt;String, String&gt; defaults)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String url;</span><br><span class="line">       <span class="keyword">if</span> (address.indexOf(<span class="string">"://"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           url = address;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           String[] addresses = Constants.COMMA_SPLIT_PATTERN.split(address);</span><br><span class="line">           url = addresses[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">if</span> (addresses.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">               StringBuilder backup = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; addresses.length; i++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                       backup.append(<span class="string">","</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   backup.append(addresses[i]);</span><br><span class="line">               &#125;</span><br><span class="line">               url += <span class="string">"?"</span> + Constants.BACKUP_KEY + <span class="string">"="</span> + backup.toString();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       String defaultProtocol = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"protocol"</span>);</span><br><span class="line">       <span class="keyword">if</span> (defaultProtocol == <span class="keyword">null</span> || defaultProtocol.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           defaultProtocol = <span class="string">"dubbo"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String defaultUsername = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"username"</span>);</span><br><span class="line">       String defaultPassword = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"password"</span>);</span><br><span class="line">       <span class="keyword">int</span> defaultPort = StringUtils.parseInteger(defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"port"</span>));</span><br><span class="line">       String defaultPath = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"path"</span>);</span><br><span class="line">       Map&lt;String, String&gt; defaultParameters = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> HashMap&lt;String, String&gt;(defaults);</span><br><span class="line">       <span class="keyword">if</span> (defaultParameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">           defaultParameters.remove(<span class="string">"protocol"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"username"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"password"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"host"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"port"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"path"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 分离url中的各个参数，然后根据各个参数构建标准的Dubbo URL -&gt; protocol://username:password@host:port/path?key=value&amp;key=value...</span></span><br><span class="line">       URL u = URL.valueOf(url);</span><br><span class="line">       <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">       String protocol = u.getProtocol();</span><br><span class="line">       String username = u.getUsername();</span><br><span class="line">       String password = u.getPassword();</span><br><span class="line">       String host = u.getHost();</span><br><span class="line">       <span class="keyword">int</span> port = u.getPort();</span><br><span class="line">       String path = u.getPath();</span><br><span class="line">       Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(u.getParameters());</span><br><span class="line">       <span class="keyword">if</span> ((protocol == <span class="keyword">null</span> || protocol.length() == <span class="number">0</span>) &amp;&amp; defaultProtocol != <span class="keyword">null</span> &amp;&amp; defaultProtocol.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           changed = <span class="keyword">true</span>;</span><br><span class="line">           protocol = defaultProtocol;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((username == <span class="keyword">null</span> || username.length() == <span class="number">0</span>) &amp;&amp; defaultUsername != <span class="keyword">null</span> &amp;&amp; defaultUsername.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           changed = <span class="keyword">true</span>;</span><br><span class="line">           username = defaultUsername;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((password == <span class="keyword">null</span> || password.length() == <span class="number">0</span>) &amp;&amp; defaultPassword != <span class="keyword">null</span> &amp;&amp; defaultPassword.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           changed = <span class="keyword">true</span>;</span><br><span class="line">           password = defaultPassword;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (port &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (defaultPort &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               changed = <span class="keyword">true</span>;</span><br><span class="line">               port = defaultPort;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               changed = <span class="keyword">true</span>;</span><br><span class="line">               port = <span class="number">9090</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (path == <span class="keyword">null</span> || path.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (defaultPath != <span class="keyword">null</span> &amp;&amp; defaultPath.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               changed = <span class="keyword">true</span>;</span><br><span class="line">               path = defaultPath;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (defaultParameters != <span class="keyword">null</span> &amp;&amp; defaultParameters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : defaultParameters.entrySet()) &#123;</span><br><span class="line">               String key = entry.getKey();</span><br><span class="line">               String defaultValue = entry.getValue();</span><br><span class="line">               <span class="keyword">if</span> (defaultValue != <span class="keyword">null</span> &amp;&amp; defaultValue.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   String value = parameters.get(key);</span><br><span class="line">                   <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                       changed = <span class="keyword">true</span>;</span><br><span class="line">                       parameters.put(key, defaultValue);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 根据标准构建的Ddubbo URL中的参数的值是否有效，会重新构建Dubbo URL，区别在于之前无效的参数都是用默认值替换</span></span><br><span class="line">       <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">           u = <span class="keyword">new</span> URL(protocol, username, password, host, port, path, parameters);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> u;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，本文主要分析 Dubbo 的本地暴露，本地暴露不会向注册中心注册服务，因为仅用于 JVM 内部调用，相关信息放在内存中。在下一篇远程暴露时会用到，这里为了完整就提前分析了。</p><p>加载注册中心URL代码还是挺复杂的，主要逻辑如下：</p><ol><li>检测是否存在注册中心配置类，不存在则抛出异常。存在则初始化RegistryConfig的配置属性。</li><li>组装参数集合，应用于注册中心URL的属性 ‘查漏补缺’。</li><li>构建注册中心URL列表</li></ol><p>有关注册中心URL构建还有一个数据流向操作，上面代码中也注释了，比较简单，因为会在远程暴露时用到，这里简单介绍下，以 Redis 注册中心为例进行说明，更常用 Zookeeper 作为注册中心。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-registry.jpg" alt></p><h4 id="组装-URL"><a href="#组装-URL" class="headerlink" title="组装 URL"></a>组装 URL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用不同的协议，逐个向注册中心分组暴露服务。该方法中包含了本地和远程两种暴露方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> protocolConfig 协议配置对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registryURLs   处理过的注册中心分组集合【已经添加了ApplicationConfig和RegistryConfig的参数】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 协议名</span></span><br><span class="line">        String name = protocolConfig.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 协议名为空时，缺省设置为 dubbo</span></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            name = <span class="string">"dubbo"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建参数集合map，用于Dubbo URL 的构建（服务提供者URL）</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将side,dubbo,timestamp,pid参数，添加到map集合中</span></span><br><span class="line">        map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class="line">        map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());</span><br><span class="line">        map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射将各种配置对象中的属性添加到map集合中，map用于URL的构建【注意属性覆盖问题】</span></span><br><span class="line">        appendParameters(map, application);</span><br><span class="line">        appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">        appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">        appendParameters(map, protocolConfig);</span><br><span class="line">        appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将MethodConfig 对象数组添加到 map 集合中。就是将每个MethodConfig和其对应的ArgumentConfig对象数组添加到map中【处理方法相关的属性到map】</span></span><br><span class="line">        <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// methods 为 MethodConfig 集合，MethodConfig 中存储了 &lt;dubbo:method&gt; 标签的配置信息</span></span><br><span class="line">            <span class="keyword">for</span> (MethodConfig method : methods) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 将MethodConfig对象的属性添加到map集合中，其中属性键 = 方法名.属性名。如：</span></span><br><span class="line"><span class="comment">                 * &lt;dubbo:method name="sleep" retries="2"&gt;&lt;/dubbo:method&gt;对应的MethodConfig，属性到map的格式：&#123;"sleep.retries":2&#125;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                appendParameters(map, method, method.getName());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当配置了 MehodConfig.retry = false 时，强制禁用重试</span></span><br><span class="line">                String retryKey = method.getName() + <span class="string">".retry"</span>;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class="line">                    String retryValue = map.remove(retryKey);</span><br><span class="line">                    <span class="comment">// 检测 MethodConfig retry 是否为 false，若是，则设置重试次数为0</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"false"</span>.equals(retryValue)) &#123;</span><br><span class="line">                        map.put(method.getName() + <span class="string">".retries"</span>, <span class="string">"0"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将MethodConfig下的ArgumentConfig 对象数组即&lt;dubbo:argument&gt; 标签中的配置信息，添加到 map 集合中</span></span><br><span class="line">                List&lt;ArgumentConfig&gt; arguments = method.getArguments();</span><br><span class="line">                <span class="keyword">if</span> (arguments != <span class="keyword">null</span> &amp;&amp; !arguments.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (ArgumentConfig argument : arguments) &#123;</span><br><span class="line">                        <span class="comment">// 检测type 属性是否为空</span></span><br><span class="line">                        <span class="keyword">if</span> (argument.getType() != <span class="keyword">null</span> &amp;&amp; argument.getType().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 通过反射取出接口的方法列表</span></span><br><span class="line">                            Method[] methods = interfaceClass.getMethods();</span><br><span class="line">                            <span class="comment">// 遍历接口中的方法列表</span></span><br><span class="line">                            <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">                                    String methodName = methods[i].getName();</span><br><span class="line">                                    <span class="comment">// 比对方法名，查找目标方法</span></span><br><span class="line">                                    <span class="keyword">if</span> (methodName.equals(method.getName())) &#123;</span><br><span class="line">                                        <span class="comment">// 通过反射取出目标方法的参数类型列表</span></span><br><span class="line">                                        Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();</span><br><span class="line">                                        <span class="comment">// 若果配置index配置项，且值不为-1</span></span><br><span class="line">                                        <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123;</span><br><span class="line">                                            <span class="comment">// 从argtypes数组中获取下标index处的元素argType，并检测ArgumentConfig中的type属性与argType名称是否一致，不一致则抛出异常</span></span><br><span class="line">                                            <span class="keyword">if</span> (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                <span class="comment">// 将ArgumentConfig对象的属性添加到map集合中，键前缀=方法名.index，如：map = &#123;"sleep.2":true&#125;</span></span><br><span class="line">                                                appendParameters(map, argument, method.getName() + <span class="string">"."</span> + argument.getIndex());</span><br><span class="line">                                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config error : the index attribute and type attribute not match :index :"</span> + argument.getIndex() + <span class="string">", type:"</span> + argument.getType());</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                            <span class="comment">// 遍历参数类型数组argtypes，查找argument.type类型的参数</span></span><br><span class="line">                                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; argtypes.length; j++) &#123;</span><br><span class="line">                                                Class&lt;?&gt; argclazz = argtypes[j];</span><br><span class="line">                                                <span class="comment">// 从参数类型列表中查找类型名称为argument.type的参数</span></span><br><span class="line">                                                <span class="keyword">if</span> (argclazz.getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                    <span class="comment">// 将ArgumentConfig对象的属性添加到map集合中</span></span><br><span class="line">                                                    appendParameters(map, argument, method.getName() + <span class="string">"."</span> + j);</span><br><span class="line">                                                    <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span> &amp;&amp; argument.getIndex() != j) &#123;</span><br><span class="line">                                                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config error : the index attribute and type attribute not match :index :"</span> + argument.getIndex() + <span class="string">", type:"</span> + argument.getType());</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 用户未配置 type 属性，但配置了index属性，且index != -1</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123; <span class="comment">// 指定单个参数的位置</span></span><br><span class="line">                            <span class="comment">// 将ArgumentConfig对象的属性添加到map集合中</span></span><br><span class="line">                            appendParameters(map, argument, method.getName() + <span class="string">"."</span> + argument.getIndex());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config must set index or type attribute.eg: &lt;dubbo:argument index='0' .../&gt; or &lt;dubbo:argument type=xxx .../&gt;"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// end of methods for</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//--- 检测 generic 是否 为 true ,并根据检测结果向map中添加不同的信息 ---/</span></span><br><span class="line">        <span class="comment">// 将 generic,methods,revision 加入到数组</span></span><br><span class="line">        <span class="keyword">if</span> (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">            map.put(Constants.GENERIC_KEY, generic);</span><br><span class="line">            map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先从MAINFEST.MF 中获取版本号，若获取不到，再从jar包命名中可能带的版本号作为结果，如 2.6.5.RELEASE。若都不存在，返回默认版本号【源码运行可能会没有】</span></span><br><span class="line">            String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">            <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                map.put(<span class="string">"revision"</span>, revision); <span class="comment">// 修订号</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为接口生成包裹类 Wrapper，Wrapper 中包含了接口的详细信息，如接口方法，字段信息等</span></span><br><span class="line">            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加方法名到 map 中，如果包含多个方法名，则用逗号隔开，比如：method=a,b</span></span><br><span class="line">            <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.warn(<span class="string">"NO method found in service interface "</span> + interfaceClass.getName());</span><br><span class="line">                <span class="comment">// 没有方法名就添加 method=*</span></span><br><span class="line">                map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将逗号作为分隔符连接方法名，并将连接后的字符串放入 map 中</span></span><br><span class="line">                map.put(Constants.METHODS_KEY, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">","</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// token 【使暴露出去的服务更安全，使用token做安全校验】</span></span><br><span class="line">        <span class="keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">                map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(Constants.TOKEN_KEY, token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 协议为injvm时，不注册，不通知</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) &#123;</span><br><span class="line">            protocolConfig.setRegister(<span class="keyword">false</span>);</span><br><span class="line">            map.put(<span class="string">"notify"</span>, <span class="string">"false"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得基础路径</span></span><br><span class="line">        String contextPath = protocolConfig.getContextpath();</span><br><span class="line">        <span class="keyword">if</span> ((contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span>) &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            contextPath = provider.getContextpath();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---------------------------- 主机绑定 -------------------------------------/</span></span><br><span class="line">        <span class="comment">// 获得注册到注册中心的服务提供者host，并为map设置bind.ip , anyhost 两个key</span></span><br><span class="line">        String host = <span class="keyword">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">        <span class="comment">// 获取端口，并为map设置bing.port key</span></span><br><span class="line">        Integer port = <span class="keyword">this</span>.findConfigedPorts(protocolConfig, name, map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建Dubbo URL对象 【注意这里的 path 的值】</span></span><br><span class="line"><span class="comment">         * 1 name: 协议名</span></span><br><span class="line"><span class="comment">         * 2 host: 主机名</span></span><br><span class="line"><span class="comment">         * 3 port: 端口</span></span><br><span class="line"><span class="comment">         * 4 path: 【基础路径】/path</span></span><br><span class="line"><span class="comment">         * 5 parameters: 属性集合map</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(name, host, port, (contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span> ? <span class="string">""</span> : contextPath + <span class="string">"/"</span>) + path, map);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码比较复杂，不过总体上是将配置承载对象中的属性添加到参数集合中用于构建 Dubbo URL 。其中涉及到的将配置对象的属性添加到参数集合的 appendParameters 方法可以参见  <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 。</p><h3 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h3><p>服务暴露的准备工作完成后，接下来就可以执行服务暴露工作了。服务暴露，分为本地暴露和远程暴露。我们先不研究细节，先从宏观层面上看一下服务暴露逻辑。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用不同的协议，逐个向注册中心分组暴露服务。该方法中包含了本地和远程两种暴露方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> protocolConfig 协议配置对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registryURLs   处理过的注册中心分组集合【已经添加了ApplicationConfig和RegistryConfig的参数】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果存在当前协议对应的 ConfiguratorFactory 扩展实现，就创建配置规则器 Configurator，将配置规则应用到url todo 这里应该不会存在把？</span></span><br><span class="line">        <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">url</span>.<span class="title">getProtocol</span>())) </span>&#123;</span><br><span class="line">            <span class="comment">// 加载ConfiguratorFactory ，并生成Configurator，将配置规则应用到url中</span></span><br><span class="line">            url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">url</span>.<span class="title">getProtocol</span>()).<span class="title">getConfigurator</span>(<span class="title">url</span>).<span class="title">configure</span>(<span class="title">url</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从URL中获取暴露方式</span></span><br><span class="line">        String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 scope = none，则不进行暴露，直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// scope != remote，本地暴露</span></span><br><span class="line">            <span class="keyword">if</span> (!Constants.SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                exportLocal(url);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// scope != local，远程暴露，包含了服务暴露和服务注册两个过程</span></span><br><span class="line">            <span class="keyword">if</span> (!Constants.SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to url "</span> + url);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (registryURLs != <span class="keyword">null</span> &amp;&amp; !registryURLs.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 遍历注册中心URL数组</span></span><br><span class="line">                    <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                        <span class="comment">// dynamic属性：服务是否动态注册，如果设为false,注册后将显示disable状态，需要人工启用，并且服务提供者停止时，也不会自动下线，需要人工禁用</span></span><br><span class="line">                        url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 获取监控中心URL</span></span><br><span class="line">                        URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 监控URL不能空，就将监控中心的URL作为monitor参数添加到服务提供者的URL中，并且需要编码。通过这样方式，服务提供者的URL中就包含了监控中心的配置</span></span><br><span class="line">                            url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(<span class="string">"Register dubbo service "</span> + interfaceClass.getName() + <span class="string">" url "</span> + url + <span class="string">" to registry "</span> + registryURL);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                     </span><br><span class="line">                        <span class="comment">// 获取配置的动态代理的生成方式 &lt;dubbo:service proxy=""/&gt;,可选jdk/javassist,默认使用javassist</span></span><br><span class="line">                        String proxy = url.getParameter(Constants.PROXY_KEY);</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                            registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);</span><br><span class="line">                        &#125;</span><br><span class="line">                     </span><br><span class="line">                        <span class="comment">// 使用ProxyFactory 创建 AbstractProxyInvoker 对象</span></span><br><span class="line">                        Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(</span><br><span class="line">                                ref,</span><br><span class="line">                                (Class) interfaceClass,</span><br><span class="line">                                registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString())</span><br><span class="line">                        );</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 创建 DelegateProviderMetaDataInvoker 对象，在Invoker对象基础上，增加了当前服务提供者ServiceConfig对象，即把Invoker和ServiceConfig结合在了一起</span></span><br><span class="line">                        DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line">                        <span class="comment">// 暴露服务，生成Exporter:</span></span><br><span class="line">                        Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 添加到 Exporter 集合</span></span><br><span class="line">                        exporters.add(exporter);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 无效注册中心，仅暴露服务</span></span><br><span class="line">                    <span class="comment">// 使用ProxyFactory 创建 Invoker 对象</span></span><br><span class="line">                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                    <span class="comment">// 创建 DelegateProviderMetaDataInvoker 对象</span></span><br><span class="line">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 使用Protocol 暴露Invoker 对象</span></span><br><span class="line">                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                    <span class="comment">// 添加到 Exporter 集合</span></span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从宏观层面上看，服务暴露的方式取决于 scope 参数，该参数值在文章前面有具体说明。</p><h3 id="创建-Invoker"><a href="#创建-Invoker" class="headerlink" title="创建 Invoker"></a>创建 Invoker</h3><p>不管是本地暴露，还是远程暴露，进行服务暴露之前，都需要先创建 Invoker ，这一点非常重要。在 Dubbo 中，Invoker 是一个非常重要的模型，无论是在服务提供端，还是服务消费端均会出现 Invoker。Dubbo 官方文档中对 Invoker 进行了说明。</p><blockquote><p>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p></blockquote><p>Invoker 是由 ProxyFactory 创建的，Dubbo 默认的 ProxyFactory 实现类是 JavassistProxyFactory ，在 <a href="https://gentryhuang.com/posts/c2df2fc6/">Javassist动态代理</a> 中进行了详细的说明。</p><h3 id="本地暴露"><a href="#本地暴露" class="headerlink" title="本地暴露"></a>本地暴露</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 本地暴露</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportLocal</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 1 若果URl的协议头是injvm，说明已经暴露到本地了，无需再次暴露</span></span><br><span class="line"><span class="comment">       * 2 非injvm协议就基于原有的URL构建协议为injvm，主机地址 127.0.0.1，端口为0 的新的 URL</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">          URL local = URL.valueOf(url.toFullString())</span><br><span class="line">                  .setProtocol(Constants.LOCAL_PROTOCOL)</span><br><span class="line">                  .setHost(LOCALHOST)</span><br><span class="line">                  .setPort(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 添加服务接口的实现类【仅用于RestProtocol协议】到线程变量中</span></span><br><span class="line">          ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 创建 Invoker，这里 proxyFactory 会在运行时执行 JavassistProxyFactory 的 getInvoker 方法 （默认情况，也可通过参数指定）</span></span><br><span class="line">          Invoker invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, local);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 这里的 protocol 会在运行时调用 InjvmProtocol 的 export 方法</span></span><br><span class="line">          Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 添加到Exporter集合中</span></span><br><span class="line">          exporters.add(exporter);</span><br><span class="line"></span><br><span class="line">          logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to local registry"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>本地暴露的代码比较简单，下面总结下流程：</p><ol><li>根据 URL 协议头决定是否暴露服务，如果需要暴露就创建 injvm 协议的 URL</li><li>然后通过 SPI 机制分别获取运行时的 proxyFactory 和 protocol 扩展实现，这就是 Dubbo SPI 自适应的好处</li><li>使用proxyFactory创建 Invoker(AbstractProxyInvoker) </li><li>使用protocol进行服务暴露</li></ol><p>以上流程的前 3 步已经分析过，下面对第 4 步进行分析。</p><h4 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h4><p>本地暴露涉及的 Protocol 类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-local-protocol.jpg" alt></p><p>由上图的 UML 类图可知，Protocol 有两个 Wrapper 类，由 Dubbo SPI 机制我们知道执行 Protocol#export 方法的顺序：</p><blockquote><p>Protocol$Adaptive =&gt; ProtocolListenerWrapper ==&gt; ProtocolFilterWrapper =&gt; InjvmProtocol</p></blockquote><p>下面对执行链进行分析，其中 Protocol 自适应扩展对象原理在 <a href="https://gentryhuang.com/posts/3e0b5964/">自适应扩展</a> 中已经详细分析。这里说明下，上图的 UML 类图中其它的先不做分析，只关注本地暴露相关的， Dubbo 中的多协议部分会单独作为一个模块分析。</p><h4 id="ProtocolListenerWrapper"><a href="#ProtocolListenerWrapper" class="headerlink" title="ProtocolListenerWrapper"></a>ProtocolListenerWrapper</h4><p>实现 Protocol 接口，是 Protocol 的 Wrapper 类，在服务暴露时用于给 Exporter 添加监听器，监听 Exporter 暴露和取消。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolListenerWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolListenerWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker Service invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// registry协议开头的服务暴露逻辑，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 服务暴露，创建 Exporter</span></span><br><span class="line">        Exporter&lt;T&gt; export = protocol.export(invoker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 ExporterListener</span></span><br><span class="line">        List&lt;ExporterListener&gt; exporterListeners = Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">getActivateExtension</span>(<span class="title">invoker</span>.<span class="title">getUrl</span>(), <span class="title">Constants</span>.<span class="title">EXPORTER_LISTENER_KEY</span>))</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 ListenerExporterWrapper 包装 Exporter，为 Exporter邦定监听器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListenerExporterWrapper&lt;T&gt;(export, exporterListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProtocolListenerWrapper 在服务暴露流程中的逻辑如下：</p><ol><li>判断当前Invoker对应的URL协议是否为 registry，远程暴露时需要用到注册中心，执行到这里时协议会为 registry，这种情况就无需绑定监听器。</li><li>使用具体协议暴露服务，创建 Exporter</li><li>获取ExporterListener，用户可以自行实现监听器。注意，实现的监听器是自动激活类型</li><li>将获取的监听器绑定到服务暴露生成的Exporter</li></ol><h4 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a>Exporter</h4><p>Exporter 是 Invoker 服务在 Protocol 上的对象。更多可以参考 <a href="https://gentryhuang.com/posts/e2577ca1/">Dubbo项目结构总览</a> 。本地暴露涉及到的 UML 类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-local-exporter.jpg" alt></p><h5 id="InjvmExporter"><a href="#InjvmExporter" class="headerlink" title="InjvmExporter"></a>InjvmExporter</h5><p>实现 AbstractExporter 抽象类，Injvm Exporter 实现类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InjvmExporter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractExporter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exporter 集合</span></span><br><span class="line"><span class="comment">     * key : 服务键</span></span><br><span class="line"><span class="comment">     * 该值实际就是 &#123;<span class="doctag">@link</span> com.alibaba.dubbo.rpc.protocol.AbstractProtocol#exporterMap&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，发起暴露</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 服务键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporterMap AbstractExporter的缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    InjvmExporter(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) &#123;</span><br><span class="line">        <span class="keyword">super</span>(invoker);</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.exporterMap = exporterMap;</span><br><span class="line">        <span class="comment">// 加入到Exporter集合[会把自己加入到AbstractProtocol中的Map中]</span></span><br><span class="line">        exporterMap.put(key, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.unexport();</span><br><span class="line">        <span class="comment">// 移除 key对应的Exporter</span></span><br><span class="line">        exporterMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InjvmExporter 会将自身的对象放入到其父类 AbstractExporter 和自身的缓存中，这也是本地暴露的本质。</p><h5 id="ListenerExporterWrapper"><a href="#ListenerExporterWrapper" class="headerlink" title="ListenerExporterWrapper"></a>ListenerExporterWrapper</h5><p>实现 Exporter 接口，具有监听器功能的 Exporter 的 Wrapper 类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ListenerExporter</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 实现 Exporter接口，具有监听器功能的Exporter包装器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerExporterWrapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Exporter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ListenerExporterWrapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真实的Exporter 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exporter&lt;T&gt; exporter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exporter 监听器数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExporterListener&gt; listeners;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListenerExporterWrapper</span><span class="params">(Exporter&lt;T&gt; exporter, List&lt;ExporterListener&gt; listeners)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"exporter == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.exporter = exporter;</span><br><span class="line">        <span class="keyword">this</span>.listeners = listeners;</span><br><span class="line">        <span class="comment">// 执行监听器</span></span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) &#123;</span><br><span class="line">            RuntimeException exception = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (ExporterListener listener : listeners) &#123;</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 事件触发【服务导出后】回调，可以进行自定义实现ExporterListener，重新该方法</span></span><br><span class="line">                        listener.exported(<span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException t) &#123;</span><br><span class="line">                        logger.error(t.getMessage(), t);</span><br><span class="line">                        exception = t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消服务暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exporter.unexport();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 执行监听器</span></span><br><span class="line">            <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) &#123;</span><br><span class="line">                RuntimeException exception = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (ExporterListener listener : listeners) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            listener.unexported(<span class="keyword">this</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RuntimeException t) &#123;</span><br><span class="line">                            logger.error(t.getMessage(), t);</span><br><span class="line">                            exception = t;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> exception;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ListenerExporterWrapper是一个 Wrapper 类，是用来给 Exporter 绑定 ExporterListener 监听器的。</p><h5 id="ExporterListener"><a href="#ExporterListener" class="headerlink" title="ExporterListener"></a>ExporterListener</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExporterListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The exporter exported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当服务暴露完成</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Protocol#export(Invoker)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exported</span><span class="params">(Exporter&lt;?&gt; exporter)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The exporter unexported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当服务取消完成</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Exporter#unexport()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unexported</span><span class="params">(Exporter&lt;?&gt; exporter)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exporter 的监听器，是一个扩展点。用户可以自定义实现，用来监听服务暴露。</p><h4 id="ProtocolFilterWrapper"><a href="#ProtocolFilterWrapper" class="headerlink" title="ProtocolFilterWrapper"></a>ProtocolFilterWrapper</h4><p>实现 Protocol 接口，是 Protocol 的 Wrapper 类，用于给 Invoker 增加过滤链。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolFilterWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolFilterWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建带Filter链的Invoker 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker Invoker对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     URL中参数名 【如：用于获得ServiceConfig或ReferenceConfig配置的自定义过滤器】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> group   分组 【暴露服务时：group=provider; 引用服务时：group=consumer】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 在执行的时候执行Filter </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Invoker&lt;T&gt; last = invoker;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有的过滤器，包括类上带有@Active注解的和在XML中配置的</span></span><br><span class="line">        List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter<span class="class">.<span class="keyword">class</span>).<span class="title">getActivateExtension</span>(<span class="title">invoker</span>.<span class="title">getUrl</span>(), <span class="title">key</span>, <span class="title">group</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒序循环 Filter，递归包装Invoker，就是一个链表结构： Xx1Filter-&gt;Xx2Filter-&gt;Xx3Filter-&gt;...-&gt;Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (!filters.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Filter filter = filters.get(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br><span class="line">                <span class="comment">// 创建新的Invoker 对象， 用于包装 next</span></span><br><span class="line">                last = <span class="keyword">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.getInterface();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.getUrl();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.isAvailable();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 调用Invoker的invoke方法的时候会执行</span></span><br><span class="line"><span class="comment">                     *  1 调用Filter#invoke(invoker,invocation)方法，不断执行过滤器逻辑</span></span><br><span class="line"><span class="comment">                     *  2 在Filter中会调用Invoker#invoker(invocation)方法，最后会执行到Invoker【如：InjvmInvoker,DubboInvoker等】的invoke方法</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> filter.invoke(next, invocation);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        invoker.destroy();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.getDefaultPort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 Invoker的URL中 protocol=registry,说明是注册中心的协议，这种情况无需创建Filter过滤器。</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立带有Filter 过滤链的 Invoker，再暴露服务</span></span><br><span class="line">        <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProtocolFilterWrapper 在服务暴露时就做了一件事，为 Invoker 增加过滤链。其中key和group参数是用来获取自定义过滤器的，具体规则参见 <a href="https://gentryhuang.com/posts/5d81f464/#getActivateExtension-%E6%96%B9%E6%B3%95">Dubbo SPI</a> 。过滤器链如下，包含 Dubbo 自带过滤器和用户自定义过滤器。</p><blockquote><p>EchoFilter - 回声探测过滤器<br>ClassLoaderFilter - 类加载器切换过滤器<br>GenericFilter - 服务提供者的泛化调用过滤器<br>ContextFilter - 服务提供者的上下文过滤器<br>TraceFilter - 追踪过滤器<br>TimeoutFilter - 服务提供者的超时过滤器<br>MonitorFilter - 监控过滤器<br>ExceptionFilter - 加工异常过滤器<br>XxxFilter - 自定义过滤器</p></blockquote><p>构建 Invoker 的过器滤链过程如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-invoker-filter-chain.jpg" alt></p><p>需要注意的是，返回的 Invoker 是一个匿名内部类对象，该对象的 invoke 方法没有其它逻辑，仅用来执行 <code>Filter.invoke</code> 方法。当向该 Invoker 发起调用时，会先执行过滤器链，只有当过滤器链执行完毕后，才会执行真正的 Invoker 的逻辑。</p><h4 id="InjvmProtocol"><a href="#InjvmProtocol" class="headerlink" title="InjvmProtocol"></a>InjvmProtocol</h4><p>实现 AbstractProtocol 抽象类，Injvm 协议实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * InjvmProtocol</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjvmProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = Constants.LOCAL_PROTOCOL;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例：在Dubbo SPI中，被初始化有且仅有一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InjvmProtocol INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InjvmProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        INSTANCE = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得单例子</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InjvmProtocol <span class="title">getInjvmProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">InjvmProtocol</span>.<span class="title">NAME</span>)</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_PORT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行服务暴露，创建InjvmExporter[并把自己-&gt;Exporter存入到父类的 &#123;<span class="doctag">@link</span> #exporterMap&#125; 属性中，key:当前服务键，value:Exporter]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker Service invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Exporter，并且把自己添加到 exporterMap 中，exporterMap 是父类属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>injvm 协议暴露服务比较简单，直接创建 InjvmExporter 对象，然后放入内存中即可，没有其它逻辑。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章详细分析了 Dubbo 本地服务导出过程，包括配置检测，URL 组装，Invoker 创建过程等，下一篇文章将分析远程暴露。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有了前面一系列文章铺垫，再来看服务暴露与服务引用就简单很多了。本地暴露需要配置、SPI、动态代理、协议等知识，其中协议部分会在后面的文章中着
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 领域模型扩展</title>
    <link href="https://gentryhuang.com/posts/946483bd/"/>
    <id>https://gentryhuang.com/posts/946483bd/</id>
    <published>2020-10-11T16:00:00.000Z</published>
    <updated>2021-04-06T08:28:59.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>常见的领域模型在之前的文章中有所介绍，如：<code>AbstractExpoter</code>、<code>AbstractInvoker</code>、<code>DubboExpoter</code>、<code>DubboInvoker</code>、<code>InjvmExpoter</code>、<code>InjvmInvoker</code> 等，关于集群容错中涉及的领域模型将在介绍集群容错篇章进行介绍。本篇文章将对领域模型相关的扩展进行介绍，涉及的类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-invoker-exporter-extra-uml.jpg" alt></p><p>上图描述的是 <strong>服务暴露的监听</strong>、<strong>服务引用的监听</strong> 以及 <strong>过滤器链的构建</strong> 关系。</p><h1 id="ProtocolListenerWrapper"><a href="#ProtocolListenerWrapper" class="headerlink" title="ProtocolListenerWrapper"></a>ProtocolListenerWrapper</h1><p><code>ProtocolListenerWrapper</code> 本身是 <code>Protocol</code> 扩展点的 <strong>Wrapper类</strong>， 在服务暴露和服务引用时以 Dubbo AOP 的能力分别将具有监听功能的 <code>ExporterListener</code> 和 <code>InvokerListener</code> 绑定到流程中，便于用户在 Dubbo 服务暴露和服务引用后添加自定义的业务逻辑。</p><h2 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># com.alibaba.dubbo.rpc.Protocol</span><br><span class="line">listener&#x3D;com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper</span><br></pre></td></tr></table></figure><p>作为 <code>Protocol</code> 扩展点的 <code>Wrapper</code> 实现。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolListenerWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扩展点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line">    <span class="comment">// Wrapper 的格式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolListenerWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.getDefaultPort();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+--- ProtocolListenerWrapper</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 registry协议开头的服务暴露逻辑直接返回</span></span><br><span class="line">        <span class="comment">// 因为 RegistryProtocol 并非 Dubbo 中的具体协议，它的逻辑是在执行具体协议之前处理前置工作</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 暴露服务</span></span><br><span class="line">        Exporter&lt;T&gt; export = protocol.export(invoker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获得ExporterListener的激活扩展实现。可以自定义 ExporterListener 实现，并配置 @Activate注解或者xml中listener属性</span></span><br><span class="line">        List&lt;ExporterListener&gt; exporterListeners = Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">getActivateExtension</span>(<span class="title">invoker</span>.<span class="title">getUrl</span>(), <span class="title">Constants</span>.<span class="title">EXPORTER_LISTENER_KEY</span>))</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 创建带 ExporterListener的ListenerExporterWrapper，用来监控服务暴露完毕后的回调操作。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListenerExporterWrapper&lt;T&gt;(export, exporterListeners);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ProtocolListenerWrapper.export</code> 用于具体协议暴露服务后增加监听器，用于监听服务暴露完成和服务取消暴露事件。使用 <code>ListenerExporterWrapper</code> 对 <code>ExporterListener</code> 进行封装。</p><h3 id="ExporterListener"><a href="#ExporterListener" class="headerlink" title="ExporterListener"></a>ExporterListener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExporterListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听服务暴露事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Protocol#export(Invoker)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exported</span><span class="params">(Exporter&lt;?&gt; exporter)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听取消暴露事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Exporter#unexport()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unexported</span><span class="params">(Exporter&lt;?&gt; exporter)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExporterListener</code> 是 Dubbo 的一个扩展点，其扩展实现类可以通过实现 <code>exported()</code> 方法和 <code>unexported()</code> 方法监听服务暴露事件以及取消暴露事件。<code>ExporterListenerAdapter</code> 是该扩展点的适配器抽象类，使用方在使用该扩展点进行功能定制时可以直接通过继承该抽象实现类即可。</p><h3 id="ListenerExporterWrapper"><a href="#ListenerExporterWrapper" class="headerlink" title="ListenerExporterWrapper"></a>ListenerExporterWrapper</h3><p>在 <code>ProtocolListenerWrapper</code> 的 <code>export()</code> 方法中会在原有的 <code>Exporter</code> 之上用 <code>ListenerExporterWrapper</code> 进行一层封装，<code>ListenerExporterWrapper</code> 的构造方法中会循环调用全部 <code>ExporterListener.exported()</code> 方法，通知其服务暴露的事件，核心逻辑如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+--- ListenerExporterWrapper</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporter  暴露的 Expoter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listeners 自定义的 ExporterListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListenerExporterWrapper</span><span class="params">(Exporter&lt;T&gt; exporter, List&lt;ExporterListener&gt; listeners)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"exporter == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.exporter = exporter;</span><br><span class="line">        <span class="keyword">this</span>.listeners = listeners;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在服务暴露过程中触发全部ExpoterListener监听器</span></span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) &#123;</span><br><span class="line">            RuntimeException exception = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (ExporterListener listener : listeners) &#123;</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 事件触发【服务暴露后】回调</span></span><br><span class="line">                        listener.exported(<span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException t) &#123;</span><br><span class="line">                        logger.error(t.getMessage(), t);</span><br><span class="line">                        exception = t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ListenerExporterWrapper.unexported()</code> 方法的逻辑与上述 <code>exported()</code> 方法的实现基本类似，代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- ListenerExporterWrapper</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消服务暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exporter.unexport();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 执行监听器</span></span><br><span class="line">            <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) &#123;</span><br><span class="line">                RuntimeException exception = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (ExporterListener listener : listeners) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            listener.unexported(<span class="keyword">this</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RuntimeException t) &#123;</span><br><span class="line">                            logger.error(t.getMessage(), t);</span><br><span class="line">                            exception = t;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> exception;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在服务暴露时返回的就是 <code>ListenerExporterWrapper</code> 对象，执行取消服务暴露则会调用上述 <code>unexport()</code> 方法。</p><h3 id="UML关系图"><a href="#UML关系图" class="headerlink" title="UML关系图"></a>UML关系图</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-exporter-model-extral-uml.jpg" alt></p><h2 id="服务引用"><a href="#服务引用" class="headerlink" title="服务引用"></a>服务引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--- ProtocolListenerWrapper</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 如果是注册中心协议，直接进入 ProtocolFilterWrapper#refer方法</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.refer(type, url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 引用服务</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = protocol.refer(type, url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获得 InvokerListener 的激活扩展实现，可以自定义 InvokerListener 实现，并配置 @Activate注解或者xml中listener属性</span></span><br><span class="line">        List&lt;InvokerListener&gt; listeners = Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(InvokerListener<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">getActivateExtension</span>(<span class="title">url</span>, <span class="title">Constants</span>.<span class="title">INVOKER_LISTENER_KEY</span>))</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 创建带 InvokerListener的 ListenerInvokerWrapper对象，用来监控服务引用后的回调操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListenerInvokerWrapper&lt;T&gt;(invoker, listeners);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ProtocolListenerWrapper.refer</code> 用于具体协议引用服务后增加监听器，用于监听服务引用完成和服务销毁事件。使用 <code>ListenerInvokerWrapper</code> 对 <code>InvokerListener</code> 进行封装。</p><h3 id="InvokerListener"><a href="#InvokerListener" class="headerlink" title="InvokerListener"></a>InvokerListener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvokerListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听服务引用事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Protocol#refer(Class, com.alibaba.dubbo.common.URL)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">referred</span><span class="params">(Invoker&lt;?&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听销毁引用事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Invoker#destroy()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroyed</span><span class="params">(Invoker&lt;?&gt; invoker)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，<code>InvokerListener</code> 是 Dubbo 的一个扩展点，起扩展实现类可以通过实现 <code>referred()</code> 方法和 <code>destroyed()</code> 方法监听服务引用和销毁引用事件。<code>InvokerListenerAdapter</code> 是该扩展点的适配器抽象类，使用方在使用该扩展点进行功能定制时可以直接通过继承该抽象实现类即可。</p><h3 id="ListenerInvokerWrapper"><a href="#ListenerInvokerWrapper" class="headerlink" title="ListenerInvokerWrapper"></a>ListenerInvokerWrapper</h3><p>在 <code>ProtocolListenerWrapper</code> 的 <code>refer()</code> 方法中会在原有的 <code>Invoker</code> 之上用 <code>ListenerInvokerWrapper</code> 进行一层封装，在构造方法内部会遍历整个 <code>InvokerListener</code> 列表，并调用每个 <code>InvokerListener.referred()</code> 方法，通知它们 Invoker 被引用的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- ListenerInvokerWrapper</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListenerInvokerWrapper</span><span class="params">(Invoker&lt;T&gt; invoker, List&lt;InvokerListener&gt; listeners)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invoker == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被修饰的 Invoker 对象</span></span><br><span class="line">        <span class="keyword">this</span>.invoker = invoker;</span><br><span class="line">        <span class="comment">// 监听器集合</span></span><br><span class="line">        <span class="keyword">this</span>.listeners = listeners;</span><br><span class="line">        <span class="comment">// 执行监听器</span></span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (InvokerListener listener : listeners) &#123;</span><br><span class="line">                <span class="comment">// 在服务引用过程中触发全部InvokerListener监听器</span></span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 当服务引用完成时会被调用</span></span><br><span class="line">                        listener.referred(invoker);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        logger.error(t.getMessage(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ListenerInvokerWrapper.destroy</code> 方法的逻辑与上述方法基本类似，代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+--- ListenerInvokerWrapper</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 销毁引用</span></span><br><span class="line">            invoker.destroy();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 执行监听器</span></span><br><span class="line">            <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (InvokerListener listener : listeners) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            listener.destroyed(invoker);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                            logger.error(t.getMessage(), t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>服务引用返回的就是 <code>ListenerInvokerWrapper</code> 对象，当进行引用销毁时会调用上述方法。</p><h3 id="UML关系图-1"><a href="#UML关系图-1" class="headerlink" title="UML关系图"></a>UML关系图</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-exporter-model-extral-uml.jpg" alt></p><h1 id="ProtocolFilterWrapper"><a href="#ProtocolFilterWrapper" class="headerlink" title="ProtocolFilterWrapper"></a>ProtocolFilterWrapper</h1><p><code>ProtocolFilterWrapper</code> 同样也是 <code>Protocol</code> 扩展点的 <strong>Wrapper类</strong>， 在服务暴露和服务引用时以 Dubbo AOP 的能力分别构建过滤器链。</p><h2 id="Dubbo-SPI-1"><a href="#Dubbo-SPI-1" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># com.alibaba.dubbo.rpc.Protocol</span><br><span class="line">filter&#x3D;com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper</span><br></pre></td></tr></table></figure><p>作为 <code>Protocol</code> 扩展点的 <code>Wrapper</code> 实现。</p><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolFilterWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 扩展点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line">    <span class="comment">// Wrapper 的格式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolFilterWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.getDefaultPort();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务暴露-1"><a href="#服务暴露-1" class="headerlink" title="服务暴露"></a>服务暴露</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--- ProtocolFilterWrapper</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 如果是注册中心协议，无需创建Filter过滤器。</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 建立带有Filter 过滤链的 Invoker，暴露服务。</span></span><br><span class="line">        <span class="comment">// Constants.PROVIDER 标识自己是服务提供者类型的调用链</span></span><br><span class="line">        <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ProtocolFilterWrapper.export</code> 方法会在 Invoker 的基础上创建带有 Filter 过滤器的 Invoker ，然后将处理后的 Invoker 暴露出去。</p><h2 id="服务引用-1"><a href="#服务引用-1" class="headerlink" title="服务引用"></a>服务引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--- ProtocolFilterWrapper</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">//  1 如果是注册中心协议，无需创建Filter过滤器。</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.refer(type, url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 引用服务，返回 Invoker 对象</span></span><br><span class="line"><span class="comment">         * 2 引用服务完成后，调用 buildInvokerChain(invoker,key,group)方法，创建带有Filter过滤器的Invoker对象。和服务暴露区别在group的值上，</span></span><br><span class="line"><span class="comment">         *   Constants.CONSUMER 标识自己是消费类型的调用链</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ProtocolFilterWrapper.refer</code> 方法会将引用的 Invoker 对象包装成带有 Filter 过滤器的 Invoker 。</p><p>关于过滤器链可以参考：<a href="https://gentryhuang.com/posts/96cae18/#%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE">过滤器链</a></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章介绍了服务暴露和服务引用的事件监听，触发时机是在服务暴露完成、服务引用完成，触发方式是利用 <code>Protocol</code> 扩展点的 <code>Wrapper</code> 功能，在服务暴露和服务引用的方法执行时执行自定义的监听器 <code>ExporterListener</code> 和 <code>InvokerListener</code> 的扩展实现，以完成指定功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;常见的领域模型在之前的文章中有所介绍，如：&lt;code&gt;AbstractExpoter&lt;/code&gt;、&lt;code&gt;AbstractInvoke
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>集群容错 - Cluster</title>
    <link href="https://gentryhuang.com/posts/7f19ea26/"/>
    <id>https://gentryhuang.com/posts/7f19ea26/</id>
    <published>2020-10-02T16:00:00.000Z</published>
    <updated>2021-04-08T14:58:19.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面的几篇文章分别对服务目录 <code>Directory</code>、路由 <code>Router</code>、负载均衡 <code>LoadBalance</code> 以及动态配置 <code>Configurator</code> 进行了介绍，本篇文章将对 Dubbo 的集群容错进行分析，集群容错是基于前面几部分内容实现的。考虑到 Dubbo 2.7.x 集群容错部分新增了一些内容，因此本篇文章基于 Dubbo 2.7.x 版本的源代码进行分析。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>为了避免单点故障，现在的应用通常至少会部署在两台服务器上，对一些负载比较高的服务，会部署更多的服务器。这样，在同一环境下的服务提供者就会有多台，对于服务消费者来说，需要选择一个服务提供者进行调用，如果调用失败还需要进行失败处理，如重试、抛出异常或者记录异常日志等。为了处理这些问题，Dubbo 定义了集群接口 <code>Cluster</code> 以及 <code>Cluster Invoker</code> 。<strong>Cluster 用途是将多个服务提供者对应的 Invoker 合并为一个 Cluster Invoker，并将这个 Invoker 暴露给服务消费者</strong>。这样一来，服务消费者只需通过这个 Invoker 进行远程调用即可，至于具体调用哪个服务提供者，以及调用失败后如何处理等问题，现在都交给集群模块去处理。集群模块是服务提供者和服务消费者的中间层，为服务消费者屏蔽了服务提供者的情况，这样服务消费者就可以专心处理远程调用相关事宜。比如发请求，接受服务提供者返回的数据等。这就是集群的作用。</p><p>Dubbo 默认内置了若干容错策略，每种容错策略都有独特的应用场景，使用方可以根据具体需要配置不同的容错策略，如果这些内置容错策略不能满足需求，还可以自定义容错策略。</p><h1 id="集群容错"><a href="#集群容错" class="headerlink" title="集群容错"></a>集群容错</h1><p>在分析集群容错相关代码之前，先对涉及的组件进行介绍，主要包括了 <code>Cluster</code>、<code>Cluster Invoker</code>、<code>Directory</code>、<code>Router</code> 和 <code>LoadBalance</code> 等。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-frame.jpeg" alt></p><p><strong>集群工作过程可分为两个阶段，具体如下：</strong></p><ol><li>创建 <code>Cluster Invoker</code> 实例<blockquote><p>在服务消费者初始化期间（服务引用过程），集群 Cluster 实现类为服务消费者创建 Cluster Invoker 实例，即上图中的 merge 操作。</p></blockquote></li><li>使用 <code>Cluster Invoker</code> 实例<blockquote><p>在服务消费者发起远程调用请求时，<code>Cluster Invoker</code> 会依赖 <code>Directory</code>、<code>Router</code>、<code>LoadBalance</code> 等组件得到最终要调用的 Invoker 对象。</p></blockquote></li></ol><p><strong>其中使用 <code>Cluster Invoker</code> 获取目标 Invoker 的具体流程如下：</strong></p><ol><li>通过服务目录 Directory 获取消费端 Invoker 列表（提供者对应的 Invoker 列表），其中的 RegistryDirectory 会感知注册中心的动态变化，实时获取提供者对应的 Invoker 对象。</li><li>使用 Router 对服务目录中提供者对应的 Invoker 列表进行路由，过滤掉不符合路由规则的 Invoker 对象。</li><li>使用 LoadBalance 从路由后的 Invoker 列表中选择一个目标 Invoker。</li><li>ClusterInvoker 会将请求信息传给负载均衡选出的 Invoker 实例，进行真正的远程调用。</li></ol><p>以上就是集群工作的正常流程，没有涉及到容错处理，容错处理逻辑是在 <code>Cluster Invoker</code> 中封装的。到这里我们知道了，集群工作的正常流程就是单纯地对其他组件的使用，只有调用出现异常时才会使用到容错逻辑。</p><p><strong>Dubbo 主要提供了以下的容错方式：</strong></p><ul><li><strong>Failover Cluster - 失败自动切换</strong> <blockquote><p>失败自动切换，是 Dubbo 默认的容错机制。当请求一个提供者节点失败时，会自动切换到其他提供者节点，默认执行 3 次，也就是重试 2 次，适合幂等场景操作。</p></blockquote></li><li><strong>Failfast Cluster - 快速失败</strong><blockquote><p>快速失败。请求失败后返回异常，不进行任务重试。适合非幂等的操作</p></blockquote></li><li><strong>Failsafe Cluster - 失败安全</strong><blockquote><p>失败安全。请求失败后忽略异常，不进行任何重试，返回一个空结果。</p></blockquote></li><li><strong>Failback Cluster - 失败自动恢复</strong><blockquote><p>失败自动恢复。失败后记录到队列，并返回一个空结果，对于失败的调用会定时重试，重试是不关心结果的。</p></blockquote></li><li><strong>Forking Cluster - 并行调用多个提供者</strong><blockquote><p>并行调用多个提供者，只要有一个成功就返回。主要应用在一些对实时性要求比较高的读操作下使用，但这将会耗费更多的资源。</p></blockquote></li><li><strong>Broadcast Cluster - 广播多个提供者</strong><blockquote><p>广播多个提供者，只要有一个失败就失败。通常用于通知类的操作，如通知所有提供者更新缓存或日志等本地资源信息。</p></blockquote></li><li><strong>Availabel Cluster - 调用首个可用的提供者</strong><blockquote><p>遍历所有的 Provider 节点，找到每一个可用的节点，就直接调用。如果没有可用的 Provider 节点，则直接抛出异常。</p></blockquote></li><li><strong>ZoneAware Cluster - 优先多注册中心选择提供者</strong><blockquote><p>在 Dubbo 中使用多个注册中心的情况，服务消费端可以使用 ZoneAwareClusterInvoker 先在多个注册中心之间选择，确定注册中心之后，再选择服务提供者节点。</p></blockquote></li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>集群容错有两个概念，分别是集群接口 <code>Cluster</code> 和封装集群容错功能的 <code>Cluster Invoker</code> ，这两者是不同的。<code>Cluster</code> 是扩展接口，它的扩展实现仅用于创建 <code>Cluster Invoker</code> 。<code>Cluster Invoker</code> 是一种特殊的 Invoker ，服务提供者的选择逻辑，以及远程调用失败后的处理逻辑都是封装在 <code>Cluster Invoker</code> 中。</p><h2 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(FailoverCluster.NAME)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Merge the directory invokers to a virtual invoker.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> cluster invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Cluster</code> 接口是一个扩展接口，通过 <strong>@SPI</strong> 注解的参数可知其默认实现是 <code>FailoverCluster</code>。它只定义了一个 <code>join</code> 方法，其上添加了 <strong>@Adaptive</strong> 注解，会动态生成适配器类，其中会优先根据 <strong>Directory.getUrl</strong> 方法返回的 URL 中的 <strong>cluster</strong> 参数值选择扩展实现，若无 <strong>cluster</strong> 参数则使用默认的 <code>FailoverCluster</code> 实现。</p><p><code>Cluster</code> 的继承体系如下图所示：</p><p><img src="/posts/7f19ea26/dubbo-cluster-cluster-uml.jpg" alt></p><p>在每个 Cluster 接口实现中，都会创建对应的 Invoker 对象，它们都继续自 <code>AbstractClusterInvoker</code> 抽象类，继承体系如下图所示：</p><p><img src="/posts/7f19ea26/dubbo-cluster-cluster-invoker-uml.jpg" alt></p><p>通过上面的继承关系图不难发现，<code>Cluster</code> 接口和 <code>Invoker</code> 接口都有相应的抽象实现类，这些抽象实现类都提供了一些公共能力。下面我们先对 <code>AbstractCluster</code> 和 <code>AbstractClusterInvoker</code> 这两个抽象类进行介绍。</p><p>关于 <code>Mock</code> 和 <code>Merger</code> 相关的实现，会分别在服务降级部分和分组聚合部分进行详细分析，本篇文章暂不展开说明。</p><h2 id="AbstractCluster"><a href="#AbstractCluster" class="headerlink" title="AbstractCluster"></a>AbstractCluster</h2><p><code>AbstractCluster</code> 核心逻辑是在 <code>AbstractClusterInvoker</code> 外层包装一层 <code>ClusterInterceptor</code>，从而实现类似切面的效果。切面逻辑目前应用不是很多，这是 Dubbo 2.7.x 增加的，这里了解即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildClusterInterceptors</span><span class="params">(AbstractClusterInvoker&lt;T&gt; clusterInvoker, String key)</span> </span>&#123;</span><br><span class="line">        AbstractClusterInvoker&lt;T&gt; last = clusterInvoker;</span><br><span class="line">        <span class="comment">// 通过 SPI 方式加载 ClusterInterceptor 扩展实现</span></span><br><span class="line">        List&lt;ClusterInterceptor&gt; interceptors = ExtensionLoader.getExtensionLoader(ClusterInterceptor<span class="class">.<span class="keyword">class</span>).<span class="title">getActivateExtension</span>(<span class="title">clusterInvoker</span>.<span class="title">getUrl</span>(), <span class="title">key</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果存在，则将 InterceptorInvokerNode 首尾连接到一起，形成调用链。</span></span><br><span class="line">        <span class="keyword">if</span> (!interceptors.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> ClusterInterceptor interceptor = interceptors.get(i);</span><br><span class="line">                <span class="keyword">final</span> AbstractClusterInvoker&lt;T&gt; next = last;</span><br><span class="line">                last = <span class="keyword">new</span> InterceptorInvokerNode&lt;&gt;(clusterInvoker, interceptor, next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 在 AbstractClusterInvoker 外层包装一层 ClusterInterceptor</span></span><br><span class="line">        <span class="keyword">return</span> buildClusterInterceptors(doJoin(directory), directory.getUrl().getParameter(REFERENCE_INTERCEPTOR_KEY));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体子类创建 AbstractClusterInvoker</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>AbstractCluster</code> 抽象类的 <strong>join</strong> 方法中，首先会调用 <strong>doJoin</strong> 方法获取最终要调用的 Invoker 对象，该方法由具体子类根据具体策略实现。之后，<strong>join</strong> 方法会调用 <strong>buildClusterInterceptors</strong> 方法对 Invoker 对象进行包装，实现切面逻辑。切面逻辑由 <code>InterceptorInvokerNode</code> 对象完成，它会将 ClusterInvoker 对象以及关联的 ClusterInterceptor 对象封装到一起，同时还会维护一个 next 引用，指向下一个 InterceptorInvokerNode 对象，核心逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorInvokerNode</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> AbstractClusterInvoker&lt;T&gt; clusterInvoker;</span><br><span class="line">       <span class="keyword">private</span> ClusterInterceptor interceptor;</span><br><span class="line">       <span class="keyword">private</span> AbstractClusterInvoker&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">InterceptorInvokerNode</span><span class="params">(AbstractClusterInvoker&lt;T&gt; clusterInvoker,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     ClusterInterceptor interceptor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     AbstractClusterInvoker&lt;T&gt; next)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.clusterInvoker = clusterInvoker;</span><br><span class="line">           <span class="keyword">this</span>.interceptor = interceptor;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">           Result asyncResult;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 前置逻辑</span></span><br><span class="line">               interceptor.before(next, invocation);</span><br><span class="line">               <span class="comment">// 执行 invoke() 方法完成远程调用</span></span><br><span class="line">               asyncResult = interceptor.intercept(next, invocation);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               <span class="comment">// 出现异常时，会触发监听器的 onError 方法</span></span><br><span class="line">               <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> ClusterInterceptor.Listener) &#123;</span><br><span class="line">                   ClusterInterceptor.Listener listener = (ClusterInterceptor.Listener) interceptor;</span><br><span class="line">                   listener.onError(e, clusterInvoker, invocation);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">throw</span> e;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">// 后置逻辑</span></span><br><span class="line">               interceptor.after(next, invocation);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> asyncResult.whenCompleteWithContext((r, t) -&gt; &#123;</span><br><span class="line">               <span class="comment">// onResponse callback</span></span><br><span class="line">               <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> ClusterInterceptor.Listener) &#123;</span><br><span class="line">                   ClusterInterceptor.Listener listener = (ClusterInterceptor.Listener) interceptor;</span><br><span class="line">                   <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       listener.onMessage(r, clusterInvoker, invocation);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       listener.onError(t, clusterInvoker, invocation);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ClusterInterceptor"><a href="#ClusterInterceptor" class="headerlink" title="ClusterInterceptor"></a>ClusterInterceptor</h2><p>用于对 <code>Cluster Invoker</code> 外围包装一层类似切面逻辑，具体有没有该切面逻辑需要看环境中没有对应扩展实现被加载到内存中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClusterInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置拦截方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clusterInvoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">(AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置拦截方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clusterInvoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">(AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用 clusterInvoker.invoke 方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clusterInvoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Result <span class="title">intercept</span><span class="params">(AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clusterInvoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来监听请求的正常结果以及异常</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Listener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Result appResponse, AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t, AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo 提供了两个 <code>ClusterInterceptor</code> 实现类，分别是 <code>ConsumerContextClusterInterceptor</code> 和 <code>ZoneAwareClusterInterceptor</code>，继承关系如下图所示：</p><p><img src="/posts/7f19ea26/dubbo-cluster-interceptor-uml.jpg" alt></p><h3 id="ConsumerContextClusterInterceptor"><a href="#ConsumerContextClusterInterceptor" class="headerlink" title="ConsumerContextClusterInterceptor"></a>ConsumerContextClusterInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerContextClusterInterceptor</span> <span class="keyword">implements</span> <span class="title">ClusterInterceptor</span>, <span class="title">ClusterInterceptor</span>.<span class="title">Listener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(AbstractClusterInvoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        RpcContext context = RpcContext.getContext();</span><br><span class="line">        <span class="comment">// 设置当前 Consumer 地址</span></span><br><span class="line">        context.setInvocation(invocation).setLocalAddress(NetUtils.getLocalHost(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置此次调用的 Invoker </span></span><br><span class="line">        <span class="keyword">if</span> (invocation <span class="keyword">instanceof</span> RpcInvocation) &#123;</span><br><span class="line">            ((RpcInvocation) invocation).setInvoker(invoker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除 Server Context</span></span><br><span class="line">        RpcContext.removeServerContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 移除本地 RpcContext</span></span><br><span class="line">        RpcContext.removeContext(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现了 ClusterInterceptor.Listener 接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Result appResponse, AbstractClusterInvoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取响应中的 attachments 并设置到 RpcContext</span></span><br><span class="line">        RpcContext.getServerContext().setObjectAttachments(appResponse.getObjectAttachments());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t, AbstractClusterInvoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ZoneAwareClusterInterceptor"><a href="#ZoneAwareClusterInterceptor" class="headerlink" title="ZoneAwareClusterInterceptor"></a>ZoneAwareClusterInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determines the zone information of current request.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * active only when url has key 'cluster=zone-aware'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Activate</span>(value = <span class="string">"cluster:zone-aware"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneAwareClusterInterceptor</span> <span class="keyword">implements</span> <span class="title">ClusterInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        RpcContext rpcContext = RpcContext.getContext();</span><br><span class="line">        <span class="comment">// 获取多注册中心相关参数并设置到 Invocation 中，主要是 registry_zone 参数和 registry_zone_force 参数</span></span><br><span class="line">        String zone = (String) rpcContext.getAttachment(REGISTRY_ZONE);</span><br><span class="line">        String force = (String) rpcContext.getAttachment(REGISTRY_ZONE_FORCE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测用户是否提供了ZoneDetector接口的扩展实现</span></span><br><span class="line">        ExtensionLoader&lt;ZoneDetector&gt; loader = ExtensionLoader.getExtensionLoader(ZoneDetector<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(zone) &amp;&amp; loader.hasExtension(<span class="string">"default"</span>)) &#123;</span><br><span class="line">            ZoneDetector detector = loader.getExtension(<span class="string">"default"</span>);</span><br><span class="line">            zone = detector.getZoneOfCurrentRequest(invocation);</span><br><span class="line">            force = detector.isZoneForcingEnabled(invocation, zone);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将registry_zone参数和registry_zone_force参数设置到Invocation中</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(zone)) &#123;</span><br><span class="line">            invocation.setAttachment(REGISTRY_ZONE, zone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(force)) &#123;</span><br><span class="line">            invocation.setAttachment(REGISTRY_ZONE_FORCE, force);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(AbstractClusterInvoker&lt;?&gt; clusterInvoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，只有当 URL 中存在 <code>key = cluster=zone-aware</code> 时 <code>ZoneAwareClusterInterceptor</code> 才会激活。该拦截器主要是将多注册中心相关的参数设置到 Invocation 中，为 <code>ZoneAwareClusterInvoker</code> 服务。</p><h2 id="AbstractClusterInvoker"><a href="#AbstractClusterInvoker" class="headerlink" title="AbstractClusterInvoker"></a>AbstractClusterInvoker</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractClusterInvoker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重要- Directory[RegistryDirectory]，通过它，可以获得所有服务提供者的Invoker对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Directory&lt;T&gt; directory;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群时是否排除非可用的Invoker，默认为true。通过 cluster.availablecheck 配置项设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> availablecheck;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经销毁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 粘滞连接 Invoker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Invoker&lt;T&gt; stickyInvoker = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(directory, directory.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (directory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"service directory == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.directory = directory;</span><br><span class="line">        <span class="comment">// sticky: invoker.isAvailable() should always be checked before using when availablecheck is true.</span></span><br><span class="line">        <span class="keyword">this</span>.availablecheck = url.getParameter(Constants.CLUSTER_AVAILABLE_CHECK_KEY, Constants.DEFAULT_CLUSTER_AVAILABLE_CHECK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面对 <code>AbstractClusterInvoker</code> 中的核心属性进行说明：</strong></p><ul><li><strong>directory</strong><blockquote><p>服务目录，可以获取所有提供者对应的 Invoker 集合。</p></blockquote></li><li><strong>availablecheck</strong><blockquote><p>集群时是否排除非可用的 Invoker，默认为 true，可通过 cluster.availablecheck 配置项设置.</p></blockquote></li><li><strong>destroyed</strong><blockquote><p>标记当前 Cluster Invoker 是否已销毁。</p></blockquote></li><li><strong>stickyInvoker</strong><blockquote><ol><li>粘滞连接用于有状态服务，尽可能让<strong>客户端</strong>总是向同一提供者发起调用，除非该提供者挂了，再连另一台。粘滞连接将自动开启延迟连接，以减少长连接数。</li><li>配置：<code>&lt;dubbo:reference stick=&quot;true&quot;/&gt;</code> 或 <code>&lt;dubbo:reference&gt; &lt;dubbo:method name=&quot;&quot; sticky=&quot;true&quot;&gt;&lt;/dubbo:method&gt;&lt;/dubbo:reference&gt;</code></li></ol></blockquote></li></ul><h3 id="判断-Cluster-Invoker-状态"><a href="#判断-Cluster-Invoker-状态" class="headerlink" title="判断 Cluster Invoker 状态"></a>判断 Cluster Invoker 状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractClusterInvoker</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断 Cluster Invoker 是否可用</span></span><br><span class="line"><span class="comment">     * 1. 如果存在粘滞 Invoker，则基于该 Invoker 进行判断</span></span><br><span class="line"><span class="comment">     * 2. 如果不存在粘滞 Invoker，则基于 Directory 判断</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Invoker&lt;T&gt; invoker = stickyInvoker;</span><br><span class="line">        <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.isAvailable();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> directory.isAvailable();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="获取-Invoker-列表"><a href="#获取-Invoker-列表" class="headerlink" title="获取 Invoker 列表"></a>获取 Invoker 列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractClusterInvoker</span><br><span class="line">  <span class="keyword">protected</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">       <span class="keyword">return</span> directory.list(invocation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="invoke-调用"><a href="#invoke-调用" class="headerlink" title="invoke() 调用"></a>invoke() 调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractClusterInvoker</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 检查当前 Cluster Invoker 是否已销毁</span></span><br><span class="line">        checkWhetherDestroyed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 将 RpcContext 中的 attachments 添加到 invocation 中</span></span><br><span class="line">        Map&lt;String, Object&gt; contextAttachments = RpcContext.getContext().getObjectAttachments();</span><br><span class="line">        <span class="keyword">if</span> (contextAttachments != <span class="keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            ((RpcInvocation) invocation).addObjectAttachments(contextAttachments);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 通过 Directory 获取 Invoker 列表</span></span><br><span class="line">        <span class="comment">// 注意，该 Invoker 列表是已经经过 Router 过滤后的结果</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 通过 SPI 加载 LoadBalance</span></span><br><span class="line">        <span class="comment">// 4.1 如果 Invoker 列表不为空，则根据第一个 Invoker的URL和调用信息初始化</span></span><br><span class="line">        <span class="comment">// 4.2 如果 Invoker 列表为空，则使用默认的负载均衡器</span></span><br><span class="line">        LoadBalance loadbalance = initLoadBalance(invokers, invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 如果是异步操作，则添加一个 id 调用编号到 invocation 的 attachment 中</span></span><br><span class="line">        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 执行调用逻辑，由子类实现</span></span><br><span class="line">        <span class="keyword">return</span> doInvoke(invocation, invokers, loadbalance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong><code>AbstractClusterInvoker</code> 的 <code>invoke</code> 方法主要做以下工作：</strong></p><ol><li>检查当前 Cluster Invoker 的状态，如果处于销毁状态，则不可调用。</li><li>从上下文中取出隐式参数，然后设置到调用信息 Invocation 中。</li><li>从服务目录中获取 Invoker 列表，<strong>注意是经过 Router 过滤后的结果</strong>。</li><li>初始化 LoadBalance ，子类将会使用该负载均衡器选择目标 Invoker 。</li><li>对异步操作进行处理，添加一个调用编号到调用信息中</li><li>子类实现选择目标 Invoker 并调用逻辑。</li></ol><p><code>AbstractClusterInvoker.invoke</code> 逻辑就是为选择和调用目标 Invoker 作准备的，具体地选择和调用目标 Invoker 由子类实现。 </p><h3 id="通用选择方法"><a href="#通用选择方法" class="headerlink" title="通用选择方法"></a>通用选择方法</h3><p><code>AbstractClusterInvoker</code> 并没有简单粗暴地直接使用负载均衡完成选择逻辑，而是做了进一步的封装。<strong>在效率方面使用了粘滞连接的特性，在正确性方面使用了重新选择的方式来尽最大努力确保选出的 Invoker 是可用的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractClusterInvoker</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadbalance 负载均衡器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation  调用信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers    候选的 Invoker 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selected    已选择过的 Invoker 集合（注意，不是所有的集群策略都会传该值，不关心的将会传 null）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标 Invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 候选 Invoker 列表为空，直接返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取调用方法名</span></span><br><span class="line">        String methodName = invocation == <span class="keyword">null</span> ? StringUtils.EMPTY_STRING : invocation.getMethodName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取 sticky 配置项，优先方法级别的</span></span><br><span class="line">        <span class="comment">// sticky 表示粘滞连接，所谓粘滞连接是指 Consumer 会尽可能地调用同一个Provider节点，除非这个Provider无法提供服务</span></span><br><span class="line">        <span class="keyword">boolean</span> sticky = invokers.get(<span class="number">0</span>).getUrl()</span><br><span class="line">                .getMethodParameter(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 检测候选 Invoker 列表是否包含 sticky Invoker。</span></span><br><span class="line">        <span class="comment">// 如果不包含，说明缓存的 sticky Invoker 是不可用的，需要将其置空</span></span><br><span class="line">        <span class="keyword">if</span> (stickyInvoker != <span class="keyword">null</span> &amp;&amp; !invokers.contains(stickyInvoker)) &#123;</span><br><span class="line">            stickyInvoker = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 开启了粘滞连接特性 &amp; sticky Invoker 存在且没有被选择过 &amp; sticky Invoker 可用</span></span><br><span class="line">        <span class="keyword">if</span> (sticky &amp;&amp; <span class="comment">// 开启粘滞连接特性</span></span><br><span class="line">                stickyInvoker != <span class="keyword">null</span> &amp;&amp; <span class="comment">// sticky Invoker 不为空</span></span><br><span class="line">                (selected == <span class="keyword">null</span> || !selected.contains(stickyInvoker))) &#123; <span class="comment">// sticky Invoker 未被选择过</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测当前 stickyInvoker 是否可用，如果可用，直接返回 sticky Invoker</span></span><br><span class="line">            <span class="keyword">if</span> (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">return</span> stickyInvoker;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 sticky Invoker 为空或不可用，则执行选择 Invoker 逻辑</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = doSelect(loadbalance, invocation, invokers, selected);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7 如果开启粘滞连接特性，则更新 stickyInvoker 字段</span></span><br><span class="line">        <span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">            stickyInvoker = invoker;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 <code>select()</code> 方法中会根据配置决定是否开启粘滞连接特性，如果开启了，则会将上次选择出的 Invoker 缓存起来，只要该粘滞 Invoker 可用就直接使用，不会再进行负载均衡。该方法主要是处理粘滞连接特性。</p><p>下面我们继续分析 <code>doSelect()</code> 方法，该方法才会使用负载均衡器选择目标 Invoker，并尽最大努力确保选出的 Invoker 是可用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractClusterInvoker</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadbalance 负载均衡对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation  调用信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers    候选的 Invoker 列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selected    已选过的 Invoker 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 判断是否需要负载均衡，Invoker 集合为空，则直接返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 候选 Invoker 仅有一个，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 使用负载均衡器选择目标 Invoker</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = loadbalance.select(invokers, getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//If the `invoker` is in the  `selected` or invoker is unavailable &amp;&amp; availablecheck is true, reselect.</span></span><br><span class="line">        <span class="comment">// 4 对负载均衡选出的 Invoker 进行校验，决定是否重新选择</span></span><br><span class="line">        <span class="keyword">if</span> ((selected != <span class="keyword">null</span> &amp;&amp; selected.contains(invoker)) <span class="comment">// 选出的 Invoker 已经被选择过</span></span><br><span class="line">                || (!invoker.isAvailable() &amp;&amp; getUrl() != <span class="keyword">null</span> &amp;&amp; availablecheck)) &#123; <span class="comment">// 选出的 Invoker 不可用</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 4.1 重新进行一次负载均衡</span></span><br><span class="line">                Invoker&lt;T&gt; rInvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);</span><br><span class="line">                <span class="comment">// 4.2 如果重新选择的 Invoker 对象不为空，则直接使用该 Invoker</span></span><br><span class="line">                <span class="keyword">if</span> (rInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    invoker = rInvoker;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.3 如果重新选择的Invoker为空，就进行容错，无论如何都要选出一个</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.4 第一次选的Invoker如果不是候选Invoker列表中最后一个就选它的下一个，否则就使用候选Invoker列表中的第一个。进行兜底，保证能够获取到一个Invoker</span></span><br><span class="line">                    <span class="keyword">int</span> index = invokers.indexOf(invoker);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//Avoid collision</span></span><br><span class="line">                        invoker = invokers.get((index + <span class="number">1</span>) % invokers.size());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.warn(e.getMessage() + <span class="string">" may because invokers list dynamic change, ignore."</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.error(<span class="string">"cluster reselect fail reason is :"</span> + t.getMessage() + <span class="string">" if can not solve, you can set cluster.availablecheck=false in url"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>doSelect()</code> 方法主要做了两件事，其一是通过 LoadBalance 选择 Invoker 对象；其二是如果选出来的 Invoker 不稳定或不可用，会调用 <code>reselect()</code> 方法进行重选。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractClusterInvoker</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reselect, use invokers not in `selected` first, if all invokers are in `selected`,</span></span><br><span class="line"><span class="comment">     * just pick an available one using loadbalance policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadbalance    负载均衡器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation     调用信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers       候选 Invoker 列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selected       已选过的 Invoker 列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> availablecheck 可用性检查</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标 Invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">reselect</span><span class="params">(LoadBalance loadbalance, Invocation invocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                                List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected, <span class="keyword">boolean</span> availablecheck)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 预先分配一个列表</span></span><br><span class="line">        <span class="comment">// 注意：这个列表大小比候选的 Invoker列表大小小 1，因为候选Invoker列表中的Invoker可能在selected中或者不可用，从上一步结果可知。</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; reselectInvokers = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">                invokers.size() &gt; <span class="number">1</span> ? (invokers.size() - <span class="number">1</span>) : invokers.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 将不在 selected 集合中且是可用状态的 Invoker 过滤出来参与负载均衡</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (availablecheck &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (selected == <span class="keyword">null</span> || !selected.contains(invoker)) &#123;</span><br><span class="line">                reselectInvokers.add(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 reselectInvokers 不为空时，才需要通过负载均衡组件进行选择</span></span><br><span class="line">        <span class="keyword">if</span> (!reselectInvokers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 线程走到这里，说明 reselectInvokers 集合为空。这时需要兜底，从已经选择过的Invoker列表中选择可用的Invoker列表，然后通过负载均衡器选择一个目标的Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (selected != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : selected) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((invoker.isAvailable()) <span class="comment">// available first</span></span><br><span class="line">                        &amp;&amp; !reselectInvokers.contains(invoker)) &#123;</span><br><span class="line">                    reselectInvokers.add(invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!reselectInvokers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> loadbalance.select(reselectInvokers, getUrl(), invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 实在选不出来，只能返回 null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>reselect</code> 方法会重新进行一次负载均衡，首先会对未尝试过的且可用状态的 Invoker 列表进行负载均衡，选出最终的 Invoker 对象并返回。如果没有可尝试的 Invoker ，则进行兜底操作，只能对尝试过的且是可用状态的 Invoker 列表重新进行负载均衡，选出目标 Invoker 对象。</p><p>至此，通用的 <code>Cluster</code> 和 <code>Cluster Invoker</code> 逻辑已经介绍完了，下面我们就来分析 Dubbo 中的具体集群策略。</p><h2 id="FailoverCluster-amp-FailoverClusterInvoker"><a href="#FailoverCluster-amp-FailoverClusterInvoker" class="headerlink" title="FailoverCluster &amp; FailoverClusterInvoker"></a>FailoverCluster &amp; FailoverClusterInvoker</h2><p><code>FailoverCluster</code> 用于创建 <code>FailoverClusterInvoker</code> 对象，<code>FailoverClusterInvoker</code> 实现了调用失败自动切换的逻辑。</p><h3 id="FailoverCluster"><a href="#FailoverCluster" class="headerlink" title="FailoverCluster"></a>FailoverCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverCluster</span> <span class="keyword">extends</span> <span class="title">AbstractCluster</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"failover"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 FailoverClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailoverClusterInvoker&lt;&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FailoverClusterInvoker"><a href="#FailoverClusterInvoker" class="headerlink" title="FailoverClusterInvoker"></a>FailoverClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailoverClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(FailoverClusterInvoker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FailoverClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers;</span><br><span class="line">        <span class="comment">// 1 检查候选 Invoker 列表是否为空</span></span><br><span class="line">        checkInvokers(copyInvokers, invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取调用方法名</span></span><br><span class="line">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取配置的重试次数，默认重试 2 次，总共执行 3 次</span></span><br><span class="line">        <span class="keyword">int</span> len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 准备调用记录属性</span></span><br><span class="line">        <span class="comment">// 记录最后一次调用异常（如果有的情况下）</span></span><br><span class="line">        RpcException le = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 记录已经调用过的 Invoker</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size());</span><br><span class="line">        <span class="comment">// 记录负载均衡选出来的 Invoker 的网络地址</span></span><br><span class="line">        Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 如果出现调用失败，则重试其他服务。这是该集群容错机制的核心。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 第一次传进来的 invokers 已经check过了，第二次则是重试，需要重新获取最新的服务列表</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查当前 ClusterInvoker 是否可用</span></span><br><span class="line">                checkWhetherDestroyed();</span><br><span class="line">                <span class="comment">// 重新从服务目录中拉取 Invoker 列表</span></span><br><span class="line">                copyInvokers = list(invocation);</span><br><span class="line">                <span class="comment">// 检查 copyInvokers ，防止服务目录中的 Invoker 列表为空</span></span><br><span class="line">                checkInvokers(copyInvokers, invocation);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 LoadBalance 选择 Invoker 对象，这里传入 invoked 集合</span></span><br><span class="line">            Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);</span><br><span class="line">            <span class="comment">// 记录此次尝试调用的 Invoker ，之后非兜底情况会过滤掉该 Invoker </span></span><br><span class="line">            invoked.add(invoker);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存已选过的 Invoker 到上下文</span></span><br><span class="line">            RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// RPC 调用</span></span><br><span class="line">                Result result = invoker.invoke(invocation);</span><br><span class="line">                <span class="comment">// 经过重试之后，成功了。这里会打印最后一次调用的异常信息。</span></span><br><span class="line">                <span class="keyword">if</span> (le != <span class="keyword">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Although retry the method "</span> + methodName</span><br><span class="line">                            + <span class="string">" in the service "</span> + getInterface().getName()</span><br><span class="line">                            + <span class="string">" was successful by the provider "</span> + invoker.getUrl().getAddress()</span><br><span class="line">                            + <span class="string">", but there have been failed providers "</span> + providers</span><br><span class="line">                            + <span class="string">" ("</span> + providers.size() + <span class="string">"/"</span> + copyInvokers.size()</span><br><span class="line">                            + <span class="string">") from the registry "</span> + directory.getUrl().getAddress()</span><br><span class="line">                            + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost()</span><br><span class="line">                            + <span class="string">" using the dubbo version "</span> + Version.getVersion() + <span class="string">". Last error is: "</span></span><br><span class="line">                            + le.getMessage(), le);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                <span class="comment">// 如果是业务性质的异常，则不再重试，直接抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (e.isBiz()) &#123; <span class="comment">// biz exception.</span></span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                le = e;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 其他异常同一封装成 RpcException，表示此次尝试失败，会进行重试。</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 记录尝试过的提供者的地址</span></span><br><span class="line">                providers.add(invoker.getUrl().getAddress());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 达到重试次数上限后仍然调用失败的话，就抛出异常。</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(le.getCode(), <span class="string">"Failed to invoke the method "</span></span><br><span class="line">                + methodName + <span class="string">" in the service "</span> + getInterface().getName()</span><br><span class="line">                + <span class="string">". Tried "</span> + len + <span class="string">" times of the providers "</span> + providers</span><br><span class="line">                + <span class="string">" ("</span> + providers.size() + <span class="string">"/"</span> + copyInvokers.size()</span><br><span class="line">                + <span class="string">") from the registry "</span> + directory.getUrl().getAddress()</span><br><span class="line">                + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" using the dubbo version "</span></span><br><span class="line">                + Version.getVersion() + <span class="string">". Last error is: "</span></span><br><span class="line">                + le.getMessage(), le.getCause() != <span class="keyword">null</span> ? le.getCause() : le);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FailoverClusterInvoker</code> 的 <code>doInvoke</code> 方法首先是获取重试次数，然后根据重试次数进行循环调用，失败后进行重试。在循环逻辑中，先根据负载均衡器选择一个 Invoker，然后再通过这个 Invoker 进行远程调用。如果失败了，记录下异常，并进行重试，直到达到最大重试次数。注意，每次进行重试时都会重新从服务目录中拉取 Invoker 列表防止脏数据，并且会进行一次负载均衡处理。</p><h2 id="FailbackCluster-amp-FailbackClusterInvoker"><a href="#FailbackCluster-amp-FailbackClusterInvoker" class="headerlink" title="FailbackCluster &amp; FailbackClusterInvoker"></a>FailbackCluster &amp; FailbackClusterInvoker</h2><p><code>FailbackCluster</code> 用于创建 <code>FailbackClusterInvoker</code> 对象，<code>FailbackClusterInvoker</code> 会在调用失败后返回一个空结果给服务消费端，并通过定时任务对失败的调用进行重试，注意，服务消费端已经收到了空的结果，虽然定时重试，但是和调用方已经无关了。</p><h3 id="FailbackCluster"><a href="#FailbackCluster" class="headerlink" title="FailbackCluster"></a>FailbackCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackCluster</span> <span class="keyword">extends</span> <span class="title">AbstractCluster</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"failback"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 FailbackClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailbackClusterInvoker&lt;&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FailbackClusterInvoker"><a href="#FailbackClusterInvoker" class="headerlink" title="FailbackClusterInvoker"></a>FailbackClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(FailbackClusterInvoker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RETRY_FAILED_PERIOD = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败重试次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> retries;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败任务数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> failbackTasks;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Timer failTimer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FailbackClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">        <span class="comment">// 1 获取 retries 配置项，即请求失败重试次数，默认 3 次</span></span><br><span class="line">        <span class="keyword">int</span> retriesConfig = getUrl().getParameter(RETRIES_KEY, DEFAULT_FAILBACK_TIMES);</span><br><span class="line">        <span class="keyword">if</span> (retriesConfig &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            retriesConfig = DEFAULT_FAILBACK_TIMES;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 失败重试的任务数，默认 100</span></span><br><span class="line">        <span class="keyword">int</span> failbackTasksConfig = getUrl().getParameter(FAIL_BACK_TASKS_KEY, DEFAULT_FAILBACK_TASKS);</span><br><span class="line">        <span class="keyword">if</span> (failbackTasksConfig &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            failbackTasksConfig = DEFAULT_FAILBACK_TASKS;</span><br><span class="line">        &#125;</span><br><span class="line">        retries = retriesConfig;</span><br><span class="line">        failbackTasks = failbackTasksConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        Invoker&lt;T&gt; invoker = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 检查候选 Invoker 列表是否为空</span></span><br><span class="line">            checkInvokers(invokers, invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 使用 LoadBalance 选择 Invoker 对象，这里传入 invoked 集合</span></span><br><span class="line">            invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 RPC 调用</span></span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Failback to invoke method "</span> + invocation.getMethodName() + <span class="string">", wait for retry in background. Ignored exception: "</span></span><br><span class="line">                    + e.getMessage() + <span class="string">", "</span>, e);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 调用失败后，添加一个定时任务进行定时重试</span></span><br><span class="line">            addFailed(loadbalance, invocation, invokers, invoker);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 返回一个空结果</span></span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, <span class="keyword">null</span>, invocation); <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加失败重试定时任务。默认每隔 5s 执行一次，总共重试 3 次。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadbalance</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastInvoker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFailed</span><span class="params">(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, Invoker&lt;T&gt; lastInvoker)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 初始化时间轮</span></span><br><span class="line">        <span class="keyword">if</span> (failTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (failTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    failTimer = <span class="keyword">new</span> HashedWheelTimer(</span><br><span class="line">                            <span class="keyword">new</span> NamedThreadFactory(<span class="string">"failback-cluster-timer"</span>, <span class="keyword">true</span>),</span><br><span class="line">                            <span class="number">1</span>,</span><br><span class="line">                            TimeUnit.SECONDS, <span class="number">32</span>, failbackTasks);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建重试定时任务</span></span><br><span class="line">        RetryTimerTask retryTimerTask = <span class="keyword">new</span> RetryTimerTask(loadbalance, invocation, invokers, lastInvoker, retries, RETRY_FAILED_PERIOD);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3 将定时任务加载到时间轮中</span></span><br><span class="line">            failTimer.newTimeout(retryTimerTask, RETRY_FAILED_PERIOD, TimeUnit.SECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Failback background works error,invocation-&gt;"</span> + invocation + <span class="string">", exception: "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>FailbackClusterInvoker</code> 主要逻辑如下：</p><ol><li>使用 LoadBalance 选择一个 Invoker 对象（存在可用的粘滞 Invoker 就不需要负载均衡了）</li><li>使用选出的 Invoker 进行 RPC 调用，如果调用成功则直接返回，也就没有重试的事了</li><li>调用失败后，通过 <code>addFailed</code> 方法创建一个失败重试的定时任务，重试任务默认会每隔 5s 执行一次，最多重试 3 次。并且，每次重试都会重新选择 Invoker 。</li><li>调用失败后，会返回一个空结果。</li></ol><p>了解了 <code>FailbackClusterInvoker</code> 逻辑后，我们继续对重试逻辑进行说明。</p><h4 id="RetryTimerTask"><a href="#RetryTimerTask" class="headerlink" title="RetryTimerTask"></a>RetryTimerTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryTimerTask</span> <span class="keyword">implements</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Invocation invocation;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> LoadBalance loadbalance;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> retries;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> tick;</span><br><span class="line">      <span class="keyword">private</span> Invoker&lt;T&gt; lastInvoker;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> retryTimes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      RetryTimerTask(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, Invoker&lt;T&gt; lastInvoker, <span class="keyword">int</span> retries, <span class="keyword">long</span> tick) &#123;</span><br><span class="line">          <span class="keyword">this</span>.loadbalance = loadbalance;</span><br><span class="line">          <span class="keyword">this</span>.invocation = invocation;</span><br><span class="line">          <span class="keyword">this</span>.invokers = invokers;</span><br><span class="line">          <span class="keyword">this</span>.retries = retries;</span><br><span class="line">          <span class="keyword">this</span>.tick = tick;</span><br><span class="line">          <span class="keyword">this</span>.lastInvoker = lastInvoker;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 重新选择 Invoker 对象，这里会将上次重试失败的 Invoker 作为 selected 集合传入</span></span><br><span class="line">              Invoker&lt;T&gt; retryInvoker = select(loadbalance, invocation, invokers, Collections.singletonList(lastInvoker));</span><br><span class="line">              lastInvoker = retryInvoker;</span><br><span class="line">              <span class="comment">// RPC 调用</span></span><br><span class="line">              retryInvoker.invoke(invocation);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// RPC 调用失败时才会尝试重试</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">              logger.error(<span class="string">"Failed retry to invoke method "</span> + invocation.getMethodName() + <span class="string">", waiting again."</span>, e);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 重试次数未达到上限，才会重新添加定时任务，然后等待重试</span></span><br><span class="line">              <span class="keyword">if</span> ((++retryTimes) &gt;= retries) &#123;</span><br><span class="line">                  logger.error(<span class="string">"Failed retry times exceed threshold ("</span> + retries + <span class="string">"), We have to abandon, invocation-&gt;"</span> + invocation);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  rePut(timeout);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 重新添加，等待重试</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rePut</span><span class="params">(Timeout timeout)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Timer timer = timeout.timer();</span><br><span class="line">          <span class="keyword">if</span> (timer.isStop() || timeout.isCancelled()) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          timer.newTimeout(timeout.task(), tick, TimeUnit.SECONDS);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="FailfastCluster-amp-FailfastClusterInvoker"><a href="#FailfastCluster-amp-FailfastClusterInvoker" class="headerlink" title="FailfastCluster &amp; FailfastClusterInvoker"></a>FailfastCluster &amp; FailfastClusterInvoker</h2><p><code>FailfastCluster</code> 用于创建 <code>FailfastClusterInvoker</code> 对象，<code>FailfastClusterInvoker</code> 只会进行一次调用，失败后立即抛出异常，这种策略适合非幂等的操作。</p><h3 id="FailfastCluster"><a href="#FailfastCluster" class="headerlink" title="FailfastCluster"></a>FailfastCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailfastCluster</span> <span class="keyword">extends</span> <span class="title">AbstractCluster</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"failfast"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 FailfastClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailfastClusterInvoker&lt;&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FailfastClusterInvoker"><a href="#FailfastClusterInvoker" class="headerlink" title="FailfastClusterInvoker"></a>FailfastClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailfastClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FailfastClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 检测候选 Invoker 列表是否为空</span></span><br><span class="line">        checkInvokers(invokers, invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 使用 LoadBalance 选择 Invoker 对象</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 RPC 调用</span></span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 请求失败，直接抛出异常</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RpcException &amp;&amp; ((RpcException) e).isBiz()) &#123; <span class="comment">// biz exception.</span></span><br><span class="line">                <span class="keyword">throw</span> (RpcException) e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e <span class="keyword">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class="number">0</span>,</span><br><span class="line">                    <span class="string">"Failfast invoke providers "</span> + invoker.getUrl() + <span class="string">" "</span> + loadbalance.getClass().getSimpleName()</span><br><span class="line">                            + <span class="string">" select from all providers "</span> + invokers + <span class="string">" for service "</span> + getInterface().getName()</span><br><span class="line">                            + <span class="string">" method "</span> + invocation.getMethodName() + <span class="string">" on consumer "</span> + NetUtils.getLocalHost()</span><br><span class="line">                            + <span class="string">" use dubbo version "</span> + Version.getVersion()</span><br><span class="line">                            + <span class="string">", but no luck to perform the invocation. Last error is: "</span> + e.getMessage(),</span><br><span class="line">                    e.getCause() != <span class="keyword">null</span> ? e.getCause() : e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FailsafeCluster-amp-FailsafeClusterInvoker"><a href="#FailsafeCluster-amp-FailsafeClusterInvoker" class="headerlink" title="FailsafeCluster &amp; FailsafeClusterInvoker"></a>FailsafeCluster &amp; FailsafeClusterInvoker</h2><p><code>FailsafeCluster</code> 用于创建 <code>FailsafeClusterInvoker</code> 对象，<code>FailsafeClusterInvoker</code> 是一种失败安全的 <code>Cluster Invoker</code> 。所谓失败安全指的是，当调用过程出现异常时，<code>FailsafeClusterInvoker</code> 仅会打印异常日志，而不会抛出异常，代替的是返回一个空间结果。</p><h3 id="FailsafeCluster"><a href="#FailsafeCluster" class="headerlink" title="FailsafeCluster"></a>FailsafeCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailsafeCluster</span> <span class="keyword">extends</span> <span class="title">AbstractCluster</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"failsafe"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 FailsafeClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailsafeClusterInvoker&lt;&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FailsafeClusterInvoker"><a href="#FailsafeClusterInvoker" class="headerlink" title="FailsafeClusterInvoker"></a>FailsafeClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailsafeClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(FailsafeClusterInvoker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FailsafeClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 检测候选 Invoker 列表是否为空</span></span><br><span class="line">            checkInvokers(invokers, invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 使用 LoadBalance 选择 Invoker 对象</span></span><br><span class="line">            Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 RPC 调用</span></span><br><span class="line">            <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Failsafe ignore exception: "</span> + e.getMessage(), e);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 调用异常，直接返回一个空结果，不会抛出异常</span></span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, <span class="keyword">null</span>, invocation); <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ForkingCluster-amp-ForkingClusterInvoker"><a href="#ForkingCluster-amp-ForkingClusterInvoker" class="headerlink" title="ForkingCluster &amp; ForkingClusterInvoker"></a>ForkingCluster &amp; ForkingClusterInvoker</h2><p><code>ForkingCluster</code> 用于创建 <code>ForkingClusterInvoker</code> 对象，<code>ForkingClusterInvoker</code> 支持并发调用多个服务提供者，只要有一个服务提供者成功返回了结果，就会立即结束运行。</p><h3 id="ForkingCluster"><a href="#ForkingCluster" class="headerlink" title="ForkingCluster"></a>ForkingCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkingCluster</span> <span class="keyword">extends</span> <span class="title">AbstractCluster</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"forking"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ForkingClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ForkingClusterInvoker&lt;&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ForkingClusterInvoker"><a href="#ForkingClusterInvoker" class="headerlink" title="ForkingClusterInvoker"></a>ForkingClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkingClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行多个 Invoker RPC 调用的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor = Executors.newCachedThreadPool(</span><br><span class="line">            <span class="keyword">new</span> NamedInternalThreadFactory(<span class="string">"forking-cluster-timer"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkingClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 检查候选 Invoker 集合是否为空</span></span><br><span class="line">            checkInvokers(invokers, invocation);</span><br><span class="line">            <span class="comment">// 保存选择的 Invoker</span></span><br><span class="line">            <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; selected;</span><br><span class="line">            <span class="comment">// 获取 forks 配置项，即并行数，默认为 2</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> forks = getUrl().getParameter(FORKS_KEY, DEFAULT_FORKS);</span><br><span class="line">            <span class="comment">// 获取 timeout 配置项，即超时时间，默认为 1000 毫秒</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> timeout = getUrl().getParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 最大并行数 &lt;= 0 或者 &gt;= Invoker 数，则选择所有的 Invoker</span></span><br><span class="line">            <span class="keyword">if</span> (forks &lt;= <span class="number">0</span> || forks &gt;= invokers.size()) &#123;</span><br><span class="line">                selected = invokers;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3 根据并行数，选择此次并发调用的 Invoker</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                selected = <span class="keyword">new</span> ArrayList&lt;&gt;(forks);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环并行数，每次循环都要尝试选择一个 Invoker</span></span><br><span class="line">                <span class="comment">// 注意：可能最终得到的 Invoker 列表大小小于并发数</span></span><br><span class="line">                <span class="keyword">while</span> (selected.size() &lt; forks) &#123;</span><br><span class="line">                    Invoker&lt;T&gt; invoker = select(loadbalance, invocation, invokers, selected);</span><br><span class="line">                    <span class="comment">// 避免重复选择</span></span><br><span class="line">                    <span class="keyword">if</span> (!selected.contains(invoker)) &#123;</span><br><span class="line">                        <span class="comment">//Avoid add the same invoker several times.</span></span><br><span class="line">                        selected.add(invoker);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 将选中的 Invoker 列表设置到上下文中</span></span><br><span class="line">            RpcContext.getContext().setInvokers((List) selected);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录调用失败数</span></span><br><span class="line">            <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">            <span class="comment">// 记录请求的结果</span></span><br><span class="line">            <span class="keyword">final</span> BlockingQueue&lt;Object&gt; ref = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 遍历 selected ，将每个 Invoker 的 RPC 调用提交到线程池，并把结果放入到阻塞队列中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> Invoker&lt;T&gt; invoker : selected) &#123;</span><br><span class="line">                executor.execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// RPC 调用</span></span><br><span class="line">                        Result result = invoker.invoke(invocation);</span><br><span class="line">                        <span class="comment">// 把调用结果放入到阻塞队列中</span></span><br><span class="line">                        ref.offer(result);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 调用失败</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        <span class="comment">// 记录调用失败数</span></span><br><span class="line">                        <span class="keyword">int</span> value = count.incrementAndGet();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果选择的 Invoker 全部调用失败，则把最后一次调用异常加入到阻塞队列</span></span><br><span class="line">                        <span class="comment">// 保证异常对象不会出现在正常结果的前面，这样可从阻塞队列中优先取出正常的结果</span></span><br><span class="line">                        <span class="keyword">if</span> (value &gt;= selected.size()) &#123;</span><br><span class="line">                            ref.offer(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 6 当前线程会阻塞等待任意一个调用结果，如果选择的 Invoker 全部调用失败，则会获取到一个异常结果。</span></span><br><span class="line">                Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line">                    Throwable e = (Throwable) ret;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e <span class="keyword">instanceof</span> RpcException ? ((RpcException) e).getCode() : <span class="number">0</span>, <span class="string">"Failed to forking invoke provider "</span> + selected + <span class="string">", but no luck to perform the invocation. Last error is: "</span> + e.getMessage(), e.getCause() != <span class="keyword">null</span> ? e.getCause() : e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> (Result) ret;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to forking invoke provider "</span> + selected + <span class="string">", but no luck to perform the invocation. Last error is: "</span> + e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// clear attachments which is binding to current thread.</span></span><br><span class="line">            RpcContext.getContext().clearAttachments();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ForkingClusterInvoker</code> 会在运行依据并行调用数通过线程池创建多个线程，并发调用多个服务提供者，只要有一个服务提供者成功返回了结果，就会立即结束运行。主要应用在一些对实时性要求比较高的读操作下使用，但这将会耗费更多的资源。需要注意的是，因为没有并发控制，并行写操作可能不安全。</p><p>主要逻辑如下：</p><ol><li>基于并行配置项 forks 的值选出合适数量的 Invoker，选出的 Invoker 数量小于等于并行数。</li><li>通过线程池并发调用步骤 1 中的多个 Invoker ，并将每个 Invoker 的调用结果暂存到阻塞队列中。</li><li>在阻塞队列中阻塞等待任意一个返回结果，并对返回结果类型进行判断，如果为异常类型，则直接抛出，否则返回。</li></ol><h2 id="BroadcastCluster-amp-BroadcastClusterInvoker"><a href="#BroadcastCluster-amp-BroadcastClusterInvoker" class="headerlink" title="BroadcastCluster &amp; BroadcastClusterInvoker"></a>BroadcastCluster &amp; BroadcastClusterInvoker</h2><p><code>BroadcastCluster</code> 用于创建 <code>BroadcastClusterInvoker</code> 对象，<code>BroadcastClusterInvoker</code> 会逐个调用每个服务提供者，其中任意一个服务提供者节点报错，都会在全部调用结束之后抛出异常。该类通常用于通知类的操作，如通知所有提供者更新缓存或日志等本地资源信息。</p><h3 id="BroadcastCluster"><a href="#BroadcastCluster" class="headerlink" title="BroadcastCluster"></a>BroadcastCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastCluster</span> <span class="keyword">extends</span> <span class="title">AbstractCluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 BroadcastClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BroadcastClusterInvoker&lt;&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BroadcastClusterInvoker"><a href="#BroadcastClusterInvoker" class="headerlink" title="BroadcastClusterInvoker"></a>BroadcastClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(BroadcastClusterInvoker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BroadcastClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 检测 Invoker 列表是否为空</span></span><br><span class="line">        checkInvokers(invokers, invocation);</span><br><span class="line">        RpcContext.getContext().setInvokers((List) invokers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于记录调用异常信息和调用结果</span></span><br><span class="line">        RpcException exception = <span class="keyword">null</span>;</span><br><span class="line">        Result result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有的 Invoker 对象</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// RPC 请求</span></span><br><span class="line">                result = invoker.invoke(invocation);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                exception = e;</span><br><span class="line">                logger.warn(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                exception = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">                logger.warn(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AvailableCluster-amp-AvailableClusterInvoker"><a href="#AvailableCluster-amp-AvailableClusterInvoker" class="headerlink" title="AvailableCluster &amp; AvailableClusterInvoker"></a>AvailableCluster &amp; AvailableClusterInvoker</h2><p><code>AvailableCluster</code> 用于创建 <code>AvailableClusterInvoker</code> 对象，<code>AvailableClusterInvoker</code> 会遍历整个候选 Invoker 列表，会使用首个可用的 Invoker 进行调用，成功则返回结果，失败则抛出异常终止遍历。需要说明的是，该集群策略没有使用到负载均衡机制。</p><h3 id="AvailableCluster"><a href="#AvailableCluster" class="headerlink" title="AvailableCluster"></a>AvailableCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailableCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"available"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">join</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 AvailableClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AvailableClusterInvoker&lt;&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AvailableClusterInvoker"><a href="#AvailableClusterInvoker" class="headerlink" title="AvailableClusterInvoker"></a>AvailableClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailableClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AvailableClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历整个候选 Invoker 列表</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 使用首个可用的 Invoker 进行调用</span></span><br><span class="line">            <span class="keyword">if</span> (invoker.isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">return</span> invoker.invoke(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到可用的 Invoker，则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"No provider available in "</span> + invokers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZoneAwareCluster-amp-ZoneAwareClusterInvoker"><a href="#ZoneAwareCluster-amp-ZoneAwareClusterInvoker" class="headerlink" title="ZoneAwareCluster &amp; ZoneAwareClusterInvoker"></a>ZoneAwareCluster &amp; ZoneAwareClusterInvoker</h2><p><code>ZoneAwareCluster</code> 用于创建 <code>ZoneAwareClusterInvoker</code> 对象，<code>ZoneAwareClusterInvoker</code> 主要优先支持注册中心层面 Invoker 的选择与调用。</p><h3 id="ZoneAwareCluster"><a href="#ZoneAwareCluster" class="headerlink" title="ZoneAwareCluster"></a>ZoneAwareCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneAwareCluster</span> <span class="keyword">extends</span> <span class="title">AbstractCluster</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"zone-aware"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">AbstractClusterInvoker&lt;T&gt; <span class="title">doJoin</span><span class="params">(Directory&lt;T&gt; directory)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ZoneAwareClusterInvoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareClusterInvoker&lt;T&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ZoneAwareClusterInvoker"><a href="#ZoneAwareClusterInvoker" class="headerlink" title="ZoneAwareClusterInvoker"></a>ZoneAwareClusterInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * When there're more than one registry for subscription.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This extension provides a strategy to decide how to distribute traffics among them:</span></span><br><span class="line"><span class="comment"> * 1. registry marked as 'preferred=true' has the highest priority.</span></span><br><span class="line"><span class="comment"> * 2. check the zone the current request belongs, pick the registry that has the same zone first.</span></span><br><span class="line"><span class="comment"> * 3. Evenly balance traffic between all registries based on each registry's weight.</span></span><br><span class="line"><span class="comment"> * 4. Pick anyone that's available.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneAwareClusterInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractClusterInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ZoneAwareClusterInvoker<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoneAwareClusterInvoker</span><span class="params">(Directory&lt;T&gt; directory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(directory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// -------------- 1 基于注册中心选择 Invoker ---------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.1 优先找到 preferred 属性为 true 的注册中心，它是优先级最高的注册中心，只有该注册中心无可用 Provider 节点时，才会回落到其他注册中心</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// FIXME, the invoker is a cluster invoker representing one Registry, so it will automatically wrapped by MockClusterInvoker.</span></span><br><span class="line">            MockClusterInvoker&lt;T&gt; mockClusterInvoker = (MockClusterInvoker&lt;T&gt;) invoker;</span><br><span class="line">            <span class="keyword">if</span> (mockClusterInvoker.isAvailable() &amp;&amp; mockClusterInvoker.getRegistryUrl()</span><br><span class="line">                    .getParameter(REGISTRY_KEY + <span class="string">"."</span> + PREFERRED_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mockClusterInvoker.invoke(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2 候选的 Invoker 都不在 preferred 属性为 true 的注册中心上，则根据请求中的 zone key 信息，查找该注册中下的 Invoker</span></span><br><span class="line">        String zone = (String) invocation.getAttachment(REGISTRY_ZONE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(zone)) &#123;</span><br><span class="line">            <span class="comment">// 遍历候选的 Invoker 列表</span></span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">                MockClusterInvoker&lt;T&gt; mockClusterInvoker = (MockClusterInvoker&lt;T&gt;) invoker;</span><br><span class="line">                <span class="comment">// 根据请求中的 registry_zone 做匹配，选择相同 zone 的注册中心下的 Invoker</span></span><br><span class="line">                <span class="keyword">if</span> (mockClusterInvoker.isAvailable() &amp;&amp; zone.equals(mockClusterInvoker.getRegistryUrl().getParameter(REGISTRY_KEY + <span class="string">"."</span> + ZONE_KEY))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mockClusterInvoker.invoke(invocation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否强制匹配</span></span><br><span class="line">            String force = (String) invocation.getAttachment(REGISTRY_ZONE_FORCE);</span><br><span class="line">            <span class="comment">// 如果强制匹配，只匹配和请求中具有相同 zone 的注册中心下提供者，如果没有匹配到，则抛出异常。如果不是强制匹配，则使用负载均衡选择 Invoker</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(force) &amp;&amp; <span class="string">"true"</span>.equalsIgnoreCase(force)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No registry instance in zone or no available providers in the registry, zone: "</span></span><br><span class="line">                        + zone</span><br><span class="line">                        + <span class="string">", registries: "</span> + invokers.stream().map(invoker -&gt; ((MockClusterInvoker&lt;T&gt;) invoker).getRegistryUrl().toString()).collect(Collectors.joining(<span class="string">","</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------------------ 2 根据负载均衡选择 Invoker  ------------------/</span></span><br><span class="line">        Invoker&lt;T&gt; balancedInvoker = select(loadbalance, invocation, invokers, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (balancedInvoker.isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">return</span> balancedInvoker.invoke(invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ------------------ 3 以上两种都没有选中 Invoker ，则从候选 Invoker 列表中选择一个可用的即可 --------------/</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            MockClusterInvoker&lt;T&gt; mockClusterInvoker = (MockClusterInvoker&lt;T&gt;) invoker;</span><br><span class="line">            <span class="keyword">if</span> (mockClusterInvoker.isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">return</span> mockClusterInvoker.invoke(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"No provider available in "</span> + invokers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Dubbo 中使用多个注册中心的情况，服务消费端可以使用 <code>ZoneAwareClusterInvoker</code> 先在多个注册中心之间选择，确定注册中心之后，再选择服务提供者节点。</p><p><code>ZoneAwareClusterInvoker</code> 选择目标 Invoker 的流程如下：</p><ol><li>优先找到 <code>preferred</code> 属性为 true 的注册中心下的 Invoker，只有该中心无可用 Invoker 时，才会去匹配其他注册中心下的 Invoker 。</li><li>根据请求中的 <code>zone</code> 信息（注册中心信息）做匹配，如果候选 Invoker 中有匹配到该注册中心信息，则选中对应的 Invoker 。</li><li>无法根据注册中心信息匹配到目标 Invoker，则使用负载均衡选出目标 Invoker 。</li><li>如果以上流程都没有选择出 Invoker，则从候选 Invoker 列表中选出第一个可用的 Invoker 。</li></ol><p>注意，前文中介绍的 <code>ZoneAwareClusterInterceptor</code> 会在前置处理方法中设置 <code>registry_zone</code> 参数和 <code>registry_zone_force</code> 参数到调用信息 Invocation 中，</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章详细分析了 Dubbo 集群容错的几种实现方式。集群模块处于服务提供者和消费者之间，对于服务消费者来说，集群可向其屏蔽服务提供者集群的情况，使其能够专心进行远程调用。需要说明是，集群模块还包括 <code>Merger</code> 策略以及 <code>Mock</code> 机制，相比本篇文章介绍的几种常见集群策略，它们具有特定地功能机制，在后面的两篇文章中将会详细介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面的几篇文章分别对服务目录 &lt;code&gt;Directory&lt;/code&gt;、路由 &lt;code&gt;Router&lt;/code&gt;、负载均衡 &lt;cod
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>集群容错 - LoadBalance</title>
    <link href="https://gentryhuang.com/posts/9966fbd5/"/>
    <id>https://gentryhuang.com/posts/9966fbd5/</id>
    <published>2020-09-30T23:00:00.000Z</published>
    <updated>2021-04-06T08:33:39.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 中的负载均衡 <code>LoadBalance</code> 的职责是将网络请求或者其它形式的负载 <code>&quot;均摊&quot;</code> 到不同的服务节点上，从而避免服务集群中部分节点压力过大，而另一部分节点比较空闲的情况。通过合理的负载均衡，可以让每个服务节点获取到适合自己处理能力的负载，实现处理能力和流量的合理分配。常用的负载均衡可分为<strong>软件负载均衡</strong>和<strong>硬件负载均衡</strong>，在日常开发中一般很难接触到硬件负载均衡，主要有 F5、NetScaler 等；软件负载均衡还是很常见的，比如 Nginx 。常见的 RPC 框架都有负载均衡的概念和相应的实现，Dubbo 也不例外。Dubbo 需要对服务消费者的调用请求进行分配，避免少数提供者节点负载过大，而其它提供者节点处于空闲状态。服务提供者负载过大，会导致部分请求超时、甚至丢失等一系列问题，造成线上故障。因此将负载均衡到每个服务提供者是非常有必要的。</p><h1 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h1><p>在集群负载均衡时，Dubbo 提供了 5 种均衡策略，缺省为 <code>random</code> 随机调用。</p><ul><li>基于加权随机算法的 <strong>RandomLoadBalance</strong></li><li>基于加权轮询算法的 <strong>RoundRobinLoadBalance</strong></li><li>基于最少活跃调用数算法的 <strong>LeastActiveLoadBalance</strong></li><li>基于一致性 Hash 的 <strong>ConsistentHashLoadBalance</strong></li><li>基于最短响应时间的 <strong>ShortestResponseLoadBalance</strong></li></ul><p>继承关系图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-loadbalance-relation.jpg" alt></p><p>其中基于最短响应时间的 <code>ShortestResponseLoadBalance</code> 负载均衡策略是 Dubbo 2.7.x 新增的，和基于最少活跃调用数算法类似。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li>服务端服务级别<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"roundrobin"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li>客户端服务级别<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"roundrobin"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li>服务端方法级别<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"roundrobin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:service</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>客户端方法级别<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:method</span> <span class="attr">name</span>=<span class="string">"..."</span> <span class="attr">loadbalance</span>=<span class="string">"roundrobin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="LoadBalance"><a href="#LoadBalance" class="headerlink" title="LoadBalance"></a>LoadBalance</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(RandomLoadBalance.NAME)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的 URL 和 Invocation ，以及负载均衡算法从 Invoker 集合中选择一个 Invoker</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers   invokers.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url        refer url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation invocation.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> selected invoker.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(<span class="string">"loadbalance"</span>)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LoadBalance</code> 是一个扩展接口，默认扩展实现是 <code>RandomLoadBalance</code> ，Dubbo 根据 <code>@Adaptive(&quot;loadbalance&quot;)</code> 注解生成的适配器会按照 URL 中的 <code>loadbalance</code> 参数值选择扩展实现类。</p><h2 id="AbstractLoadBalance"><a href="#AbstractLoadBalance" class="headerlink" title="AbstractLoadBalance"></a>AbstractLoadBalance</h2><h3 id="选择-Invoker"><a href="#选择-Invoker" class="headerlink" title="选择 Invoker"></a>选择 Invoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractLoadBalance</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers   invokers.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url        refer url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation invocation.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 Invoker集合为空，直接返回null</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 Invoker集合只包含一个Invoker，则直接返回该Invoker对象</span></span><br><span class="line">        <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3 Invoker集合包含多个Invoker对象时，交给doSelect()方法处理，这是个抽象方法，留给子类具体实现</span></span><br><span class="line">        <span class="keyword">return</span> doSelect(invokers, url, invocation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AbstractLoadBalance</code> 抽象类并没有真正实现 <code>select()</code> 方法，仅是对 Invoker 集合为空或是只包含一个 Invoker 对象的情况进行了处理，其它情况的选择逻辑交给子类实现。</p><h3 id="服务提供者权重计算"><a href="#服务提供者权重计算" class="headerlink" title="服务提供者权重计算"></a>服务提供者权重计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractLoadBalance</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line">        URL url = invoker.getUrl();</span><br><span class="line">        <span class="comment">// 1 多注册中心场景，多注册中心负载均衡。</span></span><br><span class="line">        <span class="keyword">if</span> (REGISTRY_SERVICE_REFERENCE_PATH.equals(url.getServiceInterface())) &#123;</span><br><span class="line">            <span class="comment">// 1.1 如果是RegistryService接口的话，直接根据配置项 registry.weight 获取权重即可，默认是 100</span></span><br><span class="line">            weight = url.getParameter(REGISTRY_KEY + <span class="string">"."</span> + WEIGHT_KEY, DEFAULT_WEIGHT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 非多注册中心场景</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1 从 url 中获取 weight 配置值，默认为 100</span></span><br><span class="line">            weight = url.getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);</span><br><span class="line">            <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 2.2 获取服务提供者的启动时间戳</span></span><br><span class="line">                <span class="keyword">long</span> timestamp = invoker.getUrl().getParameter(TIMESTAMP_KEY, <span class="number">0L</span>);</span><br><span class="line">                <span class="keyword">if</span> (timestamp &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                    <span class="comment">// 2.3 计算Provider运行时长</span></span><br><span class="line">                    <span class="keyword">long</span> uptime = System.currentTimeMillis() - timestamp;</span><br><span class="line">                    <span class="keyword">if</span> (uptime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 2.4 从 url 中获取 Provider 预热时间配置值，默认为10分钟</span></span><br><span class="line">                    <span class="keyword">int</span> warmup = invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 2.5 如果Provider运行时间小于预热时间，则该Provider节点可能还在预热阶段，需要降低其权重</span></span><br><span class="line">                    <span class="keyword">if</span> (uptime &gt; <span class="number">0</span> &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class="line">                        weight = calculateWarmupWeight((<span class="keyword">int</span>) uptime, warmup, weight);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3 防御性编程，权重不能为负数</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(weight, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在获取服务提供者权重时，需要考虑当前服务提供者是否还在预热阶段（运行时间小于预热时间），如果还在预热阶段需要对其进行降权处理，目的是避免服务提供者一启动就有大量请求涌来，处于高负载状态。服务预热是一个优化手段，一般在服务启动后，让其在小流量状态下运行一段时间，然后再逐步放大流量。</p><p>权重计算是在 <code>calculateWarmupWeight</code> 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractLoadBalance</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对还在预热状态的 Provider 节点进行降权，避免 Provider 一启动就有大量请求涌进来。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uptime the uptime in milliseconds 服务运行时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> warmup the warmup time in milliseconds 预热时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight the weight of an invoker 配置的服务权重</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> weight which takes warmup into account 计算的服务权重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateWarmupWeight</span><span class="params">(<span class="keyword">int</span> uptime, <span class="keyword">int</span> warmup, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 计算权重，简化为： (uptime/warmup) * weight。</span></span><br><span class="line">        <span class="comment">// 随着服务运行时间 uptime 增大，权重计算值 ww 会慢慢接近配置值 weight</span></span><br><span class="line">        <span class="keyword">int</span> ww = (<span class="keyword">int</span>) (uptime / ((<span class="keyword">float</span>) warmup / weight));</span><br><span class="line">        <span class="comment">// 权重范围为 [0,weight] 之间</span></span><br><span class="line">        <span class="keyword">return</span> ww &lt; <span class="number">1</span> ? <span class="number">1</span> : (Math.min(ww, weight));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>calculateWarmupWeight()</code> 方法用于计算还处于预热状态的 Provider 节点的权重，随着服务运行时间增大，权重计算值会慢慢接近配置的权重值。</p><p>负载均衡的抽象实现主要是对消费端 Invoker 集合为空或仅有一个的情况下直接处理，无需子类进行选择。此外还对消费端 Invoker 权重的获取做了统一实现。了解了负载均衡抽象实现后，下面我们对负载均衡的具体实现进行分析。</p><h2 id="RandomLoadBalance"><a href="#RandomLoadBalance" class="headerlink" title="RandomLoadBalance"></a>RandomLoadBalance</h2><p><code>RandomLoadBalance</code> 是<code>加权随机算法</code>的具体实现，它是一个简单、高效的负载均衡实现，也是 Dubbo 默认使用的负载均衡策略。其核心就是加权随机算法，下面我们简单对该算法进行说明。</p><p>假设有 3 个服务节点，分别为节点 A、节点 B、节点 C，它们对应的权重依次为 5、2、3，权重总和为 10。现在把这些权重值放到一维坐标上，<code>[0,5)</code>区间属于节点A，<code>[5,7)</code>区间属于节点B，<code>[7,10)</code>区间属于节点C，具体分布如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-loadbalance-random.jpg" alt></p><p>接下来通过随机数生成器在 <code>[0,10)</code> 这个范围内生成一个随机数，然后计算这个随机数会落到哪个区间上。比如，随机生成数字 3 ，就会落到 <code>Provider A</code> 对应的区间上，此时 <code>RandomLoadBalance</code> 就会返回 <code>Provider A</code> 这个节点。权重越大的节点，在坐标轴上对应的区间范围就越大，因此随机数生成器生成的数字就会有更大的概率落到此区间内。只要随机数生成器产生的随机数分布性很好，在经过多次选择后，每个服务节点被选中的次数比例接近其权重比例。比如，经过一万次选择后，服务器 A 被选中的次数大约为 5000 次，服务器 B 被选中的次数约为 3000 次，服务器 C 被选中的次数约为 2000 次。</p><p>了解了加权随机算法后，我们开始对 <code>RandomLoadBalance</code> 源码进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"random"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Select one invoker between a list using a random criteria</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers   List of possible invokers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url        URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation Invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The selected invoker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">        <span class="comment">// 每个 Invoker 权重是否相同的标志</span></span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 计算每个 Invoker 对象对应的权重，并填充到 weights 数组中</span></span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算第一个 Invoker 权重</span></span><br><span class="line">        <span class="keyword">int</span> firstWeight = getWeight(invokers.get(<span class="number">0</span>), invocation);</span><br><span class="line">        weights[<span class="number">0</span>] = firstWeight;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录权重总和</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = firstWeight;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算第 i 个 Invoker 的权重</span></span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class="line">            weights[i] = weight;</span><br><span class="line">            <span class="comment">// 累加总权重</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测是否有不同权重的 Invoker</span></span><br><span class="line">            <span class="keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) &#123;</span><br><span class="line">                sameWeight = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总权重 &gt; 0 &amp;&amp; 并非所有 Invoker 权重都相同</span></span><br><span class="line">        <span class="comment">// 计算随机数落在哪个区间</span></span><br><span class="line">        <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            <span class="comment">// 随机获取一个 [0,totalWeight) 区间内的随机数</span></span><br><span class="line">            <span class="keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环让随机数数减去Invoker的权重值，当随机数小于0时，返回相应的Invoker</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                offset -= weights[i];</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果所有的 Invoker 权重相同 或 权重总权重为 0，则均等随机</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RandomLoadBalance</code> 中 <code>doSelect()</code> 方法的实现，主要有以下 3 个关键点：</p><ol><li>通过 <code>AbstractLoadBalance.getWeight</code> 方法计算每个 Invoker 的权重值</li><li>汇总 Invoker 的总权重值</li><li>当每个 Invoker 权重不同时，使用加权随机算法选出对应的 Invoker 对象。</li><li>当所有 Invoker 权重相同时，随机返回一个 Invoker 即可。</li></ol><p>总体上加权随机负载均衡策略还是比较简单的，同时它也是其它负载均衡算法的基础，如最小活跃调用数负载均衡和最短响应时间负载均衡在具有多个相同条件的 Invoker 时，最后会通过该算法进一步选择目标 Invoker 。</p><h2 id="RoundRobinLoadBalance"><a href="#RoundRobinLoadBalance" class="headerlink" title="RoundRobinLoadBalance"></a>RoundRobinLoadBalance</h2><p><code>RoundRobinLoadBalance</code> 是<code>加权轮询算法</code>的具体实现。<code>轮询</code>指的是将请求轮流分配给每个服务节点，例如，有 A、B、C 三个服务节点，按照普通轮询的方式，会将第一个请求分配给 A 节点，将第二个请求分配给 B 节点，第三个请求分配给 C 节点，第四个请求分配给 A 节点……如此循环往复。轮询是一种无状态负载均衡算法，实现简单，适用于每台服务器性能相近的场景。但现实情况下，我们并不能保证每台服务器性能均相近。如果我们将等量的请求分配给性能较差的服务器，这显然是不合理的。因此，这个时候我们需要对轮询过程进行加权，以调控每台服务器的负载。经过加权后，每台服务器能够得到的请求数比例，接近或等于他们的权重比。比如服务节点 A、B、C 权重比为 5:2:1。那么在8次请求中，服务器 A 将收到其中的5次请求，服务器 B 会收到其中的2次请求，服务器 C 则收到其中的1次请求。</p><p><code>RoundRobinLoadBalance</code> 参考自 Nginx 的平滑加权轮询负载均衡。每个服务节点有两个权重，分别为 <code>weight</code> 和 <code>current</code> ，其中 <code>weight</code> 是通过父类的 <code>getWeight</code> 方法计算出来的值，虽然在预热过程是变化的，但这里可以认为是固定的；<code>current</code> 是动态的，初始值为 0 ，每次有新的请求进来时，遍历 Invoker 列表，并用对应的 <code>current</code> 加上 <code>weight</code> 。遍历完成后，找到具有最大 <code>current</code> 的 Invoker 和对应的 <code>WeightedRoundRobin</code> 。<strong>在返回选中的 Invoker 之前，将其对应的 <code>WeightedRoundRobin</code> 中的当前权重值 <code>current</code> 减去本次请求累加的总权重值，从而实现平滑负载均衡。</strong></p><h3 id="加权轮询算法"><a href="#加权轮询算法" class="headerlink" title="加权轮询算法"></a>加权轮询算法</h3><p>下面举例对 <code>RoundRobinLoadBalance</code> 的执行流程进行说明。假设有 3 个服务节点，分别为节点 A、节点 B、节点 C，对应的权重依次为：5、1、1 ，选择过程如下：</p><table><thead><tr><th align="left">请求编号</th><th>当前权重(current)数组</th><th>选择结果</th><th>减去权重总和后的当前权重(current)数组</th></tr></thead><tbody><tr><td align="left">1</td><td>[5, 1, 1]</td><td>A</td><td>[-2, 1, 1]</td></tr><tr><td align="left">2</td><td>[3, 2, 2]</td><td>A</td><td>[-4, 2, 2]</td></tr><tr><td align="left">3</td><td>[1, 3, 3]</td><td>B</td><td>[1, -4, 3]</td></tr><tr><td align="left">4</td><td>[6, -3, 4]</td><td>A</td><td>[-1, -3, 4]</td></tr><tr><td align="left">5</td><td>[4, -2, 5]</td><td>C</td><td>[4, -2, -2]</td></tr><tr><td align="left">6</td><td>[9, -1, -1]</td><td>A</td><td>[2, -1, -1]</td></tr><tr><td align="left">7</td><td>[7, 0, 0]</td><td>A</td><td>[0, 0, 0]</td></tr></tbody></table><p><strong>下面对以上每次请求数据变更进行说明，该过程就是加权轮询算法的实现：</strong></p><blockquote><ol><li>处理第一个请求，每个 Invoker 相关的 currentWeigh 与配置的 weight 相加，即从 [0, 0, 0] 变为 [5, 1, 1]。接下来，从中选择权重最大的 Invoker 作为结果，即节点 A。最后，将节点 A 的 currentWeight 值减去 totalWeight 值，最终得到 currentWeight 数组为 [-2, 1, 1]。</li></ol></blockquote><blockquote><ol start="2"><li>处理第二个请求，每个 Invoker 相关的 currentWeigh 与配置的 weight 相加，即从 [-2, 1, 1] 变为 [3, 2, 2]。接下来，从中选择权重最大的 Invoker 作为结果，即节点 A。最后，将节点 A 的 currentWeight 值减去 totalWeight 值，最终得到 currentWeight 数组为 [-4, 2, 2]。</li></ol></blockquote><blockquote><ol start="3"><li>处理第三个请求，每个 Invoker 相关的 currentWeigh 与配置的 weight 相加，即从 [-4, 2, 2] 变为 [1, 3, 3]。接下来，从中选择权重最大的 Invoker 作为结果，即节点 B。最后，将节点 B 的 currentWeight 值减去 totalWeight 值，最终得到 currentWeight 数组为 [1, -4, 3]。</li></ol></blockquote><blockquote><ol start="4"><li>处理第四个请求，每个 Invoker 相关的 currentWeigh 与配置的 weight 相加，即从 [1, -4, 3] 变为 [6, -3, 4]。接下来，从中选择权重最大的 Invoker 作为结果，即节点 A。最后，将节点 A 的 currentWeight 值减去 totalWeight 值，最终得到 currentWeight 数组为 [-1, -3, 4]。</li></ol></blockquote><blockquote><ol start="5"><li>处理第五个请求，每个 Invoker 相关的 currentWeigh 与配置的 weight 相加，即从 [-1, -3, 4] 变为 [4, -2, 5]。接下来，从中选择权重最大的 Invoker 作为结果，即节点 C。最后，将节点 C 的 currentWeight 值减去 totalWeight 值，最终得到 currentWeight 数组为 [4, -2, -2]。</li></ol></blockquote><blockquote><ol start="6"><li>处理第六个请求，每个 Invoker 相关的 currentWeigh 与配置的 weight 相加，即从 [4, -2, -2] 变为 [9, -1, -1]。接下来，从中选择权重最大的 Invoker 作为结果，即节点 A。最后，将节点 A 的 currentWeight 值减去 totalWeight 值，最终得到 currentWeight 数组为 [2, -1, -1]。</li></ol></blockquote><blockquote><ol start="7"><li>处理第七个请求，每个 Invoker 相关的 currentWeigh 与配置的 weight 相加，即从 [2, -1, -1] 变为 [7, 0, 0]。接下来，从中选择权重最大的 Invoker 作为结果，即节点 A。最后，将节点 A 的 currentWeight 值减去 totalWeight 值，最终得到 currentWeight 数组为 [0, 0, 0]。</li></ol></blockquote><p>以上就是一个轮询的周期。了解了加权轮询的计算过程后，下面我们就对 <code>RoundRobinLoadBalance</code> 源码实现进行分析。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">+--- RoundRobinLoadBalance</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"roundrobin"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 长时间未更新的阈值 60 s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECYCLE_PERIOD = <span class="number">60000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个 Invoker 对应的对象，加权轮流调度器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedRoundRobin</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 服务提供者配置权重，在负载均衡过程不会变化(忽略启动预热)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 服务提供者当前权重，在负载均衡过程会动态调整，初始值为 0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> AtomicLong current = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 最后更新时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> lastUpdate;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">            current.set(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoker当前权重 + 配置的权重</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">increaseCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> current.addAndGet(weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Invoker当前权重 - 总权重</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sel</span><span class="params">(<span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">            current.addAndGet(-<span class="number">1</span> * total);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastUpdate</span><span class="params">(<span class="keyword">long</span> lastUpdate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lastUpdate = lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务方法与 WeightedRoundRobin 的映射关系</span></span><br><span class="line"><span class="comment">     * key1: 服务键 + 方法名 -&gt; 完整方法名</span></span><br><span class="line"><span class="comment">     * key2: URL串</span></span><br><span class="line"><span class="comment">     * value: WeightedRoundRobin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt; methodWeightMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RoundRobinLoadBalance</code> 中有 3 个核心属性，下面我们对其进行介绍。</p><ul><li><strong>RECYCLE_PERIOD</strong> <blockquote><p>用于监控 Invoker 对应的 WeightedRoundRobin 的更新频率。由于 Invoker 对应的服务可能会宕机，如果宕机就必须将其对应的 <code>WeightedRoundRobin</code> 缓存清除，RECYCLE_PERIOD 属性就是用来监控长时间未更新的 <code>WeightedRoundRobin</code>。</p></blockquote></li><li><strong>WeightedRoundRobin</strong><blockquote><p>作为 <code>RoundRobinLoadBalance</code> 的内部类，在 <code>RoundRobinLoadBalance</code> 中会为每个 Invoker 对象都创建一个对应的 <code>WeightedRoundRobin</code> 对象，用来记录配置的权重（weight字段）以及随每次负载均衡算法执行变化的当前权重（current字段）。</p></blockquote></li><li><strong>methodWeightMap</strong><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># key1: 完整方法名</span><br><span class="line"># key2: URL串</span><br><span class="line"># value: WeightedRoundRobin</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="attr">"...UserService.query"</span>:&#123;</span><br><span class="line">         <span class="attr">"url1"</span>: WeightedRoundRobin@<span class="number">123</span>,</span><br><span class="line">         <span class="attr">"url2"</span>: WeightedRoundRobin@<span class="number">456</span></span><br><span class="line">      &#125;,</span><br><span class="line">    <span class="attr">"...UserService.update"</span>:&#123;</span><br><span class="line">         <span class="attr">"url1"</span>: WeightedRoundRobin@<span class="number">111</span>,</span><br><span class="line">         <span class="attr">"url2"</span>: WeightedRoundRobin@<span class="number">222</span></span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>会基于每个方法创建一个 <code>WeightedRoundRobin</code> 映射关系。</li></ul><h3 id="选择目标-Invoker"><a href="#选择目标-Invoker" class="headerlink" title="选择目标 Invoker"></a>选择目标 Invoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">+--- RoundRobinLoadBalance</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取请求的完整方法名</span></span><br><span class="line">        String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">"."</span> + invocation.getMethodName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取整个Invoker列表对应的 WeightedRoundRobin 映射表，如果为空，则创建一个新的WeightedRoundRobin映射表</span></span><br><span class="line">        ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 总权重</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录 Invoker 列表中最大权重</span></span><br><span class="line">        <span class="keyword">long</span> maxCurrent = Long.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 选中的 Invoker</span></span><br><span class="line">        Invoker&lt;T&gt; selectedInvoker = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 选中的 Invoker 对应的 WeightedRoundRobin</span></span><br><span class="line">        WeightedRoundRobin selectedWRR = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 遍历 Invoker 列表，选出具有最大 current 的 Invoker</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 获取 Invoker 对应的URL串</span></span><br><span class="line">            String identifyString = invoker.getUrl().toIdentityString();</span><br><span class="line">            <span class="comment">// 获取当前 Invoker 权重</span></span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(invoker, invocation);</span><br><span class="line">            <span class="comment">// 检测当前 Invoker 是否有相应的 WeightedRoundRobin ，没有则创建</span></span><br><span class="line">            WeightedRoundRobin weightedRoundRobin = map.computeIfAbsent(identifyString, k -&gt; &#123;</span><br><span class="line">                WeightedRoundRobin wrr = <span class="keyword">new</span> WeightedRoundRobin();</span><br><span class="line">                <span class="comment">// 设置权重和初始化当前权重值为0</span></span><br><span class="line">                wrr.setWeight(weight);</span><br><span class="line">                <span class="keyword">return</span> wrr;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测 Invoker 权重是否发生了变化，若变化了则更新相应 WeightedRoundRobin 中的 weight 值</span></span><br><span class="line">            <span class="keyword">if</span> (weight != weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">                <span class="comment">//weight changed</span></span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.1 让 current 加上配置的 weight 🌟</span></span><br><span class="line">            <span class="keyword">long</span> cur = weightedRoundRobin.increaseCurrent();</span><br><span class="line">            <span class="comment">// 3.2 更新 lastUpdate 字段</span></span><br><span class="line">            weightedRoundRobin.setLastUpdate(now);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.3 寻找具有最大 current 的 Invoker，以及Invoker对应的 WeightedRoundRobin ，暂存起来留作后用</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt; maxCurrent) &#123;</span><br><span class="line">                maxCurrent = cur;</span><br><span class="line">                selectedInvoker = invoker;</span><br><span class="line">                selectedWRR = weightedRoundRobin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.4 计算权重总和</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 Invoker 集合数不等于缓存数，说明存在 Invoker 挂了的可能，此时应该清除无效缓存</span></span><br><span class="line">        <span class="keyword">if</span> (invokers.size() != map.size()) &#123;</span><br><span class="line">            <span class="comment">// 清除掉长时间未被更新的节点</span></span><br><span class="line">            map.entrySet().removeIf(item -&gt; now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 更新选中的 Invoker 对应的 WeightedRoundRobin 中维护的 current 的值，然后返回选中的 Invoker 🌟</span></span><br><span class="line">        <span class="keyword">if</span> (selectedInvoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用 current 减去 totalWeight</span></span><br><span class="line">            selectedWRR.sel(totalWeight);</span><br><span class="line">            <span class="comment">// 返回选中的Invoker对象</span></span><br><span class="line">            <span class="keyword">return</span> selectedInvoker;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// should not happen here</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>RoundRobinLoadBalance</code> 中的 <code>doSelect</code> 就是对上面加权轮询计算过程的实现，理解了加权轮询算法就理解了 <code>RoundRobinLoadBalance</code> 负载均衡策略。</p><h2 id="LeastActiveLoadBalance"><a href="#LeastActiveLoadBalance" class="headerlink" title="LeastActiveLoadBalance"></a>LeastActiveLoadBalance</h2><p><code>LeastActiveLoadBalance</code> 使用的是 <code>最小活跃数负载均衡算法</code>。活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求，此时应优先将请求分配给该服务提供者。在具体实现中，每个服务提供者都对应一个活跃数 <code>active</code> ，初始情况下所有服务提供者活跃数均为 0 ，每收到一个请求，活跃数加 1 ，完成请求后则将活跃数减 1 。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求。以上就是最小活跃数负载均衡算法的基本思想。</p><p>除了最小活跃数，<code>LeastActiveLoadBalance</code> 在实现上还引入了权重，所以准确地说该负载均衡策略是基于<strong>加权最小活跃数算法</strong>实现的。<code>LeastActiveLoadBalance</code> 需要配合 <code>ActiveLimitFilter</code>使用，ActiveLimitFilter 是 Dubbo 在消费端的限流实现，会记录消费者对一个服务端方法的并发调用量，在进行负载均衡时，只会从活跃调用数最小的 Invoker 集合中挑选 Invoker ，当有多个最小活跃调用数的Invoker时，会在最小活跃调用数基础增加加权随机策略。下面我们对源码进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeastActiveLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展点名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"leastactive"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ---------------------- 1 🌟 关键属性 ------------------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoker 数量</span></span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录最小的活跃调用数</span></span><br><span class="line">        <span class="keyword">int</span> leastActive = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录具有相同最小活跃调用数（leastActive 的值）的 Invoker 数量</span></span><br><span class="line">        <span class="keyword">int</span> leastCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录具有相同最小活跃调用数（leastActive 的值）的 Invoker 在 Invoker 列表中的下标位置。</span></span><br><span class="line">        <span class="comment">// leastIndexes 数组中如果有多个值，则说明有两个及以上的 Invoker 具有相同的最小活跃数（leastActive 的值）</span></span><br><span class="line">        <span class="keyword">int</span>[] leastIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个 Invoker 的权重值</span></span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录最小活跃调用数所有 Invoker 的权重值之和</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录最小活跃请求数 Invoker 集合中第一个 Invoker 的权重值</span></span><br><span class="line">        <span class="keyword">int</span> firstWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记是否具有相同权重的最小活跃数 Invoker</span></span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---------------------- 2 🌟 操作关键属性 ------------------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有Invoker，选出最小活跃调用数的Invoker集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取该 Invoker 的活跃调用数 （使用到了消费方限流策略：ActiveLimitFilter）</span></span><br><span class="line">            <span class="keyword">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录该 Invoker 的权重</span></span><br><span class="line">            <span class="keyword">int</span> afterWarmup = getWeight(invoker, invocation);</span><br><span class="line">            weights[i] = afterWarmup;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比较活跃调用数，发现更小的活跃调用数则更新相关属性。这样情况只有一个 Invoker</span></span><br><span class="line">            <span class="comment">// 这个是必须要的，因为要的就是最小活跃调用数，具有相同的最小活跃调用数只是一种复杂情况，需要根据权重再处理</span></span><br><span class="line">            <span class="keyword">if</span> (leastActive == -<span class="number">1</span> || active &lt; leastActive) &#123;</span><br><span class="line">                <span class="comment">// 重新记录最小的活跃调用数</span></span><br><span class="line">                leastActive = active;</span><br><span class="line">                <span class="comment">// 重新记录最小活跃调用数的 Invoker 个数</span></span><br><span class="line">                leastCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重新记录最小活跃调用数的 Invoker 在 Invoker 列表中的下标</span></span><br><span class="line">                leastIndexes[<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重置总权重</span></span><br><span class="line">                totalWeight = afterWarmup;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录第一个最小活跃调用数 Invoker 的权重</span></span><br><span class="line">                firstWeight = afterWarmup;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Each invoke has the same weight (only one invoker here)</span></span><br><span class="line">                <span class="comment">// 重置权重相同标识</span></span><br><span class="line">                sameWeight = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果当前 Invoker 的活跃调用数等于最小活跃调用数，这样情况下已经存在最小活跃调用数的 Invoker</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (active == leastActive) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录当前 Invoker 在 Invoker 列表中的下标</span></span><br><span class="line">                leastIndexes[leastCount++] = i;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 累加总权重，针对的是具有相同的最小活跃数</span></span><br><span class="line">                totalWeight += afterWarmup;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否存在相同权重的最小活跃调用数的 Invoker</span></span><br><span class="line">                <span class="comment">// 即检测当前 Invoker 的权重与firstWeight是否相等，不相等则将 sameWeight 设置为 false</span></span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; afterWarmup != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---------------------- 3 🌟 选择 Invoker ------------------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.1 如果只有一个最小活跃调用数的 Invoker ，直接取出即可</span></span><br><span class="line">        <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 从 Invoker 列表中取出最小活跃数的 Invoker</span></span><br><span class="line">            <span class="keyword">return</span> invokers.get(leastIndexes[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2 存在多个具有最小活跃数的 Invoker ，但它们的权重不相同且总权重 &gt; 0 ，则使用加权随机算法。</span></span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If (not every invoker has the same weight &amp; at least one invoker's weight&gt;0), select randomly based on </span></span><br><span class="line">            <span class="comment">// totalWeight.</span></span><br><span class="line">            <span class="keyword">int</span> offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// Return a invoker based on the random value.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> leastIndex = leastIndexes[i];</span><br><span class="line">                offsetWeight -= weights[leastIndex];</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(leastIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.3 存在多个 Invoker 具有相同的最小活跃数，但它们的权重相等或总权重为0，则使用随机均等</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LeastActiveLoadBalance</code> 核心思想是选择<strong>最小活跃调用数</strong>的服务提供者，如果最小活跃调用数的服务提供者有多个，则使用<strong>加权随机</strong>算法进行选择。核心思想理解起来很容易，但是实现上显得有点复杂，体现在定义了很多的属性上，下面对整个逻辑进行简单梳理。</p><ol><li>遍历 Invoker 列表，寻找活跃调用数最小的 Invoker，</li><li>如果存在多个 Invoker 具有相同的最小活跃调用数，此时需要记录下这些 Invoker 在 Invoker 集合中的下标，并累加它们的权重，且比较它们的权重值是否相等。</li><li>如果只有一个 Invoker 具有最小活跃数，此时直接返回该 Invoker 即可。</li><li>如果存在多个 Invoker 具有最小活跃数，且它们的权重不相等，此时处理方式和加权随机 <code>RandomLoadBalance</code> 一致。</li><li>如果存在多个 Invoker 具有最小活跃数，但它们的权重都相等，此时随机返回一个即可。</li></ol><h2 id="ConsistentHashLoadBalance"><a href="#ConsistentHashLoadBalance" class="headerlink" title="ConsistentHashLoadBalance"></a>ConsistentHashLoadBalance</h2><p><code>ConsistentHashLoadBalance</code> 负载均衡策略使用的是 <code>一致性 Hash</code> 来实现的。在分析具体源码之前，我们现对相关概念进行介绍。</p><p>一致性 Hash 算法提出之初是<strong>用于大规模缓存系统的负载均衡</strong>，它的工作过程是这样的，首先根据缓存节点地址或其它信息为缓存节点生成一个 <code>hash</code> 值，并将这个 <code>hash</code> 值投射到 <code>[0, 2^32 - 1]</code> 的圆环上（Hash环），也就是对 <code>2^32</code> 取模 。当有读写请求时，则为缓存项 <code>key</code> 生成一个 <code>hash</code> 值，然后到 Hash 环上查找第一个大于或等于该 <code>hash</code> 值的缓存节点，最后就可以在找到的缓存节点上进行读写操作了。如果当前缓存节点挂了，则在下一次读写请求时查找其它大于或等于本次请求的 <code>hash</code> 值的缓存节点即可。大致的 Hash 环如下图所示，每个缓存节点在圆环上映射一个位置。如果缓存项 <code>key</code> 的 <code>hash</code> 小于或等于缓存节点对应的 <code>hash</code> 值，则到该缓存节点中进行读写操作。如下面绿色点对应的缓存项将会被存储到 <code>cahce-2</code> 节点中。由于 <code>cache-3</code> 挂了，原本应该存到该节点中的缓存项最终会存储到 <code>cache-4</code> 节点上。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-cache-consistent-hash.jpeg" alt></p><p>一致性 Hash 在 Dubbo 中的应用就是将缓存节点替换成 Dubbo 的服务提供者节点。理想情况下，一致性 Hash 算法会将 Dubbo 的服务提供者节点均匀地分布到 Hash 环上，请求也可以均匀地分发给 Dubbo 的服务提供者节点。但在实际情况中，提供者节点地址取模后的值可能在 Hash 环上分布不均匀，如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-dubbo-consistent-hash.jpeg" alt></p><p>由于 <code>Invoker-1</code> 和 <code>Invoker-2</code> 在圆环上分布不均匀，导致系统中大部分请求都会落到 <code>Invoker-1</code> 上，只有少部分请求会落到 <code>Invoker-2</code> 上，这就出现了数据倾斜的问题。所谓数据倾斜是指由于节点不够分散，导致大量请求落到了同一个节点上，而其他节点只会接收到少量请求的情况。为了解决一致性 Hash 算法中出现的数据倾斜问题，引入了虚拟节点的概念。解决思路是：既然 Dubbo 服务提供者节点在 Hash 环上分布不均匀，那么可以虚拟出 N 组 Invoker-1，Invoker-2，…，Invoker-N 的提供者节点，让多组提供者节点相对均匀分布在 Hash 环上。如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-dubbo-consistent-hash-virtual.jpeg" alt></p><p>上图中相同颜色的节点属于同一个服务提供者，如 Invoker1-1、Invoker1-2、….、Invoker1-160 表示的都是 Invoker1 这个服务节点，这样做的目的是通过引入虚拟节点，让 Invoker 在圆环上分散开来，避免数据倾斜问题。上图中有三个组。</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"consistenthash"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 虚拟节点数配置项，默认值为 160</span></span><br><span class="line"><span class="comment">     * 格式：&lt;dubbo:parameter key="hash.nodes" value="320" /&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HASH_NODES = <span class="string">"hash.nodes"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参与Hash计算的参数索引，默认只对第一个参数Hash</span></span><br><span class="line"><span class="comment">     * 格式：&lt;dubbo:parameter key="hash.arguments" value="0,1" /&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HASH_ARGUMENTS = <span class="string">"hash.arguments"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key: ServiceKey.methodName -&gt; 完整方法名</span></span><br><span class="line"><span class="comment">     * value: ConsistentHashSelector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HASH_NODES</code> 和 <code>HASH_ARGUMENTS</code> 属性分别是每个服务节点对应的虚拟节点数和参与Hash计算的请求参数的索引，<code>selectors</code> 属性用于存储 <code>请求调用&quot;完整方法名&quot;到一致性Hash选择器</code> 的映射关系。</p><h3 id="选择-Invoker-1"><a href="#选择-Invoker-1" class="headerlink" title="选择 Invoker"></a>选择 Invoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--- ConsistentHashLoadBalance</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取调用的方法名称</span></span><br><span class="line">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        <span class="comment">// 2 将 ServiceKey 和 方法名 拼接起来构成一个 key，即完整方法名</span></span><br><span class="line">        String key = invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">"."</span> + methodName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取 Invoker 列表的 hashcode（为了在 Invokers 列表发生变化时重新生成 ConsistentHashSelector 对象）</span></span><br><span class="line">        <span class="keyword">int</span> invokersHashCode = invokers.hashCode();</span><br><span class="line">        ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 如果 invokers 是一个新的 List 对象，说明服务提供者数量发生了变化，可能新增也可能减少了</span></span><br><span class="line">        <span class="comment">// 此时 selector.identityHashCode != invokersHashCode 成立</span></span><br><span class="line">        <span class="keyword">if</span> (selector == <span class="keyword">null</span> || selector.identityHashCode != invokersHashCode) &#123;</span><br><span class="line">            <span class="comment">// 创建 ConsistentHashSelector 对象</span></span><br><span class="line">            selectors.put(key, <span class="keyword">new</span> ConsistentHashSelector&lt;T&gt;(invokers, methodName, invokersHashCode));</span><br><span class="line">            selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 通过 ConsistentHashSelector 对象选择一个 Invoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> selector.select(invocation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ConsistentHashLoadBalance</code> 的 <code>doSelect</code> 方法并没有真正选择目标 Invoker 对象，而是做了一些前置工作，主要是检测 Invoker 列表是否变更了，判断是否需要创建请求方法对应的一致性 Hash 选择器对象，也就是是否需要重新构建 Hash 环。这个准备工作完成后，Hash 环也就构建完毕了，接下来将选择 Invoker 的逻辑交给一致性选择性器 <code>ConsistentHashSelector</code> 对象。下面我们就来分析一致性 Hash 选择器。</p><h3 id="ConsistentHashSelector"><a href="#ConsistentHashSelector" class="headerlink" title="ConsistentHashSelector"></a>ConsistentHashSelector</h3><p><code>ConsistentHashLoadBalance</code> 实现负载均衡都是委托给一致性 Hash 选择器 <code>ConsistentHashSelector</code> 完成的，下面我们对该内部类进行介绍。</p><h4 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+--- ConsistentHashLoadBalance</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHashSelector</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用 TreeMap 存储 Invoker 虚拟节点，TreeMap 是按照Key排序的</span></span><br><span class="line"><span class="comment">         * key: Hash 值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Invoker 虚拟节点个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> replicaNumber;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Invoker 集合的 HashCode 值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> identityHashCode;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 需要参与 Hash 计算的参数索引。</span></span><br><span class="line"><span class="comment">         * 如：argumentIndex = [0,1,2] 时，表示调用的目标方法的前三个参数要参与 Hash 计算。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] argumentIndex;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>下面对核心属性进行介绍：</strong></p><p>需要说明的是，针对每一个请求的服务方法都会创建一个 <code>ConsistentHashLoadBalance</code> 。</p><ul><li><strong>virtualInvokers</strong><blockquote><p>用于缓存 Invoker 的虚拟节点，即多个 hash 值映射到同一个 Invoker 。</p></blockquote></li><li><strong>replicaNumber</strong><blockquote><p>用于记录每个 Invoker 虚拟节点的个数。</p></blockquote></li><li><strong>identityHashCode</strong><blockquote><p>用于记录请求涉及的 Invoker 集合的 HashCode 值。</p></blockquote></li><li><strong>argumentIndex</strong><blockquote><p>用于存储参与 Hash 计算的参数索引，用于请求负载均衡时对请求参数进行匹配，确定哪些参数参与 Hash 计算。</p></blockquote></li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">        * @param invokers         消费端 Invoker 列表</span></span><br><span class="line"><span class="comment">        * @param methodName       方法名</span></span><br><span class="line"><span class="comment">        * @param identityHashCode Invoker 列表的 hashCode 的值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class="keyword">int</span> identityHashCode) &#123;</span><br><span class="line">           <span class="comment">// 1 初始化 virtualInvokers 字段，用于缓存 Invoker 的虚拟节点</span></span><br><span class="line">           <span class="keyword">this</span>.virtualInvokers = <span class="keyword">new</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 2 记录 Invoker 集合的 hashCode，用该 hashCode 值可以判断 Provider 列表是否发生了变化</span></span><br><span class="line">           <span class="keyword">this</span>.identityHashCode = identityHashCode;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 3 获取消费端 Invoker 的 URL</span></span><br><span class="line">           URL url = invokers.get(<span class="number">0</span>).getUrl();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 4 从配置中获取虚拟节点数（hash.nodes 参数）以及参与 hash 计算的参数下标（hash.arguments 参数）</span></span><br><span class="line">           <span class="keyword">this</span>.replicaNumber = url.getMethodParameter(methodName, HASH_NODES, <span class="number">160</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 5 对参与 hash  计算的参数下标进行解析，然后存放到 argumentIndex 数组中</span></span><br><span class="line">           String[] index = COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, HASH_ARGUMENTS, <span class="string">"0"</span>));</span><br><span class="line">           argumentIndex = <span class="keyword">new</span> <span class="keyword">int</span>[index.length];</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index.length; i++) &#123;</span><br><span class="line">               argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 6 构建 Invoker 虚拟节点，默认 replicaNumber=160，相当于在 Hash 环上放 160 个槽位。外层轮询 40 次，内层轮询 4 次，共 40 * 4 = 160次，也就是同一个节点虚拟出 160 个槽位</span></span><br><span class="line">           <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">               <span class="comment">// 6.1 获取服务地址 host:port</span></span><br><span class="line">               String address = invoker.getUrl().getAddress();</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; replicaNumber / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                   <span class="comment">// 6.2 对 address + i 进行md5运算，得到一个长度为16的字节数组</span></span><br><span class="line">                   <span class="comment">// 基于服务地址进行 md5 计算</span></span><br><span class="line">                   <span class="keyword">byte</span>[] digest = md5(address + i);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 6.3 对 digest 部分字节进行 4 次 Hash 运算，得到 4 个不同的 long 型正整数</span></span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                       <span class="comment">// h = 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算</span></span><br><span class="line">                       <span class="comment">// h = 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算</span></span><br><span class="line">                       <span class="comment">// h = 2, h = 3 时过程同上</span></span><br><span class="line">                       <span class="keyword">long</span> m = hash(digest, h);</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 6.3 将 hash 到 Invoker 的映射关系存储到 virtualInvokers 中</span></span><br><span class="line">                       <span class="comment">// virtualInvokers 需要提供高效、有序的查询擦操作，因此选用 TreeMap 作为存储结构</span></span><br><span class="line">                       virtualInvokers.put(m, invoker);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><code>ConsistentHashSelector</code> 的构造方法核心点是 <code>创建虚拟节点（构建 Hash 环）</code> 和 <code>收集参与一致性Hash计算的参数下标（默认情况下只使用第一个参数，也就是下标为 0）</code> 。需要特别说明的是，<code>ConsistentHashLoadBalance</code> 的负载均衡逻辑只受<strong>参数值</strong>影响，具有相同参数值的请求将会被分配给同一个服务提供者，<code>ConsistentHashLoadBalance</code> 不关心权重，因此使用时需要注意一下。下面我们就来对其选择 Invoker 的 <code>select</code> 方法进行分析，从该方法就可以看出为什么说该负载均衡策略只受<strong>参数值</strong>影响。</p><h4 id="选择服务"><a href="#选择服务" class="headerlink" title="选择服务"></a>选择服务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+--- ConsistentHashSelector</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 选择合适的 Invoker 对象</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">select</span><span class="params">(Invocation invocation)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 将参与一致性 Hash 的参数拼接到一起</span></span><br><span class="line">            String key = toKey(invocation.getArguments());</span><br><span class="line">            <span class="comment">// 2 对 key 进行 md5 运算</span></span><br><span class="line">            <span class="keyword">byte</span>[] digest = md5(key);</span><br><span class="line">            <span class="comment">// 3 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectForKey 方法，寻找合适的 Invoker</span></span><br><span class="line">            <span class="keyword">return</span> selectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将参与 Hash 计算的参数索引对应的参数值进行拼接。默认对第一个参数进行 Hash 运算。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">toKey</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">// 对参与 Hash 计算的参数值进行拼接</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : argumentIndex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; args.length) &#123;</span><br><span class="line">                    buf.append(args[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 选择 Invoker</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> hash 调用方法参数处理后的 Hash 值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Invoker&lt;T&gt; <span class="title">selectForKey</span><span class="params">(<span class="keyword">long</span> hash)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 到 TreeMap 中查找第一个节点值大于或等于当前 hash 的 Invoker</span></span><br><span class="line">            Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.ceilingEntry(hash);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 如果传入的 hash 大于 Invoker 在 Hash 环上最大的位置，此时 entry = null，此时需要回到 Hash 环的开头返回第一个 Invoker 对象</span></span><br><span class="line">            <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry = virtualInvokers.firstEntry();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 取出目标 Invoker </span></span><br><span class="line">            <span class="keyword">return</span> entry.getValue();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>一致性 Hash 选择器 <code>ConsistentHashSelector</code> 选择的过程相对比较简单。先是对参数进行 <code>md5</code> 以及 <code>hash</code> 运算，得到一个 <strong>Hash 值</strong>，然后再拿这个 <strong>Hash 值</strong>到 <code>TreeMap</code> 中查找目标 Invoker 即可。</p><h2 id="ShortestResponseLoadBalance"><a href="#ShortestResponseLoadBalance" class="headerlink" title="ShortestResponseLoadBalance"></a>ShortestResponseLoadBalance</h2><p>ShortestResponseLoadBalance 使用的是 <code>最短响应时间的负载均衡算法</code>，和最小活跃数负载均衡算法类似，唯一的差别在于最短响应时间是<strong>基于调用成功的请求</strong>来计算实现的，而最小活跃数是直接基于当前正在处理的请求数实现的，其它的两者完全一致。最短响应时间越小，表明该服务提供者效率越高，此时可以将请求优先分配给该服务。在具体实现中，会记录每个服务提供者成功处理请求的个数以及对应的处理总时间，这样可以得到一个 <strong>成功调用的平均时间</strong> ，最后结合该服务提供者的最小活跃数，<strong>计算出最短响应时间</strong>。也就是从多个提供者节点中选出调用成功且响应时间最短的服务提供者节点。满足该条件的服务节点可能有多个，这种情况再使用加权随机算法进行一次选择就可以得到最终目标节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortestResponseLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"shortestresponse"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// -------------------------- 1 🪐 关键属性 ------------------------/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录 Invoker 集合数量</span></span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录所有 Invoker 集合中最短响应时间</span></span><br><span class="line">        <span class="keyword">long</span> shortestResponse = Long.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录具有相同最短响应时间（shortestResponse 的值）的 Invoker 数量</span></span><br><span class="line">        <span class="keyword">int</span> shortestCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存放具有相同最短响应时间（shortestResponse 的值）的 Invoker 在 Invoker 列表中的下标</span></span><br><span class="line">        <span class="comment">// shortestIndexes 数组中如果有多个值，则说明有两个及以上的 Invoker 具有相同的最短响应时间</span></span><br><span class="line">        <span class="keyword">int</span>[] shortestIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存放每个 Invoker 权重，主要用于当最短响应时间的 Invoker 数量有多个的情况</span></span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录具有相同最短响应时间 Invoker 的总权重</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录第一个 Invoker 对象的权重</span></span><br><span class="line">        <span class="keyword">int</span> firstWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记是否具有相同权重的最短响应时间的 Invoker</span></span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// --------------------------- 2 🪐 操作关键属性 -----------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有 Invoker ，选出最短响应时间的 Invoker 集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用到了消费方限流策略：ActiveLimitFilter</span></span><br><span class="line">            RpcStatus rpcStatus = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取调用成功的平均时间，计算方式：调用成功的请求数总数对应的总耗时 / 调用成功的请求数总数 = 成功调用的平均时间</span></span><br><span class="line">            <span class="keyword">long</span> succeededAverageElapsed = rpcStatus.getSucceededAverageElapsed();</span><br><span class="line">            <span class="comment">// 获取该提供者的活跃请求数，也就是当前正在处理中的请求数</span></span><br><span class="line">            <span class="keyword">int</span> active = rpcStatus.getActive();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算一个处理新请求的预估值，也就是如果当前请求发给该提供者，大概耗时多久处理完成</span></span><br><span class="line">            <span class="keyword">long</span> estimateResponse = succeededAverageElapsed * active;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取该 Invoker 的权重</span></span><br><span class="line">            <span class="keyword">int</span> afterWarmup = getWeight(invoker, invocation);</span><br><span class="line">            weights[i] = afterWarmup;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 和 LeastActiveLoadBalance 类似</span></span><br><span class="line">            <span class="comment">// 比较最短时间，发现更小值则更新相关属性，这种情况只有一个 Invoker</span></span><br><span class="line">            <span class="keyword">if</span> (estimateResponse &lt; shortestResponse) &#123;</span><br><span class="line">                <span class="comment">// 重新记录最短响应时间</span></span><br><span class="line">                shortestResponse = estimateResponse;</span><br><span class="line">                <span class="comment">// 重新记录最短响应时间的 Invoker 数量</span></span><br><span class="line">                shortestCount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 重新记录最短响应时间的 Invoker 在 Invoker 列表中的下标</span></span><br><span class="line">                shortestIndexes[<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重置总权重</span></span><br><span class="line">                totalWeight = afterWarmup;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录第一个最短响应时间的 Invoker 的权重</span></span><br><span class="line">                firstWeight = afterWarmup;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重置权重相同标识</span></span><br><span class="line">                sameWeight = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 出现多个耗时最短的Invoker对象</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (estimateResponse == shortestResponse) &#123;</span><br><span class="line">                <span class="comment">// 记录当前 Invoker 在 Invoker 列表中的下标</span></span><br><span class="line">                shortestIndexes[shortestCount++] = i;</span><br><span class="line">                <span class="comment">// 累加总权重，针对的是具有相同的最短响应时间</span></span><br><span class="line">                totalWeight += afterWarmup;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 判断是否存在相同权重的最短响应时间的 Invoker</span></span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; afterWarmup != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//------------------------------ 3 🪐 选择 Invoker ----------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 仅有一个最短响应时间的 Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (shortestCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(shortestIndexes[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果耗时最短的所有Invoker对象的权重不相同，则通过加权随机负载均衡的方式选择一个Invoker返回</span></span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shortestCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> shortestIndex = shortestIndexes[i];</span><br><span class="line">                offsetWeight -= weights[shortestIndex];</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(shortestIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果耗时最短的所有 Invoker 对象的权重相同，则随机返回一个</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(shortestIndexes[ThreadLocalRandom.current().nextInt(shortestCount)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ShortestResponseLoadBalance 核心思想是选择<strong>最短响应时间</strong>的服务提供者，如果最短响应时间的提供者有多个，则使用加权随机算法继续选择即可。由于和最小活跃数负载均衡策略基本一致，这里就不再具体描述。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Dubbo 的五种负载均衡实现进行了详细分析，理解负载均衡代码逻辑的关键是理解对应的算法本身。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Dubbo 中的负载均衡 &lt;code&gt;LoadBalance&lt;/code&gt; 的职责是将网络请求或者其它形式的负载 &lt;code&gt;&amp;quot;均
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>集群容错 - Router</title>
    <link href="https://gentryhuang.com/posts/26e2f6a4/"/>
    <id>https://gentryhuang.com/posts/26e2f6a4/</id>
    <published>2020-09-26T23:00:00.000Z</published>
    <updated>2021-04-06T08:32:41.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 中的路由 <code>Router</code> 的主要功能就是根据用户配置的路由规则以及请求携带信息，过滤出符合条件的 Invoker 集合，供后续负载均衡逻辑使用。相关类图图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-router-uml.jpg" alt></p><h1 id="RouterFactory-amp-Router"><a href="#RouterFactory-amp-Router" class="headerlink" title="RouterFactory &amp; Router"></a>RouterFactory &amp; Router</h1><h2 id="RouterFactory"><a href="#RouterFactory" class="headerlink" title="RouterFactory"></a>RouterFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RouterFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 创建 Router.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> router</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(<span class="string">"protocol"</span>)</span><br><span class="line">    <span class="function">Router <span class="title">getRouter</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RouterFactory</code> 是 Dubbo 的扩展点，没有默认扩展实现，用于创建 Router。其中 <code>getRouter</code> 方法动态生成的适配器会根据 <code>protocol</code> 参数选择扩展实现。</p><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Router</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Router</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取路由规则URL</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * get the router url.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由，筛选匹配的Invoker 集合</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * route.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers   Invoker 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url        refer url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> routed invokers 路由后的Invoker 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) <span class="keyword">throws</span> RpcException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Router</code> 决定了一次 Dubbo 调用的目标服务，<strong>该接口的每个实现类都代表一个路由规则</strong>。当消费方调用服务提供方时，Dubbo 根据路由规则从服务目录中筛选出符合条件的服务列表，之后通过负载均衡算法再次进行筛选。</p><h1 id="ConditionRouterFactory-amp-ConditionRouter"><a href="#ConditionRouterFactory-amp-ConditionRouter" class="headerlink" title="ConditionRouterFactory &amp; ConditionRouter"></a>ConditionRouterFactory &amp; ConditionRouter</h1><h2 id="ConditionRouterFactory"><a href="#ConditionRouterFactory" class="headerlink" title="ConditionRouterFactory"></a>ConditionRouterFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionRouterFactory</span> <span class="keyword">implements</span> <span class="title">RouterFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拓展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"condition"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Router <span class="title">getRouter</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ConditionRouter 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionRouter(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConditionRouterFactory</code> 实现，其扩展名为 <strong>condition</strong> ，在其 <strong>getRouter</strong> 方法中会创建 <code>ConditionRouter</code> 对象。</p><h2 id="ConditionRouter"><a href="#ConditionRouter" class="headerlink" title="ConditionRouter"></a>ConditionRouter</h2><p><code>ConditionRouter</code> 是基于条件表达式的路由实现类，再分析条件路由之前，我们先对条件表达式相关内容进行说明，条件路由就是根据这些规则实现的。</p><p>下面就是一条基于条件表达式的路由规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host &#x3D; 10.20.153.10 &#x3D;&gt; host &#x3D; 10.20.153.11</span><br></pre></td></tr></table></figure><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li><strong>=&gt;</strong> 之前的为<code>消费者匹配条件</code>，该条件中的所有参数会与消费者的 URL 进行对比，当消费者满足匹配条件时，会对该消费者执行后面的过滤规则，否则直接返回消费端Invoker列表，无需继续提供者过滤条件的匹配。 </li><li><strong>=&gt;</strong> 之后的为<code>提供者地址列表的过滤条件</code>，该条件中的所有参数会与提供者的 URL 进行对比，消费者最终只能拿到过滤后的地址列表</li><li><strong>如果匹配条件为空，表示 =&gt; 之后的过滤条件对所有消费方生效</strong>，如： <code>=&gt; host!=10.20.153.11</code>，含义是所有的消费方都不能请求 <code>10.20.153.11</code> 这个提供者节点。</li><li><strong>如果提供者过滤条件为空，表示禁止访问所提供者</strong>，如：<code>host = 10.20.153.10 =&gt;</code>，含义是 <code>10.20.153.10</code> 这个消费方不能访问任何提供者。</li></ul><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h4 id="参数支持"><a href="#参数支持" class="headerlink" title="参数支持"></a>参数支持</h4><ul><li>服务调用信息，如：<code>method</code>、<code>argument</code> 等</li><li>URL 本身的字段，如：<code>protocol</code>、<code>host</code>、<code>port</code> 等</li><li>URL 上的所有参数，如：<code>application</code>、<code>organization</code> 等</li></ul><h4 id="条件支持"><a href="#条件支持" class="headerlink" title="条件支持"></a>条件支持</h4><ul><li>等号 <code>=</code> 表示匹配，如：<code>host = 10.20.153.10</code></li><li>不等号 <code>!=</code> 表示不匹配，如：<code>host != 10.20.153.10</code></li></ul><h4 id="值支持"><a href="#值支持" class="headerlink" title="值支持"></a>值支持</h4><ul><li>以逗号 <code>,</code> 分隔多个值，如：<code>host != 10.20.153.10,10.20.153.11</code></li><li>以星号 <code>*</code> 结尾，表示通配，如：<code>host != 10.20.*</code></li><li>以美元符 <code>$</code> 开头，表示引用消费者参数，如：<code>host = $host</code></li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionRouter</span> <span class="keyword">implements</span> <span class="title">Router</span>, <span class="title">Comparable</span>&lt;<span class="title">Router</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ConditionRouter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分组正则匹配，用于切分路由规则的正则表达式</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 第一个匹配组-分割符： 用于匹配 "&amp;", "!=", "=" 和 "," 等符号，作为匹配规则的分隔符。允许匹配不到，使用了 * 通配符</span></span><br><span class="line"><span class="comment">     * 第二个匹配组-内容： 这里用于匹配 英文字母，数字等字符，【不匹配 &amp;!=,】作为匹配规则的匹配内容。 可能出现，这里匹配到了，但是第一匹配组没有匹配到。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Pattern ROUTE_PATTERN = Pattern.compile(<span class="string">"([&amp;!=,]*)\\s*([^&amp;!=,\\s]+)"</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由规则 URL</span></span><br><span class="line"><span class="comment">     * 如： URL.valueOf("route://0.0.0.0/com.foo.BarService?category=routers&amp;dynamic=false&amp;rule=" + URL.encode("host = 10.20.153.10 =&gt; host = 10.20.153.11"))</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由规则优先级，用于排序，优先级越大越靠前。优先级越大越靠前执行。默认为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当路由结果为空时是否强制执行，如果不强制执行，路由匹配结果为空的路由规认为是失效的。如果强制执行，则直接返回空的路由结果。默认为false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> force;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者匹配的条件集合，通过解析条件表达式规则 '=&gt;' 之前的部分得到</span></span><br><span class="line"><span class="comment">     * key: 匹配项</span></span><br><span class="line"><span class="comment">     * value: 匹配项对应的匹配对 【包含匹配项对应的 匹配值集合/不匹配值集合 】</span></span><br><span class="line"><span class="comment">     * 效果：所有参数和消费者的 URL 进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, MatchPair&gt; whenCondition;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供者匹配的条件集合，通过解析条件表达式规则 '=&gt;' 之后的部分得到</span></span><br><span class="line"><span class="comment">     * key: 匹配项</span></span><br><span class="line"><span class="comment">     * value: 匹配项对应的匹配对 【包含匹配项对应的 匹配值集合/不匹配值集合 】</span></span><br><span class="line"><span class="comment">     * 效果：所有参数和提供者的 URL（合并处理后的）进行对比，消费者最终只拿到过滤后的地址列表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, MatchPair&gt; thenCondition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionRouter</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将条件路由规则解析成预定格式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 条件规则 URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionRouter</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取 priority 和 force 配置</span></span><br><span class="line">        <span class="keyword">this</span>.priority = url.getParameter(Constants.PRIORITY_KEY, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.force = url.getParameter(Constants.FORCE_KEY, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 获取路由规则URL中路由规则 rule 参数的值</span></span><br><span class="line">            String rule = url.getParameterAndDecoded(Constants.RULE_KEY);</span><br><span class="line">            <span class="keyword">if</span> (rule == <span class="keyword">null</span> || rule.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal route rule!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 剔除掉路由规则中的consumer.或者provider. ，如 consumer.host != 192.168.0.1 &amp; method = * =&gt; provider.host != 10.75.25.66</span></span><br><span class="line">            <span class="comment">// 剔除调前缀才是真正的规则</span></span><br><span class="line">            rule = rule.replace(<span class="string">"consumer."</span>, <span class="string">""</span>).replace(<span class="string">"provider."</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 根据 "=&gt;" 拆分路由规则</span></span><br><span class="line">            <span class="keyword">int</span> i = rule.indexOf(<span class="string">"=&gt;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 分别获取消费者匹配规则的串 和 服务提供者过滤规则的串</span></span><br><span class="line">            String whenRule = i &lt; <span class="number">0</span> ? <span class="keyword">null</span> : rule.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">            String thenRule = i &lt; <span class="number">0</span> ? rule.trim() : rule.substring(i + <span class="number">2</span>).trim();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6 将路由规则串解析为key-value形式 ,key为路由规则匹配项，value为匹配对（包含了匹配项对应的 匹配值集合和不匹配值集合）</span></span><br><span class="line">            <span class="comment">// 6.1 解析消费方匹配规则</span></span><br><span class="line">            Map&lt;String, MatchPair&gt; when = StringUtils.isBlank(whenRule) || <span class="string">"true"</span>.equals(whenRule) ? <span class="keyword">new</span> HashMap&lt;String, MatchPair&gt;() : parseRule(whenRule);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6.2 解析提供者过滤规则</span></span><br><span class="line">            Map&lt;String, MatchPair&gt; then = StringUtils.isBlank(thenRule) || <span class="string">"false"</span>.equals(thenRule) ? <span class="keyword">null</span> : parseRule(thenRule);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6.3 赋值 消费方匹配条件集合、提供者过滤条件集合</span></span><br><span class="line">            <span class="keyword">this</span>.whenCondition = when;</span><br><span class="line">            <span class="keyword">this</span>.thenCondition = then;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 <code>ConditionRouter</code> 的构造方法中，会根据 URL 中携带的相应参数初始化 <code>priority</code>、<code>force</code> 等属性。然后从条件路由 URL 的 rule 参数中获取路由规则并进行解析，最后得到匹配项集合，当需要进行匹配时，根据已经解析好的规则对消费方 URL 或提供者 URL 进行匹配即可。</p><h2 id="匹配项"><a href="#匹配项" class="headerlink" title="匹配项"></a>匹配项</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionRouter</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MatchPair</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 匹配值集合，待匹配项存在于集合，则说明匹配成功</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> Set&lt;String&gt; matches = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 不匹配值集合，待匹配项存在于集合，则说明匹配失败</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> Set&lt;String&gt; mismatches = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断 value 是否匹配 matches + mismatches</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String value, URL param)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 只匹配 matches，没有匹配上则说明失败了，返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!matches.isEmpty() &amp;&amp; mismatches.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String match : matches) &#123;</span><br><span class="line">                    <span class="comment">// 只要入参被 matches 集合中的任意一个元素匹配到，就匹配成功，返回true</span></span><br><span class="line">                    <span class="keyword">if</span> (UrlUtils.isMatchGlobPattern(match, value, param)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果所有匹配值都无法匹配到 value，则匹配失败,返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 只匹配 mismatches，没有匹配上，则说明成功了，返回true</span></span><br><span class="line">            <span class="keyword">if</span> (!mismatches.isEmpty() &amp;&amp; matches.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String mismatch : mismatches) &#123;</span><br><span class="line">                    <span class="comment">// 只要入参被 mismatches 集合中的任意一个元素匹配到，就匹配失败，返回false</span></span><br><span class="line">                    <span class="keyword">if</span> (UrlUtils.isMatchGlobPattern(mismatch, value, param)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// mismatches 集合中所有元素都无法匹配到入参，则匹配成功，返回 true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 匹配 mismatches + matches，优先去匹配 mismatches</span></span><br><span class="line">            <span class="keyword">if</span> (!matches.isEmpty() &amp;&amp; !mismatches.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 mismatches 集合中任意一个元素与入参匹配成功，则匹配失败，就立即返回 false</span></span><br><span class="line">                <span class="keyword">for</span> (String mismatch : mismatches) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (UrlUtils.isMatchGlobPattern(mismatch, value, param)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 matches 集合中任意一个元素与入参匹配成功，则匹配成功，就立即返回 true</span></span><br><span class="line">                <span class="keyword">for</span> (String match : matches) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (UrlUtils.isMatchGlobPattern(match, value, param)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 matches 和 mismatches 均为空，此时返回 false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>MatchPair</code> 表示一个匹配项，其中包含两个 <code>Set</code> 集合，匹配值集合和不匹配值集合。具体匹配逻辑如下：</p><ol><li>当 mismatches 集合为空时，会遍历 matches 集合中的匹配条件，匹配上任意一条即可返回 true。</li><li>当 matches 集合为空时，会遍历 mismatches 集合中的匹配条件，匹配上任意一条即返回 false。</li><li>当 matches 集合和 mismatches 集合同时不为空时，会优先匹配 mismatches 集合中的条件，匹配上任意一条规则即返回 false。若 mismatches 中的条件全部匹配失败，才会开始匹配 matches 集合，匹配上任意一条即返回 true。</li><li>当 matches 集合和 mismatches 集合同时为空时，则返回 false</li></ol><p>其中具体的匹配逻辑都是在 <code>UrlUtils.isMatchGlobPattern</code> 方法中实现的，主要判断逻辑如下：</p><ol><li>如果匹配条件以 <code>$</code> 符号开头，表示从 URL 中获取相应的参数值进行匹配。</li><li>对 <code>*</code> 通配符特别处理，会处理通配符在匹配条件开头、中间以及末尾三种情况。</li><li>非通配符直接等值匹配</li></ol><p>下面简单粘贴下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">+--- UrlUtils</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断 value 是否匹配 matches/mismatches</span></span><br><span class="line"><span class="comment">     * 注意：param参数是为了支持从URL中读取参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern 匹配规则</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value   待和匹配值进行匹配的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param   消息者URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatchGlobPattern</span><span class="params">(String pattern, String value, URL param)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以美元符 `$` 开头，表示引用消费者参数（从URL中获取相应的参数值），param参数为消费者URL</span></span><br><span class="line">        <span class="keyword">if</span> (param != <span class="keyword">null</span> &amp;&amp; pattern.startsWith(<span class="string">"$"</span>)) &#123;</span><br><span class="line">            pattern = param.getRawParameter(pattern.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行匹配</span></span><br><span class="line">        <span class="keyword">return</span> isMatchGlobPattern(pattern, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMatchGlobPattern</span><span class="params">(String pattern, String value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 全匹配，通配符支持</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"*"</span>.equals(pattern)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配规则和待匹配值全部为空，认为两者相等，即匹配</span></span><br><span class="line">        <span class="keyword">if</span> ((pattern == <span class="keyword">null</span> || pattern.length() == <span class="number">0</span>) &amp;&amp; (value == <span class="keyword">null</span> || value.length() == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配规则和待匹配值有一个为空，不匹配</span></span><br><span class="line">        <span class="keyword">if</span> ((pattern == <span class="keyword">null</span> || pattern.length() == <span class="number">0</span>) || (value == <span class="keyword">null</span> || value.length() == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确定 匹配规则中通配符 * 的位置</span></span><br><span class="line">        <span class="keyword">int</span> i = pattern.lastIndexOf(<span class="string">'*'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配规则中不包含通配符，此时直接比较匹配值和待匹配值 是否相等即可，并返回比较结果</span></span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value.equals(pattern);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通配符 "*" 在匹配规则尾部，比如 192.168.25.*</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == pattern.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断待匹配值是否符合含有通配符的匹配规则</span></span><br><span class="line">            <span class="keyword">return</span> value.startsWith(pattern.substring(<span class="number">0</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通配符 "*" 在匹配规则头部，如：*。168.25.100</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断待匹配值是否符合含有通配符的匹配规则</span></span><br><span class="line">            <span class="keyword">return</span> value.endsWith(pattern.substring(i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通配符 "*" 在匹配规则中间位置</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 以通配符 * 分隔，获取前后缀</span></span><br><span class="line">            String prefix = pattern.substring(<span class="number">0</span>, i);</span><br><span class="line">            String suffix = pattern.substring(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断匹配值是否以 前缀开头且以后缀结尾</span></span><br><span class="line">            <span class="keyword">return</span> value.startsWith(prefix) &amp;&amp; value.endsWith(suffix);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="解析路由规则"><a href="#解析路由规则" class="headerlink" title="解析路由规则"></a>解析路由规则</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionRouter</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, MatchPair&gt; <span class="title">parseRule</span><span class="params">(String rule)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 定义条件映射集合，key：匹配项  value: 匹配对MatchPair 。</span></span><br><span class="line">        Map&lt;String, MatchPair&gt; condition = <span class="keyword">new</span> HashMap&lt;String, MatchPair&gt;();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(rule)) &#123;</span><br><span class="line">            <span class="keyword">return</span> condition;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 存储匹配对，即匹配和不匹配条件</span></span><br><span class="line">        MatchPair pair = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 匹配对中的 匹配值集合/不匹配值集合的临时变量</span></span><br><span class="line">        Set&lt;String&gt; values = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 按照 分组正则匹配 配整路由个条件表达式</span></span><br><span class="line">        <span class="keyword">final</span> Matcher matcher = ROUTE_PATTERN.matcher(rule);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 5 通过 ROUTE_PATTERN 正则匹配 rule ，遍历匹配结果，</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 1 find()方法是部分匹配，是查找输入串中与模式匹配的子串，如果该匹配的串有组还可以使用group()函数。当且仅当输入序列的子序列，匹配规则才会返回true，可能可以匹配多个子串</span></span><br><span class="line"><span class="comment">         * 2 matcher.group() 返回匹配到的子字符串</span></span><br><span class="line"><span class="comment">         * 例子：host = 2.2.2.2 &amp; host != 1.1.1.1 &amp; method = hello</span></span><br><span class="line"><span class="comment">         * 匹配结果：</span></span><br><span class="line"><span class="comment">         * 第一个子序列： host              分组一：""  分组二：host</span></span><br><span class="line"><span class="comment">         * 第二个子序列：= 2.2.2.2          分组一：=   分组二：2.2.2.2</span></span><br><span class="line"><span class="comment">         * 第三个子序列：&amp; host             分组一：&amp;   分组二：host</span></span><br><span class="line"><span class="comment">         * ...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.1 获取匹配组一的匹配结果，即分隔符</span></span><br><span class="line">            String separator = matcher.group(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 5.2 获取匹配组二的匹配结果，即匹配规则项</span></span><br><span class="line">            String content = matcher.group(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6 匹配组一的匹配结果为空，则说明 content 为参数名称</span></span><br><span class="line">            <span class="keyword">if</span> (separator == <span class="keyword">null</span> || separator.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建 MatchPair 对象</span></span><br><span class="line">                pair = <span class="keyword">new</span> MatchPair();</span><br><span class="line">                <span class="comment">// 存储 &lt;匹配项, MatchPair&gt; 键值对，比如 &lt;host, MatchPair&gt;</span></span><br><span class="line">                condition.put(content, pair);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7 如果匹配组一的匹配结果是 '&amp;'，说明是多个表达式</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"&amp;"</span>.equals(separator)) &#123;</span><br><span class="line">                <span class="comment">// 先尝试从 condition 中获取content对应的MatchPair，不存在则新建并放入condition中</span></span><br><span class="line">                <span class="keyword">if</span> (condition.get(content) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pair = <span class="keyword">new</span> MatchPair();</span><br><span class="line">                    condition.put(content, pair);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pair = condition.get(content);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8 如果分隔符为 '='，表示KV的分界线，值是匹配值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"="</span>.equals(separator)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pair == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">"Illegal route rule \""</span></span><br><span class="line">                            + rule + <span class="string">"\", The error char '"</span> + separator</span><br><span class="line">                            + <span class="string">"' at index "</span> + matcher.start() + <span class="string">" before \""</span></span><br><span class="line">                            + content + <span class="string">"\"."</span>, matcher.start());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 匹配对中的匹配值集合，先取再放</span></span><br><span class="line">                values = pair.matches;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将 content 存入到 MatchPair 的 matches 集合中</span></span><br><span class="line">                values.add(content);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9 如果分隔符为 '!='，表示KV的分界线，值就是不匹配值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"!="</span>.equals(separator)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pair == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">"Illegal route rule \""</span></span><br><span class="line">                            + rule + <span class="string">"\", The error char '"</span> + separator</span><br><span class="line">                            + <span class="string">"' at index "</span> + matcher.start() + <span class="string">" before \""</span></span><br><span class="line">                            + content + <span class="string">"\"."</span>, matcher.start());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 匹配对中的不匹配值集合，先取再放</span></span><br><span class="line">                values = pair.mismatches;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将 content 存入到 MatchPair 的 mismatches 集合中</span></span><br><span class="line">                values.add(content);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 10 分隔符为 , 表示某个匹配项有多个值，它们以 ','分隔</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">","</span>.equals(separator)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (values == <span class="keyword">null</span> || values.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">"Illegal route rule \""</span></span><br><span class="line">                            + rule + <span class="string">"\", The error char '"</span> + separator</span><br><span class="line">                            + <span class="string">"' at index "</span> + matcher.start() + <span class="string">" before \""</span></span><br><span class="line">                            + content + <span class="string">"\"."</span>, matcher.start());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将 content 存入到上一步获取到的 values 中，可能是 matches，也可能是 mismatches</span></span><br><span class="line">                values.add(content);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 11 暂不支持的分割符</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">"Illegal route rule \""</span> + rule</span><br><span class="line">                        + <span class="string">"\", The error char '"</span> + separator + <span class="string">"' at index "</span></span><br><span class="line">                        + matcher.start() + <span class="string">" before \""</span> + content + <span class="string">"\"."</span>, matcher.start());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> condition;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>解析路由规则主要是根据正则表达式中的两个匹配组，第一个组用来匹配分割符，目前支持 <code>&amp;</code>、<code>!=</code>、<code>=</code> 以及 <code>,</code> 符号；第二个组用来匹配条件内容；其中两个匹配组中间允许有多个空白。</p><p>在解析时，规则如下：</p><blockquote><ol><li>第一个匹配组匹配为空或者匹配到 <code>&amp;</code> 符号时，说明第二个匹配项匹配到的是一个条件项，应该为其创建一个匹配项 <code>MatchPair</code> 对象，用于下一个匹配查找存放匹配值或不匹配值。</li><li>第一个匹配组匹配为 <code>=</code>、<code>!=</code> 以及 <code>,</code> 时，说明本次查找到匹配的内容了，根据等值或不等值判断，将该内容记录到上一轮的 <code>MatchPair</code> 中的等值或不等值的集合中。</li></ol></blockquote><p>以上就是路由规则的解析逻辑，下面使用一个示例对解析逻辑进行说明。</p><ul><li>示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host &#x3D; 2.2.2.2,1.1.1.1 &amp; method !&#x3D;get &#x3D;&gt; host &#x3D; 3.3.3.3</span><br></pre></td></tr></table></figure></li><li>正则解析结果 - whenCondition<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          第一个匹配组（分割符）      第二匹配组（条件）</span><br><span class="line">第一轮：    &quot;&quot;                      host</span><br><span class="line">第二轮：    &#x3D;                       2.2.2.2</span><br><span class="line">第三轮：    ,                       1.1.1.1</span><br><span class="line">第四轮：    &amp;                       method</span><br><span class="line">第五轮：    !&#x3D;                      get</span><br></pre></td></tr></table></figure></li><li>正则解析结果 - thenCondition<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">          第一个匹配组（分割符）      第二匹配组（条件）</span><br><span class="line">第一轮：    &quot;&quot;                      host</span><br><span class="line">第二轮：    &#x3D;                       3.3.3.3</span><br></pre></td></tr></table></figure></li></ul><p>解析后的 conditon 内容如下：</p><ul><li>whenConditon<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"host"</span>:&#123;</span><br><span class="line">      <span class="attr">"matches"</span>:[<span class="string">"2.2.2.2"</span>,<span class="string">"1.1.1.1"</span>],</span><br><span class="line">      <span class="attr">"mismatches"</span>:[]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"method"</span>:&#123;</span><br><span class="line">      <span class="attr">"matches"</span>:[],</span><br><span class="line">      <span class="attr">"mismatches"</span>:[<span class="string">"get"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>thenCondition<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"host"</span>:&#123;</span><br><span class="line">      <span class="attr">"matches"</span>:[<span class="string">"3.3.3.3"</span>],</span><br><span class="line">      <span class="attr">"mismatches"</span>:[]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionRouter</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由</span></span><br><span class="line"><span class="comment">     * 说明：该方法传入的url参数目前都是消费者URL: </span></span><br><span class="line"><span class="comment">     *  &#123;<span class="doctag">@link</span> AbstractDirectory#list(com.alibaba.dubbo.rpc.Invocation)&#125; </span></span><br><span class="line"><span class="comment">     *  &#123;<span class="doctag">@link</span> com.alibaba.dubbo.registry.integration.RegistryDirectory#route(java.util.List, java.lang.String)&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers   Invoker 集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url        调用者传入，目前都是消费者URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation 调用信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// 判空</span></span><br><span class="line">        <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1 优先执行消费者匹配条件，如果匹配失败，说明当前消费者URL不符合消费者匹配规则，直接返回invoker集合即可，无需继续后面的逻辑。</span></span><br><span class="line"><span class="comment">             * 说明：</span></span><br><span class="line"><span class="comment">             * 消费者 ip：192.168.25.100</span></span><br><span class="line"><span class="comment">             * 路由规则：host = 10.20.125.10 =&gt; host = 10.2.12.10  : ip为10.20.125.10的消费者调用ip为10.2.12.10的服务提供者</span></span><br><span class="line"><span class="comment">             * 结果：当前消费者ip为192.168.25.100，这条路由规则不适用于当前的消费者，直接返回</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!matchWhen(url, invocation)) &#123;</span><br><span class="line">                <span class="keyword">return</span> invokers;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 路由过滤后的Invoker结果集</span></span><br><span class="line">            List&lt;Invoker&lt;T&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 提供者过滤条件未配置的话直接返回空集合，表示无提供者可用</span></span><br><span class="line">            <span class="keyword">if</span> (thenCondition == <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.warn(<span class="string">"The current consumer in the service blacklist. consumer: "</span> + NetUtils.getLocalHost() + <span class="string">", service: "</span> + url.getServiceKey());</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 遍历Invoker集合，逐个判断 Invoker 是否符合提供者过滤条件</span></span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matchThen(invoker.getUrl(), url)) &#123;</span><br><span class="line">                    result.add(invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 如果 result 非空，则直接返回过滤后的Invoker 集合</span></span><br><span class="line">            <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5 如果过滤后的Invoker集合为空，根据 force 决定返回空集合还是返回全部 Invoker</span></span><br><span class="line">                <span class="comment">// 如果 force = true，表示强制返回空列表，否则路由结果为空的路由规则将失效</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (force) &#123;</span><br><span class="line">                logger.warn(<span class="string">"The route result is empty and force execute. consumer: "</span> + NetUtils.getLocalHost() + <span class="string">", service: "</span> + url.getServiceKey() + <span class="string">", router: "</span> + url.getParameterAndDecoded(Constants.RULE_KEY));</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(<span class="string">"Failed to execute condition router rule: "</span> + getUrl() + <span class="string">", invokers: "</span> + invokers + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 走到这里，说明过滤后的Invoker集合为空，并且非强制执行，则原样返回invoker 集合，即表示该条路由规则失效，忽律路由规则</span></span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>服务路由首先判断此次发起调用的消费方是否符合消费端匹配条件，若不符合说明当前路由规则不适用当前的消费者，直接返回整个 Invoker 列表即可。若符合，则继续通过提供者匹配条件对 Invoker 集合进行过滤。其中通过调用 <strong>matchWhen</strong> 对消费方进行匹配，匹配成功再使用 <strong>matchThen</strong> 对提供者进行过滤。下面来看一下这两个方法的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionRouter</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对服务消费方进行匹配，如果匹配失败，直接返回Invoker 列表。如果匹配成功，才会对服务提供者进行匹配。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 消费者 URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation 调用信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matchWhen</span><span class="params">(URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 服务消费者匹配条件为 null 或 空，表示对所有消费方生效，返回true，如：</span></span><br><span class="line"><span class="comment">         *    =&gt; host != 10.2.12.10  ，表示所有的消费者都不能调用 IP 为 10.2.12.10</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> whenCondition == <span class="keyword">null</span> || whenCondition.isEmpty() ||</span><br><span class="line">                matchCondition(whenCondition, url, <span class="keyword">null</span>, invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对服务提供者进行匹配</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 提供者URL合并后的 URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param 消费者 URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">matchThen</span><span class="params">(URL url, URL param)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 服务提供者条件为 null 或 空，表示禁用服务</span></span><br><span class="line">        <span class="keyword">return</span> !(thenCondition == <span class="keyword">null</span> || thenCondition.isEmpty()) &amp;&amp;</span><br><span class="line">                matchCondition(thenCondition, url, param, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这两个方法均是通过调用 <code>matchCondition</code> 方法执行匹配逻辑的，区别在它们各自传参不同。具体传参代码中已经详细标注，下面我们就看具体的匹配逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">+--- ConditionRouter</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配条件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> condition  消费者匹配的条件集合/提供者匹配的条件集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url        消费者URL/提供者URL合并后的URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> param      消费者URL，在url参数为提供者URL合并后的URL时才有值。该值仅用于匹配规则引用消费者URL的参数的场景。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation 调用信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">matchCondition</span><span class="params">(Map&lt;String, MatchPair&gt; condition, URL url, URL param, Invocation invocation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 将服务提供者或消费者 url 转成 Map</span></span><br><span class="line">        Map&lt;String, String&gt; sample = url.toMap();</span><br><span class="line">        <span class="comment">// 标记是否匹配</span></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 遍历匹配条件集合</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, MatchPair&gt; matchPair : condition.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//--------------------------- 获取匹配项，确定匹配值 --------------------------/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.1 获得匹配项名称，如 host,method</span></span><br><span class="line">            String key = matchPair.getKey();</span><br><span class="line">            <span class="comment">// 2.2 匹配项的值</span></span><br><span class="line">            String sampleValue;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.3 如果 Invocation 不为null，且匹配项名称为 method 或 methods，表示进行方法匹配</span></span><br><span class="line">            <span class="keyword">if</span> (invocation != <span class="keyword">null</span> &amp;&amp; (Constants.METHOD_KEY.equals(key) || Constants.METHODS_KEY.equals(key))) &#123;</span><br><span class="line">                <span class="comment">// 从Invocation中获取调用方法名</span></span><br><span class="line">                sampleValue = invocation.getMethodName();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.4 从服务提供者或者消费者 URL 中获取匹配项的值，如 host、application</span></span><br><span class="line">                sampleValue = sample.get(key);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.5 匹配项对应的值不存在，则尝试获取 default.key 的值</span></span><br><span class="line">                <span class="keyword">if</span> (sampleValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sampleValue = sample.get(Constants.DEFAULT_KEY_PREFIX + key);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//--------------------------- 条件匹配 ------------------------------------------/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//  3 匹配项的值不为空</span></span><br><span class="line">            <span class="keyword">if</span> (sampleValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用匹配项关联的 MatchPair 的 isMatch 方法进行匹配，只要有一个匹配规则匹配失败，就失败</span></span><br><span class="line">                <span class="keyword">if</span> (!matchPair.getValue().isMatch(sampleValue, param)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4 匹配项的值为空，说明服务提供者或消费者URL中不包含该配置项的值</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 匹配项中的匹配条件 `matches` 不为空，表示匹配失败，返回false</span></span><br><span class="line">                <span class="comment">// 如我们设置了这样一条规则：ip = 10.2.12.10 ，假设 URL 中不包含 ip 参数，此时 ip 匹配项的值为 null，</span></span><br><span class="line">                <span class="comment">// 但路由规则限制了 ip = 10.2.12.10，URL中却没有该配置项，这是不符合规则的，因此返回 false</span></span><br><span class="line">                <span class="keyword">if</span> (!matchPair.getValue().matches.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>matchCondition</code> 方法核心逻辑是使用<code>消费者匹配条件集合</code>或<code>提供者匹配条件集合</code>，去匹配 <code>消费方URL</code> 或 <code>提供方URL（合并后的结果）</code>，匹配项的匹配工作是交给 <code>MatchPair.isMatch</code> 方法完成的。</p><p>其中 URL 转成 Map 参数逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--- URL</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">toMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;(parameters);</span><br><span class="line">        <span class="keyword">if</span> (protocol != <span class="keyword">null</span>)</span><br><span class="line">            map.put(<span class="string">"protocol"</span>, protocol);</span><br><span class="line">        <span class="keyword">if</span> (username != <span class="keyword">null</span>)</span><br><span class="line">            map.put(<span class="string">"username"</span>, username);</span><br><span class="line">        <span class="keyword">if</span> (password != <span class="keyword">null</span>)</span><br><span class="line">            map.put(<span class="string">"password"</span>, password);</span><br><span class="line">        <span class="keyword">if</span> (host != <span class="keyword">null</span>)</span><br><span class="line">            map.put(<span class="string">"host"</span>, host);</span><br><span class="line">        <span class="keyword">if</span> (port &gt; <span class="number">0</span>)</span><br><span class="line">            map.put(<span class="string">"port"</span>, String.valueOf(port));</span><br><span class="line">        <span class="keyword">if</span> (path != <span class="keyword">null</span>)</span><br><span class="line">            map.put(<span class="string">"path"</span>, path);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>toMap</code> 方法将 URL 中的主干和参数部分都转成了对应的 K-V 形式，用于和匹配条件集合比对。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体来看条件路由还是比较复杂的，下面对其主要流程进行简单梳理。</p><ol><li>条件路由 <code>ConditionRouter</code> 在初始化时会对传入的条件路由规则进行解析、缓存，针对消费方和提供方各有一个条件集合，格式为 <code>&lt;匹配项,MatchPair&lt;匹配项对应的匹配值集合，匹配项对应的不匹配值集合&gt;&gt;</code> 。</li><li>进行服务路由的时候，首先使用消费方条件集合对传入的消费者URL进行匹配，匹配失败则说明当前消费者URL不符合消费者匹配条件，直接返回传入的 Invoker 集合即可。如果匹配成功，则使用提供方条件集合对传入的 Invoker 集合逐一匹配，即使用提供方条件集合对Invoker的URL进行匹配，最终筛选出符合条件的 Invoker 列表。如果对传入Invoker 列表过滤后结果为空，则需要根据 <strong>force</strong> 决定返回空集合还是返回全部 Invoker ，如果 <code>force = true</code> 表示强制返回空列表，否则路由结果为空的路由认为是失效的。如果最终过滤后的结果非空，则直接返回过滤后的 Invoker 列表。</li><li>第 2 步的匹配逻辑最终是交给 <code>MatchPair.isMatch</code> 方法处理的，本质上是使用匹配集合匹配URL中对应的参数值。</li></ol><h1 id="ScriptRouterFactory-amp-ScriptRouter"><a href="#ScriptRouterFactory-amp-ScriptRouter" class="headerlink" title="ScriptRouterFactory &amp; ScriptRouter"></a>ScriptRouterFactory &amp; ScriptRouter</h1><h2 id="ScriptRouterFactory"><a href="#ScriptRouterFactory" class="headerlink" title="ScriptRouterFactory"></a>ScriptRouterFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptRouterFactory</span> <span class="keyword">implements</span> <span class="title">RouterFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"script"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Router <span class="title">getRouter</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ScriptRouter 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScriptRouter(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ScriptRouterFactory</code> 的扩展名为 <code>script</code> ，其 <code>getRouter</code> 方法中会创建一个 <code>ScriptRouter</code> 对象。</p><h2 id="ScriptRouter"><a href="#ScriptRouter" class="headerlink" title="ScriptRouter"></a>ScriptRouter</h2><p><code>ScriptRouter</code> 支持 JDK 脚本引擎的所有脚本，如：<code>javaScript</code>、<code>JRuby</code>、<code>Groovy</code> 等，通过 <code>type=javascript</code> 参数设置脚本类型，缺省为 <code>javaScript</code> 。</p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;script:&#x2F;&#x2F;0.0.0.0&#x2F;com.foo.BarService?category&#x3D;routers&amp;dynamic&#x3D;false&amp;rule&#x3D;&quot; + URL.encode(&quot;（function route(invokers) &#123; ... &#125; (invokers)）&quot;)</span><br></pre></td></tr></table></figure><p>基于脚本引擎的路由规则，下面定义一个 route() 函数进行 ip 过滤。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">（<span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">invokers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> java.util.ArrayList(invokers.size());</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; invokers.size(); i ++) &#123;</span><br><span class="line">        <span class="comment">// 判断 Invoker 的 host 是否符合条件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"10.20.153.10"</span>.equals(invokers.get(i).getUrl().getHost())) &#123;</span><br><span class="line">            result.add(invokers.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; (invokers)）; <span class="comment">// 表示立即执行方法</span></span><br></pre></td></tr></table></figure><p>可以将上面的脚本进行编码并作为路由规则参数 <strong>rule</strong> 的值添加到 URL 中，该 URL 传入 <code>ScriptRouter</code> 的构造函数时即可被解析。</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScriptRouter</span> <span class="keyword">implements</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ScriptRouter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 脚本类型 与脚本引擎的映射缓存</span></span><br><span class="line"><span class="comment">     * key：脚本语言的名称</span></span><br><span class="line"><span class="comment">     * value: 脚本引擎</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, ScriptEngine&gt; engines = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ScriptEngine&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 脚本路由规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScriptEngine engine;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由规则优先级，用于排序，该字段值越大，优先级越高，默认值为 0。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前 ScriptRouter 使用的具体脚本内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String rule;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由规则 URL，可以从 rule 参数中获取具体的路由规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- ScriptRouter</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ScriptRouter</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="comment">// 获取脚本类型和路由优先级</span></span><br><span class="line">        String type = url.getParameter(Constants.TYPE_KEY);</span><br><span class="line">        <span class="keyword">this</span>.priority = url.getParameter(Constants.PRIORITY_KEY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取脚本内容</span></span><br><span class="line">        String rule = url.getParameterAndDecoded(Constants.RULE_KEY);</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span> || type.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            type = Constants.DEFAULT_SCRIPT_TYPE_KEY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rule == <span class="keyword">null</span> || rule.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="keyword">new</span> IllegalStateException(<span class="string">"route rule can not be empty. rule:"</span> + rule));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据脚本类型获取对应的脚本引擎</span></span><br><span class="line">        ScriptEngine engine = engines.get(type);</span><br><span class="line">        <span class="keyword">if</span> (engine == <span class="keyword">null</span>) &#123;</span><br><span class="line">            engine = <span class="keyword">new</span> ScriptEngineManager().getEngineByName(type);</span><br><span class="line">            <span class="keyword">if</span> (engine == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported route rule type: "</span> + type + <span class="string">", rule: "</span> + rule));</span><br><span class="line">            &#125;</span><br><span class="line">            engines.put(type, engine);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">        <span class="keyword">this</span>.rule = rule;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ScriptRouter</code> 构造方法会获取传入URL中的脚本内容，以及获取脚本类型，并根据脚本类型创建脚本引擎，脚本引擎主要用于编译和执行脚本。</p><h3 id="服务路由-1"><a href="#服务路由-1" class="headerlink" title="服务路由"></a>服务路由</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">+--- ScriptRouter</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            List&lt;Invoker&lt;T&gt;&gt; invokersCopy = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(invokers);</span><br><span class="line"></span><br><span class="line">            Compilable compilable = (Compilable) engine;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 Bindings 对象作为</span></span><br><span class="line">            Bindings bindings = engine.createBindings();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 与前面的 javascript的示例脚本结合，这里在 Bindings 中为脚本中的route()函数提供了 invokers、Invocation、context 三个参数</span></span><br><span class="line">            bindings.put(<span class="string">"invokers"</span>, invokersCopy);</span><br><span class="line">            bindings.put(<span class="string">"invocation"</span>, invocation);</span><br><span class="line">            bindings.put(<span class="string">"context"</span>, RpcContext.getContext());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用脚本引擎编译脚本</span></span><br><span class="line">            CompiledScript function = compilable.compile(rule);</span><br><span class="line">            <span class="comment">// 执行脚本</span></span><br><span class="line">            Object obj = function.eval(bindings);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据结果类型，转换成 (List&lt;Invoker&lt;T&gt;&gt; 类型返回</span></span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Invoker[]) &#123;</span><br><span class="line">                invokersCopy = Arrays.asList((Invoker&lt;T&gt;[]) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">                invokersCopy = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (Object inv : (Object[]) obj) &#123;</span><br><span class="line">                    invokersCopy.add((Invoker&lt;T&gt;) inv);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokersCopy = (List&lt;Invoker&lt;T&gt;&gt;) obj;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> invokersCopy;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ScriptException e) &#123;</span><br><span class="line">            <span class="comment">//fail then ignore rule .invokers.</span></span><br><span class="line">            logger.error(<span class="string">"route error , rule has been ignored. rule: "</span> + rule + <span class="string">", method:"</span> + invocation.getMethodName() + <span class="string">", url: "</span> + RpcContext.getContext().getUrl(), e);</span><br><span class="line">            <span class="keyword">return</span> invokers;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ScriptRouter</code> 服务路由相对比较简单，主要依靠 JDK 的脚本引擎对象，对脚本编译、执行，最终获取路由后的 Invoker 集合。</p><h1 id="FileRouterFactory"><a href="#FileRouterFactory" class="headerlink" title="FileRouterFactory"></a>FileRouterFactory</h1><p><code>FileRouterFactory</code> 是 <code>ScriptRouterFactory</code> 的装饰器，基于文件读取路由规则。在 <code>ScriptRouterFactory</code> 基础上增加了读取文件的能力，使用方可以将 <code>ScriptRouter</code> 使用的路由规则保存到文件中，然后在 URL 中指定文件路径，<code>FileRouterFactory</code> 从中解析到该脚本文件的路径并进行读取，然后调用 <code>ScriptRouterFactory</code> 去创建相应的 ScriptRouter 对象。</p><h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileRouterFactory</span> <span class="keyword">implements</span> <span class="title">RouterFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拓展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"file"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RouterFactory$Adaptive 对象, Dubbo IOC注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> RouterFactory routerFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRouterFactory</span><span class="params">(RouterFactory routerFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.routerFactory = routerFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取路由"><a href="#获取路由" class="headerlink" title="获取路由"></a>获取路由</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">+--- FileRouterFactory</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Router <span class="title">getRouter</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// router 配置项，默认为 script</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 file 协议的 URL 转换成 script 协议的 URL</span></span><br><span class="line">            <span class="comment">// file:///d:/path/to/route.js?router=script ==&gt; script:///d:/path/to/route.js?type=js&amp;rule=&lt;file-content&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 获取 router 配置项，默认为 script</span></span><br><span class="line">            <span class="comment">// Replace original protocol (maybe 'file') with 'script'</span></span><br><span class="line">            String protocol = url.getParameter(Constants.ROUTER_KEY, ScriptRouterFactory.NAME);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用文件后缀作为类型，如：js、groovy</span></span><br><span class="line">            String type = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 获取path</span></span><br><span class="line">            String path = url.getPath();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 获取脚本文件的语言类型</span></span><br><span class="line">            <span class="keyword">if</span> (path != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> i = path.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    type = path.substring(i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 从文件中读取路由规则，作为 ScriptRouter 的路由规则</span></span><br><span class="line">            String rule = IOUtils.read(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(url.getAbsolutePath())));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 创建script协议的URL</span></span><br><span class="line">            <span class="keyword">boolean</span> runtime = url.getParameter(Constants.RUNTIME_KEY, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 5.1 protocol 决定使用哪种路由，默认为script</span></span><br><span class="line">            URL script = url.setProtocol(protocol)</span><br><span class="line">                    <span class="comment">// 5.2 type，如：js</span></span><br><span class="line">                    .addParameter(Constants.TYPE_KEY, type)</span><br><span class="line">                    <span class="comment">// 5.3 runtime</span></span><br><span class="line">                    .addParameter(Constants.RUNTIME_KEY, runtime)</span><br><span class="line">                    <span class="comment">// 5.4 路由规则 rule</span></span><br><span class="line">                    .addParameterAndEncoded(Constants.RULE_KEY, rule);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取script对应的Router实现</span></span><br><span class="line">            <span class="keyword">return</span> routerFactory.getRouter(script);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><code>FileRouterFactory</code> 核心有两点：其一，将路由规则从脚本文件读取到内存，将作为脚本路由的规则；其二，完成 <code>file协议</code> 的 URL 到 <code>script协议</code> 的 URL 的转换，即基于 <code>file协议</code> 的URL 构建一个 <code>script协议</code> 的 URL 。有了以上两点，就可以实现基于 <code>ScriptRouterFactory</code> 基础增加读取文件内容的能力。</p><h1 id="TagRouterFactory-amp-TagRouter"><a href="#TagRouterFactory-amp-TagRouter" class="headerlink" title="TagRouterFactory &amp; TagRouter"></a>TagRouterFactory &amp; TagRouter</h1><p>标签路由是 Dubbo 2.7.x 支持的路由规则。</p><h2 id="TagRouterFactory"><a href="#TagRouterFactory" class="headerlink" title="TagRouterFactory"></a>TagRouterFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Activate</span>(order = <span class="number">100</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TagRouterFactory</span> <span class="keyword">extends</span> <span class="title">CacheableRouterFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"tag"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Router <span class="title">createRouter</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 TagRouter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TagRouter(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TagRouter"><a href="#TagRouter" class="headerlink" title="TagRouter"></a>TagRouter</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>标签路由通过将某一个或多个服务的提供者划分到同一个分组</strong>，约束流量只在指定分组中流转，从而实现流量隔离的目的，可以作为灰度发布等场景的基础。</p><h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p><strong>标签主要是指对 Provider 端应用实例的分组</strong>，目前有两种方式可以完成实例分组，分别是 <code>动态规则打标</code> 和 <code>静态规则打标</code> ，其中动态规则相较于静态规则优先级更高，当两种规则同时存在且出现冲突时，以动态规则为准。</p><h4 id="动态打标"><a href="#动态打标" class="headerlink" title="动态打标"></a>动态打标</h4><p>可随时在 <strong>服务治理平台</strong> 动态下发标签</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># governance-tagrouter-provider应用增加了两个标签分组tag1和tag2</span><br><span class="line"># tag1包含一个实例 127.0.0.1:20880</span><br><span class="line"># tag2包含一个实例 127.0.0.1:20881</span><br><span class="line">---</span><br><span class="line">  force: false</span><br><span class="line">  runtime: true</span><br><span class="line">  enabled: true</span><br><span class="line">  key: governance-tagrouter-provider</span><br><span class="line">  tags:</span><br><span class="line">    - name: tag1</span><br><span class="line">      addresses: ["127.0.0.1:20880"]</span><br><span class="line">    - name: tag2</span><br><span class="line">      addresses: ["127.0.0.1:20881"]</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p><strong>动态打标规则详解：</strong></p><ol><li><code>key</code> 明确规则体作用到哪个应用。必填。</li><li><code>enabled=true</code> 当前路由规则是否生效，可不填，缺省生效。</li><li><code>force=false</code> 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效，可不填，缺省为 false。</li><li><code>runtime=false</code> 是否在每次调用时执行路由规则，否则只在提供者地址列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。如果用了参数路由，必须设为 true，需要注意设置会影响调用的性能，可不填，缺省为 false。</li><li><code>priority=1</code> 路由规则的优先级，用于排序，优先级越大越靠前执行，可不填，缺省为 0。</li><li><code>tags</code> 定义具体的标签分组内容，可定义任意n（n&gt;=1）个标签并为每个标签指定实例列表。必填。<ul><li>name， 标签名称</li><li>addresses，当前标签包含的实例列表（标签对应的服务节点地址列表）</li></ul></li></ol><h4 id="静态打标"><a href="#静态打标" class="headerlink" title="静态打标"></a>静态打标</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 全局服务级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:provider</span> <span class="attr">tag</span>=<span class="string">"tag1"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--服务接口级别--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">tag</span>=<span class="string">"tag1"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>Consumer 端可以在 <code>RpcContext</code> 的 <code>attachment</code> 中添加 <code>request.tag</code> 附加属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 硬编码</span></span><br><span class="line">RpcContext.getContext().setAttachment(Constants.REQUEST_TAG_KEY,<span class="string">"tag1"</span>);</span><br><span class="line"><span class="comment">// 配置</span></span><br><span class="line">&lt;dubbo:reference  tag=<span class="string">"tag1"</span>/&gt;</span><br></pre></td></tr></table></figure><p>请求标签的作用域为每一次 Invocation，使用 <code>attachment</code> 来传递请求标签，注意保存在 <code>attachment</code> 中的值将会在一次完整的远程调用中持续传递，得益于这样的特性，我们只需要在起始调用时进行设置，就可以达到标签的持续传递。</p><h3 id="标签路由规则"><a href="#标签路由规则" class="headerlink" title="标签路由规则"></a>标签路由规则</h3><ol><li>当设置 <code>request.tag=tag1</code> 时优先选择标记了 <code>tag=tag1</code> 的 Provider。若 Provider 集群中不存在与请求 Tag 对应的 Provider 节点，则默认将降级请求 Tag 为空的 Provider 节点；如果希望在找不到匹配 Tag 的 Provider 节点时抛出异常，需要设置 <code>request.tag.force=true</code> 。</li><li>当 <code>request.tag</code> 未设置时，只会匹配 Tag 为空的 Provider 节点，即使集群中存在可用的服务，若 Tag 不匹配也无法调用。也就是说：<strong>携带 Tag 的请求可以降级访问到无 Tag 的 Provider，但不携带 Tag 的请求永远无法访问到带有 Tag 的 Provider</strong>。</li></ol><h3 id="Tag-使用"><a href="#Tag-使用" class="headerlink" title="Tag 使用"></a>Tag 使用</h3><p>基于 Tag 的测试环境隔离方案</p><p>在开发测试中，如果针对每个需求分别独立出一套测试环境的话，会占用大量机器并且维护成本也都比较高。此时，我们就可以通过标签路由实现环境隔离，对 Provider 进行打标，消费方配置目标服务的标签即可。</p><h3 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TagRouter</span> <span class="keyword">extends</span> <span class="title">AbstractRouter</span> <span class="keyword">implements</span> <span class="title">ConfigurationListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TagRouter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"TAG_ROUTER"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAG_ROUTER_DEFAULT_PRIORITY = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RULE_SUFFIX = <span class="string">".tag-router"</span>;</span><br><span class="line">    <span class="keyword">private</span> String application;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标签路由规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> TagRouterRule tagRouterRule;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TagRouter</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line">        <span class="comment">// 设置优先级</span></span><br><span class="line">        <span class="keyword">this</span>.priority = TAG_ROUTER_DEFAULT_PRIORITY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>TagRouter</code> 中持有 <code>TagRouterRule</code> 对象引用，它表示一个标签路由规则，该对象主要用于动态打标的方式，下面我们对其进行简单介绍。</p><h4 id="TagRouterRule"><a href="#TagRouterRule" class="headerlink" title="TagRouterRule"></a>TagRouterRule</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TagRouterRule</span> <span class="keyword">extends</span> <span class="title">AbstractRouterRule</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tag 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Tag&gt; tags;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * address 到 tag 名称的映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; addressToTagnames = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * tag 名称到 address 的映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;String&gt;&gt; tagnameToAddresses = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Tag 集合初始化 addressToTagnames 和 tagnameToAddresses</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isValid()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tags.stream().filter(tag -&gt; CollectionUtils.isNotEmpty(tag.getAddresses())).forEach(tag -&gt; &#123;</span><br><span class="line">            <span class="comment">// tag 名称 到 address 的映射</span></span><br><span class="line">            tagnameToAddresses.put(tag.getName(), tag.getAddresses());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// address 到 tag 名称的映射</span></span><br><span class="line">            tag.getAddresses().forEach(addr -&gt; &#123;</span><br><span class="line">                List&lt;String&gt; tagNames = addressToTagnames.computeIfAbsent(addr, k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                tagNames.add(tag.getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略获取 Tag 集合中地址、标签名信息等方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TagRouterRule</code> 主要为动态打标服务，继承了 <code>AbstractRouterRule</code> , 其中定义了路由规则的公用属性。 </p><h4 id="AbstractRouterRule"><a href="#AbstractRouterRule" class="headerlink" title="AbstractRouterRule"></a>AbstractRouterRule</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRouterRule</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由规则解析前的原始字符串配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String rawRule;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示是否在每次调用时执行该路由规则。</span></span><br><span class="line"><span class="comment">     * 如果设置为 false，则会在 Provider 列表变更时预先执行并缓存结果，调用时直接从缓存中获取路由结果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> runtime = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当路由结果为空时，是否强制执行，如果不强制执行，路由结果为空的路由规则将自动失效。该字段默认值为 false。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> force = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标识解析生成当前 RouterRule 对象的配置是否合法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标识当前路由规则是否生效。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于表示当前 RouterRule 的优先级。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示该路由规则是否为持久数据，当注册方退出时，路由规则是否依然存在。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> dynamic = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 范围：application/service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String scope;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 明确规则体作用在哪个服务或应用</span></span><br><span class="line"><span class="comment">     * 1 scope 为 service: 由 [&#123;group&#125;:]&#123;service&#125;[:&#123;version&#125;] 构成</span></span><br><span class="line"><span class="comment">     * 2 scope 为 application: application</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，<code>TagRouterRule</code> 中维护了一个 Tag 集合，因为一个标签路由规则支持多个 Tag，而每个 Tag 对象中维护了一个 Tag 名称，以及该 Tag 绑定的服务节点网络地址集合。</p><h4 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tag</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tag 名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tag 绑定的网络地址集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; addresses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>标签路由规则如下：</strong></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-router-tag-context.jpg" alt></p><h3 id="解析标签路由规则"><a href="#解析标签路由规则" class="headerlink" title="解析标签路由规则"></a>解析标签路由规则</h3><p><code>TagRouter</code> 实现了 <code>ConfigurationListener</code> 接口，用于监听配置的变化，用于更新动态打标信息，其中就包括 <code>TagRouterRule</code> 配置的变更。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- TagRouter</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听配置的变化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event config change event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ConfigChangedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Notification of tag rule, change type is: "</span> + event.getChangeType() + <span class="string">", raw rule is:\n "</span> +</span><br><span class="line">                    event.getContent());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 DELETED 事件会直接清空 tagRouterRule</span></span><br><span class="line">            <span class="keyword">if</span> (event.getChangeType().equals(ConfigChangeType.DELETED)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.tagRouterRule = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2  其它事件会解析最新的路由规则，并记录到 tagRouterRule 字段中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 通过 TagRuleParser 解析配置</span></span><br><span class="line">                <span class="keyword">this</span>.tagRouterRule = TagRuleParser.parse(event.getContent());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Failed to parse the raw tag router rule and it will not take effect, please check if the "</span> +</span><br><span class="line">                    <span class="string">"rule matches with the template, the raw rule is:\n "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>TagRuleParser</code> 用于解析 <code>yaml</code> 格式的 <code>TagRouterRule</code> 配置，将规则配置信息读入到 <code>TagRouterRule</code> 中。</p><h3 id="服务路由-2"><a href="#服务路由-2" class="headerlink" title="服务路由"></a>服务路由</h3><p>路由的最终目的是要过滤符合条件的 Invoker 对象，下面我们就来看 <code>TagRouter</code> 是如何使用 <code>TagRouterRule</code> 路由逻辑进行 Invoker 过滤的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">+--- TagRouter</span><br><span class="line"> <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 服务路由</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers   invoker list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url        refer url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// 1 如果 invokers 为空，直接返回空集合</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 优先使用动态规则</span></span><br><span class="line">        <span class="comment">// 检查动态规则 tagRouterRule 是否可用，如果不可用，则调用 filterUsingStaticTag 方法使用静态规则进行过滤</span></span><br><span class="line">        <span class="keyword">final</span> TagRouterRule tagRouterRuleCopy = tagRouterRule;</span><br><span class="line">        <span class="keyword">if</span> (tagRouterRuleCopy == <span class="keyword">null</span> || !tagRouterRuleCopy.isValid() || !tagRouterRuleCopy.isEnabled()) &#123;</span><br><span class="line">            <span class="keyword">return</span> filterUsingStaticTag(invokers, url, invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用动态规则</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; result = invokers;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取此次请求的 tag 信息，尝试从 Invocation 以及 URL 中获取</span></span><br><span class="line">        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :</span><br><span class="line">                invocation.getAttachment(TAG_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 此次请求指定了 tag (优先选择tag对应的Provider，如果没有Provider则降级处理，选择 tag 为空的 Provider)</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(tag)) &#123;</span><br><span class="line">            <span class="comment">// 4.1 从动态规则中获取请求 tag 对应的 address 集合</span></span><br><span class="line">            List&lt;String&gt; addresses = tagRouterRuleCopy.getTagnameToAddresses().get(tag);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(addresses)) &#123;</span><br><span class="line">                <span class="comment">// 4.1.2 根据请求 tag 对应的 address 集合去匹配符合条件的 Invoker</span></span><br><span class="line">                result = filterInvoker(invokers, invoker -&gt; addressMatches(invoker.getUrl(), addresses));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果存在符合条件的Invoker，则直接将过滤得到的Invoker集合返回。否则，根据force配置决定是否返回空Invoker集合</span></span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(result) || tagRouterRuleCopy.isForce()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4.2 如果请求 tag 没有对应 address</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4.2.1 将请求携带的 tag 与 Provider URL 中的 tag 参数值进行比较，匹配出符合条件的 Invoker 集合。</span></span><br><span class="line">                result = filterInvoker(invokers, invoker -&gt; tag.equals(invoker.getUrl().getParameter(TAG_KEY)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.3 存在符合条件的Invoker 或是 force=true，则直接返回过滤后的结果</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(result) || isForceUseTag(invocation)) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.4 如果 Invoker 过滤后的结果为空，且 force 配置为 false，则返回所有不包含任何 tag 的 Provider 列表。(降级)</span></span><br><span class="line">            <span class="comment">// FAILOVER: return all Providers without any tags.</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;Invoker&lt;T&gt;&gt; tmp = filterInvoker(invokers, invoker -&gt; addressNotMatches(invoker.getUrl(), tagRouterRuleCopy.getAddresses()));</span><br><span class="line">                <span class="keyword">return</span> filterInvoker(tmp, invoker -&gt; StringUtils.isEmpty(invoker.getUrl().getParameter(TAG_KEY)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 如果此次请求未携带 tag 信息（只匹配tag为空的Provier）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// List&lt;String&gt; addresses = tagRouterRule.filter(providerApp);</span></span><br><span class="line">            <span class="comment">// return all addresses in dynamic tag group.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.1 获取 TagRouterRule 规则中全部 tag 关联的 address 集合</span></span><br><span class="line">            List&lt;String&gt; addresses = tagRouterRuleCopy.getAddresses();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.2 如果 address 集合不为空，则过滤出不在 address 集合中的 Invoker 并添加到结果集合中。</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(addresses)) &#123;</span><br><span class="line">                result = filterInvoker(invokers, invoker -&gt; addressNotMatches(invoker.getUrl(), addresses));</span><br><span class="line">                <span class="comment">// 1. all addresses are in dynamic tag group, return empty list.</span></span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isEmpty(result)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2. if there are some addresses that are not in any dynamic tag group, continue to filter using the</span></span><br><span class="line">                <span class="comment">// static tag group.</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.3 将 Provider URL 中的 tag 值与 TagRouterRule 中的 tag 名称进行比较，过滤出不匹配的 tag，得到最终的 Invoker 集合。</span></span><br><span class="line">            <span class="keyword">return</span> filterInvoker(result, invoker -&gt; &#123;</span><br><span class="line">                String localTag = invoker.getUrl().getParameter(TAG_KEY);</span><br><span class="line">                <span class="keyword">return</span> StringUtils.isEmpty(localTag) || !tagRouterRuleCopy.getTagNames().contains(localTag);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>进行标签路由时，如果动态规则为空或不可用，则使用静态规则。使用静态规则路由规则如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+--- TagRouter</span><br><span class="line"> <span class="keyword">private</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; filterUsingStaticTag(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; result = invokers;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取请求携带的 tag</span></span><br><span class="line">        <span class="comment">// Dynamic param</span></span><br><span class="line">        String tag = StringUtils.isEmpty(invocation.getAttachment(TAG_KEY)) ? url.getParameter(TAG_KEY) :</span><br><span class="line">                invocation.getAttachment(TAG_KEY);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 请求携带了 tag</span></span><br><span class="line">        <span class="comment">// Tag request</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(tag)) &#123;</span><br><span class="line">            <span class="comment">// 2.1 比较请求携带的 tag 值与 Provider URL 中的 tag 参数值</span></span><br><span class="line">            result = filterInvoker(invokers, invoker -&gt; tag.equals(invoker.getUrl().getParameter(TAG_KEY)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.2 集群中不存在与请求tag对应的服务，默认降级请求 tag 为空的 Provider。</span></span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isEmpty(result) &amp;&amp; !isForceUseTag(invocation)) &#123;</span><br><span class="line">                result = filterInvoker(invokers, invoker -&gt; StringUtils.isEmpty(invoker.getUrl().getParameter(TAG_KEY)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 请求没有携带 tag，只会匹配 tag 为空的 Provider 。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = filterInvoker(invokers, invoker -&gt; StringUtils.isEmpty(invoker.getUrl().getParameter(TAG_KEY)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从代码层面上验证了前文提到的标签路由规则，下面对服务路由进行概述：</p><ol><li>请求指定了<code>tag</code>信息<ul><li>优先选择<code>tag</code>对应的<code>Provider</code></li><li>降级请求<code>tag</code>为空的<code>provider</code></li></ul></li><li>请求未指定<code>tag</code>信息<ul><li>只需匹配<code>tag</code>为空的Provider   </li></ul></li></ol><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>标签路由是通过动态或静态打标的方式为服务提供者设置 Tag。其中动态打标方式的规则存储到 <code>TagRouterRule</code> 对象中，是通过 <code>&lt;tag名称，Provider节点地址集合&gt;</code> 映射关系体现过滤规则的。静态打标方式的规则是作为配置信息存储到提供者URL中的，是通过 <code>tag</code> 参数体现过滤规则的。当消费请求进来，会通过 <code>TagRouterRule</code> 和 <code>tag</code> 参数进行 Invoker 列表的过滤。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章中对 <code>条件路由</code>、<code>脚本路由</code>、<code>文件路由</code> 进行了介绍，最后对 Dubbo 2.7.x 中新支持的 <code>标签路由</code> 进行了介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Dubbo 中的路由 &lt;code&gt;Router&lt;/code&gt; 的主要功能就是根据用户配置的路由规则以及请求携带信息，过滤出符合条件的 Inv
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>集群容错 - 动态配置</title>
    <link href="https://gentryhuang.com/posts/a965bdb8/"/>
    <id>https://gentryhuang.com/posts/a965bdb8/</id>
    <published>2020-09-22T23:00:00.000Z</published>
    <updated>2021-04-06T08:32:25.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在介绍动态服务目录 <code>RegistryDirectory</code> 相关内容时，提到了 <code>RegistryDirectory</code> 会监听注册中心的 <code>providers</code>、<code>routers</code> 和 <code>configurators</code> 三个目录，当配置变更时会做出相应的处理。此外在服务暴露过程中，服务提供者会向注册中心注册监听器，监听 <code>configurators</code> 目录下数据的变更。本篇文章对 Dubbo 动态配置进行分析，并对 <code>Configurator</code> 的集成进行介绍。<code>Configurator</code> 相关类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-configurator-uml.jpg" alt></p><p>覆盖规则是 Dubbo 设计的在无需重启应用的情况下，动态调整 RPC 调用行为的一种能力。从 2.7.0 版本开始，支持从服务和应用两个粒度来调整动态配置。</p><h1 id="基础协议"><a href="#基础协议" class="headerlink" title="基础协议"></a>基础协议</h1><p>在分析源码之前，我们先了解下动态配置的两种协议。下面以 <code>override</code> 协议为例：</p><blockquote><p>override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;enabled=true&amp;application=foo&amp;timeout=1000</p></blockquote><p>下面对上述 URL 进行解析：</p><ul><li><code>override://</code> 表示数据采用覆盖方式，Dubbo 支持 <code>override</code> 和 <code>absent</code> 两种协议，可扩展，必填。</li><li><code>0.0.0.0</code> 表示对所有 IP 地址生效，如果只想覆盖某个 IP 的数据，请填入具体 IP，必填。</li><li><code>com.foo.BarService</code> 表示只对指定的服务生效，必填。</li><li><code>category=configurators</code> 表示该 URL 为动态配置类型，必填。</li><li><code>dynamic=false</code> 表示该 URL 为持久数据，即使注册该 URL 的节点退出，该 URL 依旧会保存在注册中心，必填。</li><li><code>enabled=true</code> 表示该 URL 的覆盖规则生效，可不填，缺省生效。</li><li><code>application=foo</code> 表示只对指定应用生效，可不填，表示对所有应用生效。</li><li><code>timeout=1000</code> 表示将满足以上条件的 URL 中的 <code>timeout</code> 参数的值覆盖为 1000 。如果想覆盖其他配置，可以直接以参数的形式添加到 override URL 之上。</li></ul><p><strong>使用示例：</strong></p><ol><li>禁用某个提供者（通常用于临时剔除某个 Provider 节点）<blockquote><p>override://10.20.153.10/com.foo.BarService?category=configurators&amp;dynamic=false&amp;disbaled=true</p></blockquote></li><li>调整某个提供者的权重（通常用于容量评估，缺省权重为 100）<blockquote><p>override://10.20.153.10/com.foo.BarService?category=configurators&amp;dynamic=false&amp;weight=200</p></blockquote></li><li>调整负载均衡策略（缺省负载均衡策略为 random）<blockquote><p>override://10.20.153.10/com.foo.BarService?category=configurators&amp;dynamic=false&amp;loadbalance=leastactive</p></blockquote></li><li>服务降级（通常用于临时屏蔽某个出错的非关键服务）<blockquote><p>override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null</p></blockquote></li></ol><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="ConfiguratorFactory"><a href="#ConfiguratorFactory" class="headerlink" title="ConfiguratorFactory"></a>ConfiguratorFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfiguratorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 Configurator 配置规则对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url - configurator url.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> configurator instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(<span class="string">"protocol"</span>)</span><br><span class="line">    <span class="function">Configurator <span class="title">getConfigurator</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConfiguratorFactory</code> 是 Dubbo 的一个扩展点，没有默认的扩展实现。作为 <code>Configurator</code> 工厂接口，其中的 <code>@Adaptive(&quot;protocol&quot;)</code> 注解会基于 Dubbo 自适应扩展机制获取 <code>ConfiguratorFactory</code> 具体实现，即根据配置规则 URL 的 <code>protocol</code> 属性获取 <code>Configurator</code> 实现。目前配置 URL 的协议支持 <code>override</code> 和 <code>absent</code> 两种，对应的实现分别为 <code>OverrideConfiguratorFactory</code> 和 <code>AbsentConfiguratorFactory</code> 。</p><h3 id="OverrideConfiguratorFactory"><a href="#OverrideConfiguratorFactory" class="headerlink" title="OverrideConfiguratorFactory"></a>OverrideConfiguratorFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideConfiguratorFactory</span> <span class="keyword">implements</span> <span class="title">ConfiguratorFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Configurator <span class="title">getConfigurator</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 OverrideConfigurator 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OverrideConfigurator(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AbsentConfiguratorFactory"><a href="#AbsentConfiguratorFactory" class="headerlink" title="AbsentConfiguratorFactory"></a>AbsentConfiguratorFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsentConfiguratorFactory</span> <span class="keyword">implements</span> <span class="title">ConfiguratorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Configurator <span class="title">getConfigurator</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 AbsentConfigurator</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbsentConfigurator(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Configurator"><a href="#Configurator" class="headerlink" title="Configurator"></a>Configurator</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Configurator</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Configurator</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得配置URL，里面带有配置规则</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> configurator url.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 Configurator 应用到 URL</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url - old rovider url.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> new provider url.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">URL <span class="title">configure</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Configurator</code> 接口抽象了一条配置信息，即一个 <code>Configurator</code> 对象对应一条配置规则。需要注意的是，该接口实现了 <code>Comparable</code> 接口，因为 <code>Configurator</code> 有优先级的要求。</p><h3 id="AbstractConfigurator"><a href="#AbstractConfigurator" class="headerlink" title="AbstractConfigurator"></a>AbstractConfigurator</h3><p><code>AbstractConfigurator</code> 作为 <code>Configurator</code> 抽象实现类，实现了公用的配置规则的匹配、排序逻辑，将配置规则应用到目标 URL 上的工作交给了具体子类完成。</p><h4 id="获取配置规则"><a href="#获取配置规则" class="headerlink" title="获取配置规则"></a>获取配置规则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfigurator</span> <span class="keyword">implements</span> <span class="title">Configurator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置规则url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL configuratorUrl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractConfigurator</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"configurator url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.configuratorUrl = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得配置规则URL</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configuratorUrl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用配置准备工作"><a href="#应用配置准备工作" class="headerlink" title="应用配置准备工作"></a>应用配置准备工作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractConfigurator</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置配置规则到指定URl中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 待应用配置规则的URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">configure</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 参数检查，配置规则中必须要有 ip</span></span><br><span class="line">        <span class="keyword">if</span> (configuratorUrl == <span class="keyword">null</span> || configuratorUrl.getHost() == <span class="keyword">null</span> || url == <span class="keyword">null</span> || url.getHost() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> url;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  2 配置规则Url有端口，则说明这个配置规则Url是操作某个服务提供者的，可以通过配置Url的特性参数来控制服务提供者。配置成功后，既可以在服务提供者端生效也可以在服务消费端生效。</span></span><br><span class="line">        <span class="keyword">if</span> (configuratorUrl.getPort() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 配置规则Url有端口，且和待处理的url的端口一致</span></span><br><span class="line">            <span class="keyword">if</span> (url.getPort() == configuratorUrl.getPort()) &#123;</span><br><span class="line">                <span class="comment">// 因为操作的是服务提供者，所以这里使用的是url的host</span></span><br><span class="line">                <span class="keyword">return</span> configureIfMatch(url.getHost(), url);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 配置规则Url没有端口</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  3.1 如果 url 是消费端地址，目的是控制一个特定的消费者实例，只在消费端生效，服务端收到后忽略</span></span><br><span class="line">            <span class="keyword">if</span> (url.getParameter(Constants.SIDE_KEY, Constants.PROVIDER).equals(Constants.CONSUMER)) &#123;</span><br><span class="line">                <span class="comment">// NetUtils.getLocalHost() 是消费端注册到注册中心的地址</span></span><br><span class="line">                <span class="keyword">return</span> configureIfMatch(NetUtils.getLocalHost(), url);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 如果 url 是服务端地址，意图匹配全部服务提供者。【注意：这种情况暂不支持指定机器服务提供者】</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.getParameter(Constants.SIDE_KEY, Constants.CONSUMER).equals(Constants.PROVIDER)) &#123;</span><br><span class="line">                <span class="comment">// 对所有服务端生效，因此地址必须是0.0.0.0，否则它将不会执行到此if分支</span></span><br><span class="line">                <span class="keyword">return</span> configureIfMatch(Constants.ANYHOST_VALUE, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>configure</code> 方法主要的逻辑如下：</p><ol><li>对配置规则和传入的URL进行校验，ip 都不能为空。配置规则决定是否应用到目标URL中，要看配置规则的 ip 是否匹配目标URL中的 ip 值。注意，配置规则URL中的 ip 值如果为 <code>0.0.0.0</code> 表示匹配所有 ip 。</li><li>对配置规则进行判断，有以下三种情况：<ul><li>配置规则URL中有 <code>port</code> ，且和待处理的URL的 <code>port</code> 一致。目的是匹配指定的一个服务提供者 ，因此 <code>ip</code> 使用提供者URL中的 <code>host</code> 属性值。</li><li>配置规则URL中没有 <code>port</code>，传入的URL是消费端URL。目的是匹配指定的一个消费者，因此 <code>ip</code> 使用 <code>NetUtils.getLocalHost()</code> 的值。</li><li>配置规则URL中没有 <code>port</code>，传入的URL是服务端URL。目的是匹配全部提供者，因此 <code>ip</code> 使用 <code>0.0.0.0</code> 。</li></ul></li></ol><p>确定好是对提供者还是消费者后应用配置后，接下来就是对不能动态修改属性的排除工作了，主要逻辑在 <code>configureIfMatch</code> 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractConfigurator</span><br><span class="line"> <span class="function"><span class="keyword">private</span> URL <span class="title">configureIfMatch</span><span class="params">(String host, URL url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 匹配 host</span></span><br><span class="line">        <span class="comment">// 如果配置 url 的 host 为 0.0.0.0，或者配置 url 的 host 等于传入的 host，则继续匹配应用。否则直接返回url</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.ANYHOST_VALUE.equals(configuratorUrl.getHost()) || host.equals(configuratorUrl.getHost())) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 获得配置url中的 application，即应用名</span></span><br><span class="line">            String configApplication = configuratorUrl.getParameter(Constants.APPLICATION_KEY, configuratorUrl.getUsername());</span><br><span class="line">            <span class="comment">// 3 获得传入 url 的application，即应用名</span></span><br><span class="line">            String currentApplication = url.getParameter(Constants.APPLICATION_KEY, url.getUsername());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4 匹配应用， 如果配置url的应用名为null，或者为 "*"，或者和url的应用名相同，则执行配置规则逻辑。</span></span><br><span class="line">            <span class="keyword">if</span> (configApplication == <span class="keyword">null</span> || Constants.ANY_VALUE.equals(configApplication) || configApplication.equals(currentApplication)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5 排除不能动态修改的属性，除了四个内置的，还可以包括  带有"～"开头的key、"application" 、 "side"</span></span><br><span class="line">                Set&lt;String&gt; conditionKeys = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">                <span class="comment">// category</span></span><br><span class="line">                conditionKeys.add(Constants.CATEGORY_KEY);</span><br><span class="line">                <span class="comment">// check</span></span><br><span class="line">                conditionKeys.add(Constants.CHECK_KEY);</span><br><span class="line">                <span class="comment">// dynamic</span></span><br><span class="line">                conditionKeys.add(Constants.DYNAMIC_KEY);</span><br><span class="line">                <span class="comment">// enabled</span></span><br><span class="line">                conditionKeys.add(Constants.ENABLED_KEY);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 遍历配置url的 parameter 参数集合</span></span><br><span class="line"><span class="comment">                 * 1 把符合要求的条件加入到 conditionKeys 中，即：带有"～"开头的key、"application" 、 "side"</span></span><br><span class="line"><span class="comment">                 * 2 判断传入的url是否匹配配置规则Url的条件，注意是parameter部分比较，并且不是整个parameter集合的比较，只是  "～"开头的key 或 "application" 或 "side" 这个三个key/valu的比较</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : configuratorUrl.getParameters().entrySet()) &#123;</span><br><span class="line">                    <span class="comment">// 参数key</span></span><br><span class="line">                    String key = entry.getKey();</span><br><span class="line">                    <span class="comment">// 参数key对应的value</span></span><br><span class="line">                    String value = entry.getValue();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果 配置url的parameter参数的key是： "～" 或 "application" 或 "side"，那么也加入到配置Url的条件集合中，需要剔除，不能参与应用到目标URL</span></span><br><span class="line">                    <span class="keyword">if</span> (key.startsWith(<span class="string">"~"</span>) || Constants.APPLICATION_KEY.equals(key) || Constants.SIDE_KEY.equals(key)) &#123;</span><br><span class="line">                        <span class="comment">// 把key加入到条件集合中，用于剔除</span></span><br><span class="line">                        conditionKeys.add(key);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果目标URL中不存在配置URL中的剔除参数值（以 ～ 开头的参数），则说明url不匹配配置规则，直接返回url</span></span><br><span class="line">                        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !Constants.ANY_VALUE.equals(value) &amp;&amp; !value.equals(url.getParameter(key.startsWith(<span class="string">"~"</span>) ? key.substring(<span class="number">1</span>) : key))) &#123;</span><br><span class="line">                            <span class="keyword">return</span> url;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从配置Url中排除不能动态修改的属性，然后把剩余的属性配置到URL中</span></span><br><span class="line">                <span class="keyword">return</span> doConfigure(url, configuratorUrl.removeParameters(conditionKeys));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>configureIfMatch</code> 方法主要做了三件事：</p><ol><li>通过 <code>ip</code> 判断配置URL是否能够应用到目标URL上，配置URL中的ip支持 <code>0.0.0.0</code> 表示匹配所有ip。</li><li>通过 <code>application</code> 应用名判断配置URL是否能够应用到目标URL上，配置URL中的 application 允许为空或 <code>*</code> ，表示匹配所有应用。</li><li>剔除配置URL中不能动态修改的属性。</li></ol><h4 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractConfigurator</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将配置规则配置到url中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentUrl 目标url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configUrl  配置url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> URL <span class="title">doConfigure</span><span class="params">(URL currentUrl, URL configUrl)</span></span>;</span><br></pre></td></tr></table></figure><p>应用配置规则是一个抽象方法，具体实现交给具体子类实现。</p><h4 id="配置排序"><a href="#配置排序" class="headerlink" title="配置排序"></a>配置排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractConfigurator</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Configurator o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 根据 ip 升序</span></span><br><span class="line">        <span class="keyword">int</span> ipCompare = getUrl().getHost().compareTo(o.getUrl().getHost());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 如果 ip 相同，则按照 priority 降序</span></span><br><span class="line">        <span class="keyword">if</span> (ipCompare == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = getUrl().getParameter(Constants.PRIORITY_KEY, <span class="number">0</span>),</span><br><span class="line">                    j = o.getUrl().getParameter(Constants.PRIORITY_KEY, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> i &lt; j ? -<span class="number">1</span> : (i == j ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ipCompare;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>Configurator</code> 排序首先按照 <code>ip</code> 进行排序，所有 <code>ip</code> 的优先级都高于 <code>0.0.0.0</code>，当 <code>ip</code> 相同时，会按照 <code>priority</code> 参数值进行排序。</p><h3 id="OverrideConfigurator"><a href="#OverrideConfigurator" class="headerlink" title="OverrideConfigurator"></a>OverrideConfigurator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OverrideConfigurator</span> <span class="keyword">extends</span> <span class="title">AbstractConfigurator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法会调用父类的构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OverrideConfigurator</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">doConfigure</span><span class="params">(URL currentUrl, URL configUrl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 覆盖添加，即直接用配置URL中剩余的全部参数，覆盖原始 URL 中相应参数</span></span><br><span class="line">        <span class="keyword">return</span> currentUrl.addParameters(configUrl.getParameters());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>OverrideConfigurator</code> 是一种直接覆盖策略，即直接使用配置URL中剩余的全部参数（在父类中已经剔除了不能动态修改的参数），覆盖原始 URL 中相应参数。</p><h3 id="AbsentConfigurator"><a href="#AbsentConfigurator" class="headerlink" title="AbsentConfigurator"></a>AbsentConfigurator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsentConfigurator</span> <span class="keyword">extends</span> <span class="title">AbstractConfigurator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法会调用父类的构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbsentConfigurator</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">doConfigure</span><span class="params">(URL currentUrl, URL configUrl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试用配置 URL 中的参数添加到原始 URL 中，如果原始 URL 中已经有了该参数是不会被覆盖的</span></span><br><span class="line">        <span class="keyword">return</span> currentUrl.addParametersIfAbsent(configUrl.getParameters());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbsentConfigurator</code> 是一种选择性覆盖策略，当目标URL中不存参数时才会使用配置中的参数。</p><h1 id="Configurator-集成"><a href="#Configurator-集成" class="headerlink" title="Configurator 集成"></a>Configurator 集成</h1><p>Dubbo 框架中集成 <code>Configurator</code> 如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-configurator-use.jpg" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章介绍了 Dubbo 中配置相关实现。首先对配置协议 <code>override</code> 和 <code>absent</code> URL 进行了介绍，然后分析了 <code>Configurator</code> 覆盖目标 URL 的实现，最后列出了 Dubbo 中对 <code>Configuratgor</code> 的集成代码片段。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在介绍动态服务目录 &lt;code&gt;RegistryDirectory&lt;/code&gt; 相关内容时，提到了 &lt;code&gt;RegistryDirec
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>集群容错 - Directory</title>
    <link href="https://gentryhuang.com/posts/e43ac0a6/"/>
    <id>https://gentryhuang.com/posts/e43ac0a6/</id>
    <published>2020-09-18T03:00:00.000Z</published>
    <updated>2021-04-07T11:16:58.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本篇文章对 Dubbo 集群模块中的 <code>Directory</code> 服务目录进行介绍。服务目录 <code>RegistryDirectory</code> 中存储了一些和服务提供者有关的信息（附加服务治理参数），通过服务目录消费者可获取到服务提供者的信息，比如 ip、端口、服务协议等。服务目录本质上是对注册中心上服务配置信息的整合结果，最终会结合配置信息以及消费端信息组装消费端的 <code>Invoker</code> 。服务目录可以看做是 Invoker 的集合，且这个集合中的元素会随注册中心的变化而进行动态调整。 </p><h1 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h1><p>服务目录 <code>Directory</code> 继承关系如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-directory-uml.jpg" alt></p><p>服务目录内置实现分别为 <code>StaticDirectory</code> 和 <code>RegistryDirectory</code> ，前者用于将传入的 <code>Invoker</code> 集合封装成静态的 <code>Directory</code> 对象，后者是基于注册中心的动态 <code>Directory</code> 对象。下面我们从源码层面上分析服务目录的实现。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Directory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得服务接口类型，如：com.alibaba.dubbo.demo.DemoService</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> service type.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的 Invocation 请求返回符合条件的 Invoker 集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> invokers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Directory</code> 接口表示的是一个服务目录，由多个 <code>Invoker</code> 构成，后续的 <code>路由处理</code>、<code>负载均衡</code>、<code>集群容错</code>等都是基于 <code>Directory</code> 实现的。<strong>需要注意的是，一个服务目录 Directory 仅对应一个服务类型，管理的是该类型的多个服务。</strong> 该接口包含了一个重要的方法定义，即 list(Invocation)，用于列举 Invoker。下面我们对它的抽象实现进行说明。</p><h2 id="AbstractDirectory"><a href="#AbstractDirectory" class="headerlink" title="AbstractDirectory"></a>AbstractDirectory</h2><p><code>AbstractDirectory</code> 是 <code>Directory</code> 接口的抽象实现，其中除了维护消费端的 URL 信息，还维护了路由信息。此外，封装了获取 Invoker 列表的流程，具体的逻辑由子类实现。下面我们先来看该抽象实现源码。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Directory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractDirectory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经销毁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> destroyed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者 URL</span></span><br><span class="line"><span class="comment">     * 注意：如果没有显示调用构造方法，那么该属性的值为 url的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> URL consumerUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;Router&gt; routers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDirectory</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(url, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDirectory</span><span class="params">(URL url, List&lt;Router&gt; routers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(url, url, routers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDirectory</span><span class="params">(URL url, URL consumerUrl, List&lt;Router&gt; routers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置url</span></span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="comment">// 设置consumerUrl</span></span><br><span class="line">        <span class="keyword">this</span>.consumerUrl = consumerUrl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置路由数组</span></span><br><span class="line">        setRouters(routers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法中会维护传入的 <strong>注册中心 URL</strong>、<strong>消费端 URL</strong> 以及 <strong>设置路由列表</strong>。在处理路由时，除了保存传入的路由外，如果配置了路由也会将其加入到路由集合中，下面我们看下其实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractDirectory</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setRouters</span><span class="params">(List&lt;Router&gt; routers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 保存传入的路由集合</span></span><br><span class="line">        routers = routers == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;Router&gt;() : <span class="keyword">new</span> ArrayList&lt;Router&gt;(routers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 从URL中取出配置的路由</span></span><br><span class="line">        String routerkey = url.getParameter(Constants.ROUTER_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 如果配置了路由，则获取对应的路由实现，并加入到 routers集合 中</span></span><br><span class="line">        <span class="keyword">if</span> (routerkey != <span class="keyword">null</span> &amp;&amp; routerkey.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">routerkey</span>)</span>;</span><br><span class="line">            routers.add(routerFactory.getRouter(url));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 统一添加 MockInvokersSelector 路由</span></span><br><span class="line">        routers.add(<span class="keyword">new</span> MockInvokersSelector());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 排序</span></span><br><span class="line">        Collections.sort(routers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 放入缓存</span></span><br><span class="line">        <span class="keyword">this</span>.routers = routers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建服务目录时，会同时维护路由，维护的路由由三部分组成，<strong>外部传入的Router</strong> + <strong>配置的Router</strong> + <strong>MockInvokersSelector</strong> 。关于路由的介绍会在后面的文章中单独说明，这里不再展开。</p><h3 id="拉取-Invoker-集合"><a href="#拉取-Invoker-集合" class="headerlink" title="拉取 Invoker 集合"></a>拉取 Invoker 集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractDirectory</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">// 1 服务目录销毁了就直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Directory already destroyed .url: "</span> + getUrl());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 调用 doList 方法获取 Invokers 集合，具体实现交给子类</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 使用路由</span></span><br><span class="line">        List&lt;Router&gt; localRouters = <span class="keyword">this</span>.routers;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用路由规则筛选Invoker集合</span></span><br><span class="line">        <span class="keyword">if</span> (localRouters != <span class="keyword">null</span> &amp;&amp; !localRouters.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Router router : localRouters) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 根据路由的URL值以及 runtime 参数，决定是否进行路由</span></span><br><span class="line"><span class="comment">                     * 注意：</span></span><br><span class="line"><span class="comment">                     *  Router的runtime参数决定是否每次调用服务时都执行路由规则。如果 runtime配置为true，每次调用服务前都需要进行服务路由，这个会对性能会造成影响。</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (router.getUrl() == <span class="keyword">null</span> || router.getUrl().getParameter(Constants.RUNTIME_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 使用路由筛选 Invoker</span></span><br><span class="line">                        invokers = router.route(invokers, getConsumerUrl(), invocation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Failed to execute router: "</span> + getUrl() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 返回路由后的结果</span></span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AbstractDirectory</code> 拉取 Invoker 列表的主要逻辑如下：</p><ol><li>调用子类实现的 doList 方法获取 Invoker 列表。</li><li>使用路由，根据 Router 的 getUrl 返回值是否为空，以及 runtime 参数决定是否进行路由过滤。</li></ol><p>需要说明的是，Router 的 <strong>runtime</strong> 参数决定了是否每次调用服务时都要执行路由规则。如果 <strong>runtime</strong> 为 true，那么每次调用服务前，都需要进行服务路由，这个会对性能造成影响。 </p><h2 id="StaticDirectory"><a href="#StaticDirectory" class="headerlink" title="StaticDirectory"></a>StaticDirectory</h2><p><code>StaticDirectory</code> 实现中维护的 Invoker 集合是静态的，在 <code>StaticDirectory</code> 对象创建完毕后，是不会发生改变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractDirectory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoker 集合，这个集合中的元素是不变的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDirectory</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, invokers, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDirectory</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Router&gt; routers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, invokers, routers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDirectory</span><span class="params">(URL url, List&lt;Invoker&lt;T&gt;&gt; invokers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(url, invokers, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDirectory</span><span class="params">(URL url, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Router&gt; routers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 确定url有效性</span></span><br><span class="line">        <span class="keyword">super</span>(url == <span class="keyword">null</span> &amp;&amp; invokers != <span class="keyword">null</span> &amp;&amp; !invokers.isEmpty() ? invokers.get(<span class="number">0</span>).getUrl() : url, routers);</span><br><span class="line">        <span class="keyword">if</span> (invokers == <span class="keyword">null</span> || invokers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invokers == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.invokers = invokers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Invoker对应的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>).getInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测服务目录是否可用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若已经销毁，则不可用</span></span><br><span class="line">        <span class="keyword">if</span> (isDestroyed()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任意一个Invoker 可用，当前服务目录就可用</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (invoker.isAvailable()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 已销毁，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (isDestroyed()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 销毁</span></span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">        <span class="comment">// 销毁每个 Invoker</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            invoker.destroy();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空Invoker 集合</span></span><br><span class="line">        invokers.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接返回由构造方法传入进来的Invoker 集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RegistryDirectory"><a href="#RegistryDirectory" class="headerlink" title="RegistryDirectory"></a>RegistryDirectory</h2><p><code>RegistryDirectory</code> 是一个动态的 <code>Directory</code> 实现，实现了 <code>NotifyListener</code> 接口，<strong>订阅注册中心的数据，实现监听功能</strong>。当注册中心的服务配置发生变更时，会触发回调 <code>NotifyListener.notify</code> 方法，<code>RegistryDirectory</code> 收到变更通知后会根据注册中心推送的通知，重新引用服务，即 <strong>刷新 Invoker 列表</strong>。该实现类为了让本地服务目录和注册中心的服务信息保持一致做了很多的工作，下文我们一一分析。</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">NotifyListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RegistryDirectory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集群扩展实现 Cluster$Adaptive 对象 - 对同组 Invoker 进行合并</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cluster cluster = ExtensionLoader.getExtensionLoader(Cluster<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由工厂扩展实现 RouterFactory$Adaptive对象 - 创建路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RouterFactory routerFactory = ExtensionLoader.getExtensionLoader(RouterFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置规则工厂实现 ConfiguratorFactory$Adaptive 对象 - 创建配置对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConfiguratorFactory configuratorFactory = ExtensionLoader.getExtensionLoader(ConfiguratorFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心URL的服务键， 如：com.alibaba.dubbo.registry.RegistryService</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String serviceKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口类型，如：com.alibaba.dubbo.demo.DemoService</span></span><br><span class="line"><span class="comment">     * 每一个服务引用都对应一个服务目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; serviceType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务消费者 URL 的配置项 Map。即 Consumer URL 中 refer 参数解析后得到的全部 KV</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; queryMap;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只保留 Consumer 属性的 URL，也就是由 queryMap 集合重新生成的 URL，URL 主体仍然是注册中心的 URL信息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL directoryUrl;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用的服务接口方法数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] serviceMethods;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否引用多个服务分组 - 服务分组概念</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> multiGroup;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心的Protocol 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Protocol protocol;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Registry registry;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否禁止访问：</span></span><br><span class="line"><span class="comment">     * 1 当没有服务提供者</span></span><br><span class="line"><span class="comment">     * 2 当服务提供者被禁用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> forbidden = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结合配置规则，重写原始目录URL得到的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> URL overrideDirectoryUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置规则数组</span></span><br><span class="line"><span class="comment">     * override rules</span></span><br><span class="line"><span class="comment">     * Priority: override&gt;-D&gt;consumer&gt;provider</span></span><br><span class="line"><span class="comment">     * Rule one: for a certain provider &lt;ip:port,timeout=100&gt;</span></span><br><span class="line"><span class="comment">     * Rule two: for all providers &lt;* ,timeout=5000&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> List&lt;Configurator&gt; configurators;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;服务提供者URL合并处理后的URL串,服务引用创建的Invoker&gt;</span></span><br><span class="line"><span class="comment">     * Map&lt;url, Invoker&gt; cache service url to invoker mapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Invoker&lt;T&gt;&gt; urlInvokerMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法名与引用Invoker集合的映射</span></span><br><span class="line"><span class="comment">     * Map&lt;methodName, Invoker&gt; cache service method to invokers mapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; methodInvokerMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前缓存的所有 Provider 的 URL</span></span><br><span class="line"><span class="comment">     * Set&lt;invokerUrls&gt; cache invokeUrls to invokers mapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Set&lt;URL&gt; cachedInvokerUrls;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，根据注册中心URL初始化相关属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceType 服务接口类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url         注册中心 URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegistryDirectory</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类构造方法</span></span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line">        <span class="comment">// 如果服务类型为空，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (serviceType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"service type is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Url对应的服务键为空，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (url.getServiceKey() == <span class="keyword">null</span> || url.getServiceKey().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"registry serviceKey is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置服务类型 和 注册中心URL的服务键</span></span><br><span class="line">        <span class="keyword">this</span>.serviceType = serviceType;</span><br><span class="line">        <span class="keyword">this</span>.serviceKey = url.getServiceKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置服务消费者 URL 的配置项 Map，即解析 refer 参数值，得到 Consumer 的配置参数 parameters 的值</span></span><br><span class="line">        <span class="keyword">this</span>.queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造的时候，this.overrideDirectoryUrl == this.directoryUrl</span></span><br><span class="line">        <span class="comment">// 将 queryMap 中的 KV 作为参数，重新构造 URL，URL主体不变</span></span><br><span class="line">        <span class="keyword">this</span>.overrideDirectoryUrl = <span class="keyword">this</span>.directoryUrl = url.setPath(url.getServiceInterface()).clearParameters().addParameters(queryMap).removeParameter(Constants.MONITOR_KEY);</span><br><span class="line">        <span class="comment">// 从消费者配置项中获取分组参数</span></span><br><span class="line">        String group = directoryUrl.getParameter(Constants.GROUP_KEY, <span class="string">""</span>);</span><br><span class="line">        <span class="comment">// 设置多分组标识</span></span><br><span class="line">        <span class="keyword">this</span>.multiGroup = group != <span class="keyword">null</span> &amp;&amp; (<span class="string">"*"</span>.equals(group) || group.contains(<span class="string">","</span>));</span><br><span class="line">        <span class="comment">// 从消费者配置项中获取服务方法串</span></span><br><span class="line">        String methods = queryMap.get(Constants.METHODS_KEY);</span><br><span class="line">        <span class="comment">// 设置引用服务接口中的方法数组</span></span><br><span class="line">        <span class="keyword">this</span>.serviceMethods = methods == <span class="keyword">null</span> ? <span class="keyword">null</span> : Constants.COMMA_SPLIT_PATTERN.split(methods);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>RegistryDirectory</code> 中的部分属性会根据注册中心URL初始化。下面对较为重要的属性进行说明：</p><ol><li><strong>this.queryMap:</strong><blockquote><p>Consumer 端的 URL 的参数配置项 parameters 的值</p></blockquote></li><li><strong>this.directoryUrl:</strong><blockquote><p>传入的注册中心 URL 的主干部分 + Consumer 端的 URL 的 parameters（this.queryMap）</p></blockquote></li><li><strong>this.overrideDirectoryUrl</strong><blockquote><p>初始值为 this.directoryUrl，在接收注册中心目录（某个服务接口下的目录，其中一服务接口对应一个服务目录）变更通知时会先结合配置规则 Configurator 重写 this.directoryUrl。</p></blockquote></li></ol><h3 id="InvokerDelegate"><a href="#InvokerDelegate" class="headerlink" title="InvokerDelegate"></a>InvokerDelegate</h3><p><code>InvokerDelegate</code> 是 <code>RegistryDirectory</code> 的内部类，继承了 <code>InvokerWrapper</code> 这个 Invoker 的包装类。这个代理类主要用于存储注册中心下发的服务提供者的URL以及服务引用创建的 Invoker 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerDelegate</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">InvokerWrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 服务提供者URL，注意：这是未经过配置合并的URL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> URL providerUrl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> invoker     Protocol.refer 引用的 Invoker</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> url         合并后的 URL</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> providerUrl 服务提供者URL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InvokerDelegate</span><span class="params">(Invoker&lt;T&gt; invoker, URL url, URL providerUrl)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(invoker, url);</span><br><span class="line">            <span class="keyword">this</span>.providerUrl = providerUrl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> URL <span class="title">getProviderUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> providerUrl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="拉取-Invoker"><a href="#拉取-Invoker" class="headerlink" title="拉取 Invoker"></a>拉取 Invoker</h3><p>拉取 Invoker 逻辑封装在 doList 方法中，是父类 <code>AbstractDirectory</code> 的模版方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 检测forbidden字段，当该字段在 refreshInvoker() 过程中设置为true时，表示无 Provider 可用，直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (forbidden) &#123;</span><br><span class="line">            <span class="comment">// 1. No service provider 2. Service providers are disabled</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.FORBIDDEN_EXCEPTION,</span><br><span class="line">                    <span class="string">"No provider available from registry "</span> + getUrl().getAddress() + <span class="string">" for service "</span> + getConsumerUrl().getServiceKey() + <span class="string">" on consumer "</span> + NetUtils.getLocalHost()</span><br><span class="line">                            + <span class="string">" use dubbo version "</span> + Version.getVersion() + <span class="string">", please check status of providers(disabled, not registered or in blacklist)."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokers = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取Invoker本地缓存 （服务引用的过程 methodInvokerMap 中的值已经有了，并且该值会随着订阅的服务而变化）</span></span><br><span class="line">        Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; localMethodInvokerMap = <span class="keyword">this</span>.methodInvokerMap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 从 Invoker 本地缓存信息中选出目标 Invoker 集合</span></span><br><span class="line">        <span class="keyword">if</span> (localMethodInvokerMap != <span class="keyword">null</span> &amp;&amp; localMethodInvokerMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获得调用的方法名和方法参数列表</span></span><br><span class="line">            String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">            Object[] args = RpcUtils.getArguments(invocation);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span> &amp;&amp; args[<span class="number">0</span>] != <span class="keyword">null</span> &amp;&amp; (args[<span class="number">0</span>] <span class="keyword">instanceof</span> String || args[<span class="number">0</span>].getClass().isEnum())) &#123;</span><br><span class="line">                <span class="comment">// 3.1 根据第一个参数和本身的方法名拼接确定最后的方法名，然后获得Invoker集合。</span></span><br><span class="line">                invokers = localMethodInvokerMap.get(methodName + args[<span class="number">0</span>]); <span class="comment">// The routing can be enumerated according to the first parameter</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (invokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 3.2 根据方法名获得 Invoker 集合，一般会成功</span></span><br><span class="line">                invokers = localMethodInvokerMap.get(methodName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (invokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 3.3 通过通配符 * 获取 Invoker 集合，如 回声探测方法</span></span><br><span class="line">                invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (invokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//4 使用 methodInvokerMap 第一个Invoker。防御性编程。</span></span><br><span class="line">                Iterator&lt;List&lt;Invoker&lt;T&gt;&gt;&gt; iterator = localMethodInvokerMap.values().iterator();</span><br><span class="line">                <span class="keyword">if</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    invokers = iterator.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 返回目标Invoker集合</span></span><br><span class="line">        <span class="keyword">return</span> invokers == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(<span class="number">0</span>) : invokers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上方法用于从 <code>RegistryDirectory</code> 的 <code>Invoker</code> 缓存中获取本次调用的消费端 Invoker 列表。其中获取的方式有以下 4 种：</p><ol><li>根据<strong>调用的方法名 + 参数值</strong>确定最终的调用方法名。使用例子如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello01</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费方调用</span></span><br><span class="line">DemoService demoService = (DemoService) context.getBean(<span class="string">"demoService"</span>);</span><br><span class="line"><span class="comment">// 最终调用到的是 DemoService 中的 hello01 方法</span></span><br><span class="line">demoService.hello(<span class="string">"01"</span>);</span><br></pre></td></tr></table></figure></li><li>根据调用方法名获取 Invoker 集合。</li><li>使用全量 Invoker 集合。</li><li>基于防御性编程，使用第一个 Invoker 集合。</li></ol><p>以上方法可以看作是对 <code>RegistryDirectory</code> 中 Invoker 缓存的读操作，写操作是在收到通知的时候完成的，后续会详细分析。</p><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置服务消费者URL</span></span><br><span class="line">        setConsumerUrl(url);</span><br><span class="line">        <span class="comment">// 向注册中心发起订阅</span></span><br><span class="line">        registry.subscribe(url, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法会在消费端进行订阅时被调用，通过调用 <code>Registry</code> 的 <strong>subscribe</strong> 方法完成订阅，同时还会将当前 <code>RegistryDirectory</code> 以 <code>NotifyListener</code> 监听器形式添加到 <code>Registry</code> 上。</p><p>消费端订阅触发时机是在服务引用过程，具体源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryProtocol</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行服务引用，返回Invoker对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cluster  Cluster 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry 注册中心对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type     服务接口类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      注册中心URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;      泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Invoker 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 1 创建RegistryDirectory对象【服务目录】，并设置注册中心到它的属性，该对象包含了注册中心的所有服务提供者 List&lt;Invoker&gt;</span></span><br><span class="line">        RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">        <span class="comment">// 1.1 设置注册中心和协议</span></span><br><span class="line">        directory.setRegistry(registry);</span><br><span class="line">        directory.setProtocol(protocol);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获得服务引用配置集合parameters。注意：url传入RegistryDirectory后，经过处理并重新创建，所以 url != directory.url，</span></span><br><span class="line">        Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 生成消费者URL</span></span><br><span class="line">        URL subscribeUrl = <span class="keyword">new</span> URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 注册服务消费者，在consumers目录下</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.ANY_VALUE.equals(url.getServiceInterface())</span><br><span class="line">                &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,</span><br><span class="line">                    Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 向注册中心订阅 服务提供者 + 路由规则 + 配置规则 节点下的数据</span></span><br><span class="line">        directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,</span><br><span class="line">                Constants.PROVIDERS_CATEGORY</span><br><span class="line">                        + <span class="string">","</span> + Constants.CONFIGURATORS_CATEGORY</span><br><span class="line">                        + <span class="string">","</span> + Constants.ROUTERS_CATEGORY));</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 6 基于 RegistryDirectory 创建 Invoker 对象</span></span><br><span class="line">        Invoker invoker = cluster.join(directory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向本地注册表，注册消费者</span></span><br><span class="line">        ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>消费端在服务引用过程会进行服务订阅，当监听的节点发生变更时，注册中心会将节点下的数据以 <strong>全量</strong> 形式通知给订阅方，也就是对应的 <code>NotifyListener</code> 们。关于订阅通知可以参考 <a href="https://gentryhuang.com/posts/dafcd048/#AbstractRegistry">订阅通知</a> 。下面粘贴注册中心模块通知逻辑代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 订阅URL映射的节点对应的子节点发生变化时，通知监听器</span></span><br><span class="line"><span class="comment">    * @param url      订阅URL</span></span><br><span class="line"><span class="comment">    * @param listener 订阅ULR对应的监听器</span></span><br><span class="line"><span class="comment">    * @param urls     订阅URL映射的路径下的子路径集合（全量数据）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify listener == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((urls == <span class="keyword">null</span> || urls.isEmpty()) &amp;&amp; !Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Ignore empty notify urls for subscribe url "</span> + url);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Notify urls for subscribe url "</span> + url + <span class="string">", urls: "</span> + urls);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 将 `urls` 按照 URL中的 'category` 参数进行分类，添加到Map集合result中</span></span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;String, List&lt;URL&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (URL u : urls) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 子路径URL是否匹配订阅URL</span></span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">                <span class="comment">// 获取分类，默认为 providers</span></span><br><span class="line">                String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加入到结果集</span></span><br><span class="line">                List&lt;URL&gt; categoryList = result.get(category);</span><br><span class="line">                <span class="keyword">if</span> (categoryList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    categoryList = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">                    result.put(category, categoryList);</span><br><span class="line">                &#125;</span><br><span class="line">                categoryList.add(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得订阅URL对应的缓存`notified`,即通知的 URL 变化结果（全量数据），会把result中的值放入到 categoryNotified中</span></span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.get(url);</span><br><span class="line">        <span class="keyword">if</span> (categoryNotified == <span class="keyword">null</span>) &#123;</span><br><span class="line">            notified.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;String, List&lt;URL&gt;&gt;());</span><br><span class="line">            categoryNotified = notified.get(url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理通知的 URL 变化结果（全量数据），即按照分类，循环处理通知的URL变化结果（全量数据）</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 获得分类名</span></span><br><span class="line">            String category = entry.getKey();</span><br><span class="line">            <span class="comment">// 获得分类名对应的通知ULR列表</span></span><br><span class="line">            List&lt;URL&gt; categoryList = entry.getValue();</span><br><span class="line">            <span class="comment">// 1 将result 覆盖到 `notified`缓存【更新notified集合中的通知ULR列表】，需要注意：当某个分类的数据为空时，会依然有URL，如 empty://...` ，通过这种方式统一处理所有订阅URL对应的数据为空的情况。</span></span><br><span class="line">            categoryNotified.put(category, categoryList);</span><br><span class="line">            <span class="comment">// 2 保存订阅url对应的被通知的URL到 properties和文件 中 // 在循环中的保存的原因是，订阅url对应的通知url可能是变动的，上一步的操作会更新notified集合，为了让 properties和文件中的 订阅-通知关系正确就需要不断更新。</span></span><br><span class="line">            saveProperties(url);</span><br><span class="line">            <span class="comment">// 3 调用传入的listener的notify()方法</span></span><br><span class="line">            listener.notify(categoryList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>因为 <code>RegistryDirectory</code> 作为一个 <code>NotifyListener</code> 向注册中心 <code>Registry</code> 发起了订阅，因此会收到通知。由通知代码逻辑可知，是按照分类循环通知的，也就说可能订阅的分类有多个，但是每次通知只有一类 URL 。</p><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p><code>RegistryDirectory</code> 是一个动态服务目录，它需要监听注册中心上的相关数据变更进而动态调整，因此实现了 <code>NotifyListener</code> 接口，通过该接口获取注册中心变更通知。下面我们来看具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 根据URL的分类，分成三个类别：1 服务提供者URL  2 路由URL 3 配置URL</span></span><br><span class="line">        List&lt;URL&gt; invokerUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">        List&lt;URL&gt; routerUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">        List&lt;URL&gt; configuratorUrls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 遍历 urls，进行分类</span></span><br><span class="line">        <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            <span class="comment">// 2.1 获取协议</span></span><br><span class="line">            String protocol = url.getProtocol();</span><br><span class="line">            <span class="comment">// 2.2 获取 category 参数的值，默认是 providers</span></span><br><span class="line">            String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.3 根据 category 参数将 url 分别放到不同的列表中</span></span><br><span class="line">            <span class="comment">// 2.3.1 符合路由规则</span></span><br><span class="line">            <span class="keyword">if</span> (Constants.ROUTERS_CATEGORY.equals(category) || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">                routerUrls.add(url);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.3.2 符合配置规则</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.CONFIGURATORS_CATEGORY.equals(category) || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">                configuratorUrls.add(url);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.3.3 符合服务提供者</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.PROVIDERS_CATEGORY.equals(category)) &#123;</span><br><span class="line">                invokerUrls.add(url);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"Unsupported category "</span> + category + <span class="string">" in notified url: "</span> + url + <span class="string">" from registry "</span> + getUrl().getAddress() + <span class="string">" to consumer "</span> + NetUtils.getLocalHost());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 configurators 下的数据变更，则将配置规则URL集合转换成对应的 Configurator 集合</span></span><br><span class="line">        <span class="keyword">if</span> (configuratorUrls != <span class="keyword">null</span> &amp;&amp; !configuratorUrls.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.configurators = toConfigurators(configuratorUrls);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 routers 下的数据变更，则将路由URL集合转换成对应的Router集合</span></span><br><span class="line">        <span class="keyword">if</span> (routerUrls != <span class="keyword">null</span> &amp;&amp; !routerUrls.isEmpty()) &#123;</span><br><span class="line">            List&lt;Router&gt; routers = toRouters(routerUrls);</span><br><span class="line">            <span class="comment">// 如果处理得到的Router非空，调用父类的#setRouters方法，设置路由规则。</span></span><br><span class="line">            <span class="keyword">if</span> (routers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                setRouters(routers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 合并配置规则到 directoryUrl, 形成 overrideDirectoryUrl 变量</span></span><br><span class="line">        List&lt;Configurator&gt; localConfigurators = <span class="keyword">this</span>.configurators;</span><br><span class="line">        <span class="keyword">this</span>.overrideDirectoryUrl = directoryUrl;</span><br><span class="line">        <span class="keyword">if</span> (localConfigurators != <span class="keyword">null</span> &amp;&amp; !localConfigurators.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Configurator configurator : localConfigurators) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用配置规则器 将 配置规则应用到 overrideDirectoryUrl</span></span><br><span class="line">                <span class="keyword">this</span>.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 刷新Invoker列表</span></span><br><span class="line">        refreshInvoker(invokerUrls);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过前面的介绍我们知道，在服务引用的过程中会创建 <code>RegistryDirectory</code> 对象，一方面做为 <code>NotifyListener</code> 监听注册中心的 <strong>providers</strong>、<strong>configurators</strong> 和 <strong>routers</strong> 三个目录，所以在这三个目录下发生变化的时候，就会触发 <code>RegistryDirectory</code> 的 <code>notify</code> 方法。另一方面作为消费端的 Invoker 源供集群策略使用。在该方法中，首先会按照 <strong>category 参数</strong> 对变更的 URL 进行分类，并分别对不同类型的 URL 进行处理：</p><ul><li>将 router 类型的 URL 转化为 Router ，并保存到服务目录中。</li><li>将 configurators 类型的 URL 转化为 Configurator ，并保存到服务目录中。</li><li>将 provider 类型的 URL 转化为 Invoker ，并保存到服务目录中，该过程是最核心的逻辑。</li></ul><p><code>RegistryDirectory</code> 中有很多核心属性，它们的更新主要在注册中心通知的过程，Dubbo 使用了 <code>synchronized</code> 锁来处理线程安全问题。</p><p>其中在将 configurators 类型 URL 转为 Configurator 后，还会将配置规则应用在 <code>overrideDirectoryUrl</code> 。下面我们对以上 3 个关键流程进行分析。</p><h4 id="转换-Configurator"><a href="#转换-Configurator" class="headerlink" title="转换 Configurator"></a>转换 Configurator</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Configurator&gt; <span class="title">toConfigurators</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 配置规则URL集合为空，表示不使用配置规则</span></span><br><span class="line">        <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 遍历配置规则 URL ，创建Configurator 配置规则</span></span><br><span class="line">        List&lt;Configurator&gt; configurators = <span class="keyword">new</span> ArrayList&lt;Configurator&gt;(urls.size());</span><br><span class="line">        <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">            <span class="comment">// 2.1 如果协议为 empty:// ，会清空所有配置规则，返回空集合</span></span><br><span class="line">            <span class="keyword">if</span> (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                configurators.clear();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.2 获取配置规则URL的key-value参数集合</span></span><br><span class="line">            Map&lt;String, String&gt; override = <span class="keyword">new</span> HashMap&lt;String, String&gt;(url.getParameters());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.3 override 上的 anyhost 可能是自动添加的，为了防止影响下面的判断，需要先删除掉</span></span><br><span class="line">            override.remove(Constants.ANYHOST_KEY);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.4 如果配置Url参数部分为空，会清空所有配置规则</span></span><br><span class="line">            <span class="keyword">if</span> (override.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                configurators.clear();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.5 由工厂创建Configurator 对象，并添加到 configurators 集合中</span></span><br><span class="line">            configurators.add(configuratorFactory.getConfigurator(url));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对多个配置规则对象排序</span></span><br><span class="line">        Collections.sort(configurators);</span><br><span class="line">        <span class="keyword">return</span> configurators;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上方法用于将配置规则 URL 转换成对应的配置规则 Configurator 对象，用于实现服务治理功能。配置规则 URL 可能值如下：</p><blockquote><ol><li>override://0.0.0.0/…( or override://ip:port…?anyhost=true)&amp;para1=value1… means global rules (all of the providers take effect) ## 表示全局规则（对所有的提供者全部生效）</li><li>override://ip:port…?anyhost=false Special rules (only for a certain provider) ## 特殊规则（只针对某个提供者生效）</li><li>override:// rule is not supported… ,needs to be calculated by registry itself. ##  不支持override:// 规则，需要注册中心自行计算</li><li>override://0.0.0.0/ without parameters means clearing the override ##  不带参数,表示清除override</li></ol></blockquote><h4 id="转换-Router"><a href="#转换-Router" class="headerlink" title="转换 Router"></a>转换 Router</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"> <span class="function"><span class="keyword">private</span> List&lt;Router&gt; <span class="title">toRouters</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        List&lt;Router&gt; routers = <span class="keyword">new</span> ArrayList&lt;Router&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 路由规则 URL集合判空</span></span><br><span class="line">        <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> routers;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 遍历路由规则 URL</span></span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="keyword">null</span> &amp;&amp; !urls.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                <span class="comment">// 2.1 如果是 empty:// ，则忽略。</span></span><br><span class="line">                <span class="comment">// 一般情况下，当所有路由规则被删除时，有且仅有一条协议为 empty:// 的路由规则 URL</span></span><br><span class="line">                <span class="keyword">if</span> (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.2 获取配置的 router 配置项，如果有设置则使用设置的配置项</span></span><br><span class="line">                String routerType = url.getParameter(Constants.ROUTER_KEY);</span><br><span class="line">                <span class="keyword">if</span> (routerType != <span class="keyword">null</span> &amp;&amp; routerType.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    url = url.setProtocol(routerType);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 2.3  通过路由工厂创建 Router</span></span><br><span class="line">                    Router router = routerFactory.getRouter(url);</span><br><span class="line">                    <span class="keyword">if</span> (!routers.contains(router)) &#123;</span><br><span class="line">                        routers.add(router);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(<span class="string">"convert router url to router error, url: "</span> + url, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> routers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上方法用于将路由规则 URL 转换成对应路由规则 Router 对象，用于过滤服务目录中的服务集合。</p><h4 id="刷新-Invoker-列表"><a href="#刷新-Invoker-列表" class="headerlink" title="刷新 Invoker 列表"></a>刷新 Invoker 列表</h4><p>刷新 Invoker 列表是为了保证服务目录随注册中心变化而变化，使消费端的 Invoker 是最新的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"><span class="comment">// invokerUrls 是 .../providers 路径下的子路径列表，全量数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshInvoker</span><span class="params">(List&lt;URL&gt; invokerUrls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 所有服务不可用</span></span><br><span class="line">        <span class="comment">// 当 invokerUrls 集合大小为1，并且协议是 empty://，说明所有的服务都已经下线了，即禁用所有服务。Zookeeper 册中心可参见 &#123;@link ZookeeperRegistry#toUrlsWithEmpty&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (invokerUrls != <span class="keyword">null</span> &amp;&amp; invokerUrls.size() == <span class="number">1</span> &amp;&amp; invokerUrls.get(<span class="number">0</span>) != <span class="keyword">null</span> &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(<span class="number">0</span>).getProtocol())) &#123;</span><br><span class="line">            <span class="comment">// 1.1 设置禁止访问，后续请求将直接抛出异常</span></span><br><span class="line">            <span class="keyword">this</span>.forbidden = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.2 置空 方法名与Invoker集合映射 methodInvokerMap</span></span><br><span class="line">            <span class="keyword">this</span>.methodInvokerMap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.3 清空 Invoker 缓存，销毁所有的 Invoker</span></span><br><span class="line">            destroyAllInvokers();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 存在可用服务</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.1 设置允许访问</span></span><br><span class="line">            <span class="keyword">this</span>.forbidden = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.2 保存旧的 urlInvokerMap，为后续逻辑是否存在无效的 invoker 作为判断依据。</span></span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.3 传入的 invokerUrls 为空说明 注册中心中的 providers 目录未发生变化，</span></span><br><span class="line">            <span class="comment">// 是路由规则或者配置规则发生改变。那么直接使用缓存的服务提供者 Invoker 的URL集合</span></span><br><span class="line">            <span class="keyword">if</span> (invokerUrls.isEmpty() &amp;&amp; <span class="keyword">this</span>.cachedInvokerUrls != <span class="keyword">null</span>) &#123;</span><br><span class="line">                invokerUrls.addAll(<span class="keyword">this</span>.cachedInvokerUrls);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.4 传入的 invokerUrls 非空，说明注册中心中的 providers 目录发生了改变，即服务提供者发生了改变（第一次全量拉取数据也是一种改变，从无到有）</span></span><br><span class="line">                <span class="comment">// 则使用传入的 invokerUrls 更新 cachedInvokerUrls</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.cachedInvokerUrls = <span class="keyword">new</span> HashSet&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//缓存invokerUrls列表，便于交叉对比</span></span><br><span class="line">                <span class="keyword">this</span>.cachedInvokerUrls.addAll(invokerUrls);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.4 invokerUrls 为空则直接忽略（例如：初始是按照 configurators =&gt; routers =&gt; providers ，那么前两个会出现为空的情况）</span></span><br><span class="line">            <span class="keyword">if</span> (invokerUrls.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.5 将变更的URL列表转成 URL串 到 Invoker 的映射 (最核心的方法)</span></span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);<span class="comment">// Translate url list to Invoker map</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.6 将上一步得到的 newUrlInvokerMap 转换成 方法名到Invoker列表的映射</span></span><br><span class="line">            Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); <span class="comment">// Change method name to map Invoker Map</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.7 如果转换错误，则忽略本次转换</span></span><br><span class="line">            <span class="keyword">if</span> (newUrlInvokerMap == <span class="keyword">null</span> || newUrlInvokerMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"urls to invokers error .invokerUrls.size :"</span> + invokerUrls.size() + <span class="string">", invoker.size :0. urls :"</span> + invokerUrls.toString()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.8 如果引用多个服务分组，那么就按照 method + group 维度合并Invoker</span></span><br><span class="line">            <span class="keyword">this</span>.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.9 保存 URL串 到 Invoker 的映射 </span></span><br><span class="line">            <span class="keyword">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 2.10 比较新旧两组 Invoker 集合，销毁已经下线的 Invoker 集合，避免服务消费方调用已经下线的服务</span></span><br><span class="line">                destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); <span class="comment">// Close the unused Invoker</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"destroyUnusedInvokers error. "</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>服务目录转换服务提供者URL -&gt; Invoker 的规则如下：</strong></p><blockquote><ol><li>如果 URL 已经转换为 Invoker，则不再重新引用，直接从缓存中获取。需要注意的是，如果 URL 中任何一个参数变更都会重新引用。</li><li>如果传入的服务提供者URL列表大小为 1 且协议是 empty://，说明所有的服务都已经下线，要禁用所有服务。</li><li>如多传入的服务提供者URL列表为空，则表示只是下发配置规则和路由规则。</li></ol></blockquote><p>注意，上面规则中提到的 URL 并非是服务提供者URL，而是合并后的服务提供者URL，关于合并规则下文会详细说明。</p><p><strong>刷新 Invoker 列表的逻辑如下：</strong></p><ol><li>根据入参 invokerUrls 的数量和协议判断是否禁用所有服务，如果禁用则将禁用标志 forbidden 设置为 true ，并销毁引用所有的 Invoker 。</li><li>非禁用，则将 invokerUrls 中的 URL 进行合并操作，然后转换成 Invoker（引用 Invoker），得到新的 <code>&lt;url串,Invoker&gt;</code> 的映射关系。</li><li>将第 2 步中得到的 <code>&lt;url串,Invoker&gt;</code> 进一步转成 <code>&lt;methodName,Invoker列表&gt;</code> 。</li><li>如果消费方引用多个服务分组，则根据 <strong>method + group</strong> 进行多组合并操作，同样得到 <code>&lt;methodName,Invoker列表&gt;</code> 数据，<strong>doList</strong> 方法中读取的就是该数据，而这里是写操作。</li><li>新的消费端 Invoker 列表生成后，根据第 2 步得到的 <code>&lt;url串,Invoker&gt;</code> ，同旧的 <code>&lt;url串,Invoker&gt;</code> 对比，销毁无用的 Invoker，避免服务消费者调用已经下线的服务。</li></ol><p>刷新 Invoker 逻辑中会变更两个核心的属性：<strong>urlInvokerMap</strong> 和 <strong>methodInvokerMap</strong> ，前者以URL维度后者以方法名维度，前者用于判断是否需要重新引用服务，后者用于存储引用的Invoker集合供 <strong>doList</strong> 方法拉取。</p><p>接下来我们对上面涉及到的核心步骤进行分析。</p><h5 id="转换-Invoker"><a href="#转换-Invoker" class="headerlink" title="转换 Invoker"></a>转换 Invoker</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">        <span class="comment">// &lt;URL串,Invoker&gt;</span></span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> HashMap&lt;String, Invoker&lt;T&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若为空直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 记录已初始化的服务提供者URL串，即已经处理过的服务提供者URL</span></span><br><span class="line">        Set&lt;String&gt; keys = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取消费者配置的协议 (一般情况下，我们不在消费端 &lt;dubbo:reference protocol=""/&gt; 配置服务协议)</span></span><br><span class="line">        String queryProtocols = <span class="keyword">this</span>.queryMap.get(Constants.PROTOCOL_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 循环遍历变更的提供者URL集合</span></span><br><span class="line">        <span class="keyword">for</span> (URL providerUrl : urls) &#123;</span><br><span class="line">            <span class="comment">// 4 对消费端配置协议的处理逻辑</span></span><br><span class="line">            <span class="comment">// 4.1 如果消费端配置了协议，则只选择和消费端匹配的协议</span></span><br><span class="line">            <span class="keyword">if</span> (queryProtocols != <span class="keyword">null</span> &amp;&amp; queryProtocols.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> accept = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 可能配置了多协议</span></span><br><span class="line">                String[] acceptProtocols = queryProtocols.split(<span class="string">","</span>);</span><br><span class="line">                <span class="comment">// 4.2 根据消费方protocol过滤不匹配协议，因为Dubbo允许在消费方配置只消费指定协议的服务</span></span><br><span class="line">                <span class="keyword">for</span> (String acceptProtocol : acceptProtocols) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (providerUrl.getProtocol().equals(acceptProtocol)) &#123;</span><br><span class="line">                        accept = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 4.3 如果当前URL不支持Consumer端的协议，也就无法执行后续转换成Invoker的逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (!accept) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 跳过 empty:// 协议的 URL</span></span><br><span class="line">            <span class="keyword">if</span> (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6 如果消费端不支持变更的服务端的协议，则忽略</span></span><br><span class="line">            <span class="keyword">if</span> (!ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">providerUrl</span>.<span class="title">getProtocol</span>())) </span>&#123;</span><br><span class="line">                logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported protocol "</span> + providerUrl.getProtocol() + <span class="string">" in notified url: "</span> + providerUrl + <span class="string">" from registry "</span> + getUrl().getAddress() + <span class="string">" to consumer "</span> + NetUtils.getLocalHost()</span><br><span class="line">                        + <span class="string">", supported protocol: "</span> + ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getSupportedExtensions</span>()))</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7 合并URL数据，即将配置规则，消费端配置参数合并到服务提供者URl中</span></span><br><span class="line">            <span class="comment">// 注意服务提供者URL的主体信息不变，合并的只是参数部分</span></span><br><span class="line">            URL url = mergeUrl(providerUrl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 8 URL字符串，该字符串是服务提供者URL合并处理后的，作为是否需要重新引用的标志</span></span><br><span class="line">            String key = url.toFullString();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 9 跳过重复的 URL，防止重复引用</span></span><br><span class="line">            <span class="keyword">if</span> (keys.contains(key)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加入到 keys 集合中，为了防止重复</span></span><br><span class="line">            keys.add(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 10 判断 key 是否已经引用过，引用过则无需重新引用，直接使用对应的缓存即可</span></span><br><span class="line">            <span class="comment">// 如果没有引用过，则通过 Protocol.refer 方法引用服务，创建 Invoker</span></span><br><span class="line">            Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap;</span><br><span class="line">            Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="keyword">null</span> ? <span class="keyword">null</span> : localUrlInvokerMap.get(key);</span><br><span class="line">            <span class="comment">// 没有引用过</span></span><br><span class="line">            <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 通过获取配置项 enable 和 disable 的值判断服务是否开启</span></span><br><span class="line">                    <span class="keyword">boolean</span> enabled = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (url.hasParameter(Constants.DISABLED_KEY)) &#123;</span><br><span class="line">                        enabled = !url.getParameter(Constants.DISABLED_KEY, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        enabled = url.getParameter(Constants.ENABLED_KEY, <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果开启，则创建 Invoker 对象</span></span><br><span class="line">                    <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                        <span class="comment">// 通过 Protocol.refer 方法创建对应的 Invoker 对象，并使用 InvokerDelegate 装饰引用的 Invoker</span></span><br><span class="line">                        invoker = <span class="keyword">new</span> InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Failed to refer invoker for interface:"</span> + serviceType + <span class="string">",url:("</span> + url + <span class="string">")"</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将key和Invoker对象之间的映射关系记录到newUrlInvokerMap中</span></span><br><span class="line">                <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    newUrlInvokerMap.put(key, invoker);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缓存命中，直接使用缓存的 Invoker</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newUrlInvokerMap.put(key, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11 清空keys标记集合</span></span><br><span class="line">        keys.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 12 返回新的消费端 Invoker</span></span><br><span class="line">        <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>转换 Invoker 方法用于将服务提供者URL最终转为Invoker，即使用protocol.refer方法进行服务引用，也就是一条服务提供者URL对应一个消费端Invoker。主要核心逻辑如下：</p><ol><li>对服务提供者 URL 进行检测，若服务消费端的配置不支持服务端的协议，或服务端 URL 协议头为 empty 时，则忽略服务提供方 URL。</li><li>合并 URL ，即将配置规则和消费端配置参数合并到服务提供者URL中。</li><li>根据合并后的 URL 访问缓存，尝试获取与 URL 对应的 Invoker。缓存未命中，则通过 <code>Protocol.refer</code> 进行服务引用，并将创建的 Invoker 进行缓存。</li></ol><p>toInvokers() 方法的核心逻辑就是调用 Protocol.refer() 方法创建 Invoker 对象，其他的逻辑都是在判断是否调用该方法以及调用该方法前的准备工作。下面我们对 URL 参数合并逻辑简单介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"> <span class="function"><span class="keyword">private</span> URL <span class="title">mergeUrl</span><span class="params">(URL providerUrl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 将消费端URL参数配置项合并到服务提供者的URL中</span></span><br><span class="line">        <span class="comment">// 1.1 移除 Provider URL 中只在 Provider 端生效的属性，如：threadname、threadpool、corethreads、threads、queues、alive、transporter</span></span><br><span class="line">        <span class="comment">// 1.2 用 Consumer 端的参数配置（parameters）覆盖 Provider URL 的相应配置，但：version、group、methods、timestamp等参数以Provider端的配置优先，因为它们是远程配置的参数。</span></span><br><span class="line">        <span class="comment">// 1.3 合并 Provider 端和 Consumer 端配置的 Filter 以及 Listener</span></span><br><span class="line">        providerUrl = ClusterUtils.mergeUrl(providerUrl, queryMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 合并配置规则URL到 providerUrl中，配置规则URL可以是：</span></span><br><span class="line">        <span class="comment">// 2.1 第一类是注册中心 Configurators 目录下的的URL（override 协议）</span></span><br><span class="line">        <span class="comment">// 2.2 第二类是服务治理控制台动态添加配置</span></span><br><span class="line">        List&lt;Configurator&gt; localConfigurators = <span class="keyword">this</span>.configurators; <span class="comment">// local reference</span></span><br><span class="line">        <span class="keyword">if</span> (localConfigurators != <span class="keyword">null</span> &amp;&amp; !localConfigurators.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Configurator configurator : localConfigurators) &#123;</span><br><span class="line">                <span class="comment">// 使用配置规则器 将 配置规则应用到 providerUrl</span></span><br><span class="line">                providerUrl = configurator.configure(providerUrl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 增加check=false，即只有在调用时，才检查Provider是否可用</span></span><br><span class="line">        providerUrl = providerUrl.addParameter(Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 更新 overrideDirectoryUrl</span></span><br><span class="line">        <span class="keyword">this</span>.overrideDirectoryUrl = <span class="keyword">this</span>.overrideDirectoryUrl.addParametersIfAbsent(providerUrl.getParameters()); <span class="comment">// Merge the provider side parameters</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 忽略 对 1.0 版本的兼容</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 返回处理后的新的服务提供者 URL</span></span><br><span class="line">        <span class="keyword">return</span> providerUrl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>合并 URL 的逻辑如下：</strong></p><ol><li>将消费端URL参数配置项合并到服务提供者URL中，但 <strong>group</strong>、<strong>version</strong>、<strong>methods</strong> 等参数以服务端的配置优先，因为它们是远程服务配置参数。</li><li>filter 和 listener 参数使用两端的配置项。</li><li>将注册中心中 configurators 目录下的 URL，以及服务治理控制台动态添加的配置与 Provider URL 进行合并，即覆盖 Provider URL 原有的一些信息。</li><li>增加check=false，即只有在调用时，才检查Provider是否可用。</li><li>更新 overrideDirectoryUrl 的值：<strong>注册中心URL + 消费端URL参数配置项 -&gt; 注册中心URL + 消费端URL参数配置项 + 服务端URL合并后的URL参数配置项</strong>。</li></ol><p>需要说明的是，合并 URL 参数的优先级：<strong>配置规则</strong> -&gt; <strong>系统参数</strong> -&gt; <strong>消费端配置</strong> -&gt; <strong>服务端配置</strong> </p><p><strong>toInvokers</strong> 方法返回的是 <code>&lt;url串,Invoker&gt;</code> 映射关系，接下来还会对该结果进一步处理，得到方法名到 Invoker 列表的映射关系。</p><h5 id="方法名-gt-Invoker列表"><a href="#方法名-gt-Invoker列表" class="headerlink" title="方法名-&gt;Invoker列表"></a>方法名-&gt;Invoker列表</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; toMethodInvokers(Map&lt;String, Invoker&lt;T&gt;&gt; invokersMap) &#123;</span><br><span class="line">        <span class="comment">// 方法名到Invoker集合映射</span></span><br><span class="line">        Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录服务提供者Invoker集合</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokersList = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照服务提供者URL声明的 method 分类，兼容注册中心执行路由过滤掉的 methods</span></span><br><span class="line">        <span class="keyword">if</span> (invokersMap != <span class="keyword">null</span> &amp;&amp; invokersMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 循环每个服务提供者Invoker</span></span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokersMap.values()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1 服务提供者URL声明的 methods</span></span><br><span class="line">                String parameter = invoker.getUrl().getParameter(Constants.METHODS_KEY);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 遍历方法集合</span></span><br><span class="line">                <span class="keyword">if</span> (parameter != <span class="keyword">null</span> &amp;&amp; parameter.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 切割 methods 参数值，处理成方法名数组</span></span><br><span class="line">                    String[] methods = Constants.COMMA_SPLIT_PATTERN.split(parameter);</span><br><span class="line">                    <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 3 循环每个方法，按照方法名的维度收集引用的 Invoker</span></span><br><span class="line">                        <span class="keyword">for</span> (String method : methods) &#123;</span><br><span class="line">                            <span class="comment">// 当服务提供者的方法为 * 时，代表泛化调用，不处理。</span></span><br><span class="line">                            <span class="keyword">if</span> (method != <span class="keyword">null</span> &amp;&amp; method.length() &gt; <span class="number">0</span> &amp;&amp; !Constants.ANY_VALUE.equals(method)) &#123;</span><br><span class="line">                                List&lt;Invoker&lt;T&gt;&gt; methodInvokers = newMethodInvokerMap.get(method);</span><br><span class="line">                                <span class="keyword">if</span> (methodInvokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    methodInvokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line">                                    newMethodInvokerMap.put(method, methodInvokers);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 根据方法名获取Invoker集合</span></span><br><span class="line">                                methodInvokers.add(invoker);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4 收集引用的 Invoker</span></span><br><span class="line">                invokersList.add(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 进行服务级别路由，即对引用的服务进行路由</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; newInvokersList = route(invokersList, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 存储 &lt;*, newInvokersList&gt; 映射关系</span></span><br><span class="line">        newMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7 对引用的服务接口中的方法进行方法级别路由</span></span><br><span class="line">        <span class="keyword">if</span> (serviceMethods != <span class="keyword">null</span> &amp;&amp; serviceMethods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历服务方法数组基于每个方法路由，匹配方法对应的Invoker集合</span></span><br><span class="line">            <span class="keyword">for</span> (String method : serviceMethods) &#123;</span><br><span class="line">                List&lt;Invoker&lt;T&gt;&gt; methodInvokers = newMethodInvokerMap.get(method);</span><br><span class="line">                <span class="keyword">if</span> (methodInvokers == <span class="keyword">null</span> || methodInvokers.isEmpty()) &#123;</span><br><span class="line">                    methodInvokers = newInvokersList;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 进行方法级别路由</span></span><br><span class="line">                newMethodInvokerMap.put(method, route(methodInvokers, method));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8 排序，转成不可变集合</span></span><br><span class="line">        <span class="keyword">for</span> (String method : <span class="keyword">new</span> HashSet&lt;String&gt;(newMethodInvokerMap.keySet())) &#123;</span><br><span class="line">            List&lt;Invoker&lt;T&gt;&gt; methodInvokers = newMethodInvokerMap.get(method);</span><br><span class="line">            Collections.sort(methodInvokers, InvokerComparator.getComparator());</span><br><span class="line">            newMethodInvokerMap.put(method, Collections.unmodifiableList(methodInvokers));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(newMethodInvokerMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">---+</span><br><span class="line">    <span class="keyword">private</span> List&lt;Invoker&lt;T&gt;&gt; route(List&lt;Invoker&lt;T&gt;&gt; invokers, String method) &#123;</span><br><span class="line">        <span class="comment">// 创建Invocation 对象</span></span><br><span class="line">        Invocation invocation = <span class="keyword">new</span> RpcInvocation(method, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>], <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 获得 Router 数组</span></span><br><span class="line">        List&lt;Router&gt; routers = getRouters();</span><br><span class="line">        <span class="comment">// 根据路由规则，筛选Invoker 集合</span></span><br><span class="line">        <span class="keyword">if</span> (routers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Router router : routers) &#123;</span><br><span class="line">                <span class="keyword">if</span> (router.getUrl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    invokers = router.route(invokers, getConsumerUrl(), invocation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>将引用的 Invoker 列表进行映射，得到方法名到 Invoker 的映射。主要过程如下：</p><ol><li>对传入的引用 Invoker 进行遍历，获取其中的 <strong>methods</strong> 参数，并切分成数组。然后以方法名为键，Invoker 列表为值进行缓存。</li><li>先后基于服务级别和方法级别对 Invoker 列表进行路由操作，筛选目标 Invoker 。</li><li>对路由后的 Invoker 列表进行排序，并转成不可变列表。</li></ol><h5 id="多分组聚合"><a href="#多分组聚合" class="headerlink" title="多分组聚合"></a>多分组聚合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; toMergeMethodInvokerMap(Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; methodMap) &#123;</span><br><span class="line">        Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt;();</span><br><span class="line">        <span class="comment">// 循环map集合，根据 method + group 聚合 Invoker 集合</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; entry : methodMap.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 获取方法名</span></span><br><span class="line">            String method = entry.getKey();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 获取方法名对应的invoker列表</span></span><br><span class="line">            List&lt;Invoker&lt;T&gt;&gt; invokers = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 按照 group 聚合 Invoker 集合的结果，key：group value：Invoker集合</span></span><br><span class="line">            Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; groupMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 遍历Invoker集合 。注意：一个方法对应的 Invoker 列表可能属于多个组</span></span><br><span class="line">            <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">                <span class="comment">// 4.1 获取分组名</span></span><br><span class="line">                String group = invoker.getUrl().getParameter(Constants.GROUP_KEY, <span class="string">""</span>);</span><br><span class="line">                <span class="comment">// 4.2 以分组名聚合Invoker集合</span></span><br><span class="line">                List&lt;Invoker&lt;T&gt;&gt; groupInvokers = groupMap.get(group);</span><br><span class="line">                <span class="keyword">if</span> (groupInvokers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    groupInvokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line">                    groupMap.put(group, groupInvokers);</span><br><span class="line">                &#125;</span><br><span class="line">                groupInvokers.add(invoker);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 如果只有一个group，则直接使用该group分组对应的Invoker集合作为结果</span></span><br><span class="line">            <span class="keyword">if</span> (groupMap.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                result.put(method, groupMap.values().iterator().next());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6 有多个分组的话，将每个group对应的Invoker集合经过Cluster合并成一个Invoker</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (groupMap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                List&lt;Invoker&lt;T&gt;&gt; groupInvokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (List&lt;Invoker&lt;T&gt;&gt; groupList : groupMap.values()) &#123;</span><br><span class="line">                    <span class="comment">// 这里使用到StaticDirectory以及Cluster合并每个group中的Invoker</span></span><br><span class="line">                    groupInvokers.add(cluster.join(<span class="keyword">new</span> StaticDirectory&lt;T&gt;(groupList)));</span><br><span class="line">                &#125;</span><br><span class="line">                result.put(method, groupInvokers);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 没有的话，就使用原来的数据</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.put(method, invokers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>多分组聚合方法用于在 <code>&lt;methodName,Invoker列表&gt;</code> 基础中，对同一个方法对应的 Invoker 列表进行 group 维度的分类，同一个 group 维度的 Invoker 列表通过 Cluster 合并成一个 Invoker 。</p><h5 id="销毁无用-Invoker"><a href="#销毁无用-Invoker" class="headerlink" title="销毁无用 Invoker"></a>销毁无用 Invoker</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+--- RegistryDirectory</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destroyUnusedInvokers</span><span class="params">(Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap, Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 安全处理</span></span><br><span class="line">        <span class="keyword">if</span> (newUrlInvokerMap == <span class="keyword">null</span> || newUrlInvokerMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 销毁所有服务提供者Invoker</span></span><br><span class="line">            destroyAllInvokers();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 比较新老集合，确定需要销毁哪些Invoker。</span></span><br><span class="line">        <span class="comment">// 原则是：以新的为基准，如果新的中不包含老的，说明老的应该被销毁</span></span><br><span class="line">        List&lt;String&gt; deleted = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldUrlInvokerMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取新生成的 Invoker 集合</span></span><br><span class="line">            Collection&lt;Invoker&lt;T&gt;&gt; newInvokers = newUrlInvokerMap.values();</span><br><span class="line">            <span class="comment">// 遍历老的 &lt;url串, Invoker&gt; 映射表</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Invoker&lt;T&gt;&gt; entry : oldUrlInvokerMap.entrySet()) &#123;</span><br><span class="line">                <span class="comment">// 如果新的集合中不包含老的Invoker，则表示可以把当前老的Invoker删除</span></span><br><span class="line">                <span class="keyword">if</span> (!newInvokers.contains(entry.getValue())) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (deleted == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        deleted = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 若不包含，则将老的 Invoker 对应的 url 存入 deleted 列表中</span></span><br><span class="line">                    deleted.add(entry.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 有需要销毁的Invoker就进行销毁</span></span><br><span class="line">        <span class="keyword">if</span> (deleted != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历 deleted 集合，并到老的 &lt;url, Invoker&gt; 映射关系表查出 Invoker并销毁</span></span><br><span class="line">            <span class="keyword">for</span> (String url : deleted) &#123;</span><br><span class="line">                <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 从老的Invoker集合中移除要销毁的Invoker</span></span><br><span class="line">                    Invoker&lt;T&gt; invoker = oldUrlInvokerMap.remove(url);</span><br><span class="line">                    <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 销毁Invoker</span></span><br><span class="line">                            invoker.destroy();</span><br><span class="line">                            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                                logger.debug(<span class="string">"destroy invoker["</span> + invoker.getUrl() + <span class="string">"] success. "</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            logger.warn(<span class="string">"destroy invoker["</span> + invoker.getUrl() + <span class="string">"] faild. "</span> + e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>销毁无用 Invoker 关键看旧的 Invoker 是否在新的 Invoker 集合中，不在则说明需要销毁。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Dubbo 的服务目录进行了分析，相比静态服务目录 <strong>StaticDirectory</strong> ，动态的服务目录 <strong>RegistryDirectory</strong> 要复杂得多。为了让本地服务目录和注册中心保持一致，需要做很多工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本篇文章对 Dubbo 集群模块中的 &lt;code&gt;Directory&lt;/code&gt; 服务目录进行介绍。服务目录 &lt;code&gt;Registry
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 集群模块总览</title>
    <link href="https://gentryhuang.com/posts/7aca9035/"/>
    <id>https://gentryhuang.com/posts/7aca9035/</id>
    <published>2020-09-11T16:00:00.000Z</published>
    <updated>2021-04-06T08:31:35.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>为了保证服务的可靠性、吞吐量以及容错能力，通常会在多个服务器上运行相同的应用程序，然后以集群的形式对外提供服务。根据应用场景不同，每个集群中的服务实例个数也不尽相同。Dubbo 中的 <code>Cluster</code> 是外围概念，<strong>用于将多个 Invoker 伪装成一个 Invoker</strong>，这样调用方只需关注 <strong>Protocol 层 Invoker</strong> 即可，加上 Cluster 或者去掉 Cluster 对其它层都不会造成影响，因为只有一个提供者时，是不需要 Cluster 的。</p><p><strong>Cluster 层</strong> 在 Dubbo 架构中的位置如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-outline.jpg" alt></p><h1 id="Cluster-架构"><a href="#Cluster-架构" class="headerlink" title="Cluster 架构"></a>Cluster 架构</h1><p>Dubbo 的集群模块主要功能是将多个服务提供者伪装成一个提供者供消费方调用，核心组件如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-frame.jpeg" alt></p><p><strong>从上图可以看出，Dubbo 集群模块涉及以下 4 个核心组件：</strong></p><ul><li><strong><code>Directory</code> - 服务目录</strong><blockquote><p>代表多个 <code>Invoker</code>，可以把它看成 <code>List&lt;Invoker&gt;</code> ，但与 <code>List</code> 不同的是，它的值可能是动态变化的，比如注册中心推送变更。它是后续路由规则、负载均衡策略以及集群容错的基础。</p></blockquote></li><li><strong><code>Cluster</code> - 集群</strong> <blockquote><p>将 <code>Directory</code> 中的多个 <code>Invoker</code> 伪装成一个 <code>Invoker</code> ，对上层透明。<strong>伪装过程包含了容错逻辑</strong>，用于在某些 <code>Provider</code> 节点发生故障时让 <code>Consumer</code> 的调用请求能够发送到正常的 <code>Provider</code> 节点，从而保证整个系统的可用性。</p></blockquote></li><li><strong><code>Router</code> - 路由</strong><blockquote><p>负责从 <code>Directory</code> 中按路由规则选出子集，比如应用在 <strong>读写分离</strong>、<strong>应用隔离</strong> 、<strong>灰度发布</strong> 等。</p></blockquote></li><li><strong><code>LoadBalance</code> - 负载均衡</strong><blockquote><p>负责从 <code>Router</code> 中选出具体的一个 <code>Invoker</code>。选的过程包含了负载均衡算法。</p></blockquote></li></ul><p><strong><code>Cluster</code> 层的核心流程：</strong> 当调用进入 Cluster 模块时，<code>Cluster</code> 会从 <code>Directory</code> 中获取当前 <code>Invoker</code> 集合；然后按照 <code>Router</code> 进行路由，从 <code>Directory</code> 中筛选出符合条件的 <code>Invoker</code> 子集；接着按照 <code>LoadBalance</code> 进行负载均衡，从 <code>Router</code> 子集中选出一个最终要调用的 <code>Invoker</code> 对象。</p><h1 id="Cluster-模块"><a href="#Cluster-模块" class="headerlink" title="Cluster 模块"></a>Cluster 模块</h1><p>了解了 Dubbo 的 Cluster 架构，下面我们对 Dubbo 集群模块的实现简单说明下。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-cluster-code-outline.jpg" alt></p><p>Dubbo 的 Cluster 模块代码实现如上图所示。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章相对比较轻松，简单介绍了 <code>Cluster</code> 层在 Dubbo 架构中所处的位置和其架构的组成。在后面几篇文章中，我们会分别介绍这些组件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;为了保证服务的可靠性、吞吐量以及容错能力，通常会在多个服务器上运行相同的应用程序，然后以集群的形式对外提供服务。根据应用场景不同，每个集群中
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - HTTP协议</title>
    <link href="https://gentryhuang.com/posts/c5a37c18/"/>
    <id>https://gentryhuang.com/posts/c5a37c18/</id>
    <published>2020-09-05T16:00:00.000Z</published>
    <updated>2021-03-15T03:08:20.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>RPC 实现</strong></p><p>远程过程调用需要解决以下问题：</p><blockquote><ol><li>寻址：客户端调用的时候需要告诉服务端调用的是哪个服务、哪个方法、哪些参数以及附加属性。</li><li>序列化/反序列化：由于客户端和服务端不是同一个进程不能通过内存来传递参数，需要网络传输，因此客户端需要将参数序列化成字节流然后经网络传递给服务端，服务端收到字节流后反序列化为自己能读取的格式。序列化/反序列化可以使用 Hessian、Dubbo、Protobuf、JSON 等。</li><li>网络传输：客户端和服务端需要通过网络连接来传输数据，网络传输可以使用 Socket、TCP、UDP、HTTP、HTTP2 等。</li></ol></blockquote><p><strong>HTTP</strong></p><blockquote><p>HTTP 请求调用本身也可以看作是 RPC 的一种具体形式，HTTP 请求也是从客户端发出请求到服务端，服务端执行具体逻辑，然后返回结果给客户端。HTTP 请求非常常见，一般开放服务给任意的一方调用，使用 HTTP API的形式是非常合适的。对于内部通信为了灵活、高效，可以根据实际需要自定制一套 RPC 框架，坏处就是没有那么通用。</p></blockquote><p><strong>JSON-RPC</strong></p><blockquote><p>JSON-RPC 是基于 JSON 的跨语言远程调用（RPC）协议，其 <strong>传输的内容以JSON方式</strong>（注意，传输格式是二进制形式），相比 XML-RPC、WebService 等基于文本的协议传输数据格式小。相对 Dubbo、Hessian 等二进制协议，JSON-RPC 更便于调试、实现和扩展。目前主流语言几乎都基于 JSON-RPC 实现了框架，Java 中较好的 JSON-RPC 实现框架有 <code>jsonrpc4j</code>、<code>jpoxy</code> 以及 <code>json-rpc</code> ，其中 <code>jsonrpc4j</code> 既可单独使用，又可与 Spring 无缝整合。 </p></blockquote><p><strong>二进制协议和文本协议</strong></p><blockquote><p>二进制协议需要通信双方约定协议的结构（如 Dubbo 协议的结构），发送方在发送数据前按照协议的结构组装数据然后序列化成字节流传送给对端，接收方收到字节流后按照协议的结构进行解析就可以了。文本协议（如 JSON-RPC协议）不需要通信双方约定协议结构，发送方只需将具体的文本数据（如 JSON数据）序列化成字节流发送到对端即可，接收方收到字节流后按照同样的文本格式（如 JSON）解析就可以了。</p></blockquote><blockquote><p>二进制协议的优点在于，进行数据转化时不需要包含定义数据的结构信息，相比文本协议要小；文本协议的优点在于不需要定义数据的传输格式，较为方便。需要说明的是，无论是二进制协议还是文本协议，都是以二进制数据形式进行网络传输的，区别在于二进制协议需要定制结构，而文本协议不需要。</p></blockquote><p><strong>协议和序列化</strong></p><blockquote><p>协议和序列化是不同的东西，它们之间属于组合关系，协议需要用到序列化技术，而序列化技术可以服务于不同的协议。</p></blockquote><p><strong>跨语言</strong></p><blockquote><p>跨语言调用一个重要的思路就是要有一个通用的协议，或者使用一定的策略完成协议适配，对于前者而言 HTTP 协议就是很好的选择，如异构语言对 <code>SpringCloud</code> 的调用只需提供 HTTP 客户端便可以实现跨语言调用。</p></blockquote><blockquote><p>跨语言难点在于 <strong>异构语言如何表示目标服务所需的数据类型</strong> 和 <strong>序列化方案如何做到跨语言</strong>，如 <code>nodejs</code> 对 dubbo 协议下的 Java 服务的调用是利用 <code>dubbo2.js</code> 组件来实现的，使用 <code>js-to-java</code>类库使得 <code>node.js</code>具备 Java 对象的表达能力，使用 <code>hessian.js</code> 提供了序列化能力，这样一来 <code>nodejs</code> 就能通过自己的 socket 发送一套 dubbo 协议的报文，最终实现服务调用。</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 中支持的 <code>HTTP</code> 协议并非是通用的 <strong>HTTP协议</strong>，而是将 <strong>HTTP协议</strong> 与 <code>Spring</code> 结合使用，基于 HTTP 表单的远程调用协议，采用 Spring 的 <code>HttpInvoker</code> 实现，但在 Dubbo 的 2.7.x 版本中摒弃了 <code>HttpInvoker</code> 实现方式，代替的是将 <strong>HTTP协议</strong> 与 <code>JSON-RPC</code> 结合使用，实现跨语言调用的效果。</p><h1 id="Dubbo-2-6-x-实现"><a href="#Dubbo-2-6-x-实现" class="headerlink" title="Dubbo 2.6.x 实现"></a>Dubbo 2.6.x 实现</h1><p>Dubbo 2.6.x 版本中的 HTTP 协议是基于 <strong>HTTP 表单的远程调用协议</strong>，采用 Spring 的 <code>HttpInvoker</code> 实现。</p><ul><li><p>特点</p><blockquote><p>连接个数：多连接<br>连接方式：短连接<br>传输协议：HTTP<br>传输方式：同步传输<br>序列化：表单序列化（默认使用的是 java 序列化的方式）<br>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。<br>适用场景：需同时给应用程序和浏览器 JS 使用的服务。</p></blockquote></li><li><p>配置</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用的应用服务器默认是 jetty --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"http"</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">server</span>=<span class="string">"jetty"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>当服务消费者向服务提供者发起调用时，底层便会使用标准的 HTTP 协议进行通信。在分析 Dubbo 2.6.x 版本中的 “HTTP协议” 之前，让我们先了解下 Spring 的 HttpInvoker 实现。</p><h2 id="HttpInvoker-原生实现"><a href="#HttpInvoker-原生实现" class="headerlink" title="HttpInvoker 原生实现"></a>HttpInvoker 原生实现</h2><h3 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerServiceImpl</span> <span class="keyword">implements</span> <span class="title">IInvokerService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpInvokerConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> iInvokerService</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"/invokerService"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpInvokerServiceExporter <span class="title">httpInvokerServiceExporter</span><span class="params">(IInvokerService iInvokerService)</span> </span>&#123;</span><br><span class="line">        HttpInvokerServiceExporter httpInvokerServiceExporter = <span class="keyword">new</span> HttpInvokerServiceExporter();</span><br><span class="line">        httpInvokerServiceExporter.setService(iInvokerService);</span><br><span class="line">        httpInvokerServiceExporter.setServiceInterface(IInvokerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> httpInvokerServiceExporter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>暴露服务逻辑如下：</strong></p><ul><li>1 对外提供的服务，访问路径格式: <strong><a href="http://ip:port/上下文/invokerService">http://ip:port/上下文/invokerService</a></strong></li><li>2 <strong>HttpInvokerServiceExporter</strong> 是 Spring 封装的一个服务暴露器，它会以 serviceInterface 为公共接口，以 service 为实现类向外提供服务。<ul><li>Spring封装了远程调用的逻辑，网络传输使用的是 HTTP，当有请求过来，当前服务会进行处理并将处理后的结果传输到对端。</li></ul></li><li>3 <strong>@Bean(“/invokerService”)</strong> 不仅仅指定了 IOC 容器中 bean 的名字，还充当了路径映射的功能，如果本地服务器暴露在 8080 端口，则示例服务的访问路径为 <a href="http://localhost:8080/上下文/invokerService" target="_blank" rel="noopener">http://localhost:8080/上下文/invokerService</a></li></ul><h3 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableApplicationContext applicationContext = SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">IInvokerService iInvokerService = applicationContext.getBean(IInvokerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(iInvokerService.sayHello(<span class="string">"shunhua!"</span>));</span><br></pre></td></tr></table></figure><h3 id="服务引用"><a href="#服务引用" class="headerlink" title="服务引用"></a>服务引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 访问服务路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String serviceUrl = <span class="string">"http://localhost:8080/上下文/invokerService"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpInvokerProxyFactoryBean <span class="title">httpInvokerProxyFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpInvokerProxyFactoryBean httpInvokerProxyFactoryBean = <span class="keyword">new</span> HttpInvokerProxyFactoryBean();</span><br><span class="line">        httpInvokerProxyFactoryBean.setServiceUrl(serviceUrl);</span><br><span class="line">        httpInvokerProxyFactoryBean.setServiceInterface(IInvokerService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> httpInvokerProxyFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务引用逻辑如下：</strong></p><ul><li>1 <strong>HttpInvokerProxyFactoryBean</strong> 是 Spring 封装的一个服务引用器，serviceInterface 指定了生成代理的接口，serviceUrl 指定了服务所在的地址，与之前配置的服务暴露者的路径需要对应。</li><li>2 <strong>HttpInvokerProxyFactoryBean</strong> 注册到 Spring 容器中时，会同时生成一个指定接口的代理类，由 Spring 封装远程调用的逻辑，使用 HTTP 传输数据，默认使用java 序列化的方式。</li></ul><h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>Dubbo 的 HTTP 协议实现代码结构如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-protocol-http-springinvoker-code.jpg" alt></p><p>对比 Dubbo 协议可以看出，HTTP 协议实现的非常简单，主要原因如下：</p><blockquote><ol><li>使用 HTTP 通信，不需要自定义编解码器。</li><li>使用的序列化是 JDK 原生的</li><li>借助了 Spring 提供的服务暴露和服务引用机制</li></ol></blockquote><h3 id="HttpProtocol"><a href="#HttpProtocol" class="headerlink" title="HttpProtocol"></a>HttpProtocol</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProxyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认服务器端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Http 服务器集合</span></span><br><span class="line"><span class="comment">     * key: ip:port</span></span><br><span class="line"><span class="comment">     * value: Http服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, HttpServer&gt; serverMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, HttpServer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 的 HttpInvokerServiceExporter 集合</span></span><br><span class="line"><span class="comment">     * key: path 服务名</span></span><br><span class="line"><span class="comment">     * value: spring的HttpInvokerServiceExporter</span></span><br><span class="line"><span class="comment">     * 请求处理过程说明：</span></span><br><span class="line"><span class="comment">     * HttpServer -&gt; DispatcherServlet -&gt; InternalHandler -&gt; HttpInvokerServiceExporter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, HttpInvokerServiceExporter&gt; skeletonMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, HttpInvokerServiceExporter&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HttpBinder$Adaptive 对象,通过 &#123;<span class="doctag">@link</span> #setHttpBinder(HttpBinder)&#125;方法，Dubbo SPI IOC注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HttpBinder httpBinder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(RemoteAccessException<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHttpBinder</span><span class="params">(HttpBinder httpBinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.httpBinder = httpBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_PORT;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- HttpProtocol</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Runnable <span class="title">doExport</span><span class="params">(<span class="keyword">final</span> T impl, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取服务器地址 ip:port</span></span><br><span class="line">        String addr = getAddr(url);</span><br><span class="line">        <span class="comment">// 2 根据地址从缓存中获得 HttpServer 对象，若不存在，进行创建</span></span><br><span class="line">        HttpServer server = serverMap.get(addr);</span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1 通过SPI机制获取具体的 HttpBinder的拓展实现</span></span><br><span class="line"><span class="comment">             * 2 具体的HttpBinder实现调用bind方法：</span></span><br><span class="line"><span class="comment">             *   1）启动服务</span></span><br><span class="line"><span class="comment">             *   2）为服务设置请求处理器(InternalHandler对象)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            server = httpBinder.bind(url, <span class="keyword">new</span> InternalHandler());</span><br><span class="line">            <span class="comment">// 将创建好的服务加入缓存</span></span><br><span class="line">            serverMap.put(addr, server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取 url 的 path，以此为 key缓存 HttpInvokerServiceExporter</span></span><br><span class="line">        <span class="keyword">final</span> String path = url.getAbsolutePath();</span><br><span class="line">        skeletonMap.put(path, createExporter(impl, type));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 支持泛化，只需将服务实现的接口替换成泛化接口 GenericService 即可</span></span><br><span class="line">        <span class="keyword">final</span> String genericPath = path + <span class="string">"/"</span> + Constants.GENERIC_KEY;</span><br><span class="line">        skeletonMap.put(genericPath, createExporter(impl, GenericService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 返回取消暴露的回调 Runnable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在回调时会移除对应的缓存 HttpInvokerServiceExporter</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                skeletonMap.remove(path);</span><br><span class="line">                skeletonMap.remove(genericPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>HttpProtocol</code> 的 <code>doExport()</code> 方法是对其父类 <code>AbstractProxyProtocol</code> 服务暴露模版方法的实现，该方法的逻辑主要过程如下：</p><ol><li>基于服务地址维度查询缓存的 HTTP服务器 <code>HttpServer</code>。</li><li>使用 HTTP 绑定器创建并启动 HTTP服务器，该服务器用于接收请求。</li><li>创建 <code>HttpInvokerServiceExporter</code> 服务暴露器，向外提供服务，用于处理 HTTP 服务器接收的请求。其中支持泛化实现，即使用服务暴露器暴露一个泛化服务即可。</li><li>返回取消暴露的回调 Runnable 。</li></ol><p>为了适配各种 HTTP 服务器，如 Tomcat、Jetty，以及需要外部 Servlet 容器的 Servlet ，Dubbo 在 Transporter 层提供了一系列接口，代码结构如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-protocol-remoting-http-outline.jpg" alt></p><p>从代码结构结合 <code>Servlet</code> 知识点我们不难看出，Dubbo 使用了四个不同的组件将 Servlet 串联起来。下面我们分别来看这三个组件类。</p><h5 id="HTTP-绑定器"><a href="#HTTP-绑定器" class="headerlink" title="HTTP 绑定器"></a>HTTP 绑定器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"jetty"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpBinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于Dubbo SPI 机制，加载对应的Server 实现。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * bind the server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url server url.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> server.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.SERVER_KEY&#125;)</span><br><span class="line">    <span class="function">HttpServer <span class="title">bind</span><span class="params">(URL url, HttpHandler handler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HttpBinder</code> 用于创建并启动 HTTP 服务器，默认扩展实现为 JettyHttpServer 。</p><ul><li><p>Jetty 绑定器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JettyHttpBinder</span> <span class="keyword">implements</span> <span class="title">HttpBinder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpServer <span class="title">bind</span><span class="params">(URL url, HttpHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于创建并启动 Jetty 服务器。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JettyHttpServer(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Tomcat 绑定器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatHttpBinder</span> <span class="keyword">implements</span> <span class="title">HttpBinder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpServer <span class="title">bind</span><span class="params">(URL url, HttpHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用于创建并启动 Tomcat 服务器。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TomcatHttpServer(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Servlet 绑定器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletHttpBinder</span> <span class="keyword">implements</span> <span class="title">HttpBinder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Adaptive</span>()</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpServer <span class="title">bind</span><span class="params">(URL url, HttpHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这种方式并不直接创建服务器，而是将请求处理器保存起来，用于处理外部 Servlet 容器转发的请求。</span></span><br><span class="line">        <span class="comment">// 也就是说，需要外部配置 Servlet ，该外部 Servlet 接收的请求交由 handler 来处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServletHttpServer(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="HTTP-服务器"><a href="#HTTP-服务器" class="headerlink" title="HTTP 服务器"></a>HTTP 服务器</h5><h6 id="HttpServer"><a href="#HttpServer" class="headerlink" title="HttpServer"></a>HttpServer</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpServer</span> <span class="keyword">extends</span> <span class="title">Resetable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get http handler. 获取处理器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> http handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">HttpHandler <span class="title">getHttpHandler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get url.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get local address.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> local address.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">getLocalAddress</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * close the channel.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Graceful close the channel.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * is bound.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bound</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBound</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * is closed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> closed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HttpServer</code> 继承了 <code>Resetable</code> 接口，定义了 HTTP 服务器接口。在 <strong>dubbo-rpc</strong> 模块中，<code>http://</code>、<code>rest://</code>、<code>hessian://</code>、<code>webservice://</code> 协议实现等，都是基于 HTTP 服务器实现请求处理的。</p><h6 id="AbstractHttpServer"><a href="#AbstractHttpServer" class="headerlink" title="AbstractHttpServer"></a>AbstractHttpServer</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHttpServer</span> <span class="keyword">implements</span> <span class="title">HttpServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否关闭标记</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractHttpServer</span><span class="params">(URL url, HttpHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        closed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不支持超时关闭</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> closed;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其它代码...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTTP 服务器抽象类仅是对处理器和URL的简单封装，外加标记服务器关闭标志。下面我们具体分析 Dubbo 如何实现内置的 Servlet 容器的。考虑到 JettyHttpServer 实现逻辑 和 TomcatHttpServer 实现逻辑类似，这里我们只对 Tomcat 服务器实现进行分析。</p><h6 id="TomcatHttpServer"><a href="#TomcatHttpServer" class="headerlink" title="TomcatHttpServer"></a>TomcatHttpServer</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatHttpServer</span> <span class="keyword">extends</span> <span class="title">AbstractHttpServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TomcatHttpServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内嵌Tomcat</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Tomcat tomcat;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TomcatHttpServer</span><span class="params">(URL url, <span class="keyword">final</span> HttpHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="comment">// 1 注册请求处理器HttpHandler 到 DispatcherServlet的 处理器集合中</span></span><br><span class="line">        DispatcherServlet.addHttpHandler(url.getPort(), handler);</span><br><span class="line">        <span class="comment">// 2 创建内嵌Tomcat</span></span><br><span class="line">        String baseDir = <span class="keyword">new</span> File(System.getProperty(<span class="string">"java.io.tmpdir"</span>)).getAbsolutePath();</span><br><span class="line">        tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">        tomcat.setBaseDir(baseDir);</span><br><span class="line">        <span class="comment">// 设置端口</span></span><br><span class="line">        tomcat.setPort(url.getPort());</span><br><span class="line">        <span class="comment">// 设置最大线程数</span></span><br><span class="line">        tomcat.getConnector().setProperty(<span class="string">"maxThreads"</span>, String.valueOf(url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS)));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        tomcat.getConnector().setProperty(</span></span><br><span class="line"><span class="comment">//                "minSpareThreads", String.valueOf(url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS)));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置最大连接池</span></span><br><span class="line">        tomcat.getConnector().setProperty(<span class="string">"maxConnections"</span>, String.valueOf(url.getParameter(Constants.ACCEPTS_KEY, -<span class="number">1</span>)));</span><br><span class="line">        <span class="comment">// 编码为UTF-8</span></span><br><span class="line">        tomcat.getConnector().setProperty(<span class="string">"URIEncoding"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">// 连接超时 60 秒</span></span><br><span class="line">        tomcat.getConnector().setProperty(<span class="string">"connectionTimeout"</span>, <span class="string">"60000"</span>);</span><br><span class="line">        tomcat.getConnector().setProperty(<span class="string">"maxKeepAliveRequests"</span>, <span class="string">"-1"</span>);</span><br><span class="line">        tomcat.getConnector().setProtocol(<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 创建并添加DispatcherServlet 到 Tomcat 中，作为 Tomcat 的处理器分发器</span></span><br><span class="line">        Context context = tomcat.addContext(<span class="string">"/"</span>, baseDir);</span><br><span class="line">        Tomcat.addServlet(context, <span class="string">"dispatcher"</span>, <span class="keyword">new</span> DispatcherServlet());</span><br><span class="line">        context.addServletMapping(<span class="string">"/*"</span>, <span class="string">"dispatcher"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 添加ServletContext 上下文对象 到 ServletManager 中</span></span><br><span class="line">        ServletManager.getInstance().addServletContext(url.getPort(), context.getServletContext());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 5 启动tomcat</span></span><br><span class="line">            tomcat.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to start tomcat server at "</span> + url.getAddress(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TomcatHttpServer</code> 的构造方法中会创建一个内置的 <strong>Tomcat</strong> 服务器，然后设置 <strong>启动端口</strong>、<strong>最大线程</strong>以及<strong>调度器</strong> 等参数，其中 <strong>调度器</strong> 是用来处理 <strong>内置Tomcat</strong> 接收的请求的，该调度器是 Dubbo 框架通过继承 <code>HttpServer</code> 实现的，作用和 Spring 的 <code>DispatcherServlet</code> 类似，用来派发请求，我们会在下文中详细说明。</p><p>服务关闭如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--- TomcatHttpServer</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 标记关闭</span></span><br><span class="line">        <span class="keyword">super</span>.close();</span><br><span class="line">        <span class="comment">// 移除 ServletContext 对象</span></span><br><span class="line">        ServletManager.getInstance().removeServletContext(url.getPort());</span><br><span class="line">        <span class="comment">// 关闭tomcat</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tomcat.stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="ServletHttpServer"><a href="#ServletHttpServer" class="headerlink" title="ServletHttpServer"></a>ServletHttpServer</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletHttpServer</span> <span class="keyword">extends</span> <span class="title">AbstractHttpServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServletHttpServer</span><span class="params">(URL url, HttpHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line">        <span class="comment">// 注册HttpHandler 到 DispatcherServlet 中</span></span><br><span class="line">        DispatcherServlet.addHttpHandler(url.getParameter(Constants.BIND_PORT_KEY, <span class="number">8080</span>), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ServletHttpServer</code> 是基于 <code>Servlet</code> 的服务器实现类，该方式需要配置 <strong>DispatcherServlet(Dubbo 实现的 HttpServlet)</strong> 到 <strong>web.xml</strong> 中，通过这样的方式，让外部的Servlet容器可以进行转发请求。</p><h5 id="HTTP-调度器"><a href="#HTTP-调度器" class="headerlink" title="HTTP 调度器"></a>HTTP 调度器</h5><p><code>DispatcherServlet</code> 继承了 <code>javax.servlet.http.HttpServlet</code> ，是 Dubbo 实现的服务器请求调度 Servlet。用于调度请求，将请求交给对应的处理器执行。无论是内置的 Jetty 实现，还是 Tomcat 实现，或者是作为外部的 Servlet , <code>DispatcherServlet</code> 作用都是一致的，用于调度请求。</p><h6 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5766349180380479888L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理器缓存集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, HttpHandler&gt; handlers = <span class="keyword">new</span> ConcurrentHashMap&lt;Integer, HttpHandler&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例 - 饿汉模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DispatcherServlet INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DispatcherServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DispatcherServlet.INSTANCE = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加处理器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port      服务器端口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> processor 处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addHttpHandler</span><span class="params">(<span class="keyword">int</span> port, HttpHandler processor)</span> </span>&#123;</span><br><span class="line">        handlers.put(port, processor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DispatcherServlet <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除处理器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port 服务器端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeHttpHandler</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        handlers.remove(port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="调度请求"><a href="#调度请求" class="headerlink" title="调度请求"></a>调度请求</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- DispatcherServlet</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 从HANDLERS集合中查询端口对应的HttpHandler对象</span></span><br><span class="line">        HttpHandler handler = handlers.get(request.getLocalPort());</span><br><span class="line">        <span class="comment">// 2 没有处理器就报错</span></span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND, <span class="string">"Service not found."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3 将请求委托给对应的HttpHandler对象处理</span></span><br><span class="line">            handler.handle(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DispatcherServlet</code> 将接收到的请求交给请求 HTTP 处理器处理。</p><h5 id="HTTP-处理器"><a href="#HTTP-处理器" class="headerlink" title="HTTP 处理器"></a>HTTP 处理器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  request. 请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response response. 响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 HTTP 服务的 Protocol 都有各自的实现，下面我们分析 HttpProtocol 中的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+--- HttpProtocol</span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">implements</span> <span class="title">HttpHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理请求</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> request  request 请求</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> response response 响应</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取请求的uri</span></span><br><span class="line">            String uri = request.getRequestURI();</span><br><span class="line">            <span class="comment">// 2 从缓存中取出uri对应的 HttpInvokerServiceExporter 对象</span></span><br><span class="line">            HttpInvokerServiceExporter skeleton = skeletonMap.get(uri);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 必须是post请求（ Dubbo 2.6.x 的 http 协议是基于HTTP表单的远程调用协议)</span></span><br><span class="line">            <span class="keyword">if</span> (!request.getMethod().equalsIgnoreCase(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 不是post请求就直接返回500</span></span><br><span class="line">                response.setStatus(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 4 设置远程调用地址</span></span><br><span class="line">                RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 5 处理请求，结果写到response中</span></span><br><span class="line">                    <span class="comment">// 响应数据类型使用的也是 application/x-java-serialized-object</span></span><br><span class="line">                    skeleton.handleRequest(request, response);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>HttpProtocol</code> 中 HTTP 处理器是一个内部实现类，用于处理 HTTP 调度器转发过来的请求，最终又会将请求交给 <code>HttpInvokerServiceExporter</code> 暴露的服务处理。其中请求的 <strong>uri</strong> 作为映射 <code>HttpInvokerServiceExporter</code> 暴露的服务的键，在服务引用方法 <code>doRefer</code> 中会设置好这个请求路径。</p><h5 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h5><p>使用 <code>HttpInvokerServiceExporter</code> 向外提供服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">HttpInvokerServiceExporter <span class="title">createExporter</span><span class="params">(T impl, Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  1 创建 HttpInvokerServiceExporter，以 serviceInterface 为公共接口，以 service 为实现类向外提供服务。</span></span><br><span class="line">    <span class="keyword">final</span> HttpInvokerServiceExporter httpServiceExporter = <span class="keyword">new</span> HttpInvokerServiceExporter();</span><br><span class="line">    <span class="comment">// 2 设置接口</span></span><br><span class="line">    httpServiceExporter.setServiceInterface(type);</span><br><span class="line">    <span class="comment">// 3 设置实现</span></span><br><span class="line">    httpServiceExporter.setService(impl);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 4 根据接口和实现，创建代理对象（Spring实现的），是 HttpInvokerServiceExporter 中的一个属性。</span></span><br><span class="line">        httpServiceExporter.afterPropertiesSet();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> httpServiceExporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>HttpInvokerServiceExporter</code> 默认使用的序列化为 <strong>application/x-java-serialized-object</strong>，即 Java 序列方式。理论上可以通过 <code>HttpInvokerServiceExporter.setContentType()</code> 方法指定序列化方式。</p><h4 id="服务引用-1"><a href="#服务引用-1" class="headerlink" title="服务引用"></a>服务引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">+--- HttpProtocol</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doRefer</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; serviceType, <span class="keyword">final</span> URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 判断是否是泛化调用</span></span><br><span class="line">        <span class="keyword">final</span> String generic = url.getParameter(Constants.GENERIC_KEY);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isGeneric = ProtocolUtils.isGeneric(generic) || serviceType.equals(GenericService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建 HttpInvokerProxyFactoryBean 对象</span></span><br><span class="line">        <span class="comment">// Spring 封装的一个服务引用器，serviceInterface 指定了生成代理的接口，serviceUrl 指定了服务所在的地址（与服务暴露者的路径需要对应）</span></span><br><span class="line">        <span class="keyword">final</span> HttpInvokerProxyFactoryBean httpProxyFactoryBean = <span class="keyword">new</span> HttpInvokerProxyFactoryBean();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 设置远程调用信息，其中包括对附加属性和泛化调用的处理</span></span><br><span class="line">        httpProxyFactoryBean.setRemoteInvocationFactory(<span class="keyword">new</span> RemoteInvocationFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> RemoteInvocation <span class="title">createRemoteInvocation</span><span class="params">(MethodInvocation methodInvocation)</span> </span>&#123;</span><br><span class="line">                RemoteInvocation invocation = <span class="keyword">new</span> HttpRemoteInvocation(methodInvocation);</span><br><span class="line">                <span class="keyword">if</span> (isGeneric) &#123;</span><br><span class="line">                    invocation.addAttribute(Constants.GENERIC_KEY, generic);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> invocation;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 设置目标服务的调用地址 ，如：http://10.1.31.48:8080/com.alibaba.dubbo.demo.DemoService</span></span><br><span class="line">        String key = url.toIdentityString();</span><br><span class="line">        <span class="comment">// 4.1 调用泛化服务 如：http://10.1.31.48:8080/com.alibaba.dubbo.demo.DemoService/generic</span></span><br><span class="line">        <span class="keyword">if</span> (isGeneric) &#123;</span><br><span class="line">            key = key + <span class="string">"/"</span> + Constants.GENERIC_KEY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.2 设置访问服务路径，格式：ip:port/path</span></span><br><span class="line">        httpProxyFactoryBean.setServiceUrl(key);</span><br><span class="line">        <span class="comment">// 4.3 设置生成代理的接口</span></span><br><span class="line">        httpProxyFactoryBean.setServiceInterface(serviceType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 初始化客户端类型 client 参数</span></span><br><span class="line">        String client = url.getParameter(Constants.CLIENT_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据客户端类型不同，创建不同的 执行器，默认创建 SimpleHttpInvokerRequestExecutor 对象，即使用的是 JDK 的 HTTP 功能。</span></span><br><span class="line">        <span class="comment">// 以下两种方式 Content-Type 的值为 application/x-java-serialized-object，即使用的序列化方式为 java 序列化</span></span><br><span class="line">        <span class="keyword">if</span> (client == <span class="keyword">null</span> || client.length() == <span class="number">0</span> || <span class="string">"simple"</span>.equals(client)) &#123;</span><br><span class="line">            <span class="comment">// 使用的HttpClient 是 JDK HttpClent</span></span><br><span class="line">            SimpleHttpInvokerRequestExecutor httpInvokerRequestExecutor = <span class="keyword">new</span> SimpleHttpInvokerRequestExecutor() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareConnection</span><span class="params">(HttpURLConnection con,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">int</span> contentLength)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.prepareConnection(con, contentLength);</span><br><span class="line">                    con.setReadTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));</span><br><span class="line">                    con.setConnectTimeout(url.getParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            httpProxyFactoryBean.setHttpInvokerRequestExecutor(httpInvokerRequestExecutor);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"commons"</span>.equals(client)) &#123;</span><br><span class="line">            <span class="comment">// 使用的HttpClient 是 Apache HttpClient</span></span><br><span class="line">            HttpComponentsHttpInvokerRequestExecutor httpInvokerRequestExecutor = <span class="keyword">new</span> HttpComponentsHttpInvokerRequestExecutor();</span><br><span class="line">            httpInvokerRequestExecutor.setReadTimeout(url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));</span><br><span class="line">            httpInvokerRequestExecutor.setConnectTimeout(url.getParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT));</span><br><span class="line">            httpProxyFactoryBean.setHttpInvokerRequestExecutor(httpInvokerRequestExecutor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported http protocol client "</span> + client + <span class="string">", only supported: simple, commons"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 返回指定接口的代理对象</span></span><br><span class="line">        httpProxyFactoryBean.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> (T) httpProxyFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>服务引用的关键有两点：其一，确定好目标服务访问路径，访问路径的 <strong>uri</strong> 部分使用 Dubbo URL 中的 <strong>path参数</strong>。其二，设置 <strong>目标服务的接口</strong>，注意泛化调用的实现方式。</p><h4 id="关系类图"><a href="#关系类图" class="headerlink" title="关系类图"></a>关系类图</h4><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-http-protocol-relation-uml.jpg" alt></p><h4 id="HTTP-报文信息"><a href="#HTTP-报文信息" class="headerlink" title="HTTP 报文信息"></a>HTTP 报文信息</h4><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-protocol-http-spring-package.jpg" alt><br>上图中的客户端之所以是 <strong>Apache-HttpClient</strong>，是配置了 <code>client=commons</code>。默认采用 Java 的客户端，如： <code>User-Agent: Java/1.8.0_211</code>。</p><p>基于 HTTP 表单的远程调用协议，采用 Spring 的 HttpInvoker 实现的 <code>HTTP协议</code>，总体来看比较鸡肋。一方面网络传输使用的是 <code>HTTP</code> 方式，其本身具有通用性，但采用的序列化方式却是 Java 的序列化，这使得其在一定程度上丧失了跨语言的优势。</p><h1 id="Dubbo-2-7-x-实现"><a href="#Dubbo-2-7-x-实现" class="headerlink" title="Dubbo 2.7.x 实现"></a>Dubbo 2.7.x 实现</h1><p>Dubbo 2.7.x 中使用 <strong>HTTP协议 + JSON-RPC</strong> 的方式来实现跨语言调用，其中 HTTP 协议和 JSON 都是天然跨语言的标准，几乎各种语言中都有成熟的类库。该版本中支持的 HTTP 协议实际上使用的是 JSON-RPC 协议，具体是使用 <code>jsonrpc4j</code> 库来实现 <code>JSON-RPC</code> 协议的。</p><h2 id="JSON-RPC-原生使用"><a href="#JSON-RPC-原生使用" class="headerlink" title="JSON-RPC 原生使用"></a>JSON-RPC 原生使用</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>JSON-RPC</code> 协议非常简单，发起远程调用时向服务端传输数据格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"jsonrpc"</span> : <span class="number">2.0</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"sayHello"</span>, </span><br><span class="line">  <span class="attr">"params"</span>: [</span><br><span class="line">     <span class="string">"Hello JSON-RPC"</span></span><br><span class="line">     ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>id：调用标识符，用于标示一次远程调用过程。</li><li>jsonrpc: 定义 JSON-RPC 版本</li><li>method: 调用的方法名</li><li>params: 方法传入参数，需要是数组格式，若无参数则传入 [] 。</li></ul><p>服务器收到调用请求后会查找到相应的方法并进行调用，然后将方法的返回值整理成如下格式，返回给客户端：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>:  <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"jsonrpc"</span> : <span class="number">2.0</span>,</span><br><span class="line">    <span class="attr">"result"</span>: <span class="string">"Hello JSON-RPC"</span>,</span><br><span class="line">    <span class="attr">"error"</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>id: 调用标识符，与调用方传入的标识符一致。</li><li>jsonrpc: 定义 JSON-RPC 版本</li><li>result: 方法返回值，若无返回值，则返回null。若调用错误，返回null。</li><li>error: 调用发生异常时错误信息，无错误返回null。</li></ul><h3 id="jsonrpc4j-使用示例"><a href="#jsonrpc4j-使用示例" class="headerlink" title="jsonrpc4j 使用示例"></a>jsonrpc4j 使用示例</h3><h4 id="服务暴露-1"><a href="#服务暴露-1" class="headerlink" title="服务暴露"></a>服务暴露</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里使用 SpringMvc 接收请求，然后将请求交给 JsonRpcServer</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/json_rpc"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                       HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 将服务 IJsonRpcService 与 JSON-RPC 关联起来，HTTP 请求委托给 JsonPpcServer 进行处理</span></span><br><span class="line"><span class="comment">         * 2 JsonRpcServer 会按照 json-rpc 请求调用 JsonRpcServiceImpl 中的方法。其中 IJsonRrcService 没有用到。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JsonRpcServer rpcServer = <span class="keyword">new</span> JsonRpcServer(<span class="keyword">new</span> JsonRpcServiceImpl(), IJsonRrcService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        rpcServer.handle(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该案例借助 Servlet 容器接收请求，然后将请求委托给 <code>JsonRpcServer</code> 处理。</p><p>下面我们简单对 <code>jsonrpc4j</code> 进行分析，这样可以更直观地感受 <code>JSON-RPC</code> 协议实现。</p><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><h6 id="创建-JsonRpcServer"><a href="#创建-JsonRpcServer" class="headerlink" title="创建 JsonRpcServer"></a>创建 JsonRpcServer</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- JsonRpcServer</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler         服务实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remoteInterface 服务接口，没有用到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonRpcServer</span><span class="params">(Object handler, Class&lt;?&gt; remoteInterface)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 jackson 域对象</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> ObjectMapper(), handler, (Class) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonRpcServer</span><span class="params">(ObjectMapper mapper, Object handler, Class&lt;?&gt; remoteInterface)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.backwardsComaptible = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.rethrowExceptions = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.allowExtraParams = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.allowLessParams = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.errorResolver = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.exceptionLogLevel = Level.WARNING;</span><br><span class="line">        <span class="keyword">this</span>.mapper = mapper; <span class="comment">// mapper</span></span><br><span class="line">        <span class="keyword">this</span>.handler = handler; <span class="comment">// 服务对象</span></span><br><span class="line">        <span class="keyword">this</span>.remoteInterface = remoteInterface; <span class="comment">// null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">+--- JsonRpcServer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isLoggable(Level.FINE)) &#123;</span><br><span class="line">            LOGGER.log(Level.FINE, <span class="string">"Handing HttpServletRequest "</span> + request.getMethod());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1 响应数据类型</span></span><br><span class="line">        response.setContentType(<span class="string">"application/json-rpc"</span>);</span><br><span class="line">        InputStream input = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 获取输出流</span></span><br><span class="line">        OutputStream output = response.getOutputStream();</span><br><span class="line">        <span class="comment">// 2 判断请求类型</span></span><br><span class="line">        <span class="keyword">if</span> (request.getMethod().equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 2.1 如果是 POST 请求，那么请求内容在请求体中</span></span><br><span class="line">            input = request.getInputStream();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!request.getMethod().equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Invalid request method, only POST and GET is supported"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2.2 如果是 GET 请求，则需要把关键的请求参数提取出来，并封装成 InputStream 对象</span></span><br><span class="line">            input = createInputStream(request.getParameter(<span class="string">"method"</span>), request.getParameter(<span class="string">"id"</span>), request.getParameter(<span class="string">"params"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 处理请求</span></span><br><span class="line">        <span class="keyword">this</span>.handle((InputStream) input, (OutputStream) output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(InputStream ips, OutputStream ops)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        JsonNode jsonNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将请求的字节数据反序列化成对象</span></span><br><span class="line">            jsonNode = <span class="keyword">this</span>.mapper.readTree(<span class="keyword">new</span> NoCloseInputStream(ips));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonParseException var5) &#123;</span><br><span class="line">            <span class="keyword">this</span>.writeAndFlushValue(ops, <span class="keyword">this</span>.createErrorResponse(<span class="string">"jsonrpc"</span>, <span class="string">"null"</span>, -<span class="number">32700</span>, <span class="string">"Parse error"</span>, (Object) <span class="keyword">null</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进一步处理请求</span></span><br><span class="line">        <span class="keyword">this</span>.handleNode(jsonNode, ops);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 请求字节流反序列化的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ops  响应输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNode</span><span class="params">(JsonNode node, OutputStream ops)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 根据不同的请求参数类型，进行不同的处理</span></span><br><span class="line">        <span class="keyword">if</span> (node.isObject()) &#123;</span><br><span class="line">            <span class="comment">// 最终有效的请求会走这个分支</span></span><br><span class="line">            <span class="keyword">this</span>.handleObject((ObjectNode) ObjectNode<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">node</span>), <span class="title">ops</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.isArray()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleArray((ArrayNode) ArrayNode<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">node</span>), <span class="title">ops</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.writeAndFlushValue(ops, <span class="keyword">this</span>.createErrorResponse(<span class="string">"2.0"</span>, <span class="string">"null"</span>, -<span class="number">32600</span>, <span class="string">"Invalid Request"</span>, (Object) <span class="keyword">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// node 请求信息 ： &#123;"id":"7325124684462669617","jsonrpc":"2.0","method":"getUser","params":[1]&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleObject</span><span class="params">(ObjectNode node, OutputStream ops)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isLoggable(Level.FINE)) &#123;</span><br><span class="line">            LOGGER.log(Level.FINE, <span class="string">"Request: "</span> + node.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.backwardsComaptible || node.has(<span class="string">"jsonrpc"</span>)) &amp;&amp; node.has(<span class="string">"method"</span>)) &#123;</span><br><span class="line">            <span class="comment">// 1 获取请求信息</span></span><br><span class="line">            JsonNode jsonPrcNode = node.get(<span class="string">"jsonrpc"</span>); <span class="comment">// json-rpc 协议版本</span></span><br><span class="line">            JsonNode methodNode = node.get(<span class="string">"method"</span>);  <span class="comment">// 调用信息 - 方法</span></span><br><span class="line">            JsonNode idNode = node.get(<span class="string">"id"</span>);  <span class="comment">// 调用信息 - 调用唯一id</span></span><br><span class="line">            JsonNode paramsNode = node.get(<span class="string">"params"</span>);  <span class="comment">// 调用信息 - 参数</span></span><br><span class="line">            String jsonRpc = jsonPrcNode != <span class="keyword">null</span> &amp;&amp; !jsonPrcNode.isNull() ? jsonPrcNode.asText() : <span class="string">"2.0"</span>; <span class="comment">// 版本</span></span><br><span class="line">            String methodName = <span class="keyword">this</span>.getMethodName(methodNode); <span class="comment">// 方法名</span></span><br><span class="line">            String serviceName = <span class="keyword">this</span>.getServiceName(methodNode); <span class="comment">// 服务名 ，目前版本返回 null</span></span><br><span class="line">            Object id = <span class="keyword">this</span>.parseId(idNode);  <span class="comment">// 调用id</span></span><br><span class="line">            Set&lt;Method&gt; methods = <span class="keyword">new</span> HashSet();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 反射获取方法对象，即根据服务对象和方法名，反射获取方法对象。</span></span><br><span class="line">            <span class="comment">// getHandlerInterfaces 方法的 serviceName 没有用到，直接是使用 this.handler 获取 Class 信息，即服务对象的Class</span></span><br><span class="line">            methods.addAll(ReflectionUtil.findMethods(<span class="keyword">this</span>.getHandlerInterfaces(serviceName), methodName));</span><br><span class="line">            <span class="keyword">if</span> (methods.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.writeAndFlushValue(ops, <span class="keyword">this</span>.createErrorResponse(jsonRpc, id, -<span class="number">32601</span>, <span class="string">"Method not found"</span>, (Object) <span class="keyword">null</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取方法对象和方法的参数值</span></span><br><span class="line">                JsonRpcServer.MethodAndArgs methodArgs = <span class="keyword">this</span>.findBestMethodByParamsNode(methods, paramsNode);</span><br><span class="line">                <span class="keyword">if</span> (methodArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.writeAndFlushValue(ops, <span class="keyword">this</span>.createErrorResponse(jsonRpc, id, -<span class="number">32602</span>, <span class="string">"Invalid method parameters"</span>, (Object) <span class="keyword">null</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    JsonNode result = <span class="keyword">null</span>;</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 3 反射调用服务方法</span></span><br><span class="line">                        <span class="comment">// this.getHandler(serviceName) 直接返回 this.handler，即服务对象</span></span><br><span class="line">                        result = <span class="keyword">this</span>.invoke(<span class="keyword">this</span>.getHandler(serviceName), methodArgs.method, methodArgs.arguments);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var17) &#123;</span><br><span class="line">                        thrown = var17;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (id != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        JsonError error = <span class="keyword">null</span>;</span><br><span class="line">                        Throwable e;</span><br><span class="line">                        <span class="keyword">if</span> (thrown != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            e = thrown;</span><br><span class="line">                            <span class="keyword">if</span> (InvocationTargetException<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">thrown</span>)) </span>&#123;</span><br><span class="line">                                e = ((InvocationTargetException) InvocationTargetException<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">thrown</span>)).<span class="title">getTargetException</span>()</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.errorResolver != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                error = <span class="keyword">this</span>.errorResolver.resolveError(e, methodArgs.method, methodArgs.arguments);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                error = DEFAULT_ERRROR_RESOLVER.resolveError(e, methodArgs.method, methodArgs.arguments);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                error = <span class="keyword">new</span> JsonError(<span class="number">0</span>, e.getMessage(), e.getClass().getName());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e = <span class="keyword">null</span>;</span><br><span class="line">                        ObjectNode response;</span><br><span class="line">                        <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 4 封装错误响应</span></span><br><span class="line">                            response = <span class="keyword">this</span>.createErrorResponse(jsonRpc, id, error.getCode(), error.getMessage(), error.getData());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 4 封装响应对象</span></span><br><span class="line">                            response = <span class="keyword">this</span>.createSuccessResponse(jsonRpc, id, result);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 5 将结果通过 ops 响应给客户端</span></span><br><span class="line">                        <span class="keyword">this</span>.writeAndFlushValue(ops, response);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (thrown != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (LOGGER.isLoggable(<span class="keyword">this</span>.exceptionLogLevel)) &#123;</span><br><span class="line">                            LOGGER.log(<span class="keyword">this</span>.exceptionLogLevel, <span class="string">"Error in JSON-RPC Service"</span>, thrown);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.rethrowExceptions) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(thrown);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.writeAndFlushValue(ops, <span class="keyword">this</span>.createErrorResponse(<span class="string">"2.0"</span>, <span class="string">"null"</span>, -<span class="number">32600</span>, <span class="string">"Invalid Request"</span>, (Object) <span class="keyword">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="服务引用-2"><a href="#服务引用-2" class="headerlink" title="服务引用"></a>服务引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 1 创建 JsonRpcHttpClient</span></span><br><span class="line">        JsonRpcHttpClient client = <span class="keyword">new</span> JsonRpcHttpClient(<span class="keyword">new</span> URL(<span class="string">"http://127.0.0.1:8080/json_rpc"</span>));</span><br><span class="line">        <span class="comment">// 2 通过 JsonRpcHttpClient.invoke 方法进行调用</span></span><br><span class="line">        <span class="comment">// 2.1 指定调用方法</span></span><br><span class="line">        <span class="comment">// 2.2 指定方法参数，要求数组</span></span><br><span class="line">        <span class="comment">// 2.3 选填，这里是返回值类型</span></span><br><span class="line">        Integer[] params = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>&#125;;</span><br><span class="line">        User getUser = client.invoke(<span class="string">"getUser"</span>, params, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(getUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 <code>JsonRpcHttpClient</code> 对象，并通过 <code>JsonRpcHttpClient</code> 请求服务端。</p><h5 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h5><h6 id="创建-JsonRpcHttpClient"><a href="#创建-JsonRpcHttpClient" class="headerlink" title="创建 JsonRpcHttpClient"></a>创建 JsonRpcHttpClient</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--- JsonRpcHttpClient</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonRpcHttpClient</span><span class="params">(URL serviceUrl)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 jackson 阈对象</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> ObjectMapper(), serviceUrl, <span class="keyword">new</span> HashMap());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JsonRpcHttpClient</span><span class="params">(ObjectMapper mapper, URL serviceUrl, Map&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mapper);  <span class="comment">// JackJson 对象</span></span><br><span class="line">        <span class="keyword">this</span>.connectionProxy = Proxy.NO_PROXY;</span><br><span class="line">        <span class="keyword">this</span>.connectionTimeoutMillis = <span class="number">60000</span>;</span><br><span class="line">        <span class="keyword">this</span>.readTimeoutMillis = <span class="number">120000</span>;</span><br><span class="line">        <span class="keyword">this</span>.sslContext = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.hostNameVerifier = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.headers = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">this</span>.serviceUrl = serviceUrl; <span class="comment">// 服务URL</span></span><br><span class="line">        <span class="keyword">this</span>.headers.putAll(headers);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="调用服务"><a href="#调用服务" class="headerlink" title="调用服务"></a>调用服务</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">+--- JsonRpcHttpClient</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName 方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> argument   参数 ，数组形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz      返回值类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invoke</span><span class="params">(String methodName, Object argument, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.invoke(methodName, argument, (Type) Type<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">clazz</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(String methodName, Object argument, Type returnType, Map&lt;String, String&gt; extraHeaders)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 1 打开连接，连接服务 （JDK 的 HTTP 功能）</span></span><br><span class="line">        HttpURLConnection con = <span class="keyword">this</span>.prepareConnection(extraHeaders);</span><br><span class="line">        con.connect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取连接的输出流对象</span></span><br><span class="line">        OutputStream ops = con.getOutputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3 调用 JsonRpcClient 中 invoke 方法。该方法涉及到请求数据的封装、序列化</span></span><br><span class="line">            <span class="keyword">super</span>.invoke(methodName, argument, ops);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ops.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 获取连接的输入流</span></span><br><span class="line">        InputStream ips = con.getInputStream();</span><br><span class="line">        Object var8;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 5 反序列化</span></span><br><span class="line">            var8 = <span class="keyword">super</span>.readResponse(returnType, ips);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ips.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var8;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 HTTP 连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> extraHeaders</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HttpURLConnection <span class="title">prepareConnection</span><span class="params">(Map&lt;String, String&gt; extraHeaders)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 打开 Http连接</span></span><br><span class="line">        <span class="comment">// this.serviceUrl 服务URL</span></span><br><span class="line">        HttpURLConnection con = (HttpURLConnection) <span class="keyword">this</span>.serviceUrl.openConnection(<span class="keyword">this</span>.connectionProxy);</span><br><span class="line">        con.setConnectTimeout(<span class="keyword">this</span>.connectionTimeoutMillis);</span><br><span class="line">        con.setReadTimeout(<span class="keyword">this</span>.readTimeoutMillis);</span><br><span class="line">        con.setAllowUserInteraction(<span class="keyword">false</span>);</span><br><span class="line">        con.setDefaultUseCaches(<span class="keyword">false</span>);</span><br><span class="line">        con.setDoInput(<span class="keyword">true</span>);</span><br><span class="line">        con.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">        con.setUseCaches(<span class="keyword">false</span>);</span><br><span class="line">        con.setInstanceFollowRedirects(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 设置请求方式为 POST</span></span><br><span class="line">        con.setRequestMethod(<span class="string">"POST"</span>);</span><br><span class="line">        <span class="keyword">if</span> (HttpsURLConnection<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">con</span>)) </span>&#123;</span><br><span class="line">            HttpsURLConnection https = (HttpsURLConnection) HttpsURLConnection<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">con</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hostNameVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">                https.setHostnameVerifier(<span class="keyword">this</span>.hostNameVerifier);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.sslContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">                https.setSSLSocketFactory(<span class="keyword">this</span>.sslContext.getSocketFactory());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator i$ = <span class="keyword">this</span>.headers.entrySet().iterator();</span><br><span class="line">        Entry entry;</span><br><span class="line">        <span class="keyword">while</span> (i$.hasNext()) &#123;</span><br><span class="line">            entry = (Entry) i$.next();</span><br><span class="line">            con.setRequestProperty((String) entry.getKey(), (String) entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i$ = extraHeaders.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (i$.hasNext()) &#123;</span><br><span class="line">            entry = (Entry) i$.next();</span><br><span class="line">            con.setRequestProperty((String) entry.getKey(), (String) entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置请求数据类型固定为  application/json-rpc</span></span><br><span class="line">        con.setRequestProperty(<span class="string">"Content-Type"</span>, <span class="string">"application/json-rpc"</span>);</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>JsonRpcHttpClient.invoke()</code> 方法流程主要完成 JDK HTTP连接的创建， 响应数据的读取，以及反序列化数据。请求的数据的封装和发送是又其父类 <code>JsonRpcClient</code> 完成。</p><h6 id="发起调用"><a href="#发起调用" class="headerlink" title="发起调用"></a>发起调用</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">+--- JsonRpcClient</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName 方法名，如：getUser</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> argument   方法参数值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ops        连接的输出流对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(String methodName, Object argument, OutputStream ops)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 这里会生成一个调用id</span></span><br><span class="line">        <span class="keyword">this</span>.invoke(methodName, argument, ops, <span class="keyword">this</span>.random.nextLong() + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ops</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id         当前调用的唯一标识别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(String methodName, Object argument, OutputStream ops, String id)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.writeRequest(methodName, argument, ops, id);</span><br><span class="line">        ops.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeRequest</span><span class="params">(String methodName, Object argument, OutputStream ops, String id)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 内部发送请求</span></span><br><span class="line">        <span class="keyword">this</span>.internalWriteRequest(methodName, argument, ops, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalWriteRequest</span><span class="params">(String methodName, Object arguments, OutputStream ops, String id)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 构造请求对象</span></span><br><span class="line">        ObjectNode request = <span class="keyword">this</span>.mapper.createObjectNode();</span><br><span class="line">        <span class="comment">// 1.1 id</span></span><br><span class="line">        <span class="keyword">if</span> (id != <span class="keyword">null</span>) &#123;</span><br><span class="line">            request.put(<span class="string">"id"</span>, id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.2 jsonrpc</span></span><br><span class="line">        request.put(<span class="string">"jsonrpc"</span>, <span class="string">"2.0"</span>);</span><br><span class="line">        <span class="comment">// 1.3 method</span></span><br><span class="line">        request.put(<span class="string">"method"</span>, methodName);</span><br><span class="line">        <span class="comment">// 1.4 params</span></span><br><span class="line">        ArrayNode paramsNode;</span><br><span class="line">        <span class="comment">// 1.4.1 数组</span></span><br><span class="line">        <span class="keyword">if</span> (arguments != <span class="keyword">null</span> &amp;&amp; arguments.getClass().isArray()) &#123;</span><br><span class="line">            Object[] args = (Object[]) Object[]<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">arguments</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                paramsNode = <span class="keyword">new</span> ArrayNode(<span class="keyword">this</span>.mapper.getNodeFactory());</span><br><span class="line">                Object[] arr$ = args;</span><br><span class="line">                <span class="keyword">int</span> len$ = args.length;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i$ = <span class="number">0</span>; i$ &lt; len$; ++i$) &#123;</span><br><span class="line">                    Object arg = arr$[i$];</span><br><span class="line">                    JsonNode argNode = <span class="keyword">this</span>.mapper.valueToTree(arg);</span><br><span class="line">                    paramsNode.add(argNode);</span><br><span class="line">                &#125;</span><br><span class="line">                request.put(<span class="string">"params"</span>, paramsNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1.4.2 集合</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arguments != <span class="keyword">null</span> &amp;&amp; Collection<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">arguments</span>)) </span>&#123;</span><br><span class="line">            Collection&lt;?&gt; args = (Collection) Collection<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">arguments</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (!args.isEmpty()) &#123;</span><br><span class="line">                paramsNode = <span class="keyword">new</span> ArrayNode(<span class="keyword">this</span>.mapper.getNodeFactory());</span><br><span class="line">                Iterator i$ = args.iterator();</span><br><span class="line">                <span class="keyword">while</span> (i$.hasNext()) &#123;</span><br><span class="line">                    Object arg = i$.next();</span><br><span class="line">                    JsonNode argNode = <span class="keyword">this</span>.mapper.valueToTree(arg);</span><br><span class="line">                    paramsNode.add(argNode);</span><br><span class="line">                &#125;</span><br><span class="line">                request.put(<span class="string">"params"</span>, paramsNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1.4.3 Map</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arguments != <span class="keyword">null</span> &amp;&amp; Map<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">arguments</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!((Map) Map<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">arguments</span>)).<span class="title">isEmpty</span>()) </span>&#123;</span><br><span class="line">                request.put(<span class="string">"params"</span>, <span class="keyword">this</span>.mapper.valueToTree(arguments));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arguments != <span class="keyword">null</span>) &#123;</span><br><span class="line">            request.put(<span class="string">"params"</span>, <span class="keyword">this</span>.mapper.valueToTree(arguments));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.requestListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.requestListener.onBeforeRequestSent(<span class="keyword">this</span>, request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isLoggable(Level.FINE)) &#123;</span><br><span class="line">            LOGGER.log(Level.FINE, <span class="string">"JSON-PRC Request: "</span> + request.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 使用连接的输出流将请求数据写出去（发送到对端）</span></span><br><span class="line">        <span class="keyword">this</span>.writeAndFlushValue(ops, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeAndFlushValue</span><span class="params">(OutputStream ops, Object value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 将请求对象序列化，然后写出去</span></span><br><span class="line">        <span class="keyword">this</span>.mapper.writeValue(<span class="keyword">new</span> NoCloseOutputStream(ops), value);</span><br><span class="line">        ops.flush();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="源码实现-1"><a href="#源码实现-1" class="headerlink" title="源码实现"></a>源码实现</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-protocol-http-json-rpc-code.jpg" alt></p><p>HTTP 协议实现相关的代码结构如上图所示。</p><h3 id="HttpProtocol-1"><a href="#HttpProtocol-1" class="headerlink" title="HttpProtocol"></a>HttpProtocol</h3><h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProxyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 跨域支持</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACCESS_CONTROL_ALLOW_ORIGIN_HEADER = <span class="string">"Access-Control-Allow-Origin"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACCESS_CONTROL_ALLOW_METHODS_HEADER = <span class="string">"Access-Control-Allow-Methods"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACCESS_CONTROL_ALLOW_HEADERS_HEADER = <span class="string">"Access-Control-Allow-Headers"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务路径（path）到 JsonRpcServer 的映射</span></span><br><span class="line"><span class="comment">     * 请求处理过程说明：HttpServer -&gt; DispatcherServlet -&gt; InternalHandler -&gt; JsonRpcServer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, JsonRpcServer&gt; skeletonMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// HTTP绑定器</span></span><br><span class="line">    <span class="keyword">private</span> HttpBinder httpBinder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(HttpException<span class="class">.<span class="keyword">class</span>, <span class="title">JsonRpcClientException</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HttpBinder$Adaptive 对象,通过 &#123;@link #setHttpBinder(HttpBinder)&#125;方法，Dubbo SPI IOC注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHttpBinder</span><span class="params">(HttpBinder httpBinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.httpBinder = httpBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">80</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务暴露-2"><a href="#服务暴露-2" class="headerlink" title="服务暴露"></a>服务暴露</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+--- HttpProtocol</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Runnable <span class="title">doExport</span><span class="params">(<span class="keyword">final</span> T impl, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取服务器地址 ip:port</span></span><br><span class="line">        String addr = getAddr(url);</span><br><span class="line">        <span class="comment">// 2 根据地址从缓存中获得 HTTP 服务，若不存在，进行创建</span></span><br><span class="line">        ProtocolServer protocolServer = serverMap.get(addr);</span><br><span class="line">        <span class="keyword">if</span> (protocolServer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1 通过SPI机制获取具体的 HttpBinder的拓展实现</span></span><br><span class="line"><span class="comment">             * 2 具体的HttpBinder实现调用bind方法：</span></span><br><span class="line"><span class="comment">             *   1）启动服务</span></span><br><span class="line"><span class="comment">             *   2）为服务设置请求处理器(InternalHandler对象)，支持设置跨域参数</span></span><br><span class="line"><span class="comment">             * 3 缓存 HTTP 服务</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            RemotingServer remotingServer = httpBinder.bind(url, <span class="keyword">new</span> InternalHandler(url.getParameter(<span class="string">"cors"</span>, <span class="keyword">false</span>)));</span><br><span class="line">            serverMap.put(addr, <span class="keyword">new</span> ProxyProtocolServer(remotingServer));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取 url 的 path ，以此为 key 缓存 JsonRpcServer。如：/org.apache.dubbo.demo.GreetingService</span></span><br><span class="line">        <span class="keyword">final</span> String path = url.getAbsolutePath();</span><br><span class="line">        <span class="comment">// 4 支持泛化，如：/org.apache.dubbo.demo.GreetingService/generic</span></span><br><span class="line">        <span class="keyword">final</span> String genericPath = path + <span class="string">"/"</span> + GENERIC_KEY;</span><br><span class="line">        <span class="comment">// 5 创建 JsonRpcServer，暴露服务</span></span><br><span class="line">        JsonRpcServer skeleton = <span class="keyword">new</span> JsonRpcServer(impl, type);</span><br><span class="line">        JsonRpcServer genericServer = <span class="keyword">new</span> JsonRpcServer(impl, GenericService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 6 分别缓存服务和泛化服务的 JsonRpcServer</span></span><br><span class="line">        skeletonMap.put(path, skeleton);</span><br><span class="line">        skeletonMap.put(genericPath, genericServer);</span><br><span class="line">        <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">            skeletonMap.remove(path);</span><br><span class="line">            skeletonMap.remove(genericPath);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="HTTP-处理器-1"><a href="#HTTP-处理器-1" class="headerlink" title="HTTP 处理器"></a>HTTP 处理器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+--- HttpProtocol</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">implements</span> <span class="title">HttpHandler</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 是否跨域支持</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> cors;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(<span class="keyword">boolean</span> cors)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cors = cors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取请求的uri</span></span><br><span class="line">            String uri = request.getRequestURI();</span><br><span class="line">            <span class="comment">// 2 从缓存中取出请求uri 对应的 JsonRpcServer</span></span><br><span class="line">            JsonRpcServer skeleton = skeletonMap.get(uri);</span><br><span class="line">            <span class="comment">// 3 处理跨域</span></span><br><span class="line">            <span class="keyword">if</span> (cors) &#123;</span><br><span class="line">                response.setHeader(ACCESS_CONTROL_ALLOW_ORIGIN_HEADER, <span class="string">"*"</span>);</span><br><span class="line">                response.setHeader(ACCESS_CONTROL_ALLOW_METHODS_HEADER, <span class="string">"POST"</span>);</span><br><span class="line">                response.setHeader(ACCESS_CONTROL_ALLOW_HEADERS_HEADER, <span class="string">"*"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4 响应跨域探测请求</span></span><br><span class="line">            <span class="keyword">if</span> (request.getMethod().equalsIgnoreCase(<span class="string">"OPTIONS"</span>)) &#123;</span><br><span class="line">                response.setStatus(<span class="number">200</span>);</span><br><span class="line">                <span class="comment">// 5 必须是 POST 请求</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.getMethod().equalsIgnoreCase(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 设置远程调用地址</span></span><br><span class="line">                RpcContext.getContext().setRemoteAddress(request.getRemoteAddr(), request.getRemotePort());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 处理请求</span></span><br><span class="line">                    skeleton.handle(request.getInputStream(), response.getOutputStream());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 请求方法不匹配直接抛出 500</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                response.setStatus(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="服务引用-3"><a href="#服务引用-3" class="headerlink" title="服务引用"></a>服务引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+--- HttpProtocol</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doRefer</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 判断是否是泛化调用</span></span><br><span class="line">        <span class="keyword">final</span> String generic = url.getParameter(GENERIC_KEY);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isGeneric = ProtocolUtils.isGeneric(generic) || serviceType.equals(GenericService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 2 工厂对象</span></span><br><span class="line">        JsonProxyFactoryBean jsonProxyFactoryBean = <span class="keyword">new</span> JsonProxyFactoryBean();</span><br><span class="line">        JsonRpcProxyFactoryBean jsonRpcProxyFactoryBean = <span class="keyword">new</span> JsonRpcProxyFactoryBean(jsonProxyFactoryBean);</span><br><span class="line">        <span class="comment">// 3 附加属性和泛化调用支持</span></span><br><span class="line">        jsonRpcProxyFactoryBean.setRemoteInvocationFactory((methodInvocation) -&gt; &#123;</span><br><span class="line">            RemoteInvocation invocation = <span class="keyword">new</span> JsonRemoteInvocation(methodInvocation);</span><br><span class="line">            <span class="comment">// 泛化调用</span></span><br><span class="line">            <span class="keyword">if</span> (isGeneric) &#123;</span><br><span class="line">                invocation.addAttribute(GENERIC_KEY, generic);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> invocation;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 服务访问路径，如 http://10.1.31.48:80/org.apache.dubbo.demo.DemoService</span></span><br><span class="line">        String key = url.setProtocol(<span class="string">"http"</span>).toIdentityString();</span><br><span class="line">        <span class="comment">// 5 泛化调用服务访问路径，如: http://10.1.31.48:80/org.apache.dubbo.demo.DemoService/generic</span></span><br><span class="line">        <span class="keyword">if</span> (isGeneric) &#123;</span><br><span class="line">            key = key + <span class="string">"/"</span> + GENERIC_KEY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.1 设置服务访问路径，设置到 jsonProxyFactoryBean 中</span></span><br><span class="line">        jsonRpcProxyFactoryBean.setServiceUrl(key);</span><br><span class="line">        <span class="comment">// 6.2 设置服务接口，设置到 jsonProxyFactoryBean 中</span></span><br><span class="line">        jsonRpcProxyFactoryBean.setServiceInterface(serviceType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.3 执行Spring的InitializingBean方法， 创建 JsonRpcHttpClient &amp; 接口代理对象</span></span><br><span class="line">        jsonProxyFactoryBean.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7 返回接口的代理对象，拦截功能是 MethodInterceptor，基于aopalliance提供AOP的拦截处理机制。</span></span><br><span class="line">        <span class="comment">// 在执行接口的目标方法时，会进行拦截，执行 com.googlecode.jsonrpc4j.spring.JsonProxyFactoryBean.invoke 方法，进而使用 JsonRpcHttpClient 进行远程调用</span></span><br><span class="line">        <span class="keyword">return</span> (T) jsonProxyFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="创建-JsonRpcHttpClient-amp-接口代理对象"><a href="#创建-JsonRpcHttpClient-amp-接口代理对象" class="headerlink" title="创建 JsonRpcHttpClient &amp; 接口代理对象"></a>创建 JsonRpcHttpClient &amp; 接口代理对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+--- <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonProxyFactoryBean</span> <span class="keyword">extends</span> <span class="title">UrlBasedRemoteAccessor</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">MethodInterceptor</span>,</span></span><br><span class="line"><span class="class"><span class="title">InitializingBean</span>,</span></span><br><span class="line"><span class="class"><span class="title">FactoryBean</span>&lt;<span class="title">Object</span>&gt;,</span></span><br><span class="line"><span class="class"><span class="title">ApplicationContextAware</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">Override</span></span></span><br><span class="line">@SuppressWarnings("unchecked")</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 创建接口代理对象，拦截增强使用 MethodInterceptor</span></span><br><span class="line">proxyObject = ProxyFactory.getProxy(getServiceInterface(), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// find the ObjectMapper</span></span><br><span class="line"><span class="keyword">if</span> (objectMapper == <span class="keyword">null</span></span><br><span class="line">&amp;&amp; applicationContext != <span class="keyword">null</span></span><br><span class="line">&amp;&amp; applicationContext.containsBean(<span class="string">"objectMapper"</span>)) &#123;</span><br><span class="line">objectMapper = (ObjectMapper) applicationContext.getBean(<span class="string">"objectMapper"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (objectMapper == <span class="keyword">null</span> &amp;&amp; applicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">objectMapper = (ObjectMapper)BeanFactoryUtils</span><br><span class="line">.beanOfTypeIncludingAncestors(applicationContext, ObjectMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123; <span class="comment">/* no-op */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (objectMapper==<span class="keyword">null</span>) &#123;</span><br><span class="line">objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 创建 JsonRpcHttpClient</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">jsonRpcHttpClient = <span class="keyword">new</span> JsonRpcHttpClient(objectMapper, <span class="keyword">new</span> URL(getServiceUrl()), extraHttpHeaders);</span><br><span class="line">jsonRpcHttpClient.setRequestListener(requestListener);</span><br><span class="line">            jsonRpcHttpClient.setSslContext(sslContext);</span><br><span class="line">            jsonRpcHttpClient.setHostNameVerifier(hostNameVerifier);</span><br><span class="line">&#125; <span class="keyword">catch</span> (MalformedURLException mue) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(mue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="拦截增强"><a href="#拦截增强" class="headerlink" title="拦截增强"></a>拦截增强</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+--- <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonProxyFactoryBean</span> <span class="keyword">extends</span> <span class="title">UrlBasedRemoteAccessor</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">MethodInterceptor</span>,</span></span><br><span class="line"><span class="class"><span class="title">InitializingBean</span>,</span></span><br><span class="line"><span class="class"><span class="title">FactoryBean</span>&lt;<span class="title">Object</span>&gt;,</span></span><br><span class="line"><span class="class"><span class="title">ApplicationContextAware</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">/**</span></span><br><span class="line"><span class="class"> * </span>&#123;<span class="meta">@inheritDoc</span>&#125;</span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 handle toString()</span></span><br><span class="line">Method method = invocation.getMethod();</span><br><span class="line">if (method.getDeclaringClass() == Object.class &amp;&amp; method.getName().equals("toString")) &#123;</span><br><span class="line"><span class="keyword">return</span> proxyObject.getClass().getName() + <span class="string">"@"</span> + System.identityHashCode(proxyObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 get return type</span></span><br><span class="line">Type retType = (invocation.getMethod().getGenericReturnType() != <span class="keyword">null</span>)</span><br><span class="line">? invocation.getMethod().getGenericReturnType()</span><br><span class="line">: invocation.getMethod().getReturnType();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 get arguments</span></span><br><span class="line">Object arguments = ReflectionUtil.parseArguments(</span><br><span class="line">invocation.getMethod(), invocation.getArguments(), useNamedParams);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 invoke it</span></span><br><span class="line"><span class="keyword">return</span> jsonRpcHttpClient.invoke(</span><br><span class="line">invocation.getMethod().getName(),</span><br><span class="line">arguments,</span><br><span class="line">retType, extraHttpHeaders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以切面的方式对目标方法进行拦截，进而使用 <code>JsonRpcHttpClient</code> 调用远程服务方法。</p><h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+--- HttpProtocol</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">        <span class="comment">// 关闭服务</span></span><br><span class="line">        <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;&gt;(serverMap.keySet())) &#123;</span><br><span class="line">            ProtocolServer server = serverMap.remove(key);</span><br><span class="line">            <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Close jsonrpc server "</span> + server.getUrl());</span><br><span class="line">                    &#125;</span><br><span class="line">                    server.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>HTTP 绑定器、HTTP 调度器、HTTP 服务器 和 Dubbo 2.6.x 中的一致。</p><h4 id="HTTP-报文信息-1"><a href="#HTTP-报文信息-1" class="headerlink" title="HTTP 报文信息"></a>HTTP 报文信息</h4><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-protocol-http-json-rpc-package.jpg" alt></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-protocol-http-json-rpc-package-stream.jpg" alt></p><p>从 Dubbo 2.7.x 中的 HTTP 报文体的组织和序列化方式可以看出，相比 Spring 的 HttpInvoker ，使用 JSON-RPC 协议更加适合跨语言调用，更适合戴上 http 协议的帽子。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章介绍了 Dubbo 不同版本中 <code>HTTP协议的实现</code>，从协议名来看这是支持通用调用的协议，但是真正地实现并非如此。基于 HTTTP 表单的远程调用协议采用了 Spring 的 HttpInvoker 实现，序列化使用 Java 语言的序列化技术，远程调用逻辑由 Spring 封装，这显然失去了跨语言的能力。为了实现跨语言调用，Dubbo 转而使用 <code>HTTP协议 + JSON-RPC</code> 的方案，这依赖 <strong>HTTP 协议</strong> 和 <strong>JSON</strong> 都是跨语言的标准，几乎在各种语言中都有成熟的类库。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;RPC 实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;远程过程调用需要解决以下问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Protocol" scheme="https://gentryhuang.com/tags/Protocol/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - Dubbo协议</title>
    <link href="https://gentryhuang.com/posts/a064181a/"/>
    <id>https://gentryhuang.com/posts/a064181a/</id>
    <published>2020-08-29T16:00:00.000Z</published>
    <updated>2021-03-11T14:49:25.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://gentryhuang.com/posts/450e3eda/">多协议概览</a> 中，我们对 Dubbo 的协议的两大分支从抽象层面进行了介绍，本篇文章将对 Dubbo 协议进行详细分析。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 框架缺省协议就是 Dubbo 协议，该协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。Dubbo 协议调用简化图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-threadpool-model.jpg" alt></p><ul><li>Transporter: mina, netty, grizzy</li><li>Serialization: dubbo, hessian2, java, json</li><li>Dispatcher: all, direct, message, execution, connection</li><li>ThreadPool: fixed, cached,limited,eager</li></ul><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><blockquote><p>连接个数：单一连接<br>连接方式：长连接<br>传输协议：TCP<br>传输方式：NIO 异步传输<br>序列化：默认采用 Hessian 二进制序列化<br>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。</p></blockquote><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li><strong>为什么要消费者比提供者个数多？</strong><blockquote><p>因为 Dubbo 协议采用单一长连接，每条连接数据压网卡的字节数据量是一定的，理论上一个服务提供者需要多个服务消费者才能压满网卡。</p></blockquote></li><li><strong>为什么不能传大包？</strong><blockquote><p>因为 Dubbo 协议采用单一长连接，如果每次请求的数据包太大，单个服务提供者的 TPS 会降低，因为网络带宽是一定的。此外，单个消费者调用单个服务提供者的 TPS 也会随着请求包变大而降低。</p></blockquote></li><li><strong>为什么采用异步单一长连接？</strong><blockquote><p>通过单一连接保证单一消费者不会压垮提供者；长连接减少连接握手验证等；使用异步 IO 复用线程池，防止 C10K 问题。</p></blockquote></li></ul><h1 id="Dubbo-协议"><a href="#Dubbo-协议" class="headerlink" title="Dubbo 协议"></a>Dubbo 协议</h1><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exchange-codec.jpg" alt></p><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p><strong>不使用 HTTP 的原因:</strong></p><blockquote><ol><li>在设计 RPC 的时候，为了高性能和吞吐量，基于 TCP 性能更快。</li><li>一般 RPC 为了吞吐量，会异步发送请求，等待响应，所以需要知道哪个应答对应哪个请求，而 HTTP 属于无状态协议，无法实现请求跟响应关联。</li><li>版本不是很低的 HTTP 都支持 Keep-Alive 链接，可以避免了链接重复创建开销，也能支持长连接，但是目前应用 HTTP 更多是使用短连接。</li></ol></blockquote><p><strong>Dubbo 协议现存问题:</strong></p><blockquote><ol><li>Dubbo 协议是直接定义在 TCP 传输层协议之上，由于 TCP 高可靠全双工的特点，为 Dubbo 协议的定义提供了最大的灵活性，但同时也正是因为这样的灵活性，RPC 协议普遍都是定制化的私有协议，Dubbo 同样也面临这个问题。</li><li>相比于直接构建与 TPC 传输层的私有 RPC 协议，构建于 HTTP 之上的远程调用解决方案会有更好的通用性，如 WebServices 或 REST 架构，使用 HTTP + JSON 可以说是一个事实标准的解决方案。之所以选择构建在 HTTP 之上，有两大的优势：<ul><li>HTTP 的语义和可扩展性能很好的满足 RPC 调用需求。 - 扩展性</li><li>通用性，HTTP 协议几乎被网络上的所有设备所支持，具有很好的协议穿透性。- 通用性</li></ul></li></ol></blockquote><p><strong>优化点：</strong></p><blockquote><ol><li>Dubbo 协议体 Body 中有一个可扩展的 attachments 部分，这给 RPC 方法之外额外传递附加属性提供了可能，是一个很好的设计。但是类似的 Header 部分，却缺少类似的可扩展 attachments，这点可参考 HTTP 定义的 Ascii Header 设计，将 Body Attachments 和 Header Attachments 做职责划分。</li><li>Body 协议体中的一些 RPC 请求定位符如 Service Name、Method Name、Version 等，可以提到 Header 中，和具体的序列化协议解耦，以更好的被网络基础设施识别或用于流量管控。</li><li>扩展性不够好，欠缺协议升级方面的设计，如 Header 头中没有预留的状态标识位，或者像 HTTP 有专为协议升级或协商设计的特殊 packet。协议头要支持可扩展，可以定义一个扩展字段用于存放扩展信息，扩展后的协议头的长度就不能固定了，可以在协议头中加入一个标识头长度的字段。</li></ol></blockquote><p>Dubbo 协议设计上没有足够的前瞻性，但周边也有不少配件组件，如 <code>dubbo2.js</code>、<code>dubbo-go</code>、<code>dubbo-cpp</code> 等，在一定程度上解决了多语言问题。关于 Dubbo 协议具体可以参考 <a href="https://gentryhuang.com/posts/61d79ae/">编解码器</a> 中的介绍。</p><h1 id="DubboProtocol"><a href="#DubboProtocol" class="headerlink" title="DubboProtocol"></a>DubboProtocol</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"dubbo"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议默认端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">20880</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数回调用相关字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IS_CALLBACK_SERVICE_INVOKE = <span class="string">"_isCallBackServiceInvoke"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DubboProtocol</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DubboProtocol INSTANCE;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通信服务集合</span></span><br><span class="line"><span class="comment">     * key: 服务器地址。格式：host:port</span></span><br><span class="line"><span class="comment">     * value: ExchangeServer 信息交换服务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ExchangeServer&gt; serverMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ExchangeServer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通信连接集合</span></span><br><span class="line"><span class="comment">     * key: 服务器地址 格式：host:port</span></span><br><span class="line"><span class="comment">     * value: 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ReferenceCountExchangeClient&gt; referenceClientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ReferenceCountExchangeClient&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通信连接集合 - 延迟连接的创建</span></span><br><span class="line"><span class="comment">     * key: 服务器地址 格式:host:port</span></span><br><span class="line"><span class="comment">     * value: 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, LazyConnectExchangeClient&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于jvm 锁集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Object&gt; locks = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已初始化的 SerializationOptimizer 实现类名的集合</span></span><br><span class="line"><span class="comment">     * 用于序列化优化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; optimizers = <span class="keyword">new</span> ConcurrentHashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//consumer side export a stub service for dispatching event  和本地存根相关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, String&gt; stubServiceMethodsMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        INSTANCE = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DubboProtocol <span class="title">getDubboProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// dubbo SPI 获取 DubboProtocl</span></span><br><span class="line">            ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">DubboProtocol</span>.<span class="title">NAME</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DubboProtocol</code>中的属性包括以下几个方面的信息：</p><ol><li>Dubbo 协议的默认端口、Protocol 扩展实现</li><li>Dubbo 协议下的服务器和客户端缓存</li><li>序列化优化器实现</li></ol><h2 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取URL</span></span><br><span class="line">        URL url = invoker.getUrl();</span><br><span class="line">        <span class="comment">//2 服务暴露</span></span><br><span class="line">        <span class="comment">//2.1 获取服务键,如：demoGroup/com.alibaba.dubbo.demo.DemoService:1.0.0:20880</span></span><br><span class="line">        String key = serviceKey(url);</span><br><span class="line">        <span class="comment">//2.2 将上层传入的 Invoker 对象封装成 DubboExporter 对象</span></span><br><span class="line">        DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">        <span class="comment">//2.3 缓存 DubboExporter 到父类AbstractProtocol Map缓存中,相同则覆盖</span></span><br><span class="line">        exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//export an stub service for dispatching event 和本地存根有关</span></span><br><span class="line">        Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);</span><br><span class="line">        <span class="comment">// 参数回调相关</span></span><br><span class="line">        Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">            String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">            <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"consumer ["</span> + url.getParameter(Constants.INTERFACE_KEY) +</span><br><span class="line">                            <span class="string">"], has set stubproxy support event ,but no stub methods founded."</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3 启动服务器</span></span><br><span class="line">        openServer(url);</span><br><span class="line">        <span class="comment">// 4 优化序列化</span></span><br><span class="line">        optimizeSerialization(url);</span><br><span class="line">        <span class="comment">// 5 将 Invoker 以 Exporter 形式暴露出去</span></span><br><span class="line">        <span class="keyword">return</span> exporter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DubboProtcol</code> 直接实现了 <code>Protocol</code> 的服务暴露接口，因为 <code>AbstractProtocol</code> 并没有对服务暴露接口进行实现。Dubbo 协议下的服务暴露核心就两点，将具有服务能力的 <code>Invoker</code> 封装成 <code>DubboExporter</code>，接着启动 <code>NIO服务器</code> 用于接收请求。 下面分别对启动服务和优化序列化部分详细分析。</p><h3 id="启动NIO服务"><a href="#启动NIO服务" class="headerlink" title="启动NIO服务"></a>启动NIO服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 host:port，并将其作为服务器实例缓存 key，用于标识当前的服务起实例</span></span><br><span class="line">        String key = url.getAddress();</span><br><span class="line">        <span class="comment">// 参数配置项 isserver，只有Server端才能启动Server对象</span></span><br><span class="line">        <span class="keyword">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有Server端才能启动Server对象</span></span><br><span class="line">        <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">            <span class="comment">// 从serverMap缓存中获取服务器</span></span><br><span class="line">            ExchangeServer server = serverMap.get(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 无 Server监听该地址</span></span><br><span class="line">            <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 不存在则创建 Server</span></span><br><span class="line">                serverMap.put(key, createServer(url));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果已有 Server 实例，则尝试根据URL信息重置 Server</span></span><br><span class="line">                <span class="comment">// com.alibaba.dubbo.remoting.transport.AbstractServer.reset</span></span><br><span class="line">                server.reset(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建并启动服务是以 Dubbo 的主机绑定结果 <code>host:port</code> 进行的，并且同一台服务器同一个端口上仅允许启动一个服务器实例，若某个端口上已有服务器实例，此时<code>reset</code>方法就会调用，重置服务器的一些配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line">   <span class="function"><span class="keyword">private</span> ExchangeServer <span class="title">createServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 默认开启 在 Server 关闭的时候，只能发送 ReadOnly 请求</span></span><br><span class="line">        url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 默认开启 心跳 【heartbeat参数会在HeaderExchangeServer启动心跳计时器使用】,默认值为 60000，表示默认的心跳时间间隔为 60 秒</span></span><br><span class="line">        url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 检测SERVER_KEY参数指定的Transporter扩展实现是否合法, 即Dubbo SPI扩展是否存在，默认是Netty</span></span><br><span class="line">        String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">str</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported server type: "</span> + str + <span class="string">", url: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 设置编码解码器参数 ，默认为 DubboCountCodec</span></span><br><span class="line">        url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 创建、启动服务器</span></span><br><span class="line">        ExchangeServer server;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 5.1 通过Exchangers门面类，创建ExchangeServer对象。</span></span><br><span class="line">            <span class="comment">// 需要传入 ExchangeHandler 对象，该对象用于处理通道相关事件 </span></span><br><span class="line">            server = Exchangers.bind(url, requestHandler);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to start server(url: "</span> + url + <span class="string">") "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 校验Client 的 Dubbo SPI拓展是否存在。可指定netty,mina</span></span><br><span class="line">        str = url.getParameter(Constants.CLIENT_KEY);</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取所有的Transporter 实现类名称集合，比如 netty,mina</span></span><br><span class="line">            Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter<span class="class">.<span class="keyword">class</span>).<span class="title">getSupportedExtensions</span>()</span>;</span><br><span class="line">            <span class="comment">// 检测当前Dubbo 所支持的Transporter实现类名称列表中是否包含client所表示的 Transporter ，若不包含则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: "</span> + str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DubboProtol</code> 在创建并启动 <code>NIO服务器</code> 之前，会为 <code>URL</code> 添加功能参数：</p><blockquote><p>1 channel.readonly.sent: 开启 在 Server 关闭的时候只能发送 ReadOnly 请求<br>2 heartbeat: 开启心跳，默认值为 60000 ，表示默认的心跳时间间隔为 60 s<br>3 codec: 设置编解码器，默认为 DubboCountCodec </p></blockquote><p>功能参数设置完毕后，通过信息交换层的 <code>Exchangers</code> 门面类创建 <code>ExchangeServer</code> 对象，并传入通道处理器 <code>ExchangeHandler</code> 对象。关于信息交换层的介绍可以参考 <a href="https://gentryhuang.com/posts/26722deb/">信息交换层</a> 一文。下面我们来看看 <code>DubboProtocol</code> 的通道处理器实现。</p><h3 id="通道处理器"><a href="#通道处理器" class="headerlink" title="通道处理器"></a>通道处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"> <span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理服务消费者的 同步调用和异步调用的请求</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">            <span class="comment">// 判断消息类型。其实，经过前面的 Hander 处理后这里收到的 Message 必须是 Invocation 类型的对象</span></span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) &#123;</span><br><span class="line">                Invocation inv = (Invocation) message;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 获取此次调用的Invoker：</span></span><br><span class="line"><span class="comment">                 * 1 先获取 Exporter （在服务暴露时就已经初始化好了）</span></span><br><span class="line"><span class="comment">                 * 2 从 exporter 中获取 Invoker</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 如果是参数回调：</span></span><br><span class="line"><span class="comment">                 * 1 需要处理高版本调用低版本的问题</span></span><br><span class="line"><span class="comment">                 * 2 校验服务消费者实际存在对应的回调方法，通过方法名判断</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">                    String methodsStr = invoker.getUrl().getParameters().get(<span class="string">"methods"</span>);</span><br><span class="line">                    <span class="keyword">boolean</span> hasMethod = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (methodsStr == <span class="keyword">null</span> || methodsStr.indexOf(<span class="string">","</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">                        hasMethod = inv.getMethodName().equals(methodsStr);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        String[] methods = methodsStr.split(<span class="string">","</span>);</span><br><span class="line">                        <span class="keyword">for</span> (String method : methods) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (inv.getMethodName().equals(method)) &#123;</span><br><span class="line">                                hasMethod = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!hasMethod) &#123;</span><br><span class="line">                        logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">"The methodName "</span> + inv.getMethodName()</span><br><span class="line">                                + <span class="string">" not found in callback service interface ,invoke will be ignored."</span></span><br><span class="line">                                + <span class="string">" please update the api interface. url is:"</span></span><br><span class="line">                                + invoker.getUrl()) + <span class="string">" ,invocation is :"</span> + inv);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置调用方的地址，即将消费方地址记录到 RpcContext 中</span></span><br><span class="line">                RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *  执行调用</span></span><br><span class="line"><span class="comment">                 *  1 执行 Filter链 ：EchoFilter-&gt;ClassLoaderFilter-&gt;GenericFilter-&gt;ContextFilter-&gt;TraceFilter-&gt;TimeoutFilter-&gt;MonitorFilter-&gt;ExceptionFilter -&gt; Invoker逻辑</span></span><br><span class="line"><span class="comment">                 *  2 然后执行真正的Invoker的调用逻辑：AbstractProxyInvoker.invoke -&gt; JavassistProxyFactory$AbstractProxyInvoker.doInvoke -&gt; Wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments) -&gt; ref.xxxYYY方法</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">"Unsupported request: "</span></span><br><span class="line">                    + (message == <span class="keyword">null</span> ? <span class="keyword">null</span> : (message.getClass().getName() + <span class="string">": "</span> + message))</span><br><span class="line">                    + <span class="string">", channel: consumer: "</span> + channel.getRemoteAddress() + <span class="string">" --&gt; provider: "</span> + channel.getLocalAddress());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *处理读取到的数据</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">            <span class="comment">// 判断消息类型是不是 Invocation</span></span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) &#123;</span><br><span class="line">                reply((ExchangeChannel) channel, message);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">super</span>.received(channel, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//---------------- 以下是对设置的 onconnect 和 ondisconnect 方法的处理 -----------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在服务提供者上可以配置 onconnect 配置项指定连接上服务时会调用的方法 - 不是很重要</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">            invoke(channel, Constants.ON_CONNECT_KEY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在服务提供者上可以配置 'ondisconnect' 配置项指定方法，在服务提供者连接断开时会调用该方法 - 不是很重要</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"disconnected from "</span> + channel.getRemoteAddress() + <span class="string">",url:"</span> + channel.getUrl());</span><br><span class="line">            &#125;</span><br><span class="line">            invoke(channel, Constants.ON_DISCONNECT_KEY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 进行调用，执行对应的方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> channel 通道</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> methodKey 方法名</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Channel channel, String methodKey)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 创建调用信息 Invocation 对象</span></span><br><span class="line">            Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);</span><br><span class="line">            <span class="comment">// 如果 invocation 不为空，执行received方法</span></span><br><span class="line">            <span class="keyword">if</span> (invocation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    received(channel, invocation);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Failed to invoke event method "</span> + invocation.getMethodName() + <span class="string">"(), cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建 Invocation</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> methodKey</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Invocation <span class="title">createInvocation</span><span class="params">(Channel channel, URL url, String methodKey)</span> </span>&#123;</span><br><span class="line">            String method = url.getParameter(methodKey);</span><br><span class="line">            <span class="keyword">if</span> (method == <span class="keyword">null</span> || method.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            RpcInvocation invocation = <span class="keyword">new</span> RpcInvocation(method, <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>], <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">            invocation.setAttachment(Constants.PATH_KEY, url.getPath());</span><br><span class="line">            invocation.setAttachment(Constants.GROUP_KEY, url.getParameter(Constants.GROUP_KEY));</span><br><span class="line">            invocation.setAttachment(Constants.INTERFACE_KEY, url.getParameter(Constants.INTERFACE_KEY));</span><br><span class="line">            invocation.setAttachment(Constants.VERSION_KEY, url.getParameter(Constants.VERSION_KEY));</span><br><span class="line">            <span class="keyword">if</span> (url.getParameter(Constants.STUB_EVENT_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                invocation.setAttachment(Constants.STUB_EVENT_KEY, Boolean.TRUE.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> invocation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p><code>DubboProtocol</code> 中实现了信息交换层中的 <code>ExchangeHandlerAdapter</code> 通道处理器逻辑，服务消费者的远程调用是通过 <code>#reply</code> 方法处理的，该方法的核心逻辑如下：</p><ol><li>根据连接信息和调用信息组装服务健，并根据服务健获取具有服务能力的 <code>Invoker</code> 对象。</li><li>如果设置了参数回调用，则对参数回调逻辑进行处理。关于参数回调内容会在 Dubbo 高级特性中介绍。</li><li>将调用方的地址即消费端地址记录到上下文中。</li><li>执行 <code>Invoker.invoke</code> 。</li></ol><p>下面我们继续分析获取 <code>Invoker</code> 对象的方法。</p><h4 id="服务端侧-Invoker"><a href="#服务端侧-Invoker" class="headerlink" title="服务端侧 Invoker"></a>服务端侧 Invoker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"> Invoker&lt;?&gt; getInvoker(Channel channel, Invocation inv) <span class="keyword">throws</span> RemotingException &#123;</span><br><span class="line">        <span class="keyword">boolean</span> isCallBackServiceInvoke = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isStubServiceInvoke = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取端口</span></span><br><span class="line">        <span class="keyword">int</span> port = channel.getLocalAddress().getPort();</span><br><span class="line">        <span class="comment">// 从调用信息中国获取 path</span></span><br><span class="line">        String path = inv.getAttachments().get(Constants.PATH_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对客户端 Callback 的处理</span></span><br><span class="line">        isStubServiceInvoke = Boolean.TRUE.toString().equals(inv.getAttachments().get(Constants.STUB_EVENT_KEY));</span><br><span class="line">        <span class="keyword">if</span> (isStubServiceInvoke) &#123;</span><br><span class="line">            <span class="comment">// 从Channel中获取 端口 port</span></span><br><span class="line">            port = channel.getRemoteAddress().getPort();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 参数回调处理，获得真正的服务名 `path`</span></span><br><span class="line">        isCallBackServiceInvoke = isClientSide(channel) &amp;&amp; !isStubServiceInvoke;</span><br><span class="line">        <span class="keyword">if</span> (isCallBackServiceInvoke) &#123;</span><br><span class="line">            path = inv.getAttachments().get(Constants.PATH_KEY) + <span class="string">"."</span> + inv.getAttachments().get(Constants.CALLBACK_SERVICE_KEY);</span><br><span class="line">            inv.getAttachments().put(IS_CALLBACK_SERVICE_INVOKE, Boolean.TRUE.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得服务键，格式： group/path:version:port</span></span><br><span class="line">        <span class="comment">// 根据 Invocation 携带的信息：attachments 中的path、group、version以及从channel中获取的port 计算服务健</span></span><br><span class="line">        String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据服务健查找缓存的 DubboExporter</span></span><br><span class="line">        DubboExporter&lt;?&gt; exporter = (DubboExporter&lt;?&gt;) exporterMap.get(serviceKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有对应的 Exporter，直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, <span class="string">"Not found exported service: "</span> + serviceKey + <span class="string">" in "</span> + exporterMap.keySet() + <span class="string">", may be version or group mismatch "</span> + <span class="string">", channel: consumer: "</span> + channel.getRemoteAddress() + <span class="string">" --&gt; provider: "</span> + channel.getLocalAddress() + <span class="string">", message:"</span> + inv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出Exporter中的Invoker 对象</span></span><br><span class="line">        <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取服务端侧 <code>Invoker</code> 就是根据 <strong>服务键</strong> 从缓存中取出服务暴露时存储在内存中的 <code>Expoter</code> 对象，进而从该 <code>Expoter</code> 中取出对应的 <code>Invoker</code> 对象。注意，服务键的 <code>group</code>、<code>path</code>、<code>verison</code> 都是从调用信息中获取的，因为调用方更清楚目标服务，而 <code>port</code> 部分则是通过通道获取的，调用方无需关心端口，提供方自己更加清楚。</p><h3 id="优化序列化"><a href="#优化序列化" class="headerlink" title="优化序列化"></a>优化序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">optimizeSerialization</span><span class="params">(URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       <span class="comment">// 获得 optimizer 序列化优化器 配置项</span></span><br><span class="line">       String className = url.getParameter(Constants.OPTIMIZER_KEY, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果系统中没有指定序列化优化器就直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (StringUtils.isEmpty(className) || optimizers.contains(className)) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       logger.info(<span class="string">"Optimizing the serialization process for Kryo, FST, etc..."</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 根据 序列化优化器名 加载 SerializationOptimizer 实现类</span></span><br><span class="line">           Class clazz = Thread.currentThread().getContextClassLoader().loadClass(className);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 是否是 SerializationOptimizer.class，或者 是SerializationOptimizer 的子类</span></span><br><span class="line">           <span class="keyword">if</span> (!SerializationOptimizer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)) </span>&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"The serialization optimizer "</span> + className + <span class="string">" isn't an instance of "</span> + SerializationOptimizer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 创建 SerializationOptimizer 对象</span></span><br><span class="line">           SerializationOptimizer optimizer = (SerializationOptimizer) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 没有要优化的类直接返回</span></span><br><span class="line">           <span class="keyword">if</span> (optimizer.getSerializableClasses() == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 将要优化的类注册到 SerializableClassRegistry 中 </span></span><br><span class="line">           <span class="comment">// 在使用 Kryo,FST 等序列化算法时，会读取该集合中的类，完成注册.</span></span><br><span class="line">           <span class="keyword">for</span> (Class c : optimizer.getSerializableClasses()) &#123;</span><br><span class="line">               SerializableClassRegistry.registerClass(c);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 将 序列化优化器实现类名 加入到缓存中</span></span><br><span class="line">           optimizers.add(className);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Cannot find the serialization optimizer class: "</span> + className, e);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Cannot instantiate the serialization optimizer class: "</span> + className, e);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Cannot instantiate the serialization optimizer class: "</span> + className, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>服务暴露时会进行序列化优化，通过自定义 <code>SerializationOptimizer</code> 对象将需要优化的类全部加入到该对象中即可。关于序列化的介绍可以参考 <a href="https://gentryhuang.com/posts/16132b67/#%E5%BA%8F%E5%88%97%E5%8C%96%E4%BC%98%E5%8C%96%E5%99%A8">序列化优化器</a> 一文。</p><h3 id="服务暴露流程图"><a href="#服务暴露流程图" class="headerlink" title="服务暴露流程图"></a>服务暴露流程图</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-dubbo-protocol-export-hierarchy.jpg" alt></p><p>Dubbo 框架采用 Dubbo 协议进行服务发布的流程如上图所示。从 <code>Protocol 协议层</code> 的 <strong>openServer</strong> 方法会一路调用到 <code>Exchange 信息交换层</code>、<code>Transport 网络传输层</code>，最终创建并启动 <code>Netty 服务</code> 来接收客户端的请求。</p><h3 id="领域模型"><a href="#领域模型" class="headerlink" title="领域模型"></a>领域模型</h3><p><code>DubboExpoter</code> 是对服务端侧的 <code>Invoker</code> 的封装，服务端侧的 <code>Invoker</code> 内部封装了具体服务实现，具备服务能力。<code>DubboExpoter</code> 继承了 <code>AbstractExpoter</code> 抽象类，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboExporter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractExporter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exporter 集合</span></span><br><span class="line"><span class="comment">     * key : 服务键</span></span><br><span class="line"><span class="comment">     * value: DubboProtocol 发布的服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装 Invoker</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker     Invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key         服务键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporterMap AbstractProtocol.exporterMap属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboExporter</span><span class="params">(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(invoker);</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.exporterMap = exporterMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 取消暴露</span></span><br><span class="line">        <span class="keyword">super</span>.unexport();</span><br><span class="line">        <span class="comment">//清理该 DubboExporter 实例在 exporterMap 中相应的元素</span></span><br><span class="line">        exporterMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务引用"><a href="#服务引用" class="headerlink" title="服务引用"></a>服务引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 初始化序列化优化器</span></span><br><span class="line">        optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建 DubboInvoker 对象</span></span><br><span class="line">        DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 添加到 invokers 缓存中</span></span><br><span class="line">        invokers.add(invoker);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DubboProtocol</code> 直接实现了 <code>Protocol</code> 的服务引用接口。Dubbo 协议下的服务引用核心就一个，创建 <code>DubboInvoker</code> 对象，该对象会对 <code>Client</code> 进行封装，用于发送请求和接收响应。初始化序化优化器同服务暴露中的一致。</p><h3 id="连接NIO服务器"><a href="#连接NIO服务器" class="headerlink" title="连接NIO服务器"></a>连接NIO服务器</h3><p><code>getClients</code> 方法创建了底层发送请求和接收响应的 <code>Client</code> 集合，即创建客户端与服务端的长连接。其核心实现分为两部分，一个是针对<strong>共享连接</strong>的处理，另一个是针对<strong>独享连接</strong>的处理。实现逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"><span class="keyword">private</span> ExchangeClient[] getClients(URL url) &#123;</span><br><span class="line">        <span class="comment">// 是否使用共享连接</span></span><br><span class="line">        <span class="keyword">boolean</span> service_share_connect = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 connections 配置项，该值决定了后续建立连接的数量。不配置的情况下默认为0，并使用共享连接的方式，建立一条共享连接。</span></span><br><span class="line">        <span class="keyword">int</span> connections = url.getParameter(Constants.CONNECTIONS_KEY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有连接数的相关配置，默认使用共享连接的方式，且连接数为 1</span></span><br><span class="line">        <span class="comment">// Dubbo 在 2.7 版本中支持共享连接数的配置 SHARE_CONNECTIONS_KEY</span></span><br><span class="line">        <span class="keyword">if</span> (connections == <span class="number">0</span>) &#123;</span><br><span class="line">            service_share_connect = <span class="keyword">true</span>;</span><br><span class="line">            connections = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接服务提供者的 ExchangeClient 对象数组</span></span><br><span class="line">        ExchangeClient[] clients = <span class="keyword">new</span> ExchangeClient[connections];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clients.length; i++) &#123;</span><br><span class="line">            <span class="comment">//  1 共享连接</span></span><br><span class="line">            <span class="keyword">if</span> (service_share_connect) &#123;</span><br><span class="line">                clients[i] = getSharedClient(url);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 取独享连接，connections 的值为多少就会创建几个独享连接，在调用时会轮流使用。</span></span><br><span class="line">                <span class="comment">// 注意和 Dubbo 负载均衡的区别。</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                clients[i] = initClient(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clients;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ExchangeClient</code> 实际上并不具有通信能力，通信能力依赖其封装的更底层客户端实例，如 <code>NettyClient</code>、<code>MinaClient</code> 等。</p><p>当使用独享连接时，针对每个服务（对应一个Service）创建固定数量的 <code>Client</code> ，每个 <code>Client</code> 维护一个底层连接。如下图所示，<code>connections</code> 配置项设置了 2 ，也就是针对每个 Service 都启动了两个独享连接。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-protocol-exclusive-client.jpg" alt></p><p>当使用共享连接时，会根据节点地址（host:port），一个地址只创建固定数量的共享连接。如下图所示，<code>shareconnections</code> 配置项设置了 2，也就是针对每个服务节点都会创建两个共享连接，这两个共享连接被节点中的所有服务使用，如 Consumer 调用 Provider1 提供者中的多个服务时，是使用固定数量的共享长连接进行数据传输，这样就可以达到减少服务端连接的目的。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-protocol-share-client.jpg" alt></p><h3 id="共享连接"><a href="#共享连接" class="headerlink" title="共享连接"></a>共享连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"> <span class="function"><span class="keyword">private</span> ExchangeClient <span class="title">getSharedClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取从注册中心拉取的服务提供者的地址（ip:port），连接服务自然需要知道服务地址</span></span><br><span class="line">        String key = url.getAddress();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 从 referenceClientMap 中获取与该地址连接的带有引用记数功能的ExchangeClient</span></span><br><span class="line">        ReferenceCountExchangeClient client = referenceClientMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!client.isClosed()) &#123;</span><br><span class="line">                <span class="comment">/** 若未关闭，增加指向该Client 的数量 &#123;<span class="doctag">@link</span> #refenceCount&#125;  */</span></span><br><span class="line">                client.incrementAndGetCount();</span><br><span class="line">                <span class="keyword">return</span> client;</span><br><span class="line">                <span class="comment">// 若已关闭，移除</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                referenceClientMap.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增锁对象</span></span><br><span class="line">        locks.putIfAbsent(key, <span class="keyword">new</span> Object());</span><br><span class="line">        <span class="comment">// 针对指定地址的客户端创建进行加锁，这里使用分区加锁可以提高并发度</span></span><br><span class="line">        <span class="keyword">synchronized</span> (locks.get(key)) &#123;</span><br><span class="line">            <span class="comment">// double check</span></span><br><span class="line">            <span class="keyword">if</span> (referenceClientMap.containsKey(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> referenceClientMap.get(key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 初始化 ExchangeClient 客户端</span></span><br><span class="line">            ExchangeClient exchangeClient = initClient(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 使用装饰者模式将initClient返回的HeaderExchangeClient实例或LazyConnectExchangeClient实例封装为ReferenceCountExchangeClient对象</span></span><br><span class="line">            <span class="comment">// 注意，在使用共享连接时需要注意一个问题，如果两个以上的Invoker 共享这个连接的话，那么必须所有的Invoker 都关闭才能关闭连接。</span></span><br><span class="line">            client = <span class="keyword">new</span> ReferenceCountExchangeClient(exchangeClient, ghostClientMap);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 添加到缓存集合</span></span><br><span class="line">            referenceClientMap.put(key, client);</span><br><span class="line">            <span class="comment">// 6 新建了ExchangeClient，不需要进行兜底，移除兜底集合 ghostClientMap 中的元素</span></span><br><span class="line">            ghostClientMap.remove(key);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将作为锁标识的元素从集合中移除</span></span><br><span class="line">            locks.remove(key);</span><br><span class="line">            <span class="keyword">return</span> client;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>共享连接的创建是在独享连接创建的基础上进行的，共享连接的缓存基于对端地址（ip:port），同时共享连接的实现是 <code>ReferenceCountExchangeClient</code>，它是 <code>ExchangeClient</code> 的一个装饰器，在原始的 <code>ExchangeClient</code> 对象基础上添加了引用计数的功能。</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>共享连接使用的客户端实现是 <code>ReferenceCountExchangeClient</code> ，它是对信息交换层的 <code>ExchangeClient</code> 接口的直接实现，是 <code>ExchangeClient</code> 的装饰器，在原始的 <code>ExchangeClient</code> 对象基础上添加了引用计数功能，用于共享连接模式。在介绍信息交换层的客户端时，其中的 <code>HeaderExchangeClient</code> 也是对 <code>ExchangeClient</code> 接口的直接实现，这里 <code>ReferenceCountExchangeClient</code> 装饰的 <code>ExchangeClient</code> 就是 <code>HeaderExchangeClient</code> 对象。Dubbo 协议客户端继承关系如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-protocol-share-client-uml.jpg" alt></p><p>下面对 <code>ReferenceCountExchangeClient</code> 进行介绍。</p><h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountExchangeClient</span> <span class="keyword">implements</span> <span class="title">ExchangeClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用计数变量，用于记录 Client 被应用的次数。 每当该对象被引用一次refenceCount 都会进行自增。 每当close方法被调用时，referenceCount 就会进行自减</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger refenceCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 维护close掉的client，用于兜底。和 &#123;<span class="doctag">@link</span> Protocol#ghostClentMap&#125; 一致</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端 【类型是： HeaderExchangeClient】，被装饰对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ExchangeClient client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将HeaderExchangeClient 实例封装为ReferenceCountExchangeClient。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ghostClientMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceCountExchangeClient</span><span class="params">(ExchangeClient client, ConcurrentMap&lt;String, LazyConnectExchangeClient&gt; ghostClientMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="comment">// 引用计数递增</span></span><br><span class="line">        refenceCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">this</span>.url = client.getUrl();</span><br><span class="line">        <span class="keyword">if</span> (ghostClientMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ghostClientMap can not be null, url: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.ghostClientMap = ghostClientMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReferenceCountExchangeClient</code> 中持有的 <strong>client</strong> 属性就是被装饰的信息交换层的客户端对象，<strong>refenceCount</strong> 属性用于记录该 Client 被引用的次数，在 <code>ReferenceCountExchangeClient</code> 的构造方法以及 <code>incrementAndGetCount()</code> 方法中会增加引用次数，在 <code>close()</code> 方法中则会减少引用次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+--- ReferenceCountExchangeClient</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法一般由外部调用，引用计数递增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementAndGetCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        refenceCount.incrementAndGet();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">+--- ReferenceCountExchangeClient</span><br><span class="line">  <span class="comment">// ----------- ExchangeChannel 接口方法实现 --------------/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.request(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.request(request, timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExchangeHandler <span class="title">getExchangeHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.getExchangeHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------- Endpoint 接口方法实现 -----------------/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        client.send(message, sent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        client.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.getUrl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">getChannelHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.getChannelHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">getLocalAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.getLocalAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(Parameters parameters)</span> </span>&#123;</span><br><span class="line">        client.reset(parameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        client.reset(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * close() is not idempotent any longer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        close(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用次数减少到0时 ，ExchangeClient 连接关闭</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 引用计数减一，若无指向，进行真正的关闭</span></span><br><span class="line">        <span class="keyword">if</span> (refenceCount.decrementAndGet() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">                client.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client.close(timeout);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭ExchangeClient对象之后，会替换 client 为 LazyConnectExchangeClient 对象，即将关闭之后的连接变成一个懒加载的client</span></span><br><span class="line">            client = replaceWithLazyClient();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client.startClose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.isClosed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- Channel 接口实现 ----------/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.isConnected();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.getAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAttribute</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.hasAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        client.setAttribute(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        client.removeAttribute(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">getRemoteAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.getRemoteAddress();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- Client 接口实现 ----------/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reconnect</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        client.reconnect();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>采用装饰器模式，每个方法的实现都是交给被装饰的 <strong>client</strong> 处理，也就是 <code>HeaderExchangeClient</code> 处理。以上方法实现来源于不同的接口或类，和 <code>HeaderExchangeClient</code> 中的实现几乎一致，看起来比较乱，但是追溯到最底层可以发现，这些方法几乎都是交给通道 <code>Channel</code> 来处理的，Client 只完成了重连的逻辑。</p><h5 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+--- ReferenceCountExchangeClient</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 引用计数减一，若无指向，进行真正的关闭</span></span><br><span class="line">        <span class="keyword">if</span> (refenceCount.decrementAndGet() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">                client.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client.close(timeout);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭ExchangeClient对象之后，会替换 client 为 LazyConnectExchangeClient 对象，即将关闭之后的连接变成一个懒加载的client</span></span><br><span class="line">            client = replaceWithLazyClient();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> LazyConnectExchangeClient <span class="title">replaceWithLazyClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在原有的URL之上，添加一些LazyConnectExchangeClient特有的参数</span></span><br><span class="line">        URL lazyUrl = url.addParameter(Constants.LAZY_CONNECT_INITIAL_STATE_KEY, Boolean.FALSE)</span><br><span class="line">                <span class="comment">// 关闭重连</span></span><br><span class="line">                .addParameter(Constants.RECONNECT_KEY, Boolean.FALSE)</span><br><span class="line">                .addParameter(Constants.SEND_RECONNECT_KEY, Boolean.TRUE.toString())</span><br><span class="line">                .addParameter(<span class="string">"warning"</span>, Boolean.TRUE.toString())</span><br><span class="line">                .addParameter(LazyConnectExchangeClient.REQUEST_WITH_WARNING_KEY, <span class="keyword">true</span>)</span><br><span class="line">                .addParameter(<span class="string">"_client_memo"</span>, <span class="string">"referencecounthandler.replacewithlazyclient"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 ghostClientMap 缓存中查找</span></span><br><span class="line">        String key = url.getAddress();</span><br><span class="line">        <span class="comment">// in worst case there's only one ghost connection.</span></span><br><span class="line">        LazyConnectExchangeClient gclient = ghostClientMap.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前client字段已经指向了LazyConnectExchangeClient，则不需要再次创建</span></span><br><span class="line">        <span class="keyword">if</span> (gclient == <span class="keyword">null</span> || gclient.isClosed()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ChannelHandler 依旧使用原始ExchangeClient使用的Handler，即DubboProtocol中的requestHandler字段</span></span><br><span class="line">            gclient = <span class="keyword">new</span> LazyConnectExchangeClient(lazyUrl, client.getExchangeHandler());</span><br><span class="line">            ghostClientMap.put(key, gclient);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gclient;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从 <code>ReferenceCountExchangeClient</code> 关闭逻辑可以发现：</p><blockquote><ol><li>当引用次数减到 0 的时候，ExchangeClient 连接允许关闭。当引用次数未减到 0 的时候，底层的 ExchangeClient 不能关闭。</li><li>在关闭底层 ExchangeClient 对象之后，会立即创建一个 LazyConnectExchangeClient 对象，用于异常情况的兜底。这个连接的特点是在需要发送请求的时候才会进行 Client 的创建。</li></ol></blockquote><p>前文也提到，共享连接的创建是在独享连接的基础上，独享连接创建是通过 <code>initClient</code> 方法，而共享连接是以地址（host:port）作为标识将独享连接缓存，避免同一地址创建多条连接。下面我们就来分析独享连接的创建。</p><h3 id="独享连接"><a href="#独享连接" class="headerlink" title="独享连接"></a>独享连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"> <span class="function"><span class="keyword">private</span> ExchangeClient <span class="title">initClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 获取客户端类型，默认为netty。下面逻辑会检查该扩展</span></span><br><span class="line">        String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 设置编解码器Codec2的扩展名,即DubboCountCodec &#123;@link DubboCountCodec&#125;</span></span><br><span class="line">        url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 默认开启heartbeat,60 * 1000</span></span><br><span class="line">        url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验配置的Client 的 Dubbo SPI拓展是否存在，若不存在，抛出RpcException</span></span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">str</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: "</span> + str + <span class="string">","</span> +</span><br><span class="line">                    " supported client type is " + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), " "));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 连接服务器，创建客户端</span></span><br><span class="line">        ExchangeClient client;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.1 如果配置了延迟创建连接的特性</span></span><br><span class="line">            <span class="keyword">if</span> (url.getParameter(Constants.LAZY_CONNECT_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                <span class="comment">// 创建延迟建立连接的对象（在请求时才会初始化连接）</span></span><br><span class="line">                client = <span class="keyword">new</span> LazyConnectExchangeClient(url, requestHandler);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4.2 未使用延迟连接功能，则通过Exchangers的 connect 方法创建 ExchangeClient 客户端，这里是 HeaderExchangeClient</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                client = Exchangers.connect(url, requestHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to create remoting client for service("</span> + url + <span class="string">"): "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DubboProtocol</code> 创建连接的流程如下：</p><ol><li>对客户端扩展名进行校验，默认使用 netty </li><li>设置编解码器 Codec2 的扩展名，这里固定是 DubboCountCodec</li><li>设置心跳时间</li><li>连接NIO服务器，创建客户端。这里会根据是否设置延迟创建连接的特性创建不同的 Client </li></ol><p>没有设置延迟创建连接的配置项时直接使用信息交换层的 <code>Exchangers.connect</code> 创建 <code>HeaderExchangeClient</code> 对象，否则创建 <code>LazyConnectExchangeClient</code> 对象，该对象不会立刻初始化连接而是在请求时才会初始化。</p><h3 id="LazyConnectExchangeClient"><a href="#LazyConnectExchangeClient" class="headerlink" title="LazyConnectExchangeClient"></a>LazyConnectExchangeClient</h3><p><code>LazyConnectExchangeClient</code> 同样是 <code>ExchangeClient</code> 的装饰器，它会在原有 <code>ExchangeClient</code> 对象的基础上添加延迟初始化连接的功能，即在发送请求的时候才会进行初始化。</p><h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyConnectExchangeClient</span> <span class="keyword">implements</span> <span class="title">ExchangeClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(LazyConnectExchangeClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟连接告警配置项</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String REQUEST_WITH_WARNING_KEY = <span class="string">"lazyclient_request_with_warning"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求时，是否检查告警</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> requestWithWarning;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeHandler requestHandler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock connectLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 懒连接初始化状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> initialState;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通信客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ExchangeClient client;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 警告计数器。每超过一定次数，打印告警日志。参见 &#123;<span class="doctag">@link</span> #warning(Object)&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicLong warningcount = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LazyConnectExchangeClient</code> 中的 <strong>url</strong> 和 <strong>requestHandler</strong> 是创建对象的时候封装的属性，<code>LazyConnectExchangeClient</code> 在构造方法中不会创建底层持有连接的 <strong>Client</strong>，而是在需要发送请求的时候才会调用 <strong>initClient()</strong> 方法进行 <strong>Client</strong> 的创建。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--- LazyConnectExchangeClient</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyConnectExchangeClient</span><span class="params">(URL url, ExchangeHandler requestHandler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 延迟连接需要设置 send.reconnect 为 true，防止通道不良状态</span></span><br><span class="line">        <span class="keyword">this</span>.url = url.addParameter(Constants.SEND_RECONNECT_KEY, Boolean.TRUE.toString());</span><br><span class="line">        <span class="keyword">this</span>.requestHandler = requestHandler;</span><br><span class="line">        <span class="comment">// 懒连接初始化状态默认值为 true</span></span><br><span class="line">        <span class="keyword">this</span>.initialState = url.getParameter(Constants.LAZY_CONNECT_INITIAL_STATE_KEY, Constants.DEFAULT_LAZY_CONNECT_INITIAL_STATE);</span><br><span class="line">        <span class="keyword">this</span>.requestWithWarning = url.getParameter(REQUEST_WITH_WARNING_KEY, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+--- LazyConnectExchangeClient</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        warning(request);</span><br><span class="line">        initClient();</span><br><span class="line">        <span class="keyword">return</span> client.request(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        warning(request);</span><br><span class="line">        initClient();</span><br><span class="line">        <span class="keyword">return</span> client.request(request, timeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息/请求前，都会调用该方法，确保客户端已经初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        client.send(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        initClient();</span><br><span class="line">        client.send(message, sent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="初始化连接"><a href="#初始化连接" class="headerlink" title="初始化连接"></a>初始化连接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--- LazyConnectExchangeClient</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 已初始化，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Lazy connect to "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得锁</span></span><br><span class="line">        connectLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 已初始化，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建Client,连接服务器</span></span><br><span class="line">            <span class="keyword">this</span>.client = Exchangers.connect(url, requestHandler);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            connectLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="其它方法-1"><a href="#其它方法-1" class="headerlink" title="其它方法"></a>其它方法</h4><p><code>LazyConnectExchangeClient</code> 中的其它方法同样是对不同接口和类中的方法实现，如获取地址的方法，获取处理器的方法，关闭相关的方法以及和通道属性相关的方法。</p><h3 id="服务引用流程图"><a href="#服务引用流程图" class="headerlink" title="服务引用流程图"></a>服务引用流程图</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-protocol-refer-hierarchy.jpg" alt></p><p>Dubbo 框架采用 Dubbo 协议进行服务引用的流程图如上图所示。从 <code>Protocol 协议层</code> 的 <strong>getClients</strong> 方法会一路调用到 <code>Exchange 信息交换层</code>、<code>Transport 网络传输层</code>，最终启动客户端并连接到服务器，后续就可以使用处于健康状态的连接进行双向远程通信了。</p><h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><p>在 <code>DubboProtocol</code> 销毁的时候，会调用 <code>destroy()</code> 方法释放底层资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 销毁所有通信服务器 ExchangeServer</span></span><br><span class="line">        <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(serverMap.keySet())) &#123;</span><br><span class="line">            <span class="comment">// 1.1 先从缓存中删除通信服务器</span></span><br><span class="line">            ExchangeServer server = serverMap.remove(key);</span><br><span class="line">            <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Close dubbo server: "</span> + server.getLocalAddress());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 在close()方法中，下层（如HeaderExchangeServer）会发送ReadOnly请求、阻塞指定时间、关闭底层的定时任务、关闭相关线程池，最终，会断开所有连接，关闭Server。</span></span><br><span class="line">                    <span class="comment">// 这些逻辑在前文介绍HeaderExchangeServer、NettyServer等实现的时候</span></span><br><span class="line">                    <span class="comment">// 在优雅停机的等待时长内关闭 [保证了服务平滑的下线]</span></span><br><span class="line">                    server.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 销毁所有通信客户端 ExchangeClient</span></span><br><span class="line">        <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(referenceClientMap.keySet())) &#123;</span><br><span class="line">            <span class="comment">// 2.1 先从缓存中删除通信客户端</span></span><br><span class="line">            ExchangeClient client = referenceClientMap.remove(key);</span><br><span class="line">            <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Close dubbo connect: "</span> + client.getLocalAddress() + <span class="string">"--&gt;"</span> + client.getRemoteAddress());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ReferenceCountExchangeClient 中只有引用减到 0，底层的 Client 才会真正销毁</span></span><br><span class="line">                    <span class="comment">// 在优雅停机的等待时长内关闭 【保证在处理的请求能够尽可能的在优雅停机时间内完成处理】</span></span><br><span class="line">                    client.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 销毁所有的通信客户端 LazyConnectExchangeClient</span></span><br><span class="line">        <span class="keyword">for</span> (String key : <span class="keyword">new</span> ArrayList&lt;String&gt;(ghostClientMap.keySet())) &#123;</span><br><span class="line">            <span class="comment">// 3.1 先从缓存中删除</span></span><br><span class="line">            ExchangeClient client = ghostClientMap.remove(key);</span><br><span class="line">            <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Close dubbo connect: "</span> + client.getLocalAddress() + <span class="string">"--&gt;"</span> + client.getRemoteAddress());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 在优雅停机的等待时长内关闭</span></span><br><span class="line">                    client.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理 stub 缓存</span></span><br><span class="line">        stubServiceMethodsMap.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 执行父类 AbstractProtocol 的销毁方法</span></span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DubboProtocol</code> 执行销毁的逻辑主要针对三类对象，分别对该三类对象进行优雅关闭。</p><ol><li>优雅关闭<code>ExchangeServer</code>对象，保证服务平稳下线。</li><li>优雅关闭<code>ExchangeClient</code>对象，尽可能保证请求完成。</li><li>优雅关闭<code>LazyConnectExchangeClient</code>对象。</li></ol><h2 id="领域模型-1"><a href="#领域模型-1" class="headerlink" title="领域模型"></a>领域模型</h2><p><strong>DubboProtocol.refer()</strong> 方法会将底层的 <code>ExchangeClient</code> 集合封装成 <code>DubboInvoker</code>，然后由上层逻辑封装成代理对象。这样业务层就可以像调用本地对象一样，完成远程调用。相关继承关系如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-refer-protocol-invoker-uml.jpg" alt></p><p>关于 <code>AbstractInvoker</code> 在前面已经介绍过了，可以参考 <a href="https://gentryhuang.com/posts/450e3eda/#AbstractInvoker">AbstractInvoker</a> 。下面我们对 <code>DubboInvoker</code> 进行介绍。</p><h3 id="DubboInvoker"><a href="#DubboInvoker" class="headerlink" title="DubboInvoker"></a>DubboInvoker</h3><p><code>DubboInvoker</code> 是 <code>AbstractInvoker</code> 的实现类，其 <strong>doInvoke()</strong> 方法是远程调用的直接入口。</p><h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 远程通信客户端数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeClient[] clients;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用的 &#123;<span class="doctag">@link</span> #clients&#125; 的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicPositiveInteger index = <span class="keyword">new</span> AtomicPositiveInteger();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁方法中使用的jvm 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock destroyLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoker 集合，从&#123;<span class="doctag">@link</span> DubboProtocol#invokers&#125; 获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Invoker&lt;?&gt;&gt; invokers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboInvoker</span><span class="params">(Class&lt;T&gt; serviceType, URL url, ExchangeClient[] clients)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(serviceType, url, clients, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboInvoker</span><span class="params">(Class&lt;T&gt; serviceType, URL url, ExchangeClient[] clients, Set&lt;Invoker&lt;?&gt;&gt; invokers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(serviceType, url, <span class="keyword">new</span> String[]&#123;Constants.INTERFACE_KEY, Constants.GROUP_KEY, Constants.TOKEN_KEY, Constants.TIMEOUT_KEY&#125;);</span><br><span class="line">        <span class="keyword">this</span>.clients = clients;</span><br><span class="line">        <span class="comment">// get version.</span></span><br><span class="line">        <span class="keyword">this</span>.version = url.getParameter(Constants.VERSION_KEY, <span class="string">"0.0.0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.invokers = invokers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboInvoker</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">        <span class="comment">// 1 获得当前调用的方法名</span></span><br><span class="line">        <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        <span class="comment">// 2 向Invocation中添加附加信息，这里将URL的path（服务名），version 添加到 attachment 中</span></span><br><span class="line">        inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());</span><br><span class="line">        inv.setAttachment(Constants.VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 选择一个远程通信客户端 ExchangeClient</span></span><br><span class="line">        ExchangeClient currentClient;</span><br><span class="line">        <span class="comment">// 默认是单一长连接</span></span><br><span class="line">        <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">            currentClient = clients[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 远程调用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4.1 判断是否异步调用</span></span><br><span class="line">            <span class="keyword">boolean</span> isAsync = RpcUtils.isAsync(getUrl(), invocation);</span><br><span class="line">            <span class="comment">// 4.2 判断是否单向调用</span></span><br><span class="line">            <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            <span class="comment">// 4.3 根据调用的方法名称和配置获取此次调用的超时时间（毫秒），默认是 1s</span></span><br><span class="line">            <span class="keyword">int</span> timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * - 发送 oneway 请求的方式是send() 方法，而后面发送 twoway 请求的方式是 request() 方法</span></span><br><span class="line"><span class="comment">             * - request() 方法会相应地创建 DefaultFuture 对象以及检测超时的定时任务，而 send() 方法则不会创建这些东西，它是直接将 Invocation 包装成 oneway 类型的 Request 发送出去</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 4.4 单向调用，不需要关注返回值的请求</span></span><br><span class="line">            <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 注意，调用的是 ExchangeClient#send(invocation, sent) 方法</span></span><br><span class="line">                currentClient.send(inv, isSent);</span><br><span class="line">                <span class="comment">// 设置 RpcContext.future = null ，无需异步回调</span></span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 返回 空结果</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4.5 异步调用，需要关注返回值的请求</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *  调用 ExchangeClient#request(invocation, timeout) 方法，发送请求</span></span><br><span class="line"><span class="comment">                 *  DefaultFuture是ResponseFuture的实现类，实际上这里返回的就是DefaultFuture实例，而该实例就是HeaderExchangeChannel.request(Object request, int timeout)返回的future实例</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 1 调用 RpcContext#setFuture(future) 方法，在需要的时候可以使用 Future 进行回调。</span></span><br><span class="line"><span class="comment">                 * 2 将DefaultFuture 对象封装到 FutureAdapter实例中，并将 FutureAdapter实例设置到RpcContext 中，我们可以在需要的地方取出使用 【在合适的地方调用 get方法】</span></span><br><span class="line"><span class="comment">                 * 3 FutureAdapter 是一个适配器，用于将 Dubbo 中的 ResponseFuture 与 JDK 中的 Future 进行适配，这样当用户线程调用 Future 的 get 方法时，经过 FutureAdapter 适配，最终会调用 ResponseFuture 实现类对象的 get 方法，也就是 DefaultFuture 的 get 方法</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter&lt;Object&gt;(future));</span><br><span class="line">                <span class="comment">// 返回 空结果</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4.6 同步调用</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 设置 RpcContext.future = null，无需异步回调</span></span><br><span class="line">                RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 1 调用 ExchangeClient#request(invocation, timeout) 方法，发送请求</span></span><br><span class="line"><span class="comment">                 * 2 用 ResponseFuture#get() 方法，阻塞等待返回结果</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">return</span> (Result) currentClient.request(inv, timeout).get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DubboInvoker.doInvoke()</code> 方法是调用方使用 <code>ExchangeClient</code> 向服务提供方发起请求的入口，下面对该过程进行分析：</p><ol><li>向 Invocation 调用信息中添加 <code>path</code>、<code>version</code> 属性。</li><li>获取当前调用的超时时间，默认是 1s 。双向调用时是调用端最大等待时长，否则抛出请求超时异常。</li><li>判断调用模式，单向调用 or 异步调用 or 同步调用。<ul><li>单向调用：使用 <code>ExchangeClient.send</code> 方法，无需关注返回值。RpcContext 中的 Future 置空，无需异步回调。</li><li>异步调用：使用 <code>ExchangeClient.request</code> 方法，调用时传入超时时间，作为调用方最大等待时长。返回结果 <code>ResponseFuture</code> 作为 RpcContext 中的 Future ，在需要的时候可以取出 Future 进行回调。</li><li>同步调用：和异步调用类似，唯一的区别是，同步调用是拿到返回的 ResponseFuture 后立即调用其 get() 进行调用结果的获取，在结果没有返回时将阻塞业务线程。</li></ul></li></ol><h4 id="Invoker-状态"><a href="#Invoker-状态" class="headerlink" title="Invoker 状态"></a>Invoker 状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboInvoker</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前 Invoker 的状态 - 是否可用</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">super</span>.isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ExchangeClient client : clients) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 即使Client处于连接中，但如果 Server 处于正在关闭中，连接也是不可用的，即服务端广播客户端 READONLY_EVENT 事件</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * &#123;<span class="doctag">@link</span> HeaderExchangeServer#sendChannelReadOnlyEvent()&#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (client.isConnected() &amp;&amp; !client.hasAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY)) &#123;</span><br><span class="line">                <span class="comment">//cannot write == not Available ?</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DubboInvoker.isAvailable()</code> 方法用于检查当前 <strong>DubboInvoker</strong> 是否可用，是否可以体现如下：</p><ol><li>当前 Invoker 的状态是否是可用的</li><li>当前 Invoker 封装的连接是否有可用的</li><li>当前 Invoker 封装的连接的对端是否关闭，根据是否广播只读事件</li></ol><h4 id="销毁-Invoker"><a href="#销毁-Invoker" class="headerlink" title="销毁 Invoker"></a>销毁 Invoker</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果已经销毁，则忽略</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.isDestroyed()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// double check to avoid dup close</span></span><br><span class="line">            <span class="comment">// 双重检锁，避免已经销毁</span></span><br><span class="line">            destroyLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 再次检测是否销毁</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">super</span>.isDestroyed()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 标记 DubboInvoker 销毁</span></span><br><span class="line">                <span class="keyword">super</span>.destroy();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从缓存中移除当前Invoker</span></span><br><span class="line">                <span class="keyword">if</span> (invokers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    invokers.remove(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">           </span><br><span class="line">                <span class="comment">// 关闭当前 Invoker 中封装的连接</span></span><br><span class="line">                <span class="keyword">for</span> (ExchangeClient client : clients) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 等待时长内关闭 ExchangeClient</span></span><br><span class="line">                        client.close(ConfigUtils.getServerShutdownTimeout());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        logger.warn(t.getMessage(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                destroyLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>销毁 <code>DubboInvoker</code> 首先设置自身的销毁状态，接着关闭封装的连接。</p><h1 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h1><p><code>DubboProtocol</code> 的服务暴露和服务引用都设置了编解码 <code>DubboCountCodec</code>，关于编解码器可以参考 <a href="https://gentryhuang.com/posts/61d79ae/">编解码器</a> 一文，这里就不再重复说明。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章主要对 Dubbo 协议下的服务暴露和服务引用的核心流程进行了介绍。服务暴露涉及到 NIO 服务的启动，RpcInvocation 实现，通道处理器的实现以及优化序列实现。服用引用涉及到 <code>Client</code> 的初始化，Dubbo 支持 <code>共享连接</code> 和 <code>独享连接</code>，其中使用 <code>ReferenceCountExchangeClient</code> 和 <code>LazyConnectExchangeClient</code> 对 <code>ExchangeClient</code> 进行装饰，分别实现具有引用计数功能和延时初始化功能的客户端。接着对相关的领域模型 <code>DubboExpoter</code> 和 <code>DubboInvoker</code> 进行了介绍，这两个是非常重要的模型，作为提供方服务暴露实现和消费方服务引用实现。DubboProtocol 相关的编解码由于在之前的文章中已经详细说明，就不再介绍。需要说明的是，在 Dubbo 2.7.x 版本中进行了异步化改造，对消费端和提供的调用进行了优化，关于差异部分会在后面的文章中单独说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/450e3eda/&quot;&gt;多协议概览&lt;/a&gt; 中，我们对 Du
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Protocol" scheme="https://gentryhuang.com/tags/Protocol/"/>
    
  </entry>
  
</feed>
