<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gentryhuang‘s blog</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gentryhuang.com/"/>
  <updated>2021-08-03T07:56:47.424Z</updated>
  <id>https://gentryhuang.com/</id>
  
  <author>
    <name>gentryhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>时间轮算法 - HashedWheelTimer</title>
    <link href="https://gentryhuang.com/posts/1d01ceec/"/>
    <id>https://gentryhuang.com/posts/1d01ceec/</id>
    <published>2021-07-24T02:06:24.000Z</published>
    <updated>2021-08-03T07:56:47.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>时间轮是一种高效利用线程资源来进行批量化调度的一种调度模型。将大批量的调度任务全部都绑定到同一个调度器上，使用这一调度器来进行所有任务的管理、触发以及执行。本篇文章将对 HashedWheelTimer 进行分析。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>编码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.util.HashedWheelTimer;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.Timeout;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.Timer;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimerClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 创建一个 HashedWheelTimer，内部参数全部使用默认值</span></span><br><span class="line">        Timer timer = <span class="keyword">new</span> HashedWheelTimer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 编写 TimeTask 任务</span></span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"is working !"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 提交任务</span></span><br><span class="line">        <span class="comment">// 创建 HashedWheelTimeout 对象，并将该对象放入任务队列中，等待被加入到 Hash 轮中被调用。</span></span><br><span class="line">        Timeout timeout = timer.newTimeout(timerTask, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调度结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1is working !</span><br></pre></td></tr></table></figure><h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>时间轮调度模型如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/hashedwheeltimer/hash-wheel-timer-model.jpeg" alt></p><p><strong>HashedWheelTimer</strong> 时间轮算法可以通过上图来描述。假设时间轮大小为 8 即 8 个格子，1s 转一格，每格都对应一个链表，链表每个节点都保存着待执行的任务。某一时刻，时间轮走到编号为 2 的格子，此时添加了一个 3s 后执行的任务，对应 3 个格子，则 2 + 3 = 5，在编号为 5 的格子对应链表中添加一个任务节点即可，轮次 round 为 0 ；如果添加一个 10s 后执行的任务，同理得 (2 + 10) % 8 = 4，在编号为 4 的格子对应的链表中添加一个任务节点，并标识轮次 round 为 1，当时间轮第二次经过编号为 4 的格子时就会执行该任务。注意，时间轮只会执行 round = 0 的任务，并会把该格子上的其他任务的 round 减 1 。</p><p>时间轮算法的原理还是非常容易理解的，下面我们从源码层面进行分析。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>HashedWheelTimer 相关的核心类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/hashedwheeltimer/hash-wheel-timer-uml.jpg" alt></p><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>HashedWheelTimer 是接口 io.netty.util.Timer 的实现，Timer 是任务调度器，负责对延时任务进行管理、触发和调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调度指定的 TimerTask ，在指定的延迟后执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 与指定任务相关联的句柄</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException      if this timer has been &#123;<span class="doctag">@linkplain</span> #stop() stopped&#125; already</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the pending timeouts are too many and creating new timeout</span></span><br><span class="line"><span class="comment">     *                                    can cause instability in the system.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Timeout <span class="title">newTimeout</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止所有的还没被执行的定时任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 与被此方法取消的任务相关联的句柄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Set&lt;Timeout&gt; <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TimerTask"><a href="#TimerTask" class="headerlink" title="TimerTask"></a>TimerTask</h2><p>延时任务，由业务方自行实现。Timer 会在触发时间对延时任务进行调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Timer 调度的任务，由业务方实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executed after the delay specified with</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Timer#newTimeout(TimerTask, long, TimeUnit)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 任务执行的时候会将该任务对应的 Timeout 传进来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h2><p>Timeout 是一个非常重要的接口，它的唯一实现类是 HashedWheelTimer 内部类 HashedWheelTimeout ，该内部类聚合了时间轮主要的核心对象，关于该内部类下文会详细分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与&#123;<span class="doctag">@link</span> TimerTask&#125;关联的句柄，由&#123;<span class="doctag">@link</span> Timer&#125;返回。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Timeout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回创建此句柄的&#123;<span class="doctag">@link</span> Timer&#125;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Timer <span class="title">timer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TimerTask <span class="title">task</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当且仅当与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;已过期时返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当且仅当与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;已被取消时返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试取消与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;。如果任务已经被执行或取消，它将返回而没有副作用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果取消成功，则为 true，否则为 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashedWheelTimer"><a href="#HashedWheelTimer" class="headerlink" title="HashedWheelTimer"></a>HashedWheelTimer</h2><p>HashedWheelTimer 是对 Timer 的实现，也就是我们说的时间轮。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimer</span> <span class="keyword">implements</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimer 实例统计原子变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger INSTANCE_COUNTER = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过多 HashedWheelTimer 阈值开关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicBoolean WARNED_TOO_MANY_INSTANCES = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimer 数量的阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTANCE_COUNT_LIMIT = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小延时时间，默认是 1 毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MILLISECOND_NANOS = TimeUnit.MILLISECONDS.toNanos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ResourceLeakDetector&lt;HashedWheelTimer&gt; leakDetector = ResourceLeakDetectorFactory.instance()</span><br><span class="line">            .newResourceLeakDetector(HashedWheelTimer<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间轮状态，可以控制工作线程执行任务的状态。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimer&gt; WORKER_STATE_UPDATER =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimer.class, "workerState");</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceLeakTracker&lt;HashedWheelTimer&gt; leak;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread workerThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态  0 - init, 1 - started, 2 - shut down</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_INIT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_STARTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_SHUTDOWN = <span class="number">2</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unused"</span>, <span class="string">"FieldMayBeFinal"</span>&#125;)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> workerState; <span class="comment">// 0 - init, 1 - started, 2 - shut down</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走一个 bucket 需要花费的纳秒时长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> tickDuration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bucket 数组，用于存储任务，即 HashedWheelTimeout 实例们</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelBucket[] wheel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 掩码，用于 与运算 ，计算属于 wheel 哪个下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 newTimeout 方法线程等待工作线程 workerThread 开启执行任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startTimeInitialized = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimeout 任务队列。MPSC 队列，适用于这里的多生产线程，单消费线程的场景</span></span><br><span class="line">    <span class="comment">// 提交的任务会先进入到该队列中，每次 tick 才会将队列中的任务（一次最多 10 万个）加入到 bucket 中的链表里</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;HashedWheelTimeout&gt; timeouts = PlatformDependent.newMpscQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimeout 任务取消队列</span></span><br><span class="line">    <span class="comment">// 取消的任务会加入到该队列中，此次 tick 会将该队列中的任务从 bucket 中移除</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;HashedWheelTimeout&gt; cancelledTimeouts = PlatformDependent.newMpscQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间轮中处于等待执行的任务数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong pendingTimeouts = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许最大的等待任务数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxPendingTimeouts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作线程启动时间，作为时间轮的基准时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> startTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*----------------- 系列构造方法 -------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Executors.defaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(<span class="keyword">long</span> tickDuration, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Executors.defaultThreadFactory(), tickDuration, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(<span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Executors.defaultThreadFactory(), tickDuration, unit, ticksPerWheel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory, <span class="keyword">long</span> tickDuration, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, tickDuration, unit, <span class="number">512</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, tickDuration, unit, ticksPerWheel, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel, <span class="keyword">boolean</span> leakDetection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, tickDuration, unit, ticksPerWheel, leakDetection, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 HashedWheelTimer 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory      线程工厂，用于创建执行 TimerTask 任务的工作线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tickDuration       tick 之间的持续时间，即一次 tick 的时间长度。默认是 100</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit               tickDuration 的时间单位。默认是 毫秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ticksPerWheel      定义一圈有多少个 bucket 。 默认是 512</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leakDetection      用于追踪内存泄漏</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxPendingTimeouts 最大允许等待的任务数，也就是 Timeout 实例数（调用 newTimeout 方法产生），可以根据该参数控制不允许太多的任务等待。</span></span><br><span class="line"><span class="comment">     *                           如果未执行任务数达到阈值，那么再次提交任务会抛出 RejectedExecutionException 异常。如果该值为 0 或 负数，则不限制。</span></span><br><span class="line"><span class="comment">     *                           默认不限制。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel, <span class="keyword">boolean</span> leakDetection,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> maxPendingTimeouts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 参数校验</span></span><br><span class="line">        ObjectUtil.checkNotNull(threadFactory, <span class="string">"threadFactory"</span>);</span><br><span class="line">        ObjectUtil.checkNotNull(unit, <span class="string">"unit"</span>);</span><br><span class="line">        ObjectUtil.checkPositive(tickDuration, <span class="string">"tickDuration"</span>);</span><br><span class="line">        ObjectUtil.checkPositive(ticksPerWheel, <span class="string">"ticksPerWheel"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建时间轮 bucket 结构，这里做向上取整，保证 bucket 数组长度是 2 的 n 次方</span></span><br><span class="line">        <span class="comment">// wheel 就是一个个 bucket。时间轮会以循环的方式走这个 wheel 数组</span></span><br><span class="line">        wheel = createWheel(ticksPerWheel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 掩码，bucket - 1，用来做取模，计算任务应该放到哪个 bucket 中</span></span><br><span class="line">        <span class="comment">// 给定一个 deadline 的任务，其应该放置的格子: deadline%wheel.length 但是 % 操作是个相对耗时的操作，所以使用位运算代替：因为一圈的长度为 2^n 次方，mask = 2^n-1 后低位将全部是1，</span></span><br><span class="line">        <span class="comment">// 因此 deadline&amp;mast == deadline%wheel.length 。 HashMap 在进行 hash 之后，进行index的hash寻址寻址的算法也是和这个一样的</span></span><br><span class="line">        mask = wheel.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 将延迟时间统一转为纳秒</span></span><br><span class="line">        <span class="keyword">long</span> duration = unit.toNanos(tickDuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 防止延迟时间溢出</span></span><br><span class="line">        <span class="keyword">if</span> (duration &gt;= Long.MAX_VALUE / wheel.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                    <span class="string">"tickDuration: %d (expected: 0 &lt; tickDuration in nanos &lt; %d"</span>,</span><br><span class="line">                    tickDuration, Long.MAX_VALUE / wheel.length));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 延迟时间不能小于 1 毫秒</span></span><br><span class="line">        <span class="keyword">if</span> (duration &lt; MILLISECOND_NANOS) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Configured tickDuration &#123;&#125; smaller then &#123;&#125;, using 1ms."</span>,</span><br><span class="line">                    tickDuration, MILLISECOND_NANOS);</span><br><span class="line">            <span class="keyword">this</span>.tickDuration = MILLISECOND_NANOS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.tickDuration = duration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7 根据线程工厂创建线程。注意，这里并没有立即启动线程，启动线程是在第一次提交延迟任务的时候。</span></span><br><span class="line">        workerThread = threadFactory.newThread(worker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追踪内存泄露的，略</span></span><br><span class="line">        leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8 最大允许等待的 Timeout 实例数</span></span><br><span class="line">        <span class="keyword">this</span>.maxPendingTimeouts = maxPendingTimeouts;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9  如果超过 64 个 HashedWheelTimer 实例，它会打印错误日志提醒你</span></span><br><span class="line">        <span class="comment">// 因为时间轮是一个非常耗费资源的结构，所以一个 jvm 中的实例数目不能太高</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE_COUNTER.incrementAndGet() &gt; INSTANCE_COUNT_LIMIT &amp;&amp;</span><br><span class="line">                WARNED_TOO_MANY_INSTANCES.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="comment">// 打印错误日志</span></span><br><span class="line">            reportTooManyInstances();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过以上构造方法可以初始化一个时间轮对象，默认情况下，时间轮大小是 512，也就是一圈有 512 个 bucket，走一个 bucket 需要时间为 100ms 。</p><h3 id="初始化-bucket"><a href="#初始化-bucket" class="headerlink" title="初始化 bucket"></a>初始化 bucket</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时间轮 bucket 数组，用来存储任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ticksPerWheel 一圈有多少个 bucket ，默认是 512</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashedWheelBucket[] createWheel(<span class="keyword">int</span> ticksPerWheel) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"ticksPerWheel must be greater than 0: "</span> + ticksPerWheel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间轮 tick 不能多大</span></span><br><span class="line">        <span class="keyword">if</span> (ticksPerWheel &gt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"ticksPerWheel may not be greater than 2^30: "</span> + ticksPerWheel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  标准化时间轮大小</span></span><br><span class="line">        ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 HashedWheelBucket 数组</span></span><br><span class="line">        HashedWheelBucket[] wheel = <span class="keyword">new</span> HashedWheelBucket[ticksPerWheel];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wheel.length; i++) &#123;</span><br><span class="line">            wheel[i] = <span class="keyword">new</span> HashedWheelBucket();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wheel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标准化时间轮大小，原则：向上取整，达到 2 的 n 次方</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ticksPerWheel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">normalizeTicksPerWheel</span><span class="params">(<span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> normalizedTicksPerWheel = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取第一个大于 ticksPerWheel 的 2 的 n 次方的值</span></span><br><span class="line">        <span class="keyword">while</span> (normalizedTicksPerWheel &lt; ticksPerWheel) &#123;</span><br><span class="line">            <span class="comment">// 左移一位，即 扩大 2 倍</span></span><br><span class="line">            normalizedTicksPerWheel &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> normalizedTicksPerWheel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>初始化 bucket 的过程就是初始化时间轮的格子，每个格子用于管理落在当前位置的延时任务们，这些任务由链表组织起来，且任务具有轮次的语义，只有任务的轮次为 0 时才能被时间轮执行。注意，时间轮中的每个 bucket 和延时时间是通过 tick 来间接关联的，通过延时任务的时间可以计算出它对应 N 个 tick ，而 tick 通过对 bucket 数组长度取模运算就能确定具体的 bucket。延时任务完成 Bucket 分配后，时间轮不断进行 tick 的过程就可以通过计算找到 tick 对应的 Bucket ，进而处理延时任务。</p><h2 id="HashedWheelTimeout"><a href="#HashedWheelTimeout" class="headerlink" title="HashedWheelTimeout"></a>HashedWheelTimeout</h2><p>延时任务的包装类，该类聚合了时间轮所有的核心对象及属性，也就是说通过该对象可以拿到所有核心的对象和属性，并且该类包含了延时任务执行的方法<strong>expire()</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimeout</span> <span class="keyword">implements</span> <span class="title">Timeout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_INIT = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 取消</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_CANCELLED = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 到期</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_EXPIRED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来CAS方式更新任务状态</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimeout&gt; STATE_UPDATER =</span><br><span class="line">                AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimeout.class, "state");</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Timer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelTimer timer;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * TimerTask</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TimerTask task;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 任务触发时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> deadline;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unused"</span>, <span class="string">"FieldMayBeFinal"</span>, <span class="string">"RedundantFieldInitialization"</span>&#125;)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = ST_INIT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 离任务执行的轮数，0 表示当前轮次执行。当任务从队列加入 bucket 时会计算这个值。</span></span><br><span class="line">        <span class="comment">// 对与轮次非 0 的任务，那么时间轮执行到对应的 bucket 时会将该任务的该属性值 -1 </span></span><br><span class="line">        <span class="keyword">long</span> remainingRounds;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这将用于通过双向链表在 hashhedwheeltimerbucket 中链接超时 的前后指针</span></span><br><span class="line">        HashedWheelTimeout next;</span><br><span class="line">        HashedWheelTimeout prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前 HashedWheelTimeout 所在的 bucket</span></span><br><span class="line">        HashedWheelBucket bucket;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashedWheelTimeout 用于封装 HashedWheelTimer、TimerTask 以及 deadLine 触发时间</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> timer</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> deadline</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        HashedWheelTimeout(HashedWheelTimer timer, TimerTask task, <span class="keyword">long</span> deadline) &#123;</span><br><span class="line">            <span class="keyword">this</span>.timer = timer;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.deadline = deadline;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+---HashedWheelTimeout</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 到期并执行任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_EXPIRED)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行 TimerTask.run 方法</span></span><br><span class="line">                task.run(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"An exception was thrown by "</span> + TimerTask<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>() + '.', <span class="title">t</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行任务本质上是调用 HashedWheelTimeout 对象中封装的 TimerTask 对象的方法。</p><h3 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+---HashedWheelTimeout</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 取消任务</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里只是修改状态为取消，实际会在下次tick的时候移除</span></span><br><span class="line">     <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_CANCELLED)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">           </span><br><span class="line">     <span class="comment">// 加入到时间轮的待取消队列，并在每次tick的时候，从相应格子中移除。 </span></span><br><span class="line">      timer.cancelledTimeouts.add(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>取消任务只是将待执行的 HashedWheelTimeout 对象加入到全局取消队列中，在后续的 tick 过程才会从对应的 bucket 中删除。</p><h3 id="移除任务"><a href="#移除任务" class="headerlink" title="移除任务"></a>移除任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimeout</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前 Timeout 从对应的 bucket 链表中移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   HashedWheelBucket bucket = <span class="keyword">this</span>.bucket;</span><br><span class="line">     <span class="keyword">if</span> (bucket != <span class="keyword">null</span>) &#123;</span><br><span class="line">          bucket.remove(<span class="keyword">this</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          timer.pendingTimeouts.decrementAndGet();</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>将 HashedWheelTimeout 对象从对应的 bucket 中删除。</p><h2 id="HashedWheelBucket"><a href="#HashedWheelBucket" class="headerlink" title="HashedWheelBucket"></a>HashedWheelBucket</h2><p>用来存放包装任务的 HashedWheelTimeout ，以链表结构的形式进行管理，链表中的每一个节点都是 HashedWheelTimeout。</p><h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelBucket</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 头指针</span></span><br><span class="line">       <span class="keyword">private</span> HashedWheelTimeout head;</span><br><span class="line">       <span class="comment">// 尾指针</span></span><br><span class="line">       <span class="keyword">private</span> HashedWheelTimeout tail;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Add &#123;<span class="doctag">@link</span> HashedWheelTimeout&#125; to this bucket.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 添加 HashedWheelTimeout 到 当前 bucket 中，即加入到链中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTimeout</span><span class="params">(HashedWheelTimeout timeout)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">assert</span> timeout.bucket == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 设置 timeout 的桶</span></span><br><span class="line">           timeout.bucket = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 维护桶中的 HashedWheelTimeout</span></span><br><span class="line">           <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">               head = tail = timeout;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               tail.next = timeout;</span><br><span class="line">               timeout.prev = tail;</span><br><span class="line">               tail = timeout;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将 timeout 从链表中移除</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> HashedWheelTimeout <span class="title">remove</span><span class="params">(HashedWheelTimeout timeout)</span> </span>&#123;</span><br><span class="line">           HashedWheelTimeout next = timeout.next;</span><br><span class="line">           <span class="comment">// remove timeout that was either processed or cancelled by updating the linked-list</span></span><br><span class="line">           <span class="keyword">if</span> (timeout.prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">               timeout.prev.next = next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (timeout.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">               timeout.next.prev = timeout.prev;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (timeout == head) &#123;</span><br><span class="line">               <span class="comment">// if timeout is also the tail we need to adjust the entry too</span></span><br><span class="line">               <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">                   tail = <span class="keyword">null</span>;</span><br><span class="line">                   head = <span class="keyword">null</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   head = next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">               <span class="comment">// if the timeout is the tail modify the tail to be the prev node.</span></span><br><span class="line">               tail = timeout.prev;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// null out prev, next and bucket to allow for GC.</span></span><br><span class="line">           timeout.prev = <span class="keyword">null</span>;</span><br><span class="line">           timeout.next = <span class="keyword">null</span>;</span><br><span class="line">           timeout.bucket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// timeout 对应的 timer 的等待任务数减 1</span></span><br><span class="line">           timeout.timer.pendingTimeouts.decrementAndGet();</span><br><span class="line">           <span class="keyword">return</span> next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行任务-1"><a href="#执行任务-1" class="headerlink" title="执行任务"></a>执行任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelBucket</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Expire all &#123;<span class="doctag">@link</span> HashedWheelTimeout&#125;s for the given &#123;<span class="doctag">@code</span> deadline&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 执行 bucket 中的到期任务。注意，只执行 bucket 中轮次为 0 且到期的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireTimeouts</span><span class="params">(<span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取时间任务链表的头</span></span><br><span class="line">        HashedWheelTimeout timeout = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理链表上的所有 timeout 实例</span></span><br><span class="line">        <span class="keyword">while</span> (timeout != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            HashedWheelTimeout next = timeout.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调整当前 bucket 的任务链表</span></span><br><span class="line">                next = remove(timeout);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 到达触发时间</span></span><br><span class="line">                <span class="keyword">if</span> (timeout.deadline &lt;= deadline) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 执行具体的任务，即执行 timeout 中的 TimerTask.run 方法</span></span><br><span class="line">                    timeout.expire();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不可能进入到这个分支</span></span><br><span class="line">                    <span class="comment">// The timeout was placed into a wrong slot. This should never happen.</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(</span><br><span class="line">                            <span class="string">"timeout.deadline (%d) &gt; deadline (%d)"</span>, timeout.deadline, deadline));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 任务被取消了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout.isCancelled()) &#123;</span><br><span class="line">                next = remove(timeout);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 轮次减 1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout.remainingRounds--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理下个任务</span></span><br><span class="line">            timeout = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>工作线程 tick 时会找到当前 tick 对应的 bucket ，然后执行上述方法进而调度延时任务。</p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>Worker 是工作线程的任务体，里面封装了时间轮任务触发和执行的逻辑。一旦工作线程启动后，就会不停地 “滴答” bucket ，直到时间轮关闭。</p><h3 id="任务体"><a href="#任务体" class="headerlink" title="任务体"></a>任务体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录没有处理的时间任务</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Timeout&gt; unprocessedTimeouts = <span class="keyword">new</span> HashSet&lt;Timeout&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录走了几个 bucket ，不拥堵的情况下每隔 tickDuration 时间走一个 bucket</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> tick;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化启动时间。</span></span><br><span class="line">            <span class="comment">// 注意，在 HashedWheelTimer 中用的都是相对时间，因此需要以启动时间为基准。这里使用 volatile 修饰</span></span><br><span class="line">            startTime = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 因为 startTime = 0 作为工作线程未开始执行任务的标志。这里开始执行了，需要设置非 0</span></span><br><span class="line">                startTime = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一个提交任务的线程在 start() 处等待，需要唤醒它</span></span><br><span class="line">            startTimeInitialized.countDown();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * do-while 执行任务逻辑：</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 工作线程是逐个 bucket 顺序处理的，所以即使有些任务执行时间超过了一次 tick 时间，也没关系，这些任务并不会被漏掉。</span></span><br><span class="line"><span class="comment">             * 但是可能被延迟执行，毕竟工作线程是单线程。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待下次 tick 到来</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> deadline = waitForNextTick();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (deadline &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前 tick 下 bucket 数组对应 index，即哪个 bucket</span></span><br><span class="line">                    <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (tick &amp; mask);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理已经取消的任务</span></span><br><span class="line">                    processCancelledTasks();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取当前 tick 对应的桶</span></span><br><span class="line">                    HashedWheelBucket bucket = wheel[idx];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将 timeouts 队列中的 HashedWheelTimeout 转移到相应的桶中</span></span><br><span class="line">                    transferTimeoutsToBuckets();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 执行进入到 bucket 中的任务</span></span><br><span class="line">                    bucket.expireTimeouts(deadline);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 记录走了多少个 tick</span></span><br><span class="line">                    tick++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_STARTED);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 执行到这里，说明当前 Timer 要关闭了，做一些清理工作 */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将所有 bucket 中没有执行的任务，添加到 unprocessedTimeouts 这个 HashSet 中，用于 stop() 方法返回</span></span><br><span class="line">            <span class="keyword">for</span> (HashedWheelBucket bucket : wheel) &#123;</span><br><span class="line">                bucket.clearTimeouts(unprocessedTimeouts);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任务队列中的任务也添加到 unprocessedTimeouts 中</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!timeout.isCancelled()) &#123;</span><br><span class="line">                    unprocessedTimeouts.add(timeout);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理已经取消的任务</span></span><br><span class="line">            processCancelledTasks();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程启动的第一步是初始化全局的 <code>startTime</code>，它将作为时间轮的基准时间，用来计算延时任务的触发时间。并调用 <code>countDown</code> 方法来通知阻塞在 <code>start</code> 方法上的线程。接着进入主循环中，循环中的行为是每隔一段时间走一个 bucket ，下面我们拆解执行部分。</p><h3 id="waitForNextTick"><a href="#waitForNextTick" class="headerlink" title="waitForNextTick"></a>waitForNextTick</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+--- Worker</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">waitForNextTick</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 计算当前 tick 下的 deadline，这值是确定的。即一次 tick 期限是一个固定值</span></span><br><span class="line">            <span class="comment">// 注意，这里就体现了时间轮的核心，理论上每隔 tickDuration 就会 "滴答" 一次</span></span><br><span class="line">            <span class="keyword">long</span> deadline = tickDuration * (tick + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 等待当前 tick 时间到达</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.1 基于 startTime 计算距离当前时间的时间戳</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.nanoTime() - startTime;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.2 判断是否可以进行 tick</span></span><br><span class="line">                <span class="comment">// 标准是：tick 触发的时间值 - currentTime &lt;= 0，没有到触发时间则休眠 sleepTimeMs 毫秒</span></span><br><span class="line">                <span class="comment">// 这里加 999999 是补偿精度，不足 1ms 的补足 1ms</span></span><br><span class="line">                <span class="keyword">long</span> sleepTimeMs = (deadline - currentTime + <span class="number">999999</span>) / <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.3 因为每次执行任务消耗的时间是不受控制的，因此计算出来的 sleepTimeMs 可能为负数</span></span><br><span class="line">                <span class="comment">// 当为负数时，说明前面的任务执行时间过长，导致本该 tick 的时候错过了。这个时候不需要休眠等待，需要立刻处理</span></span><br><span class="line">                <span class="keyword">if</span> (sleepTimeMs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentTime == Long.MIN_VALUE) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -Long.MAX_VALUE;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 返回值是基于 startTime 计算的距离当前时间的时间戳</span></span><br><span class="line">                        <span class="keyword">return</span> currentTime;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// windows 平台特别处理。先除以10再乘以10，是因为windows平台下最小调度单位是10ms，如果不处理成10ms的倍数，可能导致sleep更不准了</span></span><br><span class="line">                <span class="keyword">if</span> (PlatformDependent.isWindows()) &#123;</span><br><span class="line">                    sleepTimeMs = sleepTimeMs / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">                    <span class="keyword">if</span> (sleepTimeMs == <span class="number">0</span>) &#123;</span><br><span class="line">                        sleepTimeMs = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 2.4 没有到 tick 时间，则休眠</span></span><br><span class="line">                    Thread.sleep(sleepTimeMs);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    <span class="comment">// 如果工作线程已经关闭，那么返回 Long.MIN_VALUE</span></span><br><span class="line">                    <span class="keyword">if</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Long.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>waitForNextTick 方法的逻辑已经详细注释，该方法就是用来控制每隔一定的时间 “滴答” 一次即跳一个 bucket，此外还处理了因上一个 tick 处理任务时间过长问题，采用的是立即触发执行的方式。不难看出，当遇到较长时间执行的任务时，会打乱原本正常 tick 的节奏，导致其他任务延期执行。 <code>tickDuration</code> 控制着时间的精准度，值越小精准度越高，工作线程则越繁忙。</p><h3 id="processCancelledTasks"><a href="#processCancelledTasks" class="headerlink" title="processCancelledTasks"></a>processCancelledTasks</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--- Worker</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理已经取消的任务。将已经取消的任务从对应的 bucket 中移除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCancelledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 遍历任务取消队列</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                HashedWheelTimeout timeout = cancelledTimeouts.poll();</span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// all processed</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 将 timeout 从对应的 bucket 中移除</span></span><br><span class="line">                    timeout.remove();</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"An exception was thrown while process a cancellation task"</span>, t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>该方法是为了处理那些被取消的任务，将被取消的任务从队列和 bucket 中分别移除。</p><h3 id="transferTimeoutsToBuckets"><a href="#transferTimeoutsToBuckets" class="headerlink" title="transferTimeoutsToBuckets"></a>transferTimeoutsToBuckets</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">+--- Worker</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将 HashedWheelTimeout 队列中的任务加入到相应的 bucket 中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferTimeoutsToBuckets</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 限制每 tick 最大转移 10 万个 HashedWheelTimeout 到 bucket，以免阻塞工作线程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">                <span class="comment">// 队列为空</span></span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// all processed</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 被取消了</span></span><br><span class="line">                <span class="keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED) &#123;</span><br><span class="line">                    <span class="comment">// Was cancelled in the meantime.</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">/*---   将任务放到相应的 bucket 中 ----*/</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算任务触发时间需要经过多少个 tick</span></span><br><span class="line">                <span class="keyword">long</span> calculated = timeout.deadline / tickDuration;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算任务所属的轮次</span></span><br><span class="line">                timeout.remainingRounds = (calculated - tick) / wheel.length;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果任务在 timeouts 队列里面放久了, 以至于已经过了执行时间(calculated &lt; tick), 这个时候就使用当前 tick 对应的 bucket，从而让那些本应该在过去执行的任务在当前 tick 快速执行掉。</span></span><br><span class="line">                <span class="comment">// 此方法调用完后就会立即执行当前 tick 对应的 bucket 中的任务</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ticks = Math.max(calculated, tick); <span class="comment">// Ensure we don't schedule for past.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算 ticks 对应 bucket</span></span><br><span class="line">                <span class="keyword">int</span> stopIndex = (<span class="keyword">int</span>) (ticks &amp; mask);</span><br><span class="line">                HashedWheelBucket bucket = wheel[stopIndex];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 单个 bucket 是由 HashedWheelBucket 实例组成的一个链表，单个线程不存在并发</span></span><br><span class="line">                <span class="comment">// 这里将 timeout 加入到 bucket 的链表中</span></span><br><span class="line">                bucket.addTimeout(timeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在每次执行 tick 对应的 bucket 中的延时任务时，会先将全局任务队列中待执行的任务加入到对应的 bucket 中。</p><h3 id="expireTimeouts"><a href="#expireTimeouts" class="headerlink" title="expireTimeouts"></a>expireTimeouts</h3><p>一次 tick 到来后找到对应的 Bucket，然后就可以处理当前 Bucket 中的延时任务了，具体实现见前文。expireTimeouts 方法中会间接执行 <code>TimeTask.run</code> 方法，如果延时任务执行时间过久则会阻塞工作线程，进一步拖慢超时检测流程。</p><p>以上对 HashedWheelTimer 主要源码进行了分析，但没有串起来。下面我们以执行过程的形式进一步说明。</p><h2 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task  任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delay 延时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit  延迟时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Timeout <span class="title">newTimeout</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 校验参数</span></span><br><span class="line">        ObjectUtil.checkNotNull(task, <span class="string">"task"</span>);</span><br><span class="line">        ObjectUtil.checkNotNull(unit, <span class="string">"unit"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 校验等待任务数是否达到阈值</span></span><br><span class="line">        <span class="keyword">long</span> pendingTimeoutsCount = pendingTimeouts.incrementAndGet();</span><br><span class="line">        <span class="keyword">if</span> (maxPendingTimeouts &gt; <span class="number">0</span> &amp;&amp; pendingTimeoutsCount &gt; maxPendingTimeouts) &#123;</span><br><span class="line">            pendingTimeouts.decrementAndGet();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Number of pending timeouts ("</span></span><br><span class="line">                    + pendingTimeoutsCount + <span class="string">") is greater than or equal to maximum allowed pending "</span></span><br><span class="line">                    + <span class="string">"timeouts ("</span> + maxPendingTimeouts + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 如果工作线程没有启动，则启动工作线程。一般由第一个提交的任务负责工作线程的启动</span></span><br><span class="line">        start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将任务添加到队列中，该队列将在下一个 tick 时进行处理，在处理过程中，所有排队的 HashedWheelTimeout 将被添加到正确的 HashedWheelBucket 中 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 deadline 是一个相对时间，相对于工作线程启动时间。</span></span><br><span class="line">        <span class="comment">// 注意，该值作为延时任务触发的时间，后续流程虽然会判断，但是貌似用处不大。主要还是用在根据该值计算 tick 进而确定将任务分配到哪个 Bucket，因为任务触发是跟着 tick 走的。</span></span><br><span class="line">        <span class="keyword">long</span> deadline = System.nanoTime() + unit.toNanos(delay) - startTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Guard against overflow.</span></span><br><span class="line">        <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; deadline &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            deadline = Long.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 创建 HashedWheelTimeout 对象，进一步封装任务对象</span></span><br><span class="line">        HashedWheelTimeout timeout = <span class="keyword">new</span> HashedWheelTimeout(<span class="keyword">this</span>, task, deadline);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 加入到 timeouts 队列中，等待被加入到 Bucket 中</span></span><br><span class="line">        timeouts.add(timeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> timeout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>时间轮在初始化后就可以接收业务方提交的延时任务请求了，任务的处理都是交给工作线程这个后台线程。提交任务的流程主要包含 3 个关键步骤：</p><blockquote><p>1 尝试启动工作线程 workerThread<br>2 计算延时任务的触发时间，创建 HashedWheelTimeout 对象进一步封装任务对象<br>3 将创建的 HashedWheelTimeout 对象加入到任务队列</p></blockquote><p>值得一提的是启动工作线程的逻辑，源码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动工作线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException if this timer has been</span></span><br><span class="line"><span class="comment">     *                               &#123;<span class="doctag">@linkplain</span> #stop() stopped&#125; already</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (WORKER_STATE_UPDATER.get(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果是初始化状态</span></span><br><span class="line">            <span class="keyword">case</span> WORKER_STATE_INIT:</span><br><span class="line">                <span class="keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_INIT, WORKER_STATE_STARTED)) &#123;</span><br><span class="line">                    <span class="comment">// 启动工作线程</span></span><br><span class="line">                    workerThread.start();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WORKER_STATE_STARTED:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WORKER_STATE_SHUTDOWN:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"cannot be started once stopped"</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Invalid WorkerState"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，直到 startTime 被工作线程初始化</span></span><br><span class="line">        <span class="keyword">while</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                startTimeInitialized.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                <span class="comment">// Ignore - it will be ready very soon.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到上述方法是 public 修饰的，也就是说用户可以显示的调用，而无需等待第一次提交任务时再启动。但一般没必要显示调用，没有任务提交没必要启动。</p><h2 id="执行任务-2"><a href="#执行任务-2" class="headerlink" title="执行任务"></a>执行任务</h2><p>前文也说了，时间轮中的任务都是由工作线程触发执行的。具体是一次 tick 到来后找到对应的 Bucket，然后就可以处理当前 Bucket 中的延时任务了。源码见前文。</p><h2 id="取消任务-1"><a href="#取消任务-1" class="headerlink" title="取消任务"></a>取消任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimeout</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// only update the state it will be removed from HashedWheelBucket on next tick.</span></span><br><span class="line">     <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_CANCELLED)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 加入到取消任务队列中</span></span><br><span class="line">         timer.cancelledTimeouts.add(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>未到期但被取消的任务会放到 <code>cancelledTimeouts</code> 队列中，工作线程周期性调用 <code>processCancelledTasks()</code> 会从 bucket 中删除对应的 HashedWheelTimeout。</p><h2 id="终止时间轮"><a href="#终止时间轮" class="headerlink" title="终止时间轮"></a>终止时间轮</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Timeout&gt; <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 工作线程不能停止时间轮</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() == workerThread) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    HashedWheelTimer<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>() +</span></span><br><span class="line">                            ".stop() cannot be called from " +</span><br><span class="line">                            TimerTask<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>())</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试 CAS 替换当前状态为 “停止：</span></span><br><span class="line">        <span class="keyword">if</span> (!WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) &#123;</span><br><span class="line">            <span class="comment">// workerState can be 0 or 2 at this moment - let it always be 2.</span></span><br><span class="line">            <span class="keyword">if</span> (WORKER_STATE_UPDATER.getAndSet(<span class="keyword">this</span>, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">                INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">                <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">assert</span> closed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 中断 worker线程，尝试把正在进行任务的线程中断掉,如果某些任务正在执行则会抛出interrupt异常，并且任务会尝试立即中断</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (workerThread.isAlive()) &#123;</span><br><span class="line">                workerThread.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    workerThread.join(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前前程会等待stop的结果</span></span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">assert</span> closed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回未处理的任务</span></span><br><span class="line">        <span class="keyword">return</span> worker.unprocessedTimeouts();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/hashedwheeltimer/hash-wheel-timer-process.jpg" alt></p><p>HashWheelTimer 是基于时间轮算法，提交的任务会被封装成 <code>HashedWheelTimeout</code> 对象并存放到全局任务队列中。时间轮的格子是用 bucket 数组表示，bucket 内部维护一个 <code>HashedWheelTimeout</code> 类型的双向链表，每一个节点都是一个 HashedWheelTimeout 对象。其内部使用一个工作线程自旋地进行 tick ，tick 的过程会先将全局任务队列中的任务添加到对应的 bucket 中，接着轮训当前 tick 对应 bucket 中的任务链表，执行轮次为 0 的任务，轮次非 0 的任务将其轮次减 1 。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p><strong>优点</strong></p><blockquote><p>1 本地机器直接执行，效率非常高。<br>2 无需扫描所有任务。通过将环切成 N 份，将查询到期延时任务的耗时降到 1/N，N 视任务量的大小可以灵活设置(1024,2048 等)</p></blockquote><p><strong>缺点</strong></p><blockquote><p>1 可靠性：<br>    -  机器重启，数据即丢失，可以使用 MySQL 等持久化存储，机器重启时从数据库 load 进内存。<br>    -  机器宕机，数据丢失，需要使用方自行处理，如由其它机器接管宕机机器的任务<br>2 时间轮调度器的时间精度可能不是很高，对于精度要求特别高的调度任务可能不太合适。因为时间轮算法的精度取决于一次 tick 的时间。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>时间轮算法不难理解，但 HashedWheelTimer 源码中有很多细节需要注意。任务的管理，体现在任务队列和 bucket 数组的使用；任务的触发，体现在工作线程自旋进行 tick ；任务的执行，体现在工作线程轮询 bucket 的任务链表，对 TimerTask.run 的执行；需要注意的是，整个时间轮的调度都是在一个线程中完成的，因此对于那些耗时较大的定时任务会影响其他任务的正常触发和执行，但任务执行异常并不会导致工作线程退出，这是不同于 JDK 中的 Timer 。</p><p><strong>参考：</strong><br><a href="https://www.javadoop.com/post/HashedWheelTimer" target="_blank" rel="noopener">https://www.javadoop.com/post/HashedWheelTimer</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;时间轮是一种高效利用线程资源来进行批量化调度的一种调度模型。将大批量的调度任务全部都绑定到同一个调度器上，使用这一调度器来进行所有任务的管理
      
    
    </summary>
    
    
      <category term="任务调度" scheme="https://gentryhuang.com/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
    
      <category term="HashedWheelTimer" scheme="https://gentryhuang.com/tags/HashedWheelTimer/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - Redis主流程</title>
    <link href="https://gentryhuang.com/posts/19fe4bc5/"/>
    <id>https://gentryhuang.com/posts/19fe4bc5/</id>
    <published>2021-06-24T06:59:01.000Z</published>
    <updated>2021-07-09T07:08:44.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章将从源码层面对 Redis 主干轮廓进行说明。以主线程执行流程为主干，对途径的枝枝蔓蔓简单介绍，不会过度展开，后续将针对每一个模块进行详细分析。由于 Redis 是用 C 语言实现的，当然应该从 main 函数开启阅读源码旅程。需要说明的是，笔者阅读的 Redis 版本是 <code>#define REDIS_VERSION &quot;6.2.4&quot;</code>，之所以选择较新的版本，因为笔者对 Redis 一些新特性比较感兴趣，特别是 Redis 在 6.0 版本中提出的 IO 多线程。</p><h1 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h1><p>Redis 服务器启动的入口是 main 函数，其它的无需多说，下面直接上代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis Server 启动入口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *  Redis是用C语言实现的，从 main 函数启动。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">char</span> config_from_stdin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INIT_SETPROCTITLE_REPLACEMENT</span></span><br><span class="line">    <span class="comment">// 1 初始化库</span></span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 检查服务器是否以 Sentinel 模式启动</span></span><br><span class="line">    <span class="comment">// 这一点非常重要，因为 Sentinel 和普通的实例不同</span></span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3  初始化服务器配置</span></span><br><span class="line">    initServerConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 ACL 初始化（6.0 对 ACL 进行了功能丰富）</span></span><br><span class="line">    ACLInit(); <span class="comment">/* The ACL subsystem must be initialized ASAP because the</span></span><br><span class="line"><span class="comment">                  basic networking code and client creation depends on it. */</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 5 如果服务器以 Sentinel 模式启动，那么需要进行 Sentinel 功能相关的初始化，并为要监视的主服务器创建一些相应的数据结构</span></span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">        <span class="comment">// Sentinel 所属的属性覆盖服务器默认的属性</span></span><br><span class="line">        initSentinelConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哨兵模式初始化</span></span><br><span class="line">        initSentinel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 6 是否需要在 redis-check-rdb/aof模式下启动，这样可以校验持久化文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>], <span class="string">"redis-check-rdb"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_rdb_main(argc, argv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>], <span class="string">"redis-check-aof"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_aof_main(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7 检查用户是否指定了配置文件，或者配置选项</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">background</span> = server.daemonize &amp;&amp; !server.supervised;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8 将服务器设置为守护进程运行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">background</span>) daemonize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9 创建并初始化服务器</span></span><br><span class="line">    initServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🌟 服务器不是运行在 SENTINEL 模式，那么执行以下代码</span></span><br><span class="line">    <span class="keyword">if</span> (!server.sentinel_mode) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 10  bio 和 io 线程的初始化</span></span><br><span class="line">        InitServerLast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11 从 AOF 文件或者 RDB 文件中载入数据</span></span><br><span class="line">        loadDataFromDisk();</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                          <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">                          <span class="string">"Cluster mode. Exiting."</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 以 SENTINEL 模式运行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ACLLoadUsersAtStartup();</span><br><span class="line">        <span class="comment">// bio 和 io 线程的初始化</span></span><br><span class="line">        InitServerLast();</span><br><span class="line">        <span class="comment">// Sentinel 准备就绪后执行</span></span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12 🌟 启动事件处理循环</span></span><br><span class="line">    <span class="comment">// 主要围绕 IO多路复用 展开的，驱动注册的时间事件回调和 IO 事件回调</span></span><br><span class="line">    aeMain(server.el);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12 退出事件循环，回收内存</span></span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retun 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 服务启动后，主线程 main 会依次执行以上流程，直到进入 <strong>aeMain</strong> 事件处理循环方法中。需要说明的是，上述代码片段删除掉了不关心的逻辑，本篇文章我们只关注以下两个逻辑：</p><ul><li>执行各种初始化</li><li>执行事件循环</li></ul><p>Redis 服务器初始化逻辑较为复杂，从底层的数据结构到服务器不同的角色，初始化的逻辑和属性都不一样，这里就不展开了。下面对流程进行概括：</p><p><img src="/posts/19fe4bc5/redis-outline-main-process.jpg" alt></p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>事件循环逻辑是 Redis 核心的直接体现，它就是在这个循环中不断处理网络请求和内部自身逻辑的。下面我们直接上代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;<span class="built_in">stop</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程进入主循环，一直处理事件，直到服务器关闭</span></span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;<span class="built_in">stop</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始处理事件</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS |</span><br><span class="line">                                   AE_CALL_BEFORE_SLEEP |</span><br><span class="line">                                   AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，只要事件循环 <code>aeEventLoop</code> 没有被停止，主线程 main 就会一直自旋，不断执行 <code>aeProcessEvents</code> 方法。不难看出 <code>aeProcessEvents</code> 方法封装了 Redis 的所有功能逻辑，这里提前说下，Redis 的功能逻辑总共两大类：一个是网络事件，也称为文件事件；另一个是时间事件；前者用于处理网络中的交互，后者用于处理 Redis 自身的一些逻辑。</p><p>下面继续贴出 <code>aeProcessEvents</code> 方法的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing to do? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line">        <span class="keyword">int64_t</span> usUntilTimer = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取最近的时间事件</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            usUntilTimer = usUntilEarliestTimer(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.1 使用 usUntilTimer 来决定文件事件的阻塞时间</span></span><br><span class="line">        <span class="keyword">if</span> (usUntilTimer &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            tv.tv_sec = usUntilTimer / <span class="number">1000000</span>;</span><br><span class="line">            tv.tv_usec = usUntilTimer % <span class="number">1000000</span>;</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.2 执行到这里，说明没有时间事件。那么根据 AE_DONT_WAIT 是否设置来决定是否阻塞，以及阻塞的时间长度</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                <span class="comment">// 设置文件事件不阻塞</span></span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Otherwise we can block */</span></span><br><span class="line">                <span class="comment">// 文件事件阻塞直到有事件到达为止</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">            tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2 前置回调函数 - beforeSleep */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_BEFORE_SLEEP)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">        <span class="number">3</span> 调用多路复用 API，只会在超时或某些事件触发时返回。即等待事件产生</span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* 4 后置回调函数 - beforeSleep */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.1 从已就绪数组中获取文件描述符信息</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> fired = <span class="number">0</span>; <span class="comment">/* Number of events fired for current fd. */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.2 如果是套接字上发生读事件，调用读事件处理器处理读事件</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">                fired++;</span><br><span class="line">                fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Fire the writable event. */</span></span><br><span class="line">            <span class="comment">// 5.3 如果是套接字上发生写事件，调用写事件处理器处理写事件</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we have to invert the call, fire the readable event now</span></span><br><span class="line"><span class="comment">             * after the writable one.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 如果需要反转调用，在可写事件之后触发可读事件</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (invert) &#123;</span><br><span class="line">                fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">                <span class="keyword">if</span> ((fe-&gt;mask &amp; mask &amp; AE_READABLE) &amp;&amp;</span><br><span class="line">                    (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc)) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 6 如果是时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        <span class="comment">// 执行时间事件</span></span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码片段中也可以看到，主线程在不断轮询时间事件和文件事件，找到就尝试执行。上述代码虽然简短，但是却几乎包含了 Redis 的所有功能，秘密就在以下几个组件中：</p><ul><li>前置处理器 beforeSleep </li><li>IO多路复用库（及多种回调函数）</li><li>后置处理器 afterSleep</li></ul><p>关于以上代码片段背后的信息，会在后面的文章中介绍 Redis 事件一文中详细说明，这里先不展开。下面对以上方法进行概括：</p><p><img src="/posts/19fe4bc5/redis-outline-multi-process.jpg" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章简单介绍了 Redis 启动的入口以及执行的主干流程，这里有个印象即可，后续会对每个模块展开说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章将从源码层面对 Redis 主干轮廓进行说明。以主线程执行流程为主干，对途径的枝枝蔓蔓简单介绍，不会过度展开，后续将针对每一个模块进
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>网络通信 - IO多路复用</title>
    <link href="https://gentryhuang.com/posts/b25f5b99/"/>
    <id>https://gentryhuang.com/posts/b25f5b99/</id>
    <published>2021-06-12T02:43:23.000Z</published>
    <updated>2021-08-03T07:48:22.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>IO多路复用简单来说就是，单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力，IO多路复用解决的本质问题是用更少的资源完成更多的事。需要说明的是，处理IO多路复用的问题需要操作系统提供内核级别的支持，操作系统充当观察者的角色。本篇文章我们就来分析IO多路复用底层实现原理，我们以 Linux 操作系统提供的IO复用API <code>select</code>、<code>poll</code> 以及<code>epoll</code> 为例，逐一进行分析。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>实现IO多路复用直接使用用户线程轮询查看若干个文件描述符的状态难道不行吗？为什么要操作系统内核支持？在请求量比较小的时候确实可以使用该方案，但是在大量请求的情况下，这对于 CPU 的使用率来说无疑是种灾难。而使用操作系统内核帮我们观察文件描述符就可以优雅、高效地实现IO多路复用。</p><p>操作系统内核虽然清楚知道每个文件描述符对应的 Socket 的状态变化，但是内核如何知道该把哪个文件描述符信息给哪个进程呢？一个 Socket 文件可以由多个进程使用，而一个进程也可以使用多个 Socket 文件，进程和 Socket 之间是多对多的关系。此外，一个 Socket 也会对应多个事件类型。操作系统表示太难了，它很难判断将哪种事件给哪个进程。因此，在进程内部就需要维护自己关注哪些 Socket 文件的哪些事件，如读事件、写事件以及异常事件等。也就是说，内核帮应用程序盯着感兴趣的 Socket ，应用程序可以根据内核反馈的信息进一步处理网络请求。</p><p>下面我们带着这些问题，结合 Linux 下的IO复用API进行分析。</p><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>select 实现IO多路复用的思想是：操作系统内核会扫描用户进程传入的 3 类 fd_set 文件描述数组(本质是 bitmap)，当对应的 Socket 准备就绪时会置位（标志对应的 Socket 有数据来了） fd_set 数组中对于元素，最后将内核置位后的 fd_set 数组们拷贝回用户空间。由于 select 并不会明确指出是哪些文件描述符就绪（一股脑返回全部 fd），因此用户进程需要根据内核返回的 fd_set 数组们自行判断哪个文件描述符对应的 Socket 发生了哪种事件，然后再进一步处理。</p><h2 id="API定义"><a href="#API定义" class="headerlink" title="API定义"></a>API定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* According to earlier standards */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 监听感兴趣的文件描述符上的事件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, </span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *readfds, fd_set *writefds,fd_set *exceptfds, </span></span></span><br><span class="line"><span class="function"><span class="params">           struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd_set 可以理解为一个集合，这个集合中存放的是文件描述符，可通过以下四个宏进行设置：</span></span><br><span class="line"><span class="comment">// 1 将一个文件描述符移除集合中 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2  检查一个文件描述符是否在集合中，可以用这个来检测一次select调用之后有哪些文件描述符可以进行IO操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 添加一个文件描述符到集合中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 清空给定集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>select 将监听的文件描述符分为了 3 类，每一类都对应一个 fd_set 数组，本质上是一个 bitmap，也就是字节数组。分别是 <strong>writefds（写文件描述符）</strong>、<strong>readfds（读文件描述符）</strong>以及 <strong>exceptfds（异常事件文件描述符）</strong>。每一类都代表 Socket 对应的事件，每一类存储的都是 Socket 对应的文件描述符。用户进程可以根据需要准备相关 fd_set 数组，在调用 select 函数时，这三个事件参数可以用 NULL 来表示对应的事件不需要监听。其实也不难看出，select 模型下操作系统内核并没有维护存储文件描述符相关的数据结构，只是定义了 fd_set ，将维护工作交给了用户进程。</p><p>下面我们对 select 相关的每个函数进行说明。</p><p><strong>void FD_SET</strong></p><blockquote><p>用户进程可以调用 FD_SET 函数将指定的文件描述符 fd 设置到准备的 fd_set 数组中。</p></blockquote><p><strong>void FD_CLR</strong></p><blockquote><p>用户进程可以调用 FD_CLR 函数将指定的文件描述符 fd 从准备的 fd_set 数组移除。</p></blockquote><p><strong>void FD_ZERO</strong></p><blockquote><p>用户进程可以调用 FD_ZERO 函数将 fd_set 数组清空。该函数主要用来每次调用 select 函数之前，清空 fd_set 数组，因为每次调用 select 函数监听就绪的 Socket 时，内核会根据就绪的 Socket 情况修改用户进程传入的数组，将就绪的 Socket 对应在 fd_set 数组中元素置位，也就是说 fd_set 不可重用。</p></blockquote><p><strong>int select</strong></p><blockquote><p>用户进程可以在超时时间内，监听感兴趣的文件描述符上的事件（读/写/异常事件）发生。下面我们对相关参数和返回值进行说明。</p></blockquote><p>参数：</p><blockquote><ul><li><strong>int nfds:</strong> fd_set 数组当中最大描述符加 1，用来告知内核扫描的bitmap的范围。</li><li><strong>fd_set *readfds:</strong> 要监听的读事件就绪的 Socket 的文件描述符数组，传 NULL 表示对应的事件不需要监听。</li><li><strong>fd_set *writefds:</strong> 要监听的写事件就绪的 Socket 的文件描述符数组，传 NULL 表示对应的事件不需要监听。</li><li><strong>fd_set *exceptfds:</strong> 要监听的异常事件对应的 Socket 的文件描述符数组，传 NULL 表示对应的事件不需要监听。</li><li><strong>struct timeval *timeout:</strong> 超时时间</li></ul></blockquote><p>返回值：</p><blockquote><p>监听的就绪 Socket 的描述符其数目，若超时则为0，若出错则为-1</p></blockquote><p><strong>int  FD_ISSET</strong></p><blockquote><p>用户进程可以调用 FD_ISSET 函数判断文件描述符是否置位了，如果置位就说明对应的 Socket 已就绪。</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>准备监听的文件描述符上的事件</strong></p><p>应用程序可以根据具体需要，将 Socket 对应的文件描述符放入到 fd_set 数组中，在调用 select 函数时根据要监听的事件类型传入对应的 fd_set 数组。注意，Socket 不限于客户端的 Socket，服务端的 Socket 也可以，比如监听服务端 Socket 的连接事件发生。其中的用户进程通过调用 FD_SET 函数，将文件描述符写入到 fd_set 数组中，也就是将对应的位设置为 1，具体如下：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/io-multi-select-1.jpg" alt></p><p>对于 select 模型，操作系统内核只是定义了文件描述符事件相关数据结构 fd_set，并没有在内核中提供维护文件描述符事件的数据结构。也就是说，应用程序需要根据系统系统内核提供的 fd_set 自行处理文件描述符相关数据。</p><p><strong>等待文件描述符就绪</strong></p><p>应用进程调用 select 函数，操作系统内核会依次遍历传入的每类 fd_set 数组，判断 fd_set 中元素对应的 Socket 有没有数据，这个过程的事件复杂度为 O(n)。如果有数据就对 fd_set 数组中的该 Socket 对应的元素进行置位，最后内核将 fd_set 拷贝回用户空间，不会阻塞当前调用进程。如果要监听的 fd_set 中的所有 Socket 都没有数据，那么进程将会阻塞在 select 函数上，直到超时或有 Socket 就绪，才会唤醒进程。</p><p>在内核遍历 fd_set 数组时，如果对应的 Socket 没有数据，那么内核会将用户进程加入到该 Socket 的等待队列中，这一点非常重要。</p><p><strong>文件描述符就绪</strong></p><p>当监听的任何一个 Socket 就绪时，中断程序将唤醒 Socket 等待队列中的进程，即每次唤醒都需要从每个 Socket 等待队列中移除进程。当用户进程被唤醒时，它知道至少有一个监视的 Socket 发生了感兴趣的事件。同时，内核会对该 Socket 对应在 fd_set 数组中的元素进行置位，然后将修改后的 fd_set 数组们拷贝回用户空间。</p><p>注意，select 虽然可以拿到内核修改后的 fd_set 数组，但是它并不知道是哪个 Socket 发生了哪个事件，需要用户进程自己去判断。</p><p><strong>处理网络请求</strong></p><p>用户进程拿到内核返回的 fd_set 数组包含整个文件描述符，程序不知道哪些 Socket 就绪，因此需要自行判断是哪个或哪些 Socket 发生了哪个事件，找到对应的 Socket 后，处理网络请求。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个服务端 Socket 套接字，</span></span><br><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span> (addr));</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">2000</span>);</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">bind(sockfd,(struct sockaddr*)&amp;addr ,<span class="keyword">sizeof</span>(addr));</span><br><span class="line"><span class="built_in">listen</span> (sockfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备客户端连接对应的文件描述符</span></span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">  addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">  <span class="comment">// 创建客户端 Socket 套接字,并保存对应的文件描述符</span></span><br><span class="line">  <span class="comment">// 注意，文件描述符是操作系统随机分配的一个非负整数</span></span><br><span class="line">  fds[i] = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存最大的文件描述符</span></span><br><span class="line">  <span class="keyword">if</span>(fds[i] &gt; <span class="built_in">max</span>)</span><br><span class="line">      <span class="built_in">max</span> = fds[i];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select 实现多路复用</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">   <span class="comment">// 1 调用  FD_ZERO 清理 rset 数组</span></span><br><span class="line">   FD_ZERO(&amp;rset);</span><br><span class="line">   <span class="comment">// 2 调用 FD_SET 设置监听的文件描述符到 rset 数组中</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">       FD_SET(fds[i],&amp;rset);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3 调用 slect 函数阻塞等待数据的到来，内核会判断 Socket 就绪情况</span></span><br><span class="line">   <span class="comment">// max+1 告知内核扫描 fd_set 数组范围</span></span><br><span class="line">   <span class="comment">// 这里只传入了 fd_set *readfds 参数，表示只监听读事件</span></span><br><span class="line">   select(<span class="built_in">max</span>+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4 监听的 Socket 有读就绪</span></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">       <span class="comment">// 调用 FD_ISSET 判断 rset 是否有置位</span></span><br><span class="line">       <span class="keyword">if</span> (FD_ISSET(fds[i], &amp;rset))&#123;</span><br><span class="line">           <span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,MAXBUF);</span><br><span class="line">           <span class="built_in">read</span>(fds[i], <span class="built_in">buffer</span>, MAXBUF);</span><br><span class="line">           <span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>单个进程能够监视的文件描述符的数量存在最大限制，通常是 1024 ，当然可以更改数量，但由于 select 采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差。</li><li>每次调用 select，都需要把 fd 数组在用户空间与内核空间来回拷贝，并且内核需要遍历传递进来的所有 fd 才能知道是否有 fd 准备就绪，这个开销随着 fd 变多而增大。</li><li>select 返回的是含有整个文件描述符的数组，并非明确指出哪些文件描述符就绪了，因此应用程序需要遍历整个数组才能发现哪些文件描述符号对应的 Socket 发生了事件。</li></ol><h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><p>poll 的实现和 select 非常相似，只是描述 fd 集合的方式不同，它们的工作原理是一样的。select 是将文件描述符分为了 3 类，使用 fd_set 结构存储，针对每一类文件描述符可关联对应的事件。poll 对所有文件描述符一视同仁，针对每个文件描述关联事件即可。具体的做法是是通过定义了一个结构体 pollfd，将文件描述符和感兴趣的事件绑定在一起。这就是 poll 和 select 的主要区别，也就是说 poll 使用 pollfd 数组解决了 select 使用 bitmap 存储文件描述符数量限制问题。需要注意的是，poll 仍然没有解决 select 中的其它问题。</p><h2 id="API-定义"><a href="#API-定义" class="headerlink" title="API 定义"></a>API 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 感兴趣的事件</span></span><br><span class="line">    short events; <span class="comment">/* requested events to watch */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核检测到的实际事件</span></span><br><span class="line">    short revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">    </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>下面对 poll 函数的参数和返回值说明。</p><p>参数：</p><blockquote><ul><li><strong>struct pollfd *fds:</strong> 该数组用于存放用户进程监听的 Socket 文件描述符事件信息，每一个元素都是 pollfd 结构。fd 属性用于存放关注的 Socket 文件描述符；events 属性用于存方关注的事件；revents 是内核检测到 fd 对应的 Socket 实际发生的事件。</li><li><strong>nfds_t nfds:</strong> 用于告诉内核 fds 数组的大小，内核会根据该参数去遍历 fds 数组。</li><li><strong>int timeout:</strong> 阻塞等待的超时时间</li></ul></blockquote><p>返回值：</p><blockquote><p>fds 集合中就绪的描述符数量，返回 0 表示超时，返回 -1 表示出错。</p></blockquote><h2 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">   addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">   <span class="comment">// 1 使用 pollfd 结构准备文件描述符</span></span><br><span class="line">   pollfds[i].fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">   <span class="comment">// 设置感兴趣的事件</span></span><br><span class="line">   pollfds[i].events = POLLIN;</span><br><span class="line">  &#125;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 调用 poll 阻塞等待数据的到来，内核会判断 Socket 就绪情况</span></span><br><span class="line">    poll(pollfds, <span class="number">5</span>, <span class="number">50000</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 用户进程自己判断哪个 Socket 发生了 POLLIN </span></span><br><span class="line">        <span class="keyword">if</span> (pollfds[i].revents &amp; POLLIN)&#123;</span><br><span class="line">            <span class="comment">// 重置 revents ，</span></span><br><span class="line">            pollfds[i].revents = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,MAXBUF);</span><br><span class="line">            <span class="built_in">read</span>(pollfds[i].fd, <span class="built_in">buffer</span>, MAXBUF);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>poll 的改进主要是围绕着存储文件描述符事件的结构体 pollfd 来展开的</strong>，用户进程准备的各种文件描述符事件都是由该结构体存储的，此外内核检测到 Socket 就绪会设置对应的 pollfd 中的 revents 属性的值。虽然 poll 提供了更优质的编程接口，但是本质和 select 模型相同。因此千级并发以下的 I/O，可以考虑 select 和 poll 模型，但是如果出现更大的并发量，就需要用 epoll 模型。可以看到，当套接字 Socket 比较多的时候，不管哪个 Socket 是活跃的，对于使用 select 或 poll 模型都需要遍历一遍,这会浪费很多CPU资源。如果能给套接字 Socket 注册某个回调函数，当他们活跃时自动完成相关操作，那就避免了轮询，这正是 epoll 做的。</p><h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p><strong>epoll</strong> 是对 <strong>select</strong> 和 <strong>poll</strong> 的改进。它的核心思想是基于<strong>事件驱动</strong>来实现的，操作系统内核维护<strong>一颗红黑树</strong>来存储文件描述符相关信息和维护一个<strong>链表</strong>来存放准备就绪的文件描述符对应的 Socket 相关的事件信息。其实，这两个数据结构存储的元素都和 epitem 结构有关，不过为了方便描述，通常都会说存储的是文件描述符，后面我们会详细介绍 epitme 结构。</p><h2 id="API-定义-1"><a href="#API-定义-1" class="headerlink" title="API 定义"></a>API 定义</h2><p>下面列举 epoll 提供的API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 epoll 实例，返回 epoll 专用文件描述符（Linux 优化后废弃了参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于往 epoll 实例中增删改要检测的文件描述符事件</span></span><br><span class="line">    <span class="comment">// 根据具体操作调整调整红黑树和就绪链表</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于阻塞等待可以执行IO操作的文件描述符事件，直到超时</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>上面列举了Linux中提供的epoll相关API，下面我们依次介绍这些函数。</p><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><p>当某一进程成功调用<strong>epoll_create</strong>函数时，Linux 内核会创建一个 <strong>epoll</strong> 实例，并返回其文件描述符。下面是 epoll 实例对应的结构体，我们只关注核心属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_wait 使用的等待队列，和用户进程唤醒有关</span></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> wq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就绪队列，用于存放就绪的文件描述符事件信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树的根节点，这颗树中存储着所有添加到 epoll 中的文件描述符信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般一个进程对应一个 <strong>epoll</strong> 实例，每个 <strong>epoll</strong> 实例都有一个独立的 <strong>eventpoll</strong> 结构体。更详细的结构如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/io-multi-epoll-1.jpg" alt></p><p>值得注意的是，进程在调用以上函数创建 <strong>epoll</strong> 对象的同时，会初始化以上三个核心数据结构：</p><ul><li><strong>wq:</strong> 等待队列链表。中断数据就绪的时候会通过 wq 来找到阻塞在 epoll 对象上的用户进程（调用 epoll_wait 函数的进程）。</li><li><strong>rdllist:</strong> 就绪链表。当有文件描述符对应的 Socket 就绪时，内核会将该 Scocket 等待队列中的 epitem 的 rdllink 成员添加到该就绪链表中。</li><li><strong>rbr:</strong> 一颗红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll 内部使用了一颗红黑树。通过这颗树来管理用户进程下添加进来的文件描述符。注意，红黑树节点并不是文件描述符，而是内核对文件描述符和事件信息封装的 epitem 的 rbn 成员。</li></ul><p>至此，这些成员其实还只是刚被定义或初始化，都还没有用到，它们会在下面被用到。</p><h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><p>某一进程通过调用 <strong>epoll_ctl</strong> 函数向 epoll 对象中添加、删除、修改感兴趣的<strong>文件描述符事件信息</strong>，返回0标识成功，返回-1表示失败。该方法的参数很重要，下面我们详细分析各个参数的作用。</p><p><strong>int epfd</strong><br>表示 epoll 实例的文件描述符，也就是 <strong>epoll_create</strong> 函数调用成功返回的值。随便说一句，文件描述符是一个非负整数。</p><p><strong>int op</strong><br>表示对文件描述符 fd 的监听事件的操作，操作类型如下：</p><blockquote><ul><li>EPOLL_CTL_ADD：注册新的 fd 的监听事件</li><li>EPOLL_CTL_MOD：修改已经注册的 fd 的监听事件</li><li>EPOLL_CTL_DEL：删除 fd 的监听事件</li></ul></blockquote><p><strong>int fd</strong><br>表示要监听的文件描述符，该文件描述符对应的 Socket 可能发生不同的操作，进而产生不同的事件。</p><p><strong>struct epoll_event *event</strong><br>表示要监听的文件描述符 fd 对应的 Socket 发生的事件，该事件的结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户附加数据定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span>        *ptr; <span class="comment">/*指向用户自定义数据*/</span></span><br><span class="line">    <span class="keyword">int</span>          fd;  <span class="comment">/*注册的文件描述符*/</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     u32; </span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll 监听事件定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="comment">// 描述 epoll 事件</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 专门给用户使用的，具体见上面的结构体</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>epoll_event</strong> 包括两部分信息，一个是文件描述符的事件信息，另一个是为使用方提供的属性。这个结构非常重要，使用方向 epoll 实例注册监听事件信息时，需要在 <strong>data</strong> 域写入文件描述符相关信息，当有文件描述符对应的 Socket 准备就绪时，会间接将对应的 epoll_event 拷贝会用户空间，用户进程就可以根据 epoll_event 中的 events 事件信息和 data 中用户指定的文件描述符 fd，进而可以根据事件信息去操作文件描述符对应 Socket 。</p><p>常用的 epoll 事件描述如下：</p><ul><li>EPOLLIN：描述符处于可读状态</li><li>EPOLLOUT：描述符处于可写状态</li><li>EPOLLET：将epoll event通知模式设置成 edge triggered</li><li>EPOLLONESHOT：第一次进行通知，之后不再监测</li><li>EPOLLHUP：本端描述符产生一个挂断事件，默认监测事件</li><li>EPOLLRDHUP：对端描述符产生一个挂断事件</li><li>EPOLLPRI：描述符有紧急的数据可读</li><li>EPOLLERR：描述符产生错误时触发，默认检测事件</li></ul><p>下面我们只考虑注册新的文件描述符的监听事件。在调用 epoll_clt 函数注册文件描述符事件时，Linux 内核会做以下工作：</p><ol><li>根据传入的参数初始化一个 epitem 对象，该对象是内核管理文件描述符的基础，后续红黑树和就绪链表中的数据都要用到它。</li><li>为传入的文件描述符对应的 Socket 新建一个等待队列项，其中的回调函数为 ep_poll_callback（该回调函数会在 Socket 准备就绪后触发），base 指针指向步骤 1 初始化的 epitem，它将来会作为添加到就绪链表的数据源。然后将该等待队列项加入到 Socket 的等待队列中。</li><li>将 epitem 的 rbn 成员插入到红黑树中。红黑树主要用来维护进程添加的文件描述符，这样就可以避免每次获取就绪 Socket 信息时都要重新拷贝一遍所有的文件描述符到内核态，并能在插入，查找和删除的操作发生高效执行。</li></ol><p>在 epoll 中，内核会根据传入的文件描述和事件，将相关信息封装成 <strong>epitem</strong> 对象，epitem 结构如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>&#123;</span></span><br><span class="line">    <span class="comment">// 红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>  <span class="title">rbn</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 就绪链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">rdllink</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件描述符具体信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>  <span class="title">ffd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向其所属的 eventpoll 对象  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听的事件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>&#123;</span></span><br><span class="line">    <span class="comment">// Socket 文件地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单说明下，epoll 为啥要使用红黑树呢？使用红黑树是基于 epoll 在查询效率、插入效率、删除效率以及内存开销等多方面均衡的结果。</p><h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><p>某一进程通过调用 <strong>epoll_wait</strong> 函数阻塞等待就绪文件描述符，成功时返回就绪的事件数目，调用失败时返回 -1，等待超时返回 0。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><strong>int epfd</strong><br>表示 epoll 实例的文件描述符，也就是 <strong>epoll_create</strong> 函数调用成功返回的值。</p><p><strong>struct epoll_event *events</strong><br>关注的文件描述符对应的 Socket 有事件触发时，内核会将对应的事件信息写入 events 数组中并拷贝回用户空间。</p><p><strong>int maxevents</strong><br>通知内核 events 的大小，内核会根据该值从就绪链表中写数据到 events 数组中。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>epoll_wait 做的事情相对比较简单，当用户进程调用它时会直接观察<strong>就绪链表</strong>中有没有数据即可。</p><p><strong>有数据</strong><br>内核会将就绪链表中元素对应的事件信息写入到 events 并拷贝回用户空间就结束了。</p><p><strong>等待文件描述符就绪</strong><br>没有数据，则创建一个等待队列项，将用户进程设置到等待队列项，并且设置一个 default_wake_function 回调函数（将来用来唤醒当前进程），然后添加到 eventpoll 的等待队列上，阻塞当前用户进程。需要注意的是，epoll_ctl 过程中是为文件描述符对应的 Socket 创建等待队列项，这里是为 epoll 创建等待队列项。从这个过程也可以看出，epoll 也是会阻塞当前进程的，这个是合理的，因为没有事情可做了占着 CPU 也没啥意义。</p><p><strong>文件描述符就绪</strong></p><p>当 Socket 就绪时，内核会找到 Socket 等待队列中设置的回调函数 ep_poll_callback 并执行该函数，该函数会根据等待队列项的 base 属性找到 epitem 对象，进而也可以找到 eventpoll 对象。接着将找到的 epitem 的 rdllink 添加到 epoll 的就绪链表中，最后会查看 eventpoll 的等待队列中是否有等待项，也就是查看是否有用户进程在等待，如果没有则执行中断的事情就做完了。如果有就查找到等待项里设置的回调函数 default_wake_function 并执行，唤醒阻塞的用户进程。</p><p><strong>处理网络请求</strong></p><p>当进程醒来之后，继续从 epoll_await 时暂停的代码继续执行，同时内核向用户空间拷贝就绪事件信息到 events 参数中，用户进程可以根据返回的具体信息处理网络请求。</p><h2 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[5];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 创建一个 epoll 实例</span></span><br><span class="line"><span class="keyword">int</span> epfd = epoll_create(<span class="number">10</span>);</span><br><span class="line"> ...</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 2 epoll 监听事件定义</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">  addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.1 设置 fd </span></span><br><span class="line">  ev.data.fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">  <span class="comment">// 2.2 设置监听事件</span></span><br><span class="line">  ev.events = EPOLLIN;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3 向 epoll 注册 文件描述符事件</span></span><br><span class="line">  epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4 调用 epoll_wait 阻塞等待数据的到来，内核会判断 Socket 就绪情况，并把就绪的 Socket 相关的 epoll_event 拷贝出用户空间</span></span><br><span class="line">   <span class="comment">// 返回的就绪 Socket 的个数</span></span><br><span class="line">   nfds = epoll_wait(epfd, events, <span class="number">5</span>, <span class="number">10000</span>);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 只需要遍历 nfds 个数即可</span></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;i++) &#123;</span><br><span class="line">           <span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,MAXBUF);</span><br><span class="line">           <span class="built_in">read</span>(events[i].data.fd, <span class="built_in">buffer</span>, MAXBUF);</span><br><span class="line">           <span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ol><li>epoll 为了减少文件描述符频繁的拷贝开销，在内核中维护了一颗红黑树用来存储文件描述符信息。并不是说 epoll 完全避免了文件描述符的拷贝，epoll 只会在新增/修改/删除的时候进行拷贝工作，避免了每次获取就绪数据信息时的重复拷贝。</li><li>epoll 使用了一个就绪链表来解决准确通知问题，也就是只会将就绪的 Socket 信息返回给用户空间，即可以直接从 events 参数中获取就绪的文件描述符的信息，无需遍历整个所有文件描述符集合。</li><li>epoll 阻塞用户进程时只会将其添加到 epoll 实例的等待队列中，而不需要将用户进程轮流加入到文件描述符对应的 Socket 的等待队列中。并且 epoll 模型为文件描述符对应的 Socket 设置一个回调函数，当 Socket 就绪时会触发该函数的调用，这就是基于事件驱动模型。基于事件驱动内核就可以避免遍历所有文件描述符的开销。</li></ol><h1 id="方案比较"><a href="#方案比较" class="headerlink" title="方案比较"></a>方案比较</h1><ol><li>select 和 poll 基本类似，都是使用内核定义的数据结构来进行文件描述符的存储，select 采用 bitmap ，poll 采用数组。select 会受到最大连接数的限制，而 poll 在一定程度上解决了这个问题。而 epoll 则是内核专门维护了一颗红黑树来存储文件描述符信息。前两个文件描述符信息需要用户空间维护，而后者是在内核空间维护的。</li><li>select 和 poll 都需要将有关文件描述符的数据结构在用户空间和内核空间来回拷贝，而 epoll 只会在新增/修改/删除的时候进行拷贝工作。</li><li>select 和 poll 采用轮询的方式来检查文件描述符是否处于就绪状态，而 epoll 采用回调机制。造成的结果是，随着文件描述符的增加，select 和 poll 的效率会线性降低，而 epoll 受到的影响较小，除非活跃的 Socket 较多。 </li><li>select 、poll 以及 epoll 虽然都会返回就绪的文件描述符数量。但是 select 和 poll 并不会明确指出是哪些文件描述符就绪，而 epoll 可以做到。用户进程返回后，调用 select 和 poll 的程序需要遍历监听整个文件描述符，而 epoll 得益于内核就绪链表则可以直接处理。</li></ol><p>注意，虽然 epoll 的性能最好，但是在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，毕竟 epoll 的通知机制需要很多函数回调，这也是需要有开销的。</p><h1 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h1><h2 id="水平触发"><a href="#水平触发" class="headerlink" title="水平触发"></a>水平触发</h2><p>当内核有事件到达，会拷贝给用户空间，如果应用程序没有处理完或者压根都没有处理，那么会在下一次再次返回没有处理的事件。这样，如果应用程序永远不处理这个事件，就导致每次都会有该事件从内核空间到用户空间的拷贝，消耗性能。但是水平触发相对安全，最起码事件不会丢掉，除非用户处理完毕。</p><h2 id="边缘触发"><a href="#边缘触发" class="headerlink" title="边缘触发"></a>边缘触发</h2><p>边缘触发，相对跟水平触发相反，当内核有事件到达，只会通知应用程序一次，至于应用程序处理还是不处理，以后将不会再通知。这样减少了拷贝过程，增加了性能，但是会产生事件丢失的情况。</p><p>对于 select 和 poll 来说，其触发都是水平触发。而 epoll 既支持水平触发也支持边缘触发。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对IO多路复用的实现方案进行了介绍，主要以 Linux 系统的 slect、poll 和 epoll 为主线进行说明。下面给出总结表：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/io-multi-2.jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;IO多路复用简单来说就是，单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力，IO多路复用解决的本质问题是用更少的资源完成更多
      
    
    </summary>
    
    
      <category term="网络通信" scheme="https://gentryhuang.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="I/O" scheme="https://gentryhuang.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>网络通信 - IO模型</title>
    <link href="https://gentryhuang.com/posts/51fff883/"/>
    <id>https://gentryhuang.com/posts/51fff883/</id>
    <published>2021-06-05T07:36:47.000Z</published>
    <updated>2021-08-03T07:48:22.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章将对网络通信相关的基本概念进行说明，并重点对常见的 I/O 模型进行介绍，接着介绍套接字并引出 I/O 多路复用。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><p>输入输出(input/output)的对象可以是文件(file)、网络(socket)、进程之间的管道。在Linux系统中，都用文件描述符(fd)来表示。</p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>没有数据传过来时，读会阻塞直到有数据；缓冲区满了，写操作也会阻塞。非阻塞都是直接返回。阻塞和非阻塞强调的是调用者是否等待。</p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>数据就绪后需要应用程序自己去读是同步。数据就绪后通过回调给到应用程序是异步。同步与异步强调的是获取数据的操作是由调用者还是被调用者完成。</p><h2 id="内核空间与用户空间"><a href="#内核空间与用户空间" class="headerlink" title="内核空间与用户空间"></a>内核空间与用户空间</h2><p>在 Linux 中，应用程序的稳定性远远比不上操作系统程序，为了保证操作系统的稳定性，分出了<strong>内核空间</strong>和<strong>用户空间</strong>。内核空间运行操作系统程序和驱动程序，用户空间运行应用程序。所有的系统资源操作都在内核空间进行，比如读写磁盘文件、内存分配和回收以及网络接口调用等。不难看出，一次网络IO读取过程中，数据并不是直接从网卡读取到用户空间中的应用程序缓冲区，而是先从网卡拷贝到内核空间缓冲区，然后再从内核拷贝到用户空间中的应用程序缓冲区。对于网络IO写入过程则相反，先将数据从用户空间中的应用程序缓冲区拷贝到内核缓冲区，再从内核缓冲区把数据通过网卡发送出去。</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>零拷贝是一种避免多次内存复制的技术，用来优化读写IO操作。</p><p>Linux 内核中的 mmap 函数可以将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址，不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理内存地址。这种方式实现用户空间和内核空间共享一个缓存数据，避免了内核空间与用户空间的数据交换。I/O 复用中的 epoll 函数中就是使用了 mmap 减少了内存拷贝。</p><p>在 Java 中，在用户空间中又存在一个拷贝，即从 Java 堆内存中拷贝到临时的直接内存中，通过临时的直接内存拷贝到内核空间中去。此时的直接内存和堆内存都是属于用户空间。<code>DirectBuffer</code> 是直接分配物理内存（非堆内存）的，它直接将过程简化为数据直接保存到非堆内存，这样就减少了一次拷贝。注意，<code>DirectBuffer</code> 只优化了用户空间内部的拷贝。而在 NIO 中，<code>MappedByteBuffer</code> 是通过本地类调用 mmap 进行文件内存映射的，可以直接将文件从网卡拷贝到用户空间，只进行一次数据拷贝，从而减少了传统的 read() 方法从网卡拷贝到内核空间这一步。</p><h1 id="网络IO模型"><a href="#网络IO模型" class="headerlink" title="网络IO模型"></a>网络IO模型</h1><p>Linux 网络IO模型包括：<strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong> 。需要说明的是，操作系统层面的IO模型和Java中的IO模型是一一对应的，Java只是堆操作系统API进行了封装。</p><p>对于一个网络IO通信过程会涉及两个对象，一个是执行IO操作的用户线程，另一个是操作系统内核。一个进程的地址空间分为用户空间和内核空间，用户线程不能直接访问内核空间。</p><h2 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h2><p>用户线程发起read 请求后就阻塞了，此时会让出 CPU 。内核等待网卡数据到来，把数据从网卡拷贝到内核空间，接着把数据拷贝到用户空间，再把用户线程唤醒。这样情况下，需要为每个连接都分配一个线程，在大量连接的场景下就需要大量的线程，会造成巨大的性能损耗，这也是传统阻塞IO的最大缺陷。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/net-io-base-1.png" alt></p><h2 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h2><p>用户线程在发起 read 请求后立即返回，如果没读取到数据，用户线程会不断轮询发起 read 请求，直到数据到达（内核准备好数据）后才停止轮询，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的，等数据到了用户空间再把线程唤醒。非阻塞IO模型虽然避免了由于线程阻塞问题带来的大量线程消耗，但是频繁地重复轮询大大增加了请求次数，对CPU消耗也比较明显。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/net-io-base-2.png" alt></p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>用户线程的读取操作分成两步了，线程先发起 select 调用，目的是问内核数据准备好了吗？等内核把数据准备好了，用户线程再发起 read 调用。在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的。注意，等待 select 返回过程也是阻塞的，所以说IO多路复用并非完全非阻塞。那为什么叫 I/O 多路复用呢？因为一次 select 调用可以向内核查多个数据通道（Channel）的状态，所以叫多路复用。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/net-io-base-3.png" alt></p><h2 id="信号驱动式IO"><a href="#信号驱动式IO" class="headerlink" title="信号驱动式IO"></a>信号驱动式IO</h2><p>用户线程发起 read 请求，会通过系统调用 sigaction 函数，给对应的套接字注册一个信号回调，此时不阻塞用户进程，进程会继续工作。当内核数据就绪时，内核就为该进程生成一个 SIGIO 信号，通过信号回调通知进程进行相关 IO 操作。</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>用户线程发起 read 请求的同时注册一个回调函数，read 立即返回，等内核已经读取完数据并把数据放到了应用进程的缓冲区中，再调用指定的回调函数完成处理。在这个过程中，用户线程一直没有阻塞。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/net-io-base-4.png" alt></p><p>介绍完常见的网络IO模型后，下面我们对 Socket(套接字) 进行说明。</p><h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><p>所谓套接字(Socket)，可以抽象成两个程序进行通讯连接中的一个端点，提供了应用层进程利用网络协议交换数据的机制。要通过互联网进行通信，至少需要一对套接字，一个运行于客户机端，另一个运行于服务器端。不同编程语言对套接字（Socket）都有对应的封装，如 Java 中的 <strong>ServerSocket/Socket</strong>，Python 中引用套接字的模式是 socket 。本质上来说，套接字是操作系统层面的产物，它既是一种编程模型，同时又是一个文件（操作系统提供支持网络通信的一种文件格式）。</p><h2 id="Socket-编程模型"><a href="#Socket-编程模型" class="headerlink" title="Socket 编程模型"></a>Socket 编程模型</h2><p>套接字（Socket）通信过程如下图所示，这里以流式套接字（TCP）为例：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/socket-process-1.jpg" alt></p><p>下面对上图的流程简单说明：</p><ol><li>应用程序通过系统调用 <strong>socket</strong> 创建一个套接字，它是操作系统分配给应用程序的一个文件描述符（用来标识套接字（Socket）的）。</li><li>应用程序会通过系统调用 <strong>bind</strong>，绑定地址和端口，给套接字命名一个名称。</li><li>系统会调用 <strong>listen</strong> 创建一个<strong>队列</strong>用于存放客户端进来的连接。</li><li>应用服务会通过系统调用 accept 来监听客户端的连接请求。</li></ol><h2 id="双向管道文件"><a href="#双向管道文件" class="headerlink" title="双向管道文件"></a>双向管道文件</h2><p>套接字（Socket）是一个支持网络通信的文件，存储的是数据。服务端 Socket 文件存储的是客户端 Socket 文件描述符；客户端 Socket 文件存储的是传输数据。</p><p>当一个客户端连接到服务端的时候，操作系统就会创建一个客户端 Socket 的文件。然后操作系统将这个文件的文件描述符写入服务端程序创建的服务端 Socket 文件中。进程可以通过 accept() 方法，从服务端 Socket 文件中读出客户端的 Socket 文件描述符，从而拿到客户端的 Socket 文件。Socket 是一个双向的管道文件，当线程想要读取客户端传输来的数据时，就从客户端 Socket 文件中读取数据；当线程想要发送数据到客户端时，就向客户端 Socket 文件中写入数据。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/socket-process-2.jpg" alt></p><p><strong>注意：</strong></p><blockquote><p>1 服务端维护的 Socket 数量是 N+1，包括 N 个与客户端对应的 Socket 和一个监听 Socket 。<br>2 操作系统创建的 Socket 是由文件系统管理的，内核中有一个文件列表(fd)管理这些 Socket。</p></blockquote><h2 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h2><p>如何同时监视多个 Socket 呢？答案就是多路复用。</p><p>在 IO 多路复用技术中，应用进程（或线程）需要维护一个 Socket 集合（可以是数组、链表等），然后定期遍历这个集合，判断每个 Socket 文件的状态。这些 Socket 文件的状态如：服务端 Socket 文件写入客户端 Socket 文件描述符，客户端 Socket 文件的读、写等操作。这样的做法在客户端 Socket 较少的情况下没有问题，但是如果接入的客户端 Socket 较多，比如达到上万，那么每次轮询的开销都会很大。</p><p>为了解决这个问题，就需要一个观察者角色，观察者需要知道每个 Socket 文件的状态，这样就可以在 Socket 文件状态发生改变时，把相关信息推送应用进程了。这种方式就不需要应用进程主动轮询。不难发现，最合适的观察者其实就是操作系统本身，因为操作系统非常清楚每一个 Socket 文件的状态（包括服务端和客户端的 Socket），毕竟对 Socket 文件的读写都要经过操作系统。具体来说，每个 Socket 对应着一个端口号，而网络数据包中包含了 ip 和端口的信息，内核可以通过端口号找到对应的 Socket 。</p><p>总结起来就是：单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力，IO多路复用解决的本质问题是用更少的资源完成更多的事。注意，处理IO多路复用的问题，需要操作系统提供内核级别的支持。如 Linux 下有三种提供IO多路复用的 API，分别是 <code>select</code>、<code>poll</code> 以及<code>epoll</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章将对网络通信相关的基本概念进行说明，并重点对常见的 I/O 模型进行介绍，接着介绍套接字并引出 I/O 多路复用。&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
    
      <category term="网络通信" scheme="https://gentryhuang.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="I/O" scheme="https://gentryhuang.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - 事务</title>
    <link href="https://gentryhuang.com/posts/a26fab1/"/>
    <id>https://gentryhuang.com/posts/a26fab1/</id>
    <published>2021-05-27T12:08:59.000Z</published>
    <updated>2021-06-28T06:23:41.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Redis 通过 <strong>MULTI</strong>、<strong>EXEC</strong>、<strong>DISCARD</strong> 以及 <strong>WATCH</strong> 命令来实现事务功能。与我们所熟知的事务最大的不同是，Redis 实现的事务不支持回滚特性。此外，Redis 事务的 ACID 特性也并不完整，不同的情况下表现会有不同。Redis 事务也被称为 <strong>半事务</strong>，它是简单地使用队列存放一组 Redis 命令。</p><h1 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h1><p>Redis 事务的执行过程包含三个阶段，如下：</p><blockquote><ol><li>开启事务</li><li>命令入队</li><li>事务执行/取消</li></ol></blockquote><p>下面我们分别对以上三个阶段进行说明，并介绍核心的实现逻辑。</p><h2 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h2><p>Redis 客户端执行 <strong>MULTI</strong> 命令标志着事务的开启:</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt;</span><br></pre></td></tr></table></figure><p><strong>MULTI</strong> 命令可以将执行该命令的客户端从<strong>非事务状态</strong>切换到<strong>事务状态</strong>，这一切换是将客户端的 <code>flags</code> 属性设置为 <code>CLIENT_MULTI</code> 标识来完成的。</p><p><strong>MULTI 命令的实现逻辑如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * multi 命令对应的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 检测客户端状态，不支持在事务中嵌套事务</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReplyError(c, <span class="string">"MULTI calls can not be nested"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 开启事务，即设置客户端的状态标志为 CLIENT_MULTI</span></span><br><span class="line">    c-&gt;flags |= CLIENT_MULTI;</span><br><span class="line"></span><br><span class="line">    addReply(c, shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，Redis 开启事务主要是将当前客户端的状态标志属性 <code>flags</code> 设置为 <code>CLIENT_MULTI</code>。Redis 事务的生命周期是和该状态标志紧密相关的，除此状态外，命令入队出错需要将客户端的状态设置为 <code>REDIS_DIRTY_EXEC</code>，客户端监视的键被改动需要将客户端的状态设置为 <code>REDIS_DIRTY_CAS</code>，这两种情况将在下文进行介绍。</p><h2 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h2><p>Redis 在没有开启事务时，即一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行，这个也是我们日常多使用的方式。与此不同的是，当一个客户端开启事务，即一个客户端处于事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：</p><ul><li>如果客户端发送的命令为 <code>EXEC</code> 或 <code>DISCARD</code> ，那么服务器会立即执行这个命令，进行事务的提交或取消。</li><li>如果客户端发送的命令是操作数据命令，那么服务器并不会立即执行这个命令，而是将这个命令加入到<strong>事务队列</strong>中，然后向客户端返回 <code>QUEUED</code> 回复，标识加入事务队列完成。</li></ul><p><strong>将命令入队的实现逻辑如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a new command into the MULTI commands queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将一个新命令添加到事务队列中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueMultiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    multiCmd *mc;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 检测客户端状态，如果要入队的命令出现类似语法错误，则不允许入队</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_DIRTY_EXEC)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 为命令分配对应的空间，如存储命令结构的队列、封装命令的命令结构 multiCmd</span></span><br><span class="line">    c-&gt;mstate.commands = zrealloc(c-&gt;mstate.commands,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(multiCmd) * (c-&gt;mstate.count + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 指向新元素</span></span><br><span class="line">    mc = c-&gt;mstate.commands + c-&gt;mstate.count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 设置命令、命令参数数量、以及命令的参数</span></span><br><span class="line">    mc-&gt;cmd = c-&gt;cmd;</span><br><span class="line">    mc-&gt;argc = c-&gt;argc;</span><br><span class="line">    mc-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj *) * c-&gt;argc);</span><br><span class="line">    <span class="built_in">memcpy</span>(mc-&gt;argv, c-&gt;argv, <span class="keyword">sizeof</span>(robj *) * c-&gt;argc);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        incrRefCount(mc-&gt;argv[j]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 事务队列长度增一</span></span><br><span class="line">    c-&gt;mstate.count++;</span><br><span class="line"></span><br><span class="line">    c-&gt;mstate.cmd_flags |= c-&gt;cmd-&gt;flags;</span><br><span class="line">    c-&gt;mstate.cmd_inv_flags |= ~c-&gt;cmd-&gt;flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 每次在入队的命令出现类似语法错误时调用，将客户端的状态设置为 DIRTY_EXEC，让之后的 EXEC 命令失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flagTransaction</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前客户端的状态处于事务状态</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI)</span><br><span class="line">        <span class="comment">// 将客户端的状态设置为 CLIENT_DIRTY_EXEC，表示该客户端的事务安全性已经被破坏</span></span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_EXEC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，以上函数只是命令入队逻辑，在该方法上层会对当前客户端的状态标志进行判断，并结合当前命令选择对应处理方式，因为涉及的内容相对较多且不是本文的重点，暂不展开说明。</p><h2 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h2><p>前文介绍了 Redis 事务中的命令入队逻辑，但是并没有详细说明事务队列的结构以及命令封装结构，本小节就来对 Redis 事务中涉及的相关数据结构进行介绍。</p><p>每个 Redis 客户端都有自己的状态，其它状态我们暂不介绍，这里我们围绕着事务相关状态进行说明。下面只列举客户端结构体中涉及事务相关的属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前正在使用的数据库</span></span><br><span class="line">    redisDb *db;            <span class="comment">/* Pointer to currently SELECTed DB. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;               <span class="comment">/* Num of arguments of current command. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数对象数组</span></span><br><span class="line">    robj **argv;            <span class="comment">/* Arguments of current command. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录被客户端执行的命令</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span>  <span class="comment">/* Last command executed. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端的状态标志</span></span><br><span class="line">    <span class="keyword">uint64_t</span> flags;         <span class="comment">/* Client flags: CLIENT_* macros. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务状态（本质上是事务队列的封装）</span></span><br><span class="line">    multiState mstate;      <span class="comment">/* MULTI/EXEC state */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被监视的键，用于存放当前客户端使用 WATCH 命令监视键的链表</span></span><br><span class="line">    <span class="built_in">list</span> *watched_keys;     <span class="comment">/* Keys WATCHED for MULTI/EXEC CAS */</span></span><br><span class="line"></span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure><p>客户端的状态标志是通过 <code>flags</code> 属性记录的。如果客户端开启事务，那么客户端的 <code>mstate</code> 属性封装了事务队列信息，用来管理事务中的命令；客户端的 <code>watched_keys</code> 链表结构用来管理客户端使用 <strong>WATCH</strong> 命令监视的键信息。下文我们会分别详细介绍这些关键属性。</p><p>客户端的 <code>mstate</code> 属性主要包含一个<strong>事务队列</strong>和一个<strong>记录事务队列长度的属性</strong>，具体结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 主要包含一个事务队列，以及一个已入队命令的计数器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 事务队列，是一个 multiCmd 类型的数组</span></span><br><span class="line">    multiCmd *commands;     <span class="comment">/* Array of MULTI commands */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已入队命令计数（事务队列的长度）</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">/* Total number of MULTI commands */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cmd_flags;          <span class="comment">/* The accumulated command flags OR-ed together.</span></span><br><span class="line"><span class="comment">                               So if at least a command has a given flag, it</span></span><br><span class="line"><span class="comment">                               will be set in this field. */</span></span><br><span class="line">    <span class="keyword">int</span> cmd_inv_flags;      <span class="comment">/* Same as cmd_flags, OR-ing the ~flags. so that it</span></span><br><span class="line"><span class="comment">                               is possible to know if all the commands have a</span></span><br><span class="line"><span class="comment">                               certain flag. */</span></span><br><span class="line">&#125; multiState;</span><br></pre></td></tr></table></figure><p>从 <strong>multiState</strong> 结构中可以看出，事务队列本质上是一个 <strong>multiCmd</strong> 类型的数组。<strong>multiCmd</strong> 结构用于封装了一个已入队命令的信息，具体结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存了一个已入队命令的相关信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line">    <span class="comment">// 参数数组</span></span><br><span class="line">    robj **argv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令指针，指向具体的命令（命令结构中封装了对应的命令函数）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure><p>事务队列以先进先出（FIFO）的方式保存入队的命令信息，较先入队的命令会被放到数组的前面，而较后入队的命令则会放到数组的后面。下面结合示例，对事务队列结构进行说明。</p><p><strong>事务中的命令入队过程：</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; SET name "Practical Common Lisp"</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; GET "name"</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; SET author "Peter Seibel"</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; GET author</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt;</span><br></pre></td></tr></table></figure><p><strong>事务队列结构如下图所示：</strong><br><img src="/posts/a26fab1/redis-tx-multistate.jpg" alt></p><p>上图很直观地展示了客户端中的 <code>multiState</code> 属性的平铺结构。</p><p>了解了 Redis 事务的开启以及事务相关的数据结构后，下面我们看看 Redis 提交事务的逻辑。</p><h2 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h2><p>当一个处于事务状态的客户端向服务器发送 <code>EXEC</code> 命令时，该命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，依次执行队列中保存的命令，最后将执行命令得到的结果全部返回给客户端。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) "Practical Common Lisp"</span><br><span class="line">3) OK</span><br><span class="line">4) "Peter Seibel"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>执行事务逻辑如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * exec 命令对应的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    robj **orig_argv;</span><br><span class="line">    <span class="keyword">int</span> orig_argc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">orig_cmd</span>;</span></span><br><span class="line">    <span class="keyword">int</span> was_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 检测当前客户端状态，非事务状态直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c, <span class="string">"EXEC without MULTI"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 2 检查是否需要阻止事务执行，因为：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1) Some WATCHed key was touched.</span></span><br><span class="line"><span class="comment">     *    存在被客户端监视的键被修改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2) There was a previous error while queueing commands.</span></span><br><span class="line"><span class="comment">     *    命令在入队时发生错误</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A failed EXEC in the first case returns a multi bulk nil object</span></span><br><span class="line"><span class="comment">     * (technically it is not an error but a special behavior), while</span></span><br><span class="line"><span class="comment">     * in the second an EXECABORT error is returned. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_DIRTY_CAS | CLIENT_DIRTY_EXEC)) &#123;</span><br><span class="line">        addReply(c, c-&gt;flags &amp; CLIENT_DIRTY_EXEC ? shared.execaborterr :</span><br><span class="line">                    shared.nullarray[c-&gt;resp]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行 discard 逻辑，即取消事务</span></span><br><span class="line">        discardTransaction(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前客户端的状态标记</span></span><br><span class="line">    <span class="keyword">uint64_t</span> old_flags = c-&gt;flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we do not want to allow blocking commands inside multi */</span></span><br><span class="line">    <span class="comment">// 我们不希望在multi中允许阻塞命令</span></span><br><span class="line">    c-&gt;flags |= CLIENT_DENY_BLOCKING;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 已经可以保证安全性了，取消客户端对所有键的监视</span></span><br><span class="line">    <span class="comment">// 将当前客户端的 watched_keys 链表回收</span></span><br><span class="line">    <span class="comment">// 从当前客户端操作的数据库的 watched_keys 字典中移除当前客户端</span></span><br><span class="line">    unwatchAllKeys(c); <span class="comment">/* Unwatch ASAP otherwise we'll waste CPU cycles */</span></span><br><span class="line"></span><br><span class="line">    server.in_exec = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 因为事务中的命令在执行时可能会修改命令和命令的参数，所以为了正确地传播命令，需要现备份这些命令和参数</span></span><br><span class="line">    orig_argv = c-&gt;argv;</span><br><span class="line">    orig_argc = c-&gt;argc;</span><br><span class="line">    orig_cmd = c-&gt;cmd;</span><br><span class="line"></span><br><span class="line">    addReplyArrayLen(c, c-&gt;mstate.count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5 执行事务队列中的命令</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.1 因为 Redis 的命令必须在客户端的上下文中执行，所以需要将事务队列中的命令、命令参数等设置到客户端</span></span><br><span class="line">        c-&gt;argc = c-&gt;mstate.commands[j].argc;</span><br><span class="line">        c-&gt;argv = c-&gt;mstate.commands[j].argv;</span><br><span class="line">        c-&gt;cmd = c-&gt;mstate.commands[j].cmd;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/* 省略 ACL权限检查逻辑 */</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 5.2 执行命令</span></span><br><span class="line">        call(c, server.loading ? CMD_CALL_NONE : CMD_CALL_FULL);</span><br><span class="line">        serverAssert((c-&gt;flags &amp; CLIENT_BLOCKED) == <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Commands may alter argc/argv, restore mstate. */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 因为命令执行后命令、命令参数可能会被改变，比如 SPOP 会被改写为 SREM</span></span><br><span class="line"><span class="comment">         * 所以这里需要更新事务队列中的命令和参数，确保附属节点和 AOF 的数据一致性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c-&gt;mstate.commands[j].argc = c-&gt;argc;</span><br><span class="line">        c-&gt;mstate.commands[j].argv = c-&gt;argv;</span><br><span class="line">        c-&gt;mstate.commands[j].cmd = c-&gt;cmd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore old DENY_BLOCKING value</span></span><br><span class="line">    <span class="keyword">if</span> (!(old_flags &amp; CLIENT_DENY_BLOCKING))</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_DENY_BLOCKING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原命令</span></span><br><span class="line">    c-&gt;argv = orig_argv;</span><br><span class="line">    c-&gt;argc = orig_argc;</span><br><span class="line">    c-&gt;cmd = orig_cmd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6 清理事务状态</span></span><br><span class="line">    <span class="comment">// 释放事务队列相关的资源 &amp; 重置客户端的状态</span></span><br><span class="line">    discardTransaction(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure the EXEC command will be propagated as well if MULTI</span></span><br><span class="line"><span class="comment">     * was already propagated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果已经传播了 MULTI，也要确保传播 EXEC 命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (server.propagate_in_transaction) &#123;</span><br><span class="line">        <span class="keyword">int</span> is_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="comment">/* If inside the MULTI/EXEC block this instance was suddenly</span></span><br><span class="line"><span class="comment">         * switched from master to slave (using the SLAVEOF command), the</span></span><br><span class="line"><span class="comment">         * initial MULTI was propagated into the replication backlog, but the</span></span><br><span class="line"><span class="comment">         * rest was not. We need to make sure to at least terminate the</span></span><br><span class="line"><span class="comment">         * backlog with the final EXEC. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog &amp;&amp; was_master &amp;&amp; !is_master) &#123;</span><br><span class="line">            <span class="keyword">char</span> *execcmd = <span class="string">"*1\r\n$4\r\nEXEC\r\n"</span>;</span><br><span class="line">            feedReplicationBacklog(execcmd, <span class="built_in">strlen</span>(execcmd));</span><br><span class="line">        &#125;</span><br><span class="line">        afterPropagateExec();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.in_exec = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>事务执行逻辑比较复杂，下面进行概要总结：</strong></p><ol><li>在事务执行时会判断客户端的状态，如果没有开启事务直接返回。</li><li>对阻止事务执行的情况进行检查，检测到任何一种非法的情况，需要取消事务。</li><li>取消客户端对所有键的监视</li><li>依次执行事务队列中的任务</li><li>清理事务列表并重置客户端状态</li><li>传播 EXEC 命令</li></ol><p>事务执行时涉及的监视机制会在下文进行介绍，这里暂不展开。</p><h2 id="取消事务"><a href="#取消事务" class="headerlink" title="取消事务"></a>取消事务</h2><p>当一个处于事务状态的客户端向服务器发送 <code>DISCARD</code> 命令时，该命令将立即被服务器执行。服务器会释放事务状态资源并重置客户端的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * discard 命令对应的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检测当前客户端状态，非事务状态直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c, <span class="string">"DISCARD without MULTI"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// discard 逻辑</span></span><br><span class="line">    discardTransaction(c);</span><br><span class="line"></span><br><span class="line">    addReply(c, shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * discard 操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardTransaction</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重置事务状态</span></span><br><span class="line">    <span class="comment">// 释放所有事务状态相关的资源</span></span><br><span class="line">    freeClientMultiState(c);</span><br><span class="line">    <span class="comment">// 初始化客户端的事务状态</span></span><br><span class="line">    initClientMultiState(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置客户端状态标志</span></span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_MULTI | CLIENT_DIRTY_CAS | CLIENT_DIRTY_EXEC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消对所有键的监视</span></span><br><span class="line">    unwatchAllKeys(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WATCH-机制"><a href="#WATCH-机制" class="headerlink" title="WATCH 机制"></a>WATCH 机制</h2><p><strong>WATCH</strong> 命令可以在 <strong>EXEC</strong> 命令执行之前，监视任意数量的数据库键，并在 <strong>EXEC</strong> 命令执行时检查是否存在被监视的键被修改的情况，如果存在服务器会拒绝执行事务。前文介绍事务执行和取消时，都有 <strong>WATCH</strong> 机制逻辑，它是 Redis 事务实现的一部分，本小节我们就来详细说明该机制。</p><h3 id="监视键信息"><a href="#监视键信息" class="headerlink" title="监视键信息"></a>监视键信息</h3><p>客户端监视键的时候，被监视的键信息会分别保存在客户端的监视键链表中和当前数据库的监视键字典中，下面我们分别介绍。</p><p><strong>客户端的监视键链表</strong></p><p>每个客户端创建的时候都会初始化一个用于存放监视键的链表。前文在介绍客户端的结构有列举对应的属性，这里直接拿过来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存放被监视的键的链表</span></span><br><span class="line">    <span class="built_in">list</span> *watched_keys;     <span class="comment">/* Keys WATCHED for MULTI/EXEC CAS */</span></span><br><span class="line"></span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure><p>客户端结构中的这个链表的节点的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 在监视一个键时：</span></span><br><span class="line"><span class="comment"> * 我们既需要保存被监视的键，还需要保存该键所在的数据库</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchedKey</span> &#123;</span></span><br><span class="line">    <span class="comment">// 被监视的键对象</span></span><br><span class="line">    robj *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键所在的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">&#125; watchedKey;</span><br></pre></td></tr></table></figure><p>watched_keys 链表数据举例如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># before:</span><br><span class="line"> [</span><br><span class="line">  &#123;</span><br><span class="line">    'key': 'key1',  # 被监视的键</span><br><span class="line">    'db': 0  # 客户端操作的数据库</span><br><span class="line">   &#125;</span><br><span class="line"> ]</span><br><span class="line">#  after client watch key-2 in db 0:</span><br><span class="line"> [</span><br><span class="line">  &#123;</span><br><span class="line">   'key': 'key1',</span><br><span class="line">   'db': 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   'key': 'key2',</span><br><span class="line">   'db': 0</span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><p><strong>数据库的监视键字典</strong></p><p>每个 Redis 数据库都有一个 <code>watched_keys</code> 字典，这个字典的<code>键</code>就是被 <code>WATCH</code> 命令监视的键，而字典的<code>值</code>则是一个链表，该链表中记录了监视当前键的客户端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>watched_keys 字典数据举例如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> # before :</span><br><span class="line"> &#123;</span><br><span class="line">   'key1' : [c1, c2]</span><br><span class="line"> &#125;</span><br><span class="line"> # after c3 WATCH key1 and key2:</span><br><span class="line">&#123;</span><br><span class="line">   'key1' : [c1, c2, c3],</span><br><span class="line">   'key2' : [c3]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="监视键"><a href="#监视键" class="headerlink" title="监视键"></a>监视键</h3><p><strong>监视键命令操作如下：</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; WATCH name</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>客户端监视给定键的逻辑如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Watch for the specified key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 客户端监视给定的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchForKey</span><span class="params">(client *c, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    watchedKey *wk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are already watching for this key */</span></span><br><span class="line">    <span class="comment">// 1 检查 key 是否已经保存在 watched_keys 链表中，如果已经存在，则直接返回</span></span><br><span class="line">    listRewind(c-&gt;watched_keys, &amp;li);</span><br><span class="line">    <span class="keyword">while</span> ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        wk = listNodeValue(ln);</span><br><span class="line">        <span class="keyword">if</span> (wk-&gt;db == c-&gt;db &amp;&amp; equalStringObjects(key, wk-&gt;key))</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* Key already watched */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This key is not already watched in this DB. Let's add it */</span></span><br><span class="line">    <span class="comment">// 2 检查 key 是否存在于数据库的 watched_keys 字典中</span></span><br><span class="line">    clients = dictFetchValue(c-&gt;db-&gt;watched_keys, key);</span><br><span class="line">    <span class="comment">// 2.1 如果不存在则，添加它</span></span><br><span class="line">    <span class="keyword">if</span> (!clients) &#123;</span><br><span class="line">        <span class="comment">// 值是一个链表</span></span><br><span class="line">        clients = listCreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关联键值对到字典</span></span><br><span class="line">        dictAdd(c-&gt;db-&gt;watched_keys, key, clients);</span><br><span class="line">        incrRefCount(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将客户端添加到链表的末尾</span></span><br><span class="line">    listAddNodeTail(clients, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add the new key to the list of keys watched by this client */</span></span><br><span class="line">    <span class="comment">// 3 构建 watchedKey 结构并添加到客户端的 watched_key 链表的末尾</span></span><br><span class="line">    wk = zmalloc(<span class="keyword">sizeof</span>(*wk));</span><br><span class="line">    wk-&gt;key = key;</span><br><span class="line">    wk-&gt;db = c-&gt;db;</span><br><span class="line">    incrRefCount(key);</span><br><span class="line">    listAddNodeTail(c-&gt;watched_keys, wk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上方法是监视给定的键，本质上就是将指定的键关联上当前客户端，然后分别添加到客户端的监视键链表中和数据库监视字典中。关于取消监视的键逻辑就不再介绍。</p><h3 id="监视机制的触发"><a href="#监视机制的触发" class="headerlink" title="监视机制的触发"></a>监视机制的触发</h3><p>所有对数据库进行写操作的命令，在执行后都会尝试触发监视机制，试图将正在监视当前键的客户端的状态设置为 <code>CLIENT_DIRTY_CAS</code>，表示该客户端的事务安全性已经被破坏了(客户端开启事务的前提下，没开启则没影响)。监视机制的触发逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "Touch" a key, so that if this key is being WATCHed by some client the</span></span><br><span class="line"><span class="comment"> * next EXEC will fail.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * "触碰" key，如果该 key 正在被某个/某些客户端监视着，那么这个/这些客户端在执行 EXEC 时，事件将失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touchWatchedKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 当前数据库的 watched_leys 字典为空，没有任何键被监视</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 从监视键字典中获取所有监视这个键的客户端</span></span><br><span class="line">    clients = dictFetchValue(db-&gt;watched_keys, key);</span><br><span class="line">    <span class="keyword">if</span> (!clients) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark all the clients watching this key as CLIENT_DIRTY_CAS */</span></span><br><span class="line">    <span class="comment">/* Check if we are already watching for this key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3 遍历所有客户端，打开它们的 CLIENT_DIRTY_CAS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    listRewind(clients, &amp;li);</span><br><span class="line">    <span class="keyword">while</span> ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将客户端的状态设置为 CLIENT_DIRTY_CAS，表示该客户端的事务安全性已经被破坏</span></span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_CAS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当服务器执行客户端的 <strong>EXEC</strong> 命令时，服务器会校验客户端的状态来决定是否执行事务。如果客户端的状态是 <code>CLIENT_DIRTY_EXEC</code> 或者 <code>CLIENT_DIRTY_CAS</code> 时，服务器会拒绝执行客户端提交的事务。</p><p>至此，Redis 的事务原理已经全部介绍完毕了。下面我们从事务的 ACID 特性角度对 Redis 的事务进行说明。</p><h1 id="事务的-ACID-性质"><a href="#事务的-ACID-性质" class="headerlink" title="事务的 ACID 性质"></a>事务的 ACID 性质</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>对于 Redis 的事务功能来说，事务队列中的命令要么全部执行，要么一个都不执行。Redis 事务的原子性需要分以下三种情况来考虑。</p><p><strong>命令入队时出错</strong></p><p>在执行 EXEC 命令前，客户端发送的操作命令本身就有错误，比如语法错误或者使用了不存的命令，在命令入队过程就被 Redis 实例检测出来了，进而导致事务失败。</p><p>命令操作如下：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行一个 Redis 不支持的命令，返回报错信息</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; SETT num 1</span><br><span class="line">(error) ERR unknown command `SETT`, with args beginning with: `num`, `1`, </span><br><span class="line">(51.33s)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 继续执行命令</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; SET num 1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交事务，但由于存在命令入队失败的情况，因此 Redis 拒绝执行事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure><p>对于这种情况，Redis 实例检测出错误后会记录错误信息并调用 <strong>flagTransaction</strong> 函数将客户端的状态设置为 <code>CLIENT_DIRTY_EXEC</code>，然后执行入队逻辑时，命令入队就会失败。此时，虽然还能继续提交命令操作，但是等到执行 <strong>EXEC</strong> 命令时，Redis 服务器就会拒绝执行提交的事务，返回事务失败的结果，因为此时客户端的状态为 <code>CLIENT_DIRTY_EXEC</code>。关于命令入队和事务执行逻辑，上文已经详细说明。</p><p><strong>结论：</strong>命令入队时出现错误，会放弃事务的执行，能够保证原子性。</p><p><strong>命令执行时出错</strong></p><p>客户端发送的操作命令和操作的数据类型不匹配，在命令入队过程 Redis 实例无法检测出错误。但是在执行 <strong>EXEC</strong> 命令时，当 Redis 从事务队列中取出异常操作命令并执行时就会报错。需要注意的是，虽然 Redis 会对异常操作命令报错，但还是会继续将事务队列中的命令执行完。在这种情况下，事务的原子性就无法得到保证了，根本原因在于 Redis 并没有提供回滚机制。</p><p>命令操作如下：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开始事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行 SADD 命令</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; SADD st gentryhuang</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行 GET 命令，GET 命令操作的数据类型不匹配，此时不会影响入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; GET st</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交事务，事务中的第二个命令会报错</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong>命令入队时没有出错，实际执行时报错，不能保证原子性。</p><p><strong>实例故障</strong></p><p>在执行 <strong>EXEC</strong> 命令时，Redis 实例发生了故障，导致事务执行失败。由于 Redis 的持久化机制，实例重启后会加载 AOF 日志文件或 RDB 快照，如果只有部分的事务操作被记录，那么就无法保证原子性。但是事实是，RDB 快照不会在事务执行时执行，所以事务命令操作的结果不会被保存到 RDB 快照中。即使开启了 AOF 日志，我们可以使用 <strong>redis-check-aof</strong> 工具检查 AOF 日志文件，这个工具可以把未完成的事务操作从 AOF 文件中去除。这样一来，不管 AOF 日志文件中是否保存完整的事务操作，还是根本就没有保存事务操作，AOF 文件不再是导致原子性问题的因素。</p><p><strong>结论：</strong>实例故障可以保证原子性。</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>事务的一致性指的是数据符合数据库本身的定义和要求，事务执行过程不会产生非法或者无效的错误数据。Redis 通过语法错误检查机制和简单的设计来保证事务的一致性。Redis 事务的一致性依然需要分以下三种情况来考虑。</p><p><strong>命令入队时出错</strong></p><p>命令入队时出错，事务本身就会被放弃，所以可以保证事务的一致性。</p><p><strong>命令执行时出错</strong></p><p>在事务执行的过程中，出错的命令会被服务器识别出来，并进行相应的错误处理，这些出错的命令不会对数据库做任何改动。也就不会对事务的一致性产生任何影响。如果硬从无效的错误数据角度来看，这种情况是破坏了事务的一致性，毕竟出错的命令虽然没有执行，但没有达到预期的目的。</p><p><strong>实例故障</strong></p><p>Redis 实例发生了故障，无论 Redis 使用哪种持久化模式，都不会影响数据库的一致性。这种情况和前文介绍的实例故障是否影响原子性的因素是一致的。</p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。</p><p>由于 Redis 使用单线程的方式来执行事务，并且在执行事务期间不会对事务进行中断，也就是说 Redis 的事务总是以串行的方式运行的，事务具有隔离性。</p><p>需要特别说明的是，一个客户端在开启事务之前可以利用 <strong>WATCH</strong> 机制来监视要操作的键，通过这种方式可以自定义隔离规则，规定如果在事务执行时发现要操作的键发生了改变(也就是被其它客户端修改了)，那么就认为破坏了事务的隔离性，就需要放弃事务的执行。</p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>事务的持久性指的是，当一个事务执行完毕时，执行这个事务的结果会永久性存储起来，即使服务器在事务执行完毕后宕机了，执行事务所得到的结果也不会丢失。</p><p>Redis 并没有为事务提供任何额外的持久化功能，Redis 事务的持久性由 Redis 的持久化配置模式决定。由事务的持久性特点不难看出，Redis 要实现事务的持久性必须满足以下条件：</p><ul><li>使用 AOF 模式，并且刷盘机制 <strong>appendfsync</strong> 必须设置为 <strong>always</strong>，这样数据才能尽量不丢失。</li><li>Redis 为了提高性能尽可能不阻塞主线程，允许打开 <strong>no-appendfsync-on-rewrite</strong> 配置项（默认是关闭的），控制在执行快照或重写 AOF 日志文件时停止对 AOF 文件进行刷盘。那么这种情况下即使 Redis 实例运行在 <strong>always</strong> 模式的 AOF 持久化之下，事务也不具有持久性。因此，要保证事务的持久性就不能打开 <strong>no-appendfsync-on-rewrite</strong> 配置项.</li></ul><p>注意，Redis 本身是内存数据库，持久性并不是一个必须的属性，具体可以根据使用场景进行取舍。</p><h2 id="回滚实现"><a href="#回滚实现" class="headerlink" title="回滚实现"></a>回滚实现</h2><p>Redis 的事务和传统的关系型数据库事务最大的区别在于，Redis 不支持事务回滚机制，即使事务队列中的某个命令在执行时出错，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。需要说明的是 Redis 提供的 <code>DISCARD</code> 命令，并没有回滚事务的能力，它只是用来放弃事务，把事务队列清空并重置客户端的事务状态。只要开启一个事务，就能通过 <code>DISCARD</code> 命令放弃事务。<code>DISCARD</code> 命令具体使用如下：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; SADD num </span><br><span class="line">(error) ERR wrong number of arguments for 'sadd' command</span><br><span class="line">(5.99s)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 放弃事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; discard</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><strong>Redis 不支持事务回滚的原因有两点：</strong>其一，较为复杂的事务回滚功能和 Redis 追求简单高效的设计主旨不相符；其二，Redis 事务执行时的错误通常都是编程错误产生的，需要使用方去避免。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Redis 的事务进行了详细介绍，并结合源码层面对整个事务的执行流程进行了梳理。可以对比 MySQL 的事务机制，对比学习 Redis 的事务机制，两者使用的场景不同，对应的实现机制也有很大差别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Redis 通过 &lt;strong&gt;MULTI&lt;/strong&gt;、&lt;strong&gt;EXEC&lt;/strong&gt;、&lt;strong&gt;DISCARD&lt;
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL - 事务与隔离级别</title>
    <link href="https://gentryhuang.com/posts/d80e61c2/"/>
    <id>https://gentryhuang.com/posts/d80e61c2/</id>
    <published>2021-05-21T10:49:59.000Z</published>
    <updated>2021-07-01T02:32:51.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章将以<strong>事务</strong>为主线，分别介绍事务的基本特性、事务并发问题、封锁协议、隔离级别及基本实现，最后简单介绍下 MySQL 对标准的隔离级别规范的实现。</p><h1 id="事务基本特性"><a href="#事务基本特性" class="headerlink" title="事务基本特性"></a>事务基本特性</h1><ul><li><strong>原子性(Atomicity)</strong><blockquote><p>要么全部完成，要么全部不完成。</p></blockquote></li><li><strong>一致性(Consistency)</strong><blockquote><p>一个事务单元需要提交之后才会被其它事务可见。</p></blockquote></li><li><strong>隔离性(Isolation)</strong><blockquote><p>并发事务之间不会相互影响。</p></blockquote></li><li><strong>持久性(Durability)</strong><blockquote><p>事务提交后即持久化到存储设备上。</p></blockquote></li></ul><p>注意，隔离性和一致性是有冲突的，有时候为了提高性能，会适度的破坏一致性，而这个权衡的结果会造成事务并发问题。</p><h1 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h1><ul><li><p><strong>丢失修改</strong></p><blockquote><p>回滚覆盖：回滚一个事务时，在该事务内的写操作要回滚，把其它已提交的事务写入的数据覆盖了。<br>提交覆盖：提交一个事务时，把其它已提交的事务写入的数据覆盖了。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-transaction-concurrent-problem-1.jpg" alt><br>上图描述的是回滚覆盖问题。</p></blockquote></li><li><p><strong>脏读</strong></p><blockquote><p>一个事务读取到另一个未提交事务修改过的数据。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-transaction-concurrent-problem-2.jpg" alt></p></blockquote></li><li><p><strong>不可重复读</strong></p><blockquote><p>一个事务中先后根据相同条件读取到的数据不一致。强调更新和删除操作。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-transaction-concurrent-problem-3.jpg" alt></p></blockquote></li><li><p><strong>幻读</strong></p><blockquote><p>一个事务中先后根据相同条件读取的数据记录数不一致。强调新增操作。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-transaction-concurrent-problem-4.jpg" alt></p></blockquote></li></ul><h1 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h1><h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><p>为了解决并发问题，数据库系统引入了锁锁机制。在事务T对某个数据对象操作之前，先向系统发出请求对其加锁。基本的封锁类型有两种，<strong>排它锁(Exclusive locks 简记为X锁)</strong> 和 <strong>共享锁(Share locks 简记为S锁)</strong>，其中前者又称写锁，后者又称读锁。</p><ul><li>排它锁（X锁）：若事务T对数据对象A加上X锁，其它任何事务都不能在对A加任何类型的锁，直到事务T释放A上的锁为止。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。</li><li>共享锁（S锁）：若事务T对数据对象A加上S锁，其它事务只能再对A加S锁而不能加X锁，直到事务T释放A上的S锁为止。</li></ul><h2 id="封锁协议-1"><a href="#封锁协议-1" class="headerlink" title="封锁协议"></a>封锁协议</h2><p>在运用X锁和S锁对数据对象加锁时，还需要约定一些规则，例如何时申请X锁或S锁、持锁时间、何时释放等，称这些加锁规则为封锁协议（Locking Protocol）。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。</p><ul><li><p><strong>一级封锁协议</strong></p><blockquote><p><strong>定义</strong>：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。<br><strong>说明</strong>：一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。使用一级封锁协议可以解决丢失修改问题。在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，它不能保证可重复读和不读“脏”数据。</p></blockquote></li><li><p><strong>二级封锁协议</strong></p><blockquote><p><strong>定义</strong>：一级封锁协议基础上加事务T在读取数据R之前必须先对其加S锁，读完后方可释放S锁。<br><strong>说明</strong>：二级封锁协议除防止了丢失修改，还可以进一步防止读“脏”数据。但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。</p></blockquote></li><li><p><strong>三级封锁协议</strong></p><blockquote><p><strong>定义</strong>：一级封锁协议基础上加事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。<br><strong>说明</strong>：三级封锁协议除防止了丢失修改和不读“脏”数据外，还进一步防止了不可重复读。</p></blockquote></li></ul><p>上述三级协议的主要区别在于什么操作需要申请封锁，以及何时释放。</p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>为了解决事务并发问题，进行并发控制，数据库系统提供了四种事务隔离级别。本质上三级封锁协议反映在实际的数据库系统上，就是四种事务隔离机制。总的来说，四种事务隔离机制就是在逐渐的限制事务的自由度，以满足对不同并发控制程度的要求。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul><li><strong>读未提交(Read Uncommitted)</strong><blockquote><p>可以读取未提交的记录，会出现脏读，幻读，不可重复读，所有并发问题都可能遇到。</p></blockquote></li><li><strong>读已提交(Read Committed)</strong><blockquote><p>只能读取到已经提交的数据。不会出现脏读现象，但是会出现幻读，不可重复读；（大多数数据库的默认隔离级别都是 RC，但是 MySQL InnoDb 默认是 RR）。</p></blockquote></li><li><strong>可重复读(Repeated Read)</strong><blockquote><p>在同一个事务内的查询都是事务开始时刻一致的，MySQL InnoDb 默认的隔离级别，解决了不可重复读问题，但是仍然存在幻读问题。</p></blockquote></li><li><strong>串行化(Serializable)</strong><blockquote><p>所有的增删改查串行执行，啥并发问题都没有。</p></blockquote></li></ul><p>需要明确的是，以上的隔离级别是在SQL规范层面的定义，不同数据库的实现方式和使用方式并不相同，类似于JVM规范和JVM厂商的关系。</p><h2 id="传统的隔离级别实现"><a href="#传统的隔离级别实现" class="headerlink" title="传统的隔离级别实现"></a>传统的隔离级别实现</h2><p>SQL 规范中定义的四种隔离级别，分别是为了解决事务并发时可能遇到的四种问题，至于如何解决，实现方式是什么，规则中并没有严格定义。锁作为最简单最显而易见的实现方式被广为人知，因此我们在讨论某个隔离级别的时候，通常会说这个隔离级别的加锁方式是什么样的。其实，锁只是实现隔离级别的方式之一，除了锁，实现并发问题的方式还有时间戳，多版本控制等等，这些也可以称为无锁的并发控制。</p><p>采用基于锁的并发控制实现，通过对读写操作加不同的锁，以及对释放锁的时机进行不同的控制，就可以实现四种隔离级别。</p><h1 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h1><p>虽然数据库的四种隔离级别通过基于锁的并发控制（Lock-Based Concurrent Control，简写 LBCC） 技术都可以实现，但是它最大的问题是只实现了并发的读读，对于并发的读写还是冲突的，写时不能读，读时不能写，当读写操作都很频繁时，数据库的并发性将大大降低。针对这种场景，MVCC 技术应运而生，全称叫做 Multi-Version Concurrent Control（多版本并发控制），为了兼容落后的规范，数据库引擎厂商都想办法贴近四大隔离级别，但是和标准可能会有差别。</p><p>InnoDB 对事务隔离级别的实现依赖两个重要手段：LBCC、MVCC(多版本并发控制)。MVCC 可以认为是对锁机制的优化，让普通 SELECT 避免加锁，同时保证事务隔离级别的语义。</p><p>InnoDB 默认的事务隔离级别是 RR 隔离级别，它采用通过 <code>MVCC</code> 和 <code>间隙锁</code> 解决了标准的 RR 级别下存在的幻读问题。因为 <code>幻读</code> 的这个<code>读</code>字在 MySQL 里本身就存在歧义，这个<code>读</code>指的是<strong>快照读</strong>还是<strong>当前读</strong>呢？如果是快照读，MySQL 通过版本链来保证同一个事务里每次查询得到的结果集都是一致的；如果是当前读，MySQL 通过<code>间隙锁</code>保证其他事务无法插入新的数据，从而避免幻读问题。当然，如果场景中一会是快照读，一会是当前读，导致幻读现象，那就太为难 MySQL 了。</p><p>InnoDB 对串行化隔离级别是通过 <code>临键锁</code> 实现的，普通 SELECT 语句使用 <code>S临键锁</code>，当前读语句使用 <code>X临键锁</code>，加锁规则和 RR 隔离级别一致。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章主要对事务隔离级别的规范以及传统实现原理进行了介绍，并对 MySQL 的事务隔离级别的实现进行了简单说明。有了对事务整体的深入了解，对于理解 MySQL 中的锁机制、MVCC 原理会有很大的帮助。如果不知道事务隔离级别的基本实现，或者不清楚事务隔离级别和锁的关系，那么对于 MySQL 只能是管中窥豹。关于锁机制、MVCC原理会在后面的文章详细说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章将以&lt;strong&gt;事务&lt;/strong&gt;为主线，分别介绍事务的基本特性、事务并发问题、封锁协议、隔离级别及基本实现，最后简单介绍下
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://gentryhuang.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL - 慢查询日志</title>
    <link href="https://gentryhuang.com/posts/4132ef9f/"/>
    <id>https://gentryhuang.com/posts/4132ef9f/</id>
    <published>2021-05-14T11:17:14.000Z</published>
    <updated>2021-05-25T03:06:04.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MySQL 慢查询日志是排查问题 SQL 语句，以及检查当前 MySQL 性能的一个重要手段。默认情况下，MySQL 并不启动慢查询日志，需要我们手动来开启。如果不是调优需要的话，一般不建议开启慢查询，毕竟开启慢查询或多或少会带来一定的性能影响。</p><h1 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h1><ul><li><strong>slow_query_log:</strong>  是否开启慢查询日志，默认 OFF，开启则设置为 ON。</li><li><strong>slow_query_log_file:</strong>  慢查询日志文件存储位置。</li><li><strong>long_query_time:</strong>  超过多少秒的查询才会记录到日志中。单位是秒。</li><li><strong>log_queries_not_using_indexes:</strong>  是否把没有使用到索引的 SQL 记录到日志中，默认 OFF,开启则设置为 ON。</li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>默认情况下是没有开启慢查询日志，下面通过两种配置方式进行设置。</p><h2 id="临时配置"><a href="#临时配置" class="headerlink" title="临时配置"></a>临时配置</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global slow_query_log='ON';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; set global slow_query_log_file='/var/lib/mysql/instance-1-slow.log';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; set global long_query_time=2; # 下次会话才会生效</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="永久配置"><a href="#永久配置" class="headerlink" title="永久配置"></a>永久配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;mysql.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">slow_query_log &#x3D; ON</span><br><span class="line">slow_query_log_file &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;instance-1-slow.log</span><br><span class="line">long_query_time &#x3D; 2</span><br></pre></td></tr></table></figure><p>配置好慢 SQL 相关参数后，重启 MySQL 即可。</p><h1 id="查看慢查询功能"><a href="#查看慢查询功能" class="headerlink" title="查看慢查询功能"></a>查看慢查询功能</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'slow_query%';</span><br><span class="line">+<span class="comment">---------------------+----------------------------------+</span></span><br><span class="line">| Variable_name       | Value                            |</span><br><span class="line">+<span class="comment">---------------------+----------------------------------+</span></span><br><span class="line">| slow_query_log      | ON                               |</span><br><span class="line">| slow_query_log_file | /var/lib/mysql/mysql001-slow.log |</span><br><span class="line">+<span class="comment">---------------------+----------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.05</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'long_query_time';</span><br><span class="line">+<span class="comment">-----------------+----------+</span></span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+<span class="comment">-----------------+----------+</span></span><br><span class="line">| long_query_time | 1.000000 |</span><br><span class="line">+<span class="comment">-----------------+----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'log_queries_not_using_indexes';</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| log_queries_not_using_indexes | OFF   |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h1 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h1><p><strong>mysqldumpslow</strong> 是 MySQL 官方提供的慢查询日志分析工具，使用 <strong>mysqldumpslow</strong> 命令可以非常明确的得到各种我们需要的查询语句。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>慢查询日志是排查SQL问题以及优化的重要手段，在生产环境中一般都会实时采集慢查询日志，对 MySQL 查询语句监控、分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;MySQL 慢查询日志是排查问题 SQL 语句，以及检查当前 MySQL 性能的一个重要手段。默认情况下，MySQL 并不启动慢查询日志，需
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://gentryhuang.com/categories/MySQL/"/>
    
    
      <category term="慢查询日志" scheme="https://gentryhuang.com/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>缓存一致性问题</title>
    <link href="https://gentryhuang.com/posts/fa9a5340/"/>
    <id>https://gentryhuang.com/posts/fa9a5340/</id>
    <published>2021-05-04T04:44:15.000Z</published>
    <updated>2021-06-24T09:59:07.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>使用 DB + Cache 的架构时，会带来缓存和数据库一致性问题。理论上来说，给缓存设置过期时间是保证最终一致性的解决方案。基于此，所有的写操作以 DB 为准，对 Cache 操作尽最大努力即可，也就是说如果 DB 写成功，缓存更新失败，那么只要到达过期时间缓存就会失效，后续的读请求获取的自然就是最新的数据并回填 Cache。</p><p>对于缓存和数据库一致性问题有很多的解决方案，没有最完美的方案，只有适合业务场景的方案。注意，本文讨论的相关更新策略是不考虑缓存过期时间问题。</p><h1 id="Cache-操作方式"><a href="#Cache-操作方式" class="headerlink" title="Cache 操作方式"></a>Cache 操作方式</h1><p>当数据 data 发生改变时，对 Cache 的操作有两种方式：<strong>更新 Cache 中的数据</strong>和<strong>淘汰 Cache 中的数据</strong> 。</p><p><strong>更新 Cache</strong></p><blockquote><p>更新 Cache 是指数据 data 不仅会写入 DB，还会写入 Cache 。更新 Cache 的优点：缓存不会增加一次 miss，命中率高。</p></blockquote><p><strong>淘汰 Cache</strong></p><blockquote><p>淘汰 Cache 是指数据 data 只会写入 DB，不会写入 Cache，并且把 Cache 清除。</p></blockquote><p>使用<strong>更新 Cache</strong> 还是<strong>淘汰 Cache</strong> 取决于设置 Cache 的复杂度。Cache 可能是单一的值，也可能是通过复杂的计算得到的值，前者适合使用更新 Cache，后者适合使用淘汰 Cache。但从总体上考虑，淘汰 Cache 操作简单，并且带来的副作用只是增加了一次 Cache miss，因此推荐使用淘汰 Cache 的处理方式。</p><h1 id="Cache-和-DB-操作序列"><a href="#Cache-和-DB-操作序列" class="headerlink" title="Cache 和 DB 操作序列"></a>Cache 和 DB 操作序列</h1><p>当数据 data 发生改变时，除了需要对 Cache 的操作进行选择（推荐使用淘汰 Cache），还需要对 Cache 和 DB 的操作序列进行选择：</p><ul><li>先更新 DB，后淘汰 Cache</li><li>先淘汰 Cache，后更新 DB</li></ul><p>对于不能保证事务性的操作，选择标准是：<strong>当出现不一致，哪个操作影响较小，就选择该操作先执行</strong>。由于更新 DB 和淘汰 Cache 不能保证原子性，因此需要判断哪一个先执行影响更小。</p><p><strong>先更新 DB，后淘汰 Cache</strong></p><blockquote><p>操作 DB 失败没有影响，重试即可。一旦更新 DB 成功，淘汰 Cache 失败，则会出现 DB 中是新数据，Cache 中是旧数据，导致<strong>数据不一致</strong>。</p></blockquote><p><strong>先淘汰 Cache，后更新 DB</strong></p><blockquote><p>淘汰 Cache 失败没有影响，重试即可。一旦淘汰 Cache 成功，更新 DB 失败，<strong>只会引发一次 Cache miss</strong>。</p></blockquote><p>结论：<strong>先淘汰 Cache，再更新 DB</strong> 。</p><p><strong>特别说明：</strong>这里给出的先淘汰 Cache ，再更新 DB 是针对没有额外处理手段的情况下，这种操作序列即使出现问题影响是最小的。如果使用类似重试机制保证操作序列的完整性，那么这两种序列就没有多大差异了，下文会着重分析。</p><h1 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h1><p><strong>淘汰 Cache</strong> 是一种推荐的处理方式，<strong>先淘汰 Cache 后更新 DB</strong> 的时序产生问题相对更小。下面我们对常见方案进行分析：</p><ul><li><strong>先更新 DB，再更新 Cache</strong></li><li><strong>先淘汰 Cache，再更新 DB</strong></li><li><strong>先更新 DB，再淘汰 Cache</strong></li></ul><p>需要说明的是，先更新 Cache，再更新 DB 的策略问题较大，一旦出现不一致就存在超前的脏数据，这样的不一致是要不得的。根据上文我们分析的，先更新 DB，再更新 Cache 也是不推荐的。</p><h2 id="先更新-DB-后更新-Cache"><a href="#先更新-DB-后更新-Cache" class="headerlink" title="先更新 DB 后更新 Cache"></a>先更新 DB 后更新 Cache</h2><p>该策略也是不推荐使用的，主要原因如下：</p><ol><li>并发更新导致缓存更新顺序问题<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-1.jpg" alt><br>如上图，线程 A、B 同时进行更新操作，那么会出现：<blockquote><ol><li>线程 A 更新了 DB</li><li>线程 B 更新了 DB</li><li>线程 B 更新了 Cache</li><li>线程 A 更新了 Cache</li></ol></blockquote></li></ol><p>线程 A 先进行了 DB 更新操作，理论上也应该是线程 A 先更新 Cache，但因为线程 A 处理的较慢，缓存最后是线程 A 更新后的值。这就导致了脏数据。可以使用串行化解决，但是会导致效率变低。<br>2. 更新 DB 成功，但更新 Cache 失败时会导致 Cache 中的脏数据。</p><p>这里为了完整性，把该策略列举出来，了解即可。我们重点关注另外两种方式。</p><h2 id="先淘汰-Cache-后更新-DB"><a href="#先淘汰-Cache-后更新-DB" class="headerlink" title="先淘汰 Cache 后更新 DB"></a>先淘汰 Cache 后更新 DB</h2><p>针对以上更新 Cache 出现的问题，有人就提出淘汰 Cache 的策略。先淘汰 Cache ，如果成功，则更新 DB；如果失败则不更新 DB，后续可以通过重试来解决失败的问题，但是增加了一次 Cache 的 miss。该策略导致不一致的原因不在于后更新 DB 失败了，而是汰 Cache 成功，但更新 DB 完成前存在读请求将旧数据设置到 Cache 中造成脏数据（并发问题），具体场景如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-2.jpg" alt><br>如上图，同时有一个线程 A 进行更新操作，另一个线程 B 进行查询操作，那么就会出现：</p><blockquote><ol><li>线程 A 淘汰 Cache</li><li>线程 B 没有命中 Cache</li><li>线程 B 查询 DB</li><li>线程 B 将查询结果写入 Cache ，对<strong>后续读</strong>就是脏数据</li><li>线程 A 更新 DB</li></ol></blockquote><p>上述情况会导致不一致的问题，而且，如果不采用给 Cache 设置过期时间策略，该脏数据会一直保留到下次更新操作。</p><p>针对以上问题可以采用 <strong>延时双删策略</strong> 将 Cache 脏数据删除，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 数据 key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data 数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String key, Object data)</span> </span>&#123;</span><br><span class="line">    cache.delKey(key);<span class="comment">// 1 淘汰 Cache</span></span><br><span class="line">    db.updateData(data); <span class="comment">// 2 更新 DB</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 3 延时 delay</span></span><br><span class="line">    cache.delKey(key);<span class="comment">// 4 再次淘汰 Cache</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在更新 DB 完成后，评估一定的延时时间再次淘汰 Cache 。这里的延时时间不好确定，一般需要评估项目读数据业务逻辑的耗时，在此基础上加一定的毫秒值即可。值得一说的是，延时一定的时间才会再次淘汰 Cache 是为了确保读请求结束，写请求可以删除读请求造成的缓存脏数据。这里也可以看出，并不是更新 DB 后立刻再次淘汰 Cache ，因为可能有线程读取到了更新前的旧数据还没来得及写入缓存，因此需要等待它写入缓存。</p><p>如果 DB 采用读写分离架构，可能产生以下问题：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-3.jpg" alt><br>如上图，过程如下：</p><blockquote><ol><li>线程 A 淘汰 Cache</li><li>线程 A 更新 DB</li><li>线程 B 没有命中缓存</li><li>线程 B 查询从库 DB，此时并没有完成主从同步，因此查询的是旧值</li><li>线程 B 将旧值放入 Cache</li><li>主从同步完成</li></ol></blockquote><p>上述解决方案还是使用 <strong>延时双删策略</strong>，只需要延时时间确保完成主从同步，即主从同步完成再删一次 Cache 即可。</p><p><strong>存在问题</strong></p><p>第二次淘汰 Cache 是为了防止 Cache 中的脏数据（旧的数据）而做的操作，而非业务要求。因此，<strong>延时双删策略</strong>虽然在<strong>一定程度上</strong>能保证 Cache 中不会有脏数据，但对业务是有损的，具体表现为：</p><ul><li>吞吐量降低<blockquote><p>问题描述：因为要实现延时淘汰 Cache，写的请求需要休眠等待一段时间。<br>解决方案：将第二次淘汰 Cache 以异步处理，这样写请求完成后就能立即返回，提高吞吐量。</p></blockquote></li><li>第二次淘汰 Cache 失败<blockquote><p>问题描述：写请求完成了 DB 更新，再次淘汰 Cache 失败了，导致 Cache 和 DB 一致性问题<br>解决方案：理论上可以依赖 Cache 的失效时间，但是可能不及时，因此最好采用重试机制，具体实现下文详细分析。</p></blockquote></li></ul><p>此外，<strong>延时双删策略</strong>只能在<strong>一定程度上</strong>能保证 Cache 中不会有脏数据，具体哪种程度要看<strong>延时时间</strong>的准确性。</p><h2 id="先更新-DB-后淘汰-Cache"><a href="#先更新-DB-后淘汰-Cache" class="headerlink" title="先更新 DB 后淘汰 Cache"></a>先更新 DB 后淘汰 Cache</h2><p>基于同样套路，我们先分别从并发和操作完整性出发，分析该策略存在的问题。</p><p><strong>并发问题</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-4-fix.jpg" alt><br>如上图，线程 A 执行查询，线程 B 执行更新，那么会有如下情况：</p><blockquote><ol><li>线程 A 没有命中 Cache</li><li>线程 A 查询 DB</li><li>线程 B 更新 DB</li><li>线程 B 淘汰 Cache</li><li>线程 A 将查询到的旧值放入 Cache</li></ol></blockquote><p>由于 DB 读操作速度远快于写操作，因此这样的并发问题（放入值到缓存还没有一次磁盘IO快）导致的脏数据概率非常非常低。如果非要解决，依然可以采用<strong>延时双删策略</strong>，即保证读请求完成后再一次淘汰 Cache。</p><p><strong>淘汰 Cache 时延问题</strong><br>在更新 DB 后还没来得及淘汰 Cache，其它请求就开始读取数据了，那么此时由于能命中缓存，就会直接从缓存中取旧数据，因此会有不一致数据短暂存在。不过，在这种情况下如果并发读缓存的请求不多，对业务影响还是小的，毕竟缓存很快就会被淘汰，后续请求就不会读取到旧的值了。再严格就需要使用分布式事务了。</p><h3 id="淘汰-Cache-失败"><a href="#淘汰-Cache-失败" class="headerlink" title="淘汰 Cache 失败"></a>淘汰 Cache 失败</h3><p>淘汰 Cache 失败也是<strong>延时双删策略</strong>中存在的问题，也同样会产生脏数据问题，<strong>根本策略就是重试，保证淘汰 Cache 成功</strong>。</p><p><strong>如果对一致性要求不是很高，可以使用以下两种方案：</strong></p><blockquote><ol><li>等待 Cache 过期失效</li><li>直接在程序中另起一个线程，定时重试</li></ol></blockquote><p>如果对一致性要求相对较高，就需要采用其它手段来保证及时淘汰掉 Cache 。下面就先更新 DB 后淘汰 Cache 给出两个具体方案，其中淘汰 Cache 的流程是通用的。</p><h3 id="消息队列重试"><a href="#消息队列重试" class="headerlink" title="消息队列重试"></a>消息队列重试</h3><p>通过消息 MQ 来实现重试，即将淘汰 Cache 失败的数据 key 发送到 MQ 中，然后消费MQ，执行淘汰 Cache 操作，直到淘汰成功。流程图如下：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-5.jpg" alt></p><p><strong>上图流程描述如下：</strong></p><blockquote><ol><li>更新 DB</li><li>淘汰 Cache 失败</li><li>将数据 key 发送到消息队列</li><li>消费消息，获得数据 key</li><li>继续重试淘汰 Cache 操作，直到成功</li></ol></blockquote><p>使用该方案有一个缺点，会对业务代码造成一定侵入，因为业务方需要关心将数据 key 写入到 MQ 中。采用订阅 binlog 的方式就可以做到对业务代码无侵入，下面我们就来看这种方式。</p><h3 id="订阅-binlog-重试"><a href="#订阅-binlog-重试" class="headerlink" title="订阅 binlog 重试"></a>订阅 binlog 重试</h3><p>启动一个订阅程序去订阅 DB 的 binlog，获取 binlog 中的数据的key，然后执行淘汰 Cache 操作，如果失败，则发送数据 key 到 MQ，后续同方案一。流程图如下：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-6.jpg" alt></p><p><strong>上图流程描述如下：</strong></p><blockquote><ol><li>更新 DB</li><li>DB 将操作信息写入 binlog 日志中</li><li>binlog 订阅程序提取出所需的数据 key</li><li>非业务代码获取数据 key</li><li>尝试根据数据 key 淘汰 Cache</li><li>如果淘汰 Cache 失败，则将数据 key 发送到消息队列</li><li>重新从消息队列中获得数据 key</li><li>继续重试淘汰 Cache，直到成功</li></ol></blockquote><p>其中订阅程序在 Mysql 中有 Canal 中间件，可以直接使用它完成订阅 binlog 日志的功能。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>本文介绍的缓存一致性解决方案都不能保证操作的原子性。如果需要严格保证缓存和数据库的一致性，也就是保证两者操作的原子性，就需要用到分布式事务来解决。常见的解决方案：两阶段提交（2PC）、三阶段提交（3PC）、TCC、消息队列等，这些方案相对比较复杂，一般用在对于一致性要求较高的业务场景中。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章着重点在于，DB 更新完成后，Cache 淘汰失败了，基于这种情况可以根据业务的特点选择对应的方式进行处理。如果对一致性要求不是很高，那么在淘汰 Cache 失败后可以选择等待缓存失效和异步定时重试；如果对一致性要求相对较高，那么可以使用消息队列和订阅 binlog 的方式重试淘汰 Cache 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;使用 DB + Cache 的架构时，会带来缓存和数据库一致性问题。理论上来说，给缓存设置过期时间是保证最终一致性的解决方案。基于此，所有的
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://gentryhuang.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="缓存" scheme="https://gentryhuang.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 健康检测</title>
    <link href="https://gentryhuang.com/posts/4760cec/"/>
    <id>https://gentryhuang.com/posts/4760cec/</id>
    <published>2021-05-01T10:56:21.000Z</published>
    <updated>2021-05-08T08:48:14.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 心跳检测是为了保证连接的可用性，在需要的时候及时采取重连、断开等措施。需要说明的是，Dubbo 心跳检测是针对 TCP 层面的协议（如：Dubbo 协议），HTTP 层面的协议是无需进行连接管理的。心跳检测需要容错，一次心跳失败不能认定连接不通，多次心跳失败才能采取相应措施。此外，心跳检测不应该忙检测，如果一条通道上有频繁的 RPC 调用，会给系统带来额外的负担。</p><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><h2 id="长短连接"><a href="#长短连接" class="headerlink" title="长短连接"></a>长短连接</h2><p>TCP 本身并没有长短连接之分，长短连接与否取决于对它的使用。</p><ul><li><strong>短连接：</strong> 每次通信时创建一个连接，一次通信结束关闭连接即可。短连接的好处是管理简单，存在的连接都是可用的连接，不需要额外的控制手段。</li><li><strong>长连接：</strong> 每次通信完毕后，不会立即关闭连接，这样可以做到连接的复用。长连接的好处是省去了创建连接的开销。</li></ul><p>长短连接各自的优势，分别是对方的劣势。对于不追求高性能，使用短连接合适，省去了连接状态管理的工作。追求性能最好使用长连接，但是需要额外工作，如端点之间连接的维护和保活。</p><h2 id="Dubbo-中的长连接"><a href="#Dubbo-中的长连接" class="headerlink" title="Dubbo 中的长连接"></a>Dubbo 中的长连接</h2><p>Dubbo 协议是基于 TCP 进行网络传输的，它采用的就是长连接。下面分别启动服务提供者应用和服务消费者应用，提供者负责监听本地 <code>20880</code> 端口（Dubbo 默认端口），服务消费者负责发起请求。</p><ul><li>服务提供方启动完成<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-heartbeat-provider-listen.jpg" alt><br>从上图可知，Dubbo 正在监听本地的 <code>20880</code> 端口，处理发送到本地 <code>20880</code> 端口的请求。</li><li>服务消费方发起请求<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-heartbeat-consumer-invoke-provider.jpg" alt><br>从上图可以验证，TCP 是一个双向的通信过程。</li></ul><h2 id="连接的保活"><a href="#连接的保活" class="headerlink" title="连接的保活"></a>连接的保活</h2><p>当端点间建立长连接后，由于网络问题，建立的连接可能不可用，这时就需要保证连接的可用。保证连接的可用常用的手段就是连接保活。</p><h3 id="TCP-KeepAlive"><a href="#TCP-KeepAlive" class="headerlink" title="TCP KeepAlive"></a>TCP KeepAlive</h3><p>TCP KeepAlive 是面向网络的，并不是面向应用的。<strong>连接不可用并不一定是网络问题，可能是由于应用本身的负载过高、GC频繁等导致的，此时应用失去了活性，连接也不可用</strong>。</p><h3 id="应用层心跳"><a href="#应用层心跳" class="headerlink" title="应用层心跳"></a>应用层心跳</h3><p>网络层面的 KeepAlive 不足以支撑应用层面的连接可用性，这种情况下应该使用应用层的心跳机制来实现连接保活，这也是业内常用的检测方法。</p><h1 id="Dubbo-心跳检测"><a href="#Dubbo-心跳检测" class="headerlink" title="Dubbo 心跳检测"></a>Dubbo 心跳检测</h1><p>介绍完健康检测相关基础后，下面我们详细介绍 Dubbo 是如何设计应用层心跳的。注意，以下讨论的 Dubbo 版本是 2.7.7 。</p><p>Dubbo 在改进心跳方案之前是双向心跳设计，客户端会给服务端发送心跳，反之，服务端也会向客户端心跳。关于双向心跳设计可以参见<a href="https://gentryhuang.com/posts/26722deb/#%E4%BB%BB%E5%8A%A1%E9%80%BB%E8%BE%91">心跳任务</a>，这里介绍的是 Dubbo 2.6.x 版本，任务执行没有使用时间轮，依然使用 schedule 方案。</p><p>Dubbo 心跳机制改进后，主要分为两类。其一，对于底层使用 Netty 通信的连接检测交给 Netty 本身而非 Dubbo 心跳检测逻辑，即完全使用 <code>IdleStateHandler</code> 来检测连接空闲状态。其二，对于其它 NIO 通信组件，Dubbo 优化了之前的双向心跳设计，改为了客户端在连接空闲时发送单向心跳，服务端定时检测连接可用性。下面我们就结合 Dubbo 心跳检测改进后的版本进行说明。</p><h2 id="IdleStateHandler"><a href="#IdleStateHandler" class="headerlink" title="IdleStateHandler"></a>IdleStateHandler</h2><p>Netty 对空闲连接的检测提供了天然的支持，使用 <code>IdleStateHandler</code> 可以很方便的实现空闲检测逻辑。其内部使用了 <code>EventLoop.schedule(task)</code> 来实现定时任务，使用该线程可以保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>, readerIdleTime, writerIdleTime, allIdleTime, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readerIdleTime：</strong> 读超时时间</li><li><strong>writerIdleTime：</strong> 写超时时间</li><li><strong>allIdleTime：</strong> 所有类型的超时时间</li></ul><p>IdleStateHandler 会根据设置的超时参数，循环检测通道 Channel 的读写多久没有调用。当在 Netty 的 Pipeline 中加入 <code>IdleStateHandler</code> 后，可以在此 Pipeline 的任意 Handler 的 <code>userEventTriggered</code> 方法之中检测 <code>IdleStateEvent</code> 空闲事件。</p><h2 id="IdleSensible"><a href="#IdleSensible" class="headerlink" title="IdleSensible"></a>IdleSensible</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleSensible</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否具有处理空闲连接的能力</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">canHandleIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo 新增该接口，以区分 Netty 和其它通信组件对空闲连接的处理能力。<code>NettyServer</code> 和 <code>NettyClient</code> 作为 Netty 通信组件的封装类实现了该接口，重写了接口中的方法，返回值为 <code>true</code>，表示具有处理空闲连接的能力。也就是说，如果使用 Netty 作为通信组件，那么监控空闲连接就交给 Netty 底层自己处理。而其它通信组件暂不支持，因此仍然需要 Dubbo 框架的心跳设计方案。</p><h2 id="网络传输层"><a href="#网络传输层" class="headerlink" title="网络传输层"></a>网络传输层</h2><p>下面我们先从 Dubbo 的网络传输层分析心跳检测的实现，需要说明的是网络传输层主要针对的是 Netty 组件，其它 NIO 组件几乎没有在网络传输层实现心跳逻辑（这里不包括统一处理心跳交互的 HeartbeatHandler）。</p><h3 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyServer</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Init and start netty server</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        bossGroup = NettyEventLoopFactory.eventLoopGroup(<span class="number">1</span>, <span class="string">"NettyServerBoss"</span>);</span><br><span class="line">        workerGroup = NettyEventLoopFactory.eventLoopGroup(getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS), <span class="string">"NettyServerWorker"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> NettyServerHandler nettyServerHandler = <span class="keyword">new</span> NettyServerHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">        channels = nettyServerHandler.getChannels();</span><br><span class="line">        bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NettyEventLoopFactory.serverSocketChannelClass())</span><br><span class="line">                .option(ChannelOption.SO_REUSEADDR, Boolean.TRUE)</span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)</span><br><span class="line">                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 1 心跳超时时间，是心跳间隔的 3 倍。心跳间隔默认 60s </span></span><br><span class="line">                        <span class="keyword">int</span> idleTimeout = UrlUtils.getIdleTimeout(getUrl());</span><br><span class="line">                        NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">if</span> (getUrl().getParameter(SSL_ENABLED_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">"negotiation"</span>, SslHandlerInitializer.sslServerHandler(getUrl(), nettyServerHandler));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 2 设置 ChannelPipeline 上的 ChannelHandler</span></span><br><span class="line">                        ch.pipeline()</span><br><span class="line">                                <span class="comment">// 2.1 编解码 Handler</span></span><br><span class="line">                                .addLast(<span class="string">"decoder"</span>, adapter.getDecoder())</span><br><span class="line">                                .addLast(<span class="string">"encoder"</span>, adapter.getEncoder())</span><br><span class="line">                                <span class="comment">// 2.2 心跳检测 Handler，注意超时时间针对所有类型</span></span><br><span class="line">                                .addLast(<span class="string">"server-idle-handler"</span>, <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, idleTimeout, MILLISECONDS))</span><br><span class="line">                                <span class="comment">// 2.3 Netty 融合 Dubbo Handler 的 处理器</span></span><br><span class="line">                                .addLast(<span class="string">"handler"</span>, nettyServerHandler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// bind</span></span><br><span class="line">        ChannelFuture channelFuture = bootstrap.bind(getBindAddress());</span><br><span class="line">        channelFuture.syncUninterruptibly();</span><br><span class="line">        channel = channelFuture.channel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 IdleSensible 中的方法，表示自己实现心跳检测</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canHandleIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在初始化和启动 Netty Server 时，会为 Pipeline 设置 <code>IdleStateHandler</code> 处理器，用于检测空闲连接。注意，<code>IdleStateHandler</code> 是 Netty 提供的一个工具型 Handler，用于定时心跳请求的功能以及自动关闭长时间空闲连接。<strong>如果超过设置的阈值（超时时间），则会触发 <code>IdleStateEvent</code> 事件并传递给后续的 ChannelHandler 进行处理，后续的 ChannelHandler 的 <code>userEventTriggered()</code> 方法会根据接收到的 <code>IdleStateEvent</code> 事件，决定是关闭空闲连接还是发送心跳探活</strong>。这里提到的 ChannelHandler 其实就是下文要介绍的 <code>NettyServerHandler</code> 和 <code>NettyClientHandler</code> 。</p><h3 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyClient</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Init bootstrap</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> NettyClientHandler nettyClientHandler = <span class="keyword">new</span> NettyClientHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(NIO_EVENT_LOOP_GROUP)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class="line">                <span class="comment">//.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout())</span></span><br><span class="line">                .channel(socketChannelClass());</span><br><span class="line"></span><br><span class="line">        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Math.max(<span class="number">3000</span>, getConnectTimeout()));</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1 心跳间隔，默认 60s</span></span><br><span class="line">                <span class="keyword">int</span> heartbeatInterval = UrlUtils.getHeartbeat(getUrl());</span><br><span class="line">                <span class="keyword">if</span> (getUrl().getParameter(SSL_ENABLED_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="string">"negotiation"</span>, SslHandlerInitializer.sslClientHandler(getUrl(), nettyClientHandler));</span><br><span class="line">                &#125;</span><br><span class="line">                NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 设置 ChannelPipeline 上的 ChannelHandler</span></span><br><span class="line">                ch.pipeline()<span class="comment">//.addLast("logging",new LoggingHandler(LogLevel.INFO))//for debug</span></span><br><span class="line">                        <span class="comment">// 2.1 编解码 Handler</span></span><br><span class="line">                        .addLast(<span class="string">"decoder"</span>, adapter.getDecoder())</span><br><span class="line">                        .addLast(<span class="string">"encoder"</span>, adapter.getEncoder())</span><br><span class="line">                        <span class="comment">// 2.2 心跳检测 Handler，注意超时时间针对读类型</span></span><br><span class="line">                        .addLast(<span class="string">"client-idle-handler"</span>, <span class="keyword">new</span> IdleStateHandler(heartbeatInterval, <span class="number">0</span>, <span class="number">0</span>, MILLISECONDS))</span><br><span class="line">                        <span class="comment">// 2.3 Netty 融合 Dubbo Handler 的处理</span></span><br><span class="line">                        .addLast(<span class="string">"handler"</span>, nettyClientHandler);</span><br><span class="line"></span><br><span class="line">                String socksProxyHost = ConfigUtils.getProperty(SOCKS_PROXY_HOST);</span><br><span class="line">                <span class="keyword">if</span> (socksProxyHost != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> socksProxyPort = Integer.parseInt(ConfigUtils.getProperty(SOCKS_PROXY_PORT, DEFAULT_SOCKS_PROXY_PORT));</span><br><span class="line">                    Socks5ProxyHandler socks5ProxyHandler = <span class="keyword">new</span> Socks5ProxyHandler(<span class="keyword">new</span> InetSocketAddress(socksProxyHost, socksProxyPort));</span><br><span class="line">                    ch.pipeline().addFirst(socks5ProxyHandler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 IdleSensible 中的方法，表示自己实现心跳检测</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canHandleIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>NettyClient 的初始化逻辑和 NettyServer 类似，这里就不再重复说明。</p><h3 id="IdleStateHandler-参数"><a href="#IdleStateHandler-参数" class="headerlink" title="IdleStateHandler 参数"></a>IdleStateHandler 参数</h3><ol><li>客户端和服务端配置的超时时间不一致<blockquote><p>由于客户端有重试机制，不断发送心跳失败 N 次后才会进行断开、重连。而服务端超时后是直接断开的，留给服务端时间需要长一点，默认情况是服务端超时时间是客户端超时时间的 3 倍。此外，两端都拥有断开连接的能力，但连接的创建是客户端主动发起的，那么客户端也更有权利去主动断开连接。</p></blockquote></li><li>客户端检测的是读超时，服务端检测的是读写超时<blockquote><p>这属于心跳的共识。一般情况下客户端先发起心跳（写）[IdleStateHandler 是单向的，客户端-&gt;服务端]，所以整个链路中不通的情况只可能是：（1）服务接收（读） （2）服务端发送（写） （3）客户端接收（读） 。</p></blockquote></li></ol><h3 id="NettyServerHandler"><a href="#NettyServerHandler" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyServerHandler</span><br><span class="line"><span class="meta">@io</span>.netty.channel.ChannelHandler.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到 IdleStateEvent 事件时会断开连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// server will close channel when server don't receive any heartbeat from client util timeout.</span></span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                logger.info(<span class="string">"IdleStateEvent triggered, close channel "</span> + channel);</span><br><span class="line">                <span class="comment">// 断开链接</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>NettyServerHandler 作为 Netty 服务端侧的 ChannelHandler，当收到 <code>IdleStateEvent</code> 事件时会断开连接。</p><h3 id="NettyClientHandler"><a href="#NettyClientHandler" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyClientHandler</span><br><span class="line"><span class="meta">@io</span>.netty.channel.ChannelHandler.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到 IdleStateEvent 事件会发送心跳消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// send heartbeat when read idle.</span></span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"IdleStateEvent triggered, send heartbeat to channel "</span> + channel);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 发送心跳请求</span></span><br><span class="line">                Request req = <span class="keyword">new</span> Request();</span><br><span class="line">                req.setVersion(Version.getProtocolVersion());</span><br><span class="line">                req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">                req.setEvent(HEARTBEAT_EVENT);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送心跳消息</span></span><br><span class="line">                channel.send(req);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>NettyClientHandler 作为 Netty 客户端侧的 ChannelHandler，当收到 <code>IdleStateEvent</code> 事件时会进行心跳探活。</p><h2 id="信息交换层"><a href="#信息交换层" class="headerlink" title="信息交换层"></a>信息交换层</h2><p>信息交换层是触发心跳检测的入口。</p><h3 id="HeaderExchangeServer"><a href="#HeaderExchangeServer" class="headerlink" title="HeaderExchangeServer"></a>HeaderExchangeServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeServer</span> <span class="keyword">implements</span> <span class="title">ExchangeServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RemotingServer server;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean closed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashedWheelTimer IDLE_CHECK_TIMER = <span class="keyword">new</span> HashedWheelTimer(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-server-idleCheck"</span>, <span class="keyword">true</span>), <span class="number">1</span>,</span><br><span class="line">            TimeUnit.SECONDS, TICKS_PER_WHEEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CloseTimerTask closeTimerTask;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeServer</span><span class="params">(RemotingServer server)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(server, <span class="string">"server == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.server = server;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始心跳检测任务</span></span><br><span class="line">        startIdleCheckTask(getUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startIdleCheckTask</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// server 自己是否可以心跳检测，如果自己不能，则启动一个 CloseTimerTask 定时任务，定期关闭长时间空闲的连接</span></span><br><span class="line">        <span class="comment">// NettyServer 是自己完成心跳检测的，具体依赖 NettyServerHandler 和 IdleStateHandler 实现，原理与 NettyClient 类似</span></span><br><span class="line">        <span class="keyword">if</span> (!server.canHandleIdle()) &#123;</span><br><span class="line">            AbstractTimerTask.ChannelProvider cp = () -&gt; unmodifiableCollection(HeaderExchangeServer.<span class="keyword">this</span>.getChannels());</span><br><span class="line">            <span class="comment">// 心跳超时时间</span></span><br><span class="line">            <span class="keyword">int</span> idleTimeout = getIdleTimeout(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据心跳超时时间计算出一个 tick 时间（除以了 3 得到），作为定时任务执行的频率</span></span><br><span class="line">            <span class="keyword">long</span> idleTimeoutTick = calculateLeastDuration(idleTimeout);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建闭关连接的任务</span></span><br><span class="line">            CloseTimerTask closeTimerTask = <span class="keyword">new</span> CloseTimerTask(cp, idleTimeoutTick, idleTimeout);</span><br><span class="line">            <span class="keyword">this</span>.closeTimerTask = closeTimerTask;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任务加载到时间轮</span></span><br><span class="line">            IDLE_CHECK_TIMER.newTimeout(closeTimerTask, idleTimeoutTick, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 Exchange 层的 Server 时会开启心跳检测任务，如果使用的是 Netty 通信组件则不会使用 Dubbo 的心跳检测逻辑而是直接使用 Netty 提供的心跳检测机制，如果是其它通信组件则依赖 Dubbo 提供的心跳检测逻辑。</p><p>HeaderExchangeServer 启动的心跳检测任务用于服务端侧连接超时关闭连接，这个针对非 Netty 通信组件。Netty 实现的服务端侧心跳检测是交给 <code>IdleStateHandler</code> 完成的， 连接超时关闭连接由 <code>NettyServerHandler</code> 完成。</p><p>以上关闭空闲连接相关的定时任务不再展开说明。</p><h3 id="HeaderExchangeClient"><a href="#HeaderExchangeClient" class="headerlink" title="HeaderExchangeClient"></a>HeaderExchangeClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeClient</span> <span class="keyword">implements</span> <span class="title">ExchangeClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Client client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashedWheelTimer IDLE_CHECK_TIMER = <span class="keyword">new</span> HashedWheelTimer(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-client-idleCheck"</span>, <span class="keyword">true</span>), <span class="number">1</span>, TimeUnit.SECONDS, TICKS_PER_WHEEL);</span><br><span class="line">    <span class="keyword">private</span> HeartbeatTimerTask heartBeatTimerTask;</span><br><span class="line">    <span class="keyword">private</span> ReconnectTimerTask reconnectTimerTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client     封装 Transport 层的 Client 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startTimer 参与控制是否开启心跳定时任务和重连任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeClient</span><span class="params">(Client client, <span class="keyword">boolean</span> startTimer)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="string">"Client can't be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.channel = <span class="keyword">new</span> HeaderExchangeChannel(client);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启心跳定时任务和重连任务</span></span><br><span class="line">        <span class="keyword">if</span> (startTimer) &#123;</span><br><span class="line">            URL url = client.getUrl();</span><br><span class="line">            startReconnectTask(url);</span><br><span class="line">            startHeartBeatTask(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启心跳任务</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeartBeatTask</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// client 是否可以自己检测心跳，如果自己可以发送心跳请求，则无须 HeaderExchangeClient 再启动一个定时任务</span></span><br><span class="line">        <span class="comment">// 这里的 client 是 NettyClient ，它依靠 IdleStateHandler 中的定时任务来触发心跳事件，依靠 NettyClientHandler 来发送心跳请求，对于无法自己发送心跳请求的 Client 实现，HeaderExchangeClient 会为其启动 HeartbeatTimerTask 心跳定时任务</span></span><br><span class="line">        <span class="keyword">if</span> (!client.canHandleIdle()) &#123;</span><br><span class="line">            <span class="comment">// 获取客户端测通道</span></span><br><span class="line">            AbstractTimerTask.ChannelProvider cp = () -&gt; Collections.singletonList(HeaderExchangeClient.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取心跳间隔</span></span><br><span class="line">            <span class="keyword">int</span> heartbeat = getHeartbeat(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理心跳间隔，最小间隔不能低于 1s</span></span><br><span class="line">            <span class="keyword">long</span> heartbeatTick = calculateLeastDuration(heartbeat);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建心跳任务</span></span><br><span class="line">            <span class="keyword">this</span>.heartBeatTimerTask = <span class="keyword">new</span> HeartbeatTimerTask(cp, heartbeatTick, heartbeat);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将心跳任务加载到时间轮</span></span><br><span class="line">            IDLE_CHECK_TIMER.newTimeout(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意，无论使用哪种 NIO 组件，重连逻辑使用的都是 Dubbo 提供的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startReconnectTask</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从 URL 中读取重连配置，判断是否开启重连</span></span><br><span class="line">        <span class="keyword">if</span> (shouldReconnect(url)) &#123;</span><br><span class="line">            <span class="comment">// 获取客户端测通道</span></span><br><span class="line">            AbstractTimerTask.ChannelProvider cp = () -&gt; Collections.singletonList(HeaderExchangeClient.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 心跳超时时间</span></span><br><span class="line">            <span class="keyword">int</span> idleTimeout = getIdleTimeout(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理心跳超时时间</span></span><br><span class="line">            <span class="keyword">long</span> heartbeatTimeoutTick = calculateLeastDuration(idleTimeout);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建重连任务</span></span><br><span class="line">            <span class="keyword">this</span>.reconnectTimerTask = <span class="keyword">new</span> ReconnectTimerTask(cp, heartbeatTimeoutTick, idleTimeout);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将重连任务加载到时间轮</span></span><br><span class="line">            IDLE_CHECK_TIMER.newTimeout(reconnectTimerTask, heartbeatTimeoutTick, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建 Exchange 层的 Client 时会开启心跳检测任务和重连任务。如果使用的 Netty 通信组件则不会使用 Dubbo 的心跳检测逻辑，同样是使用 Netty 提供的心跳检测机制，如果是其它通信组件则依赖 Dubbo 提供的心跳检测逻辑。重连任务无论是使用 Netty 通信组件还是其它通信组件，都会依赖 Dubbo 提供的重连逻辑。</p><p>HeaderExchangeClient 启动的心跳检测任务用于客户端侧连接超时不断发送心跳，这个针对非 Netty 通信组件。Netty 实现客户端侧心跳检测是交给 <code>IdleStateHandler</code> 完成的， 连接超时发送心跳由 <code>NettyClientHandler</code> 完成。HeaderExchangeClient 启动的重连任务针对所有的 NIO 通信组件，它们都依赖 Dubbo 实现的重连逻辑。</p><p>以上相关的定时任务不再展开说明。</p><h2 id="健康检测精度"><a href="#健康检测精度" class="headerlink" title="健康检测精度"></a>健康检测精度</h2><p>Dubbo 中默认的心跳间隔是 60s ，心跳超时时间是 3 * 60s，<strong>由于时间窗口问题，非健康连接可能不能够被及时检测出来，最坏情况为一个周期</strong>。Dubbo 目前的解决方案是，根据心跳间隔时间和心跳超时时间计算出对应的实际触发频率，使它们的值缩小，通过减少检测间隔时间来增大及时发现非健康状态连接的概率。实际触发频率需要根据场景进行权衡折中，要考虑到资源消耗问题。</p><p>注意，几乎所有的定时检测逻辑都会存在时间窗口问题，解决方案就是根据具体的场景合理地计算检测任务的触发频率。</p><h2 id="HeartbeatHandler"><a href="#HeartbeatHandler" class="headerlink" title="HeartbeatHandler"></a>HeartbeatHandler</h2><p>HeartbeatHandler 是专门用于心跳消息处理的 ChannelHandler 实现。注意哦，它是一个 ChannelHandler，意味着会接收到各种消息（不仅限心跳消息）并能处理相关消息，它的主要职能就是处理心跳消息。在通信的不同阶段会更新通道中的 <code>读写时间戳</code>(这些读写时间戳是判断超时的依据)，不仅是心跳消息会更新对应值其它消息也会更新。对收到的心跳消息进行处理，如接收到心跳请求，则生成对应的心跳响应并返回；如接收到心跳响应，则打印日志即可；如果接收到其它消息，则传递给底层的通道处理器。 HeartbeatHandler 更多详情可参考 <a href="https://gentryhuang.com/posts/26722deb/#HeartbeatHandler">HeartbeatHandler</a> 。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>介绍完 Dubbo 的心跳检测后，我们再从宏观上对健康检测进行说明。</p><p>调用方跟服务集群节点之间的网络状况是瞬息万变的，两者之间可能出现各种情况，保证连接的可靠终极解决方案：<strong>让调用方实时感知到节点的状态变化</strong>。</p><ul><li><p><strong>应用心跳检测</strong></p><blockquote><p>应用心跳检测是目前通用的健康检测方案，它能相对及时发现非健康的连接以及非健康的应用，本质上来说还是根据心跳请求结果做判断，这在一定程度上也可以应对应用僵死情况（应用失去活性会影响到心跳请求的响应）。但是对一些相对特殊的情况，应用层心跳检测就不能很好的感知了。比如心跳失败率较高（可能是服务节点网络问题、应用活性等问题），但是总能在阈值内恢复正常，这种情况应用层心跳就显得力不从心了，理论来说该连接或者服务属于不可用的，但是应用层心跳依然认为是正常情况。针对这类情况，就需要其它维度的健康检测。</p></blockquote></li><li><p><strong>业务请求可用率</strong></p><blockquote><p>判断连接或节点状态只有心跳检测维度是不够完美的，可以增加服务调用可用率来协助检测逻辑，这样健康检测就完整了。</p></blockquote></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>分布式系统中健康检测是非常有必要的，通过健康检测机制可以及时地发现连接是否可用或服务是否可用，调用方根据检测结果做出正确的选择，如重连、断开连接、将服务移除健康列表等。健康检测可从 <code>TCP KeepAlive</code>、<code>应用心跳</code> 以及 <code>业务请求可用率</code> 等<strong>多维度</strong>进行考虑。应用健康状况不仅包括 TCP 连接状况，还包括应用本身是否存活，很多情况下 TCP 连接没有断开，但应用可能已经“僵死了”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Dubbo 心跳检测是为了保证连接的可用性，在需要的时候及时采取重连、断开等措施。需要说明的是，Dubbo 心跳检测是针对 TCP 层面的协
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Gossip 协议</title>
    <link href="https://gentryhuang.com/posts/6001717d/"/>
    <id>https://gentryhuang.com/posts/6001717d/</id>
    <published>2021-04-28T16:00:00.000Z</published>
    <updated>2021-07-13T11:56:45.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过对 Raft 等算法的了解，我们知道它们都需要大多数节点正常运行才能稳定运行。如果我们需要系统在极端的情况下也要保证正常运行，比如集群中只有一个节点，那么就必须另辟蹊径了。其实，要求系统在极端的情况下也能稳定运行，根据 BASE 理论，这需要实现最终一致性，而 Gossip 协议就能实现这种系统。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Gossip 协议，顾名思义就像流言蜚语一样，利用一种随机、带有传染性的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>集群中一个节点上有数据被改动，如果想让这个改动迅速传遍整个集群中的节点，进而达到一致性的状态。一般常见的做法是发生改动的节点将最新的数据发送到其它节点，或者其它节点去定期拉取数据。但是上述的解决方案在分布式的情况下会存在以下问题：</p><ul><li>发生改动的节点还没有将最新数据给到其它节点宕机了</li><li>由于网络原因，可能存在某个或某些节点不能连接上发生改动的节点，那么也不能获取到数据，即使其它节点已经同步到了最新的数据。<br>以上两个问题虽然在像 Raft 等算法中能解决，但是存在效率问题。而我们今天的主角 Gossip 协议就能很好的解决以上问题，以一传十，十传百的方式最后迅速传遍整个集群。</li></ul><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>Gossip 过程是由种子节点发起，它会周期性的随机选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。需要注意的是，Gossip 过程是异步的，也就是说发消息的节点不会关注对方是否收到，即不等待响应；</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>Gossip 有两种类型：</p><ul><li>反熵：传播所有的数据</li><li>谣言传播：仅传播新到达的数据</li></ul><h2 id="反熵"><a href="#反熵" class="headerlink" title="反熵"></a>反熵</h2><p>反熵指的是集群中的节点，每隔段时间就随机选择其它节点，然后通过相互交换自己的<strong>所有数据</strong>来消除两者之间的差异，实现数据的最终一致性。</p><p>需要注意的是，反熵需要节点两两交换和对比自己所有的数据，执行反熵时通讯成本会很高。其次，反熵虽然实用，但是执行反熵时相关的节点都是已知的，而且节点数量不能太多，如果是一个动态变化或节点比较多的分布式环境，这时反熵就不适用了。</p><h2 id="谣言传播"><a href="#谣言传播" class="headerlink" title="谣言传播"></a>谣言传播</h2><p>谣言传播，指的是当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其它节点向其发送数据，直到所有的节点都存储了该新数据。谣言传播非常具有传染性，它适合动态变化的分布式系统。</p><h1 id="通信模式"><a href="#通信模式" class="headerlink" title="通信模式"></a>通信模式</h1><p>Gossip 协议最终目的是将数据分发到网络中的每一个节点。根据不同的具体应用场景，网络中两个节点之间存在三种通信方式。</p><ul><li>Push: 节点 A 将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据。</li><li>Pull：A 仅将数据 key, version 推送给 B，B 将本地比 A 新的数据（Key, value, version）推送给 A，A 更新本地。</li><li>Push/Pull：与 Pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 则更新本地。</li></ul><p>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，Push 需通信 1 次，Pull 需 2 次，Push/Pull 则需 3 次。虽然消息数增加了，但从效果上来讲，Push/Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push/Pull 的收敛速度也是最快的。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p><strong>扩展性：</strong>允许节点的任意增加和减少，新增节点的状态最终会与其他节点一致。<br><strong>容错性：</strong>任意节点的宕机和重启都不会影响 Gossip 消息的传播，一方面一个节点会多次传播信息，另一方面即使不能连通某个节点，其他被“感染”的节点也会尝试向这个节点传播信息。具有天然的分布式系统容错性。<br><strong>健壮性：</strong>无需中心节点，所有节点都是对等的，只要网络连通，任意节点可把消息散播到全网。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><strong>消息延迟：</strong>节点随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网；不可避免的造成消息延迟。<br><strong>消息冗余：</strong>节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，不可避免的引起同一节点消息多次接收，增加了消息处理压力。</p><p>需要说明的是，Gossip 协议适用于 AP 场景的数据一致性。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Gossip 协议基本思想是，一个节点想要分享一些信息给网络中的其他节点，会周期性的随机选择一些节点，并把信息传递给这些节点。这些收到信息的节点接下来会做同样的事情，即把这些信息传递给其他一些随机选择的节点。基于 Gossip 协议的一些系统，如 Apache Cassandra，Redis（Cluster模式），Consul等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通过对 Raft 等算法的了解，我们知道它们都需要大多数节点正常运行才能稳定运行。如果我们需要系统在极端的情况下也要保证正常运行，比如集群中
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://gentryhuang.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Gossip" scheme="https://gentryhuang.com/tags/Gossip/"/>
    
  </entry>
  
  <entry>
    <title>Raft 共识算法</title>
    <link href="https://gentryhuang.com/posts/48468614/"/>
    <id>https://gentryhuang.com/posts/48468614/</id>
    <published>2021-04-23T11:28:56.000Z</published>
    <updated>2021-07-24T08:06:03.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Raft 是一个共识算法（consensus algorithm），也称作 Raft 协议。所谓共识就是多个节点就某个事情达成一致，即使是在部分节点故障、甚至网络分区的情况下也是可行的。在分布式系统中，共识算法更多用于提供系统的容错性。</p><p>Raft 算法是在兰伯特 Multi-Paxos 思想的基础上进行了简化和限制，目标就是容易理解。Raft 虽然增强了可理解性，但在性能、可靠性、可用性方面是不输于 Paxos 的。Raft 算法将共识的关键要素进行了拆分，以简化流程和提供算法的可理解性。</p><h1 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h1><p>共识算法的实现一般是基于复制状态机（Replicated state machines），即所有节点都是从同一个 <code>state</code> 出发，都经过同样的一些操作序列（log），最后到达同样的 <code>state</code> ，架构图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/architecture-raft-replicated-state-machines.jpeg" alt></p><p>这是一个<strong>共识系统的典型架构</strong>，其中涉及到三个组件：</p><blockquote><ol><li>状态机：处理来自 Log 的指令序列，将执行结果对外输出。状态机具有确定性，只要 Log 的指令序列相同，产生的结果也是相同的。</li><li>Log：保存了所有写操作记录。</li><li>共识模块：保证包含来自客户端的指令的 Log 的一致性，充当管理日志的角色。（这也是 Raft 算法核心内容） </li></ol></blockquote><p>复制状态机通常使用<strong>复制日志</strong>来实现。每个服务节点存储一个包含一系列命令的日志，日志会被其状态机所使用，用于计算其中的指令。注意，只要各个服务节点上的日志是相同的或者大多数节点日志相同，说明系统已经达成共识，这些具有相同日志的服务节点上的状态机就能以相同的顺序执行相同的命令，执行的结果也是相同的。不难看出，<strong>复制日志充当数据副本的角色</strong>。</p><p>保证复制日志的一致性是共识算法的工作。服务节点上的共识模块从客户端接收命令，并将其添加到其 Log 中，然后与其它服务节点的共识模块进行通信，以完成日志复制。正确复制指令后，每台服务节点将命令应用到状态机（状态机执行对应的指令）。</p><h1 id="Raft-算法概览"><a href="#Raft-算法概览" class="headerlink" title="Raft 算法概览"></a>Raft 算法概览</h1><p>Raft 是一种用于管理复制日志的算法，它采用领导者模式，将共识问题分解为三个相对独立的子问题：Leader 选举、日志复制、安全（约定）。下面对 Raft 算法进行总体说明，并就关键特性进行列举。图中的相关元素会在后文具体说明。</p><h2 id="算法简要"><a href="#算法简要" class="headerlink" title="算法简要"></a>算法简要</h2><h3 id="状态数据结构"><a href="#状态数据结构" class="headerlink" title="状态数据结构"></a>状态数据结构</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-node-state.jpg" alt></p><ul><li>所有服务节点上的持久性状态（在响应RPC请求之前，已经更新到了稳定的存储设备）<blockquote><ul><li>currentTerm: 服务节点已知最新任期（在服务节点首次启动时初始化为 0，该值是单调递增的）</li><li>votedFor: 当前任期内收到选票的候选者id,如果没有投给任何候选者，则为空</li><li>log[]: 日志条目</li></ul></blockquote></li><li>所有服务节点上的易失性状态<blockquote><ul><li>commitIndex: 已知已提交的最高的日志条目的索引（初始值为 0，单调递增）</li><li>lastApplied: 已经被应用到状态机的最高的日志条目的索引（初始值为 0，单调递增）</li></ul></blockquote></li><li>领导者（服务节点）上的易失性状态（选举后已经重新初始化）<blockquote><ul><li>nextIndex[]: 对于每个服务节点，发送到该服务节点的下一个日志条目的索引（初始值为领导者最后的日志条目的索引+1）</li><li>matchIndex[]: 对于每一台服务节点，已知的已经复制到该服务节点的最高日志条目的索引（初始值为0，单调递增）</li></ul></blockquote></li></ul><h3 id="选举-RPC-数据结构"><a href="#选举-RPC-数据结构" class="headerlink" title="选举 RPC 数据结构"></a>选举 RPC 数据结构</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-vote-rpc.jpg" alt></p><ul><li>由候选人负责调用，用来征集选票<blockquote><ul><li>term：候选人的任期编号</li><li>candidatedId: 请求选票的候选人的 id</li><li>lastLogIndex: 候选人最后日志条目的索引值</li><li>lastLogTerm: 候选人最后日志条目的任期编号</li></ul></blockquote></li><li>返回值<blockquote><ul><li>term: 响应中的任期号，以便于候选人去更新自己的任期号（候选人任期号较小时）</li><li>voteGranted: 候选人赢得了此张选票时为真</li></ul></blockquote></li></ul><h3 id="日志复制｜心跳-RPC-数据结构"><a href="#日志复制｜心跳-RPC-数据结构" class="headerlink" title="日志复制｜心跳 RPC 数据结构"></a>日志复制｜心跳 RPC 数据结构</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replicate-heartbeat-rpc.jpg" alt></p><ul><li>领导者用于日志条目的复制 RPC 和 心跳 RPC<blockquote><ul><li>term: 领导者任期</li><li>leaderId: 领导者Id，跟随者可以根据该值对客户端进行重定向</li><li>prevLogIndex: 上一个日志条目的索引</li><li>prevLogTerm: 上一个日志条目的任期</li><li>entries[]: 需要被保存的日志条目（如果是心跳 RPC，则为空；为了提高效率可能一次性发送多个）</li><li>leaderCommit: 领导者的已知已提交的最高的日志条目的索引</li></ul></blockquote></li></ul><p>需要特别说明的是，<code>prevLogIndex</code> 和 <code>prevLogTerm</code> 是动态变化的，不是很好理解。</p><ul><li>结果<blockquote><ul><li>term: 响应中的任期，对于领导者而言，它会更新自己的任期（其它领导者任期更高）</li><li>success: 如果跟随者所含有的条目和 prevLogIndex 以及 prevLogTerm 匹配上了，则结果为 true</li></ul></blockquote></li><li>接受者的实现<blockquote><ul><li>如果领导者的任期小于接收者的当前任期，则返回 false</li><li>如果接受者日志中不能找到一个和 prevlogIndex 以及 prevLogTerm 一样的索引和任期的日志条目，则返回 false</li><li>如果接受者的条目和新条目发生了冲突（索引相同，任期不同），那么就删除这个已存在的条目以及它之后的所有条目</li></ul></blockquote></li></ul><h3 id="服务节点规则"><a href="#服务节点规则" class="headerlink" title="服务节点规则"></a>服务节点规则</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-rules.jpg" alt></p><ul><li>所有服务节点<blockquote><ul><li>如果commitIndex &gt; lastApplied，那么 lastApplied 加一，并把log[lastApplied]应用到状态机中。</li><li>如果接收到的 RPC 请求或响应中，任期号T &gt; currentTerm，那么就令 currentTerm 等于 T，并切换状态为跟随者</li></ul></blockquote></li><li>跟随者<blockquote><ul><li>响应来自候选人和领导者的请求</li><li>如果超过选举超时时间没有收到当前领导人（即该领导人的任期需与这个跟随者的当前任期相同）的心跳/附加日志，就自己变成候选者</li></ul></blockquote></li><li>候选者<blockquote><ul><li>节点在转变成候选者后就立即开始选举过程</li><li>如果接收到大多数服务节点的选票，那么就变成领导者</li><li>如果接收到来自新的领导者的 AppendEntries RPC，转变成跟随者</li><li>如果选举过程超时，再次发起一轮选举</li></ul></blockquote></li><li>领导人<blockquote><ul><li>选举后，向每个服务节点发送 AppendEntries RPC（心跳）；以一定的时间间隔不停的重复发送，以阻止跟随者超时</li><li>如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端</li><li>如果跟随者的最后一个日志条目的索引值大于等于 nextIndex ，则以 AppendEntries RPC 发送从 nextIndex 开始的所有日志条目<ul><li>如果成功：更新相应跟随者的 nextIndex 和 matchIndex</li><li>如果因为日志不一致而失败，则递减 nextIndex 并进行重试</li></ul></li></ul></blockquote></li></ul><h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-property.jpg" alt></p><blockquote><ul><li><strong>Election Safety:</strong> 选举安全性。对于一个给定的任期号，最多只会有一个领导人被选举出来。</li><li><strong>Leader Append-Only:</strong> 领导者只附加原则。领导人绝对不会删除或者覆盖自己的日志，只会增加。</li><li><strong>Log Matching:</strong> 日志匹配原则。如果两个日志在相同的索引位置的日志条目的任期号相同，那么就可以认为这两个日志从头到这个索引位置之间全部完全相同。</li><li><strong>Leader Completeness:</strong> 领导者完全特性。如果某个日志条目在某个任期中已经被提交，那么该条目必然出现在更大任期号的所有领导者中。</li><li><strong>State Machine Safety:</strong> 状态机安全特性。如果一个领导者已经将给定的索引值位置的日志条目应用到状态机中，那么其它任何的服务节点在这个索引位置不会应用一个不同的日志。</li></ul></blockquote><p> <strong>Raft 在任何时候都保证以上的各个特性，这也是 Raft 实现共识算法的基础。</strong></p><h2 id="阶段状态（角色）"><a href="#阶段状态（角色）" class="headerlink" title="阶段状态（角色）"></a>阶段状态（角色）</h2><p><strong>在任何时候，每个服务节点都处于以下三种状态之一：</strong></p><blockquote><p><strong>领导者（Leader）：</strong>处理所有客户端的交互以及日志复制，一个任期内只能有一个领导者。<br><strong>跟随者（Follower）：</strong>绝大多数服务节点在大多数时间都处于跟随者的状态，这些服务节点完全处于被动状态，它们不会发起任何 RPC 请求，仅仅对其它服务节点发起的 RPC 请求做出响应。<br><strong>候选者（Candidate）：</strong>处于领导者（Leader）与跟随者（Follower）之间的一种状态，只在选举新领导者的过程中临时出现，当系统处于稳定状态，只会有一个领导者，其他的服务节点都是跟随者。</p></blockquote><p>下图展示了相关状态图，描述了三种状态以及变化情况。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-state-change.jpg" alt></p><h2 id="领导者任期"><a href="#领导者任期" class="headerlink" title="领导者任期"></a>领导者任期</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-term.jpg" alt></p><p>每届领导者都会有一个任期 term，term 是随着任期数递增的，并且不会被重复使用。Raft 系统中的服务节点会持久化相关数据，其中包括当前任期 term 值。任期这个概念非常重要，Raft 可以根据该值判断过期信息。<strong>服务节点之间在通信时会交换当前任期号。如果一个服务节点的当前任期小于另一个服务节点，则它将其当前任期更新为较大的值。如果候选者或领导者发现其当前任期已过时，则将立即恢复为跟随者状态。如果服务节点收到带有过期任期的请求，则会拒绝该请求。</strong></p><h2 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h2><p>Raft 中有两个控制选举的超时设置，第一个是选举超时时间（election timeout），另一个是心跳超时时间（heartbeat timeout）。Leader 发送心跳消息是以心跳超时指定的时间间隔进行的，也就是根据 heartbeat timeout 发送心跳信息。Follower 会在 election timeout 内等待 RPC 消息，如果没有等到则会主动发起选举请求。</p><p>在 Raft 中定义了随机超时时间，巧妙地使用随机选举超时时间策略把超时时间都分散开来，在大多数情况下只有一个服务节点先发起选举，这样就能减少因选票瓜分导致选举失败的情况。</p><p>Raft 算法中，随机超时时间具有 2 种含义：可以定义为不一样</p><blockquote><ul><li>Follower 等待 Leader 心跳信息超时的时间间隔是随机的。</li><li>Candidate 在一个随机时间间隔内没有获得 majority 投票（含自己一票），那么选举无效，然后 Candidate 发起新一轮的选举。该过程的选举超时时间间隔是随机的。</li></ul></blockquote><p>在 Raft 算法中，选举超时时间随机分配在 [150ms,300ms] 区间中，当 Follower 收到 RPC 消息时（包括选举 RPC、AppendEntries RPC） 都会重置其选举超时时间。</p><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>Raft 服务节点使用远程过程调用（RPC）进行通信，其中主要包括以下两种类型的 RPC （Raft 在传输快照时使用的是第三种 RPC）。</p><ul><li><strong>RequestVote RPC</strong><blockquote><p>由候选人在选举期间发送的 RPC 请求，该 RPC 请求对应的数据结构可以参见前文的 <strong>选举 RPC 数据结构</strong> 。</p></blockquote></li><li><strong>AppendEntries RPC</strong><blockquote><p>领导者在发送心跳和复制日志条目时会发送该 RPC 请求，该 RPC 请求对应的数据结构可以参见前文的 <strong>日志复制｜心跳 RPC 数据结构</strong> 。需要注意的是，心跳 RPC 相比日志复制 RPC 缺少了日志条目。</p></blockquote></li></ul><p><strong>注意：AppendEntries RPC 具有一致性检查的功能，它是实现各节点间日志的一致性（或者说副本数据）的重要机制。</strong></p><h1 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h1><p>Raft 使用心跳超时机制触发领导者选举。前面已经介绍，如果存在 Follower 在 election timeout 内没有收到来自 Leader 的心跳，则会主动发起选举。没有收到 Leader 的心跳的原因可能是：此时还没有 Leader、Leader 挂了、网络故障。</p><h2 id="选举-Leader"><a href="#选举-Leader" class="headerlink" title="选举 Leader"></a>选举 Leader</h2><p>下面我们以初始化状态下，集群中所有的节点都是跟随者的状态为例介绍选举过程。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-election-1.jpg" alt></p><p>设定，节点初始化状态都是 Follower 状态，任期为 0 ，各节点随机分配的 election timeout 如上图所示 。需要注意的是，节点都会对相关属性进行持久化，防止节点宕机后数据丢失。</p><p><strong>等待超时</strong></p><p>通过上图可知，集群中没有领导者，而节点 A 的选举超时时间最小（150ms），因此它会最先因为没有等到领导者的信息（不仅仅心跳信息）而发生超时，进而主动发起选举。</p><p><strong>切换到 Candidate 状态</strong></p><p>节点 A 增加自己的任期编号并推荐自己为候选者，先给自己投上一张票，然后向其它节点发送请求投票 RPC 消息，通常这些请求是并行发出的。注意此时 RPC 消息携带的信息。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-election-2.jpg" alt></p><p><strong>响应投票请求</strong></p><p>如果其它节点收到候选者 A 的投票请求，在任期编号为 1 的这一任期内还么没有进行过投票，那么就会把票投给节点 A 并将自己记录的任期替换成候选者的任期编号（投票 RPC 中会携带），此外节点的选举超时时间会被重置。投票请求对应的数据结构可参考前文。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-election-3.jpg" alt></p><p><strong>切换到 Leader 状态</strong></p><p>如果候选人在选举超时时间内获得 majority 投票，那么它就会成为本届任期内新的领导者。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-election-4.jpg" alt></p><p><strong>发送心跳消息</strong><br>节点 A 当选领导者后，它会立刻向其它节点发送心跳消息（AppendEntries RPC），避免其它节点触发新的选举，以维护自己领导者的地位。注意心跳消息一致性检查的作用，通过这种机制，领导者在获得权力的时候就不需要任何特殊的操作来恢复一致性，只需要进行正常的操作，然后日志就能自动的在回复附加日志 RPC 的一致性检查失败的时候自动趋于一致。关于日志复制内容下文详细介绍。以上是正常流选举 Leader 的过程，下面对候选者选举的所有可能情况进行介绍。</p><h2 id="选举结果"><a href="#选举结果" class="headerlink" title="选举结果"></a>选举结果</h2><p>第一、在选举超时时间内得到了 majority 投票，然后它会将自己的状态切换到 Leader 并立即向集群中其它服务节点发送心跳消息，以建立它的领导者地位并防止进行新的选举。注意，收到 Leader 的 RPC 消息后（包括日志复制消息和心跳消息），其它节点的心跳超时时间会重置。这也是前面介绍的正常流的过程。</p><p>第二、在等待投票结果时收到其它节点发送的 AppendEntries RPC 消息（以领导者身份），如果该领导者的任期（包括在此次 RPC 消息中）不小于候选者当前任期，则候选者转成 Follower 状态，并更新自己的任期，否则候选者拒绝该 RPC 请求并继续处于候选人的状态。</p><p>第三、没有任何服务节点获胜。可能存在有多个服务节点同时成为 Candidate 导致了分票，没有服务节点获得 majority 投票。发生这种情况时，每一个 Candidate 都等待选举超时，其中先超时的会增加其任期，然后进行一轮新的选举。<strong>注意这里选举超时时间的重要性，没有该机制的话，选票就可能会被无限地瓜分，那么就延长了系统不可用的时间（没有leader是不能处理客户端相关请求的）。</strong></p><h2 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h2><p>选举过程涉及的约定如下，其中包含了 Raft 安全约定中的部分内容。</p><blockquote><ol><li>Leader 会周期性地向所有 Follower 发送心跳请求（不包含日志项的 AppendEntries RPC）来维持自己的权威，以并行的方式执行，防止 Follower 发起新的选举。</li><li>如果在 Follower 的选举超时时间内没有收到来自领导者的消息（心跳或日志复制），那么就推荐自己为候选人，发起领导者选举。</li><li>选举中获得 majority 投票（含自己一票）的 Candidate 将晋升为 Leader 。</li><li><strong>一个任期内只允许有一个领导者，除非领导者宕机、网络故障等发生，其它节点才会发起新一轮的选举。</strong></li><li><strong>每一个服务节点最多会对一个任期号投出一张选票，按照先来先服务的原则。</strong><br> <img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-election-same-term.jpg" alt><br> 节点 C 的任期编号为 1，先收到一个来自节点 A 的包含任期编号为 2 的投票请求，接着又收到一个来自节点 B 的包含任期编号为 2 的投票请求。按照先来先服务的原则，C 会把唯一的一张票投给节点 A 并更新自己的任期编号，当再收到节点 B 的投票请求时，发现已经对任期编号为 2 的投票请求做出了响应，于是就拒绝节点 B 的投票请求。</li><li><strong>日志完整性高的跟随者不会投票给日志完整性低的候选者，日志完整性高低依据节点最后一条日志条目对应的任期编号及索引号，任期编号更大、索引号更大完整性就越高。</strong></li></ol></blockquote><p>上述涉及到的选票的安全性，会在 Raft 安全部分进行详细说明。</p><h1 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h1><h2 id="日志结构"><a href="#日志结构" class="headerlink" title="日志结构"></a>日志结构</h2><p>Log 具有持久化、保序的特点，是大多数分布式系统的基石。在 Raft 算法中，<strong>副本数据是以日志的形式存在的</strong>，Raft 中的日志结构如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-log-struct.jpg" alt></p><p>日志由有序序号标记的条目组成，每个日志条目包含了：<code>索引（index）</code>、<code>任期编码（term）</code>以及<code>指令（command）</code>。其中提交状态（ <code>committed</code>） 指日志条目被复制到大多数节点后日志条目的状态，<code>applied</code> 是指节点将日志条目应用到状态机。</p><p><strong>索引：</strong>用来标识日志条目在日志中的位置，是一个连续的、单调递增的整数。<br><strong>任期编号：</strong>创建当前日志条目的领导者的任期编号。<br><strong>指令：</strong>一般由客户端请求指定的、状态机需要执行的指令，本质上是客户端指定的数据。</p><p>每个服务节点无论是领导者还是跟随者，都各自保存一个日志副本，日志条目格式如上图所示。每个服务节点都必须保证日志能在奔溃后还可以恢复，所以日志本身需要持久化。领导者将创建的日志条目复制到大多数的服务节点上的时候，该日志条目就会被提交（例如上图中的日志条目 7），同时该日志之前的所有日志条目也都会被提交，包括由其它领导者创建的日志条目。注意，领导者不能单独直接提交其它领导者创建的日志条目，只能在提交自己任期的日志时间接提交，这也是安全性规定的。</p><h2 id="日志复制操作"><a href="#日志复制操作" class="headerlink" title="日志复制操作"></a>日志复制操作</h2><p>客户端将指令发送给领导者，领导者首先<strong>将命令封装成一个日志条目</strong>并写入自己的日志中，然后向所有其它的跟随者发送 AppendEntries 的远程调用，通常以并行的方式将调用的消息发送到所有服务节点，然后等待这些消息的响应。一旦领导者收到足够多的响应，该日志条目也就具备提交状态，那么领导者就会将该日志条目的指令应用到状态机并将执行结果返回给客户端，否则返回异常给客户端。需要注意的是，领导者将日志条目应用到它的状态机时并不需要直接通知跟随者应用日志条目，领导者会通过后续的 AppendEntries 远程调用通知其它的服务节点，最终每个跟随者都会知道该记录已提交，然后也将该日志条目应用到它的状态机。</p><p>领导者不直接发送消息通知其它节点应用指定的日志条目，是 Raft 的一个优化。通过前文的 AppendEntries RPC 的数据结构，我们知道领导者的日志复制 RPC 消息或心跳消息，包含了领导者已知已提交的最高的日志条目索引，所以通过日志复制 RPC 消息或心跳消息，跟随者就可以知道领导者的日志提交位置信息。因此，当其它节点接收到领导者的心跳消息或日志复制消息后，就会将该日志条目应用到它的状态机。这个优化降低了处理客户端请求的延迟。</p><p>下图展示了正常流程的日志复制过程：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replication-simple-process.jpg" alt></p><blockquote><ol><li>接收到客户端请求后，领导者基于客户端请求中的指令会创建一个日志条目并添加到本地日志中。</li><li>领导者通过日志复制 RPC ，将新的日志条目复制到其它的服务节点上。</li><li>当领导者将日志条目成功复制到大多数的服务节点上的时候，领导者会将该日志条目应用到它的状态机中。</li><li>领导者将执行的结果返回给客户端。</li><li>当跟随者接收到心跳消息或者日志复制消息后，如果跟随者发现领导者已经提交了某个日志条目而自己还没有，那么跟随者就将这条日志条目应用到本地的状态机中。</li></ol></blockquote><p>以上是理想状态下的日志过程，在实际环境中可能会遇到进程奔溃、服务节点宕机等问题，这些问题会导致日志不一致。下面我们对日志复制过程进行讨论，主要讨论 Leader 在不同阶段宕机的情况。关于跟随者节点或候选者节点宕机比较容易处理，我们会在后文简单介绍。</p><blockquote><ol><li>客户端数据到达 Leader 节点之前，Leader 宕机了。<br> <img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replication-process-1.jpg" alt><br> 这种情况对数据的一致性没有影响。</li><li>客户端数据到达 Leader 节点，但未复制到 Follower 节点<br> <img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replication-process-2.jpg" alt><br> 该阶段 Leader 挂掉，数据属于未提交状态，客户端不会收到响应。Follower 节点上没有该数据，重新选举 Leader 后客户端重试重新提交可成功。原来的 Leader 节点恢复作为 Follower 加入集群重新从当前任期的新 Leader 同步数据，强制保持和 Leader 数据一致。</li><li>客户端数据到达 Leader 节点，成功复制到 Follower 所有节点，但还未向 Leader 响应接收<br> <img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replication-process-6.jpg" alt><br> 这个阶段 Leader 挂掉，虽然数据在 Follower 节点处于未提交状态，但是保持一致。重新选举出 Leader 后可完成数据提交。</li><li>客户端数据到达 Leader 节点，成功复制到 Follower 大多数节点，但还未向 Leader 响应接收<br> <img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replication-process-3.jpg" alt><br> 这个阶段 Leader 挂掉，数据在 Follower 节点处于未提交状态且不一致，Raft 协议要求投票只能投给拥有最新数据的节点。所以，拥有最新数据的节点会被选为 Leader ，然后再强制同步数据到 Follower ，数据不会丢失并最终一致。注意，如果是成功复制到少数 Follower ,那么数据就可能会丢失。</li><li>客户端数据到达 Leader 节点，成功复制到 Folloer 所有或多数节点，数据在 Leader 处于已提交状态，但在 Follower 处于未提交状态<br> <img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replication-process-4.jpg" alt><br> 这个阶段 Leader 挂掉，选出的新 Leader 拥有最新的数据，对于数据缺失的 Follower 节点，执行同步机制会保证最终一致。</li><li>网络分区导致脑裂，出现双 Leader<br> <img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replication-process-5.jpg" alt><br> 网络分区将原先的 Leader 节点和 Follower 节点分隔开，Follower 收不到 Leader 的心跳将发起选举产生新的 Leader。这时就产生了双 Leader，原先的 Leader 独自在一个区，向它提交数据不可能复制到多数节点所以永远提交不成功。向新的 Leader 提交数据可以提交成功，网络恢复后旧的 Leader 发现集群中有更新任期的 Leader（任期更大），则自动降级为 Follower 并更新任期且从新 Leader 同步数据达成集群数据一致。</li></ol></blockquote><p>通过上述穷举不难看出，Raft 能很好地应对一致性问题。此外，跟随者崩溃了或处于慢响应状态，领导者会反复重试这个调用，直到跟随者恢复后，领导者就能重试成功。但是领导者并不需要等待每个跟随者的响应，它只需要等到足够数量的响应，保证记录已被大多数服务节点存储即可。所以这样就能在一般情况下获得很好的性能提升。也就是说，在通常情况下，只需要获得大多数最快的服务器的应答，领导者就可以立即执行命令，并将结果返回至客户端。</p><h2 id="任期更新"><a href="#任期更新" class="headerlink" title="任期更新"></a>任期更新</h2><p>出现网络分区时，可能使集群中出现两个 Leader，网络恢复时该如何处理两个 Leader 的问题呢？Raft 使用任期号来处理。每个 RPC 请求都包括发送者的任期号，接收者收到请求后会将其与自己的任期号相比较，如果不匹配，则会更新那些过期的记录。所以如果发送者的任期比接收者小，接收者会立即拒绝 RPC 请求，并将包括了接受者任期信息的响应发送回发送者，当发送者接收到响应时会发现自己的任期号是过期的，此时它就会停下并作为跟随者继续运行，同时更新自己的任期号。反之，如果接受者的任期号更小，它同样会更新自己的任期号。</p><p>选举过程也会导致任期号的更新。候选者发起投票请求时会将自己的任期号随着 RPC 请求发送出去，这样所有的接收者都会更新自己的任期号，与候选者保持一致。</p><h2 id="日志的一致性"><a href="#日志的一致性" class="headerlink" title="日志的一致性"></a>日志的一致性</h2><p>在 Raft 算法中，<strong>领导者处理不一致日志是通过强制跟随者直接复制自己的日志来解决的</strong>。也就是说，Raft 是通过以领导者的日志为准来实现各节点日志的一致，这意味着在跟随者中的冲突的日志条目会被领导者的日志覆盖。</p><p>日志记录的索引以及任期编号可以唯一标识一条日志条目。Raft 维护着以下特性：</p><ol><li>如果两条日志条目拥有相同的索引和任期号，那么它们存储的指令也是相同的。</li><li>如果两条日志条目拥有相同的索引和任期号，那么它们之前的所有日志条目也全部相同。</li></ol><p>第一个特性来自领导者创建日志条目的原则，领导者最多在一个任期里在指定的日志索引位置创建一条日志条目，而且日志条目在日志中的位置不会改变。第二个特性由一致性检查来保证。此外，如果某条日志条目是已提交的，那么其所有前序的记录都应该处于已提交状态。</p><h2 id="AppendEntries-一致性检查"><a href="#AppendEntries-一致性检查" class="headerlink" title="AppendEntries 一致性检查"></a>AppendEntries 一致性检查</h2><p><strong>Raft 强制在 AppendEntries 远程（日志复制和心跳）调用时进行一致性检查，如果发现问题则需要修复跟随者日志</strong>。要使得跟随者的日志和领导者一致，领导者就必须找到最后两者达成一致的地方，然后删除从那个点之后的所有日志条目，发送自己的日志给跟随者。而这些操作都在进行 AppendEntries 的一致性检查时完成。</p><p>领导者会为每个跟随者维护一个状态变量 <code>nextIndex</code> ，这个变量存储下一个需要发送给跟随者的日志条目的下标位置索引。当一个服务节点成为领导者后，它会将 nextIndex 值统一设置为自己最后一条日志条目的 index 加 1 。领导者会根据 AppendEntries 调用发现一致性问题，因为当跟随者接收到 AppendEntries 调用时都会进行检查。当领导者与跟随者进行 AppendEntries 通信时，都会包括日志条目下标索引 index 以及任期号 term 作为请求参数，这里日志条目就是 log[nextIndex-1] 的值。当消息到达跟随者后，它会将接收到的下标位置索引与任期与自己的日志信息进行比较，如果不一致就会拒绝当前请求。在被跟随者拒绝之后，领导者就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得领导者和跟随者的日志达成一致。当这种情况发生，附加日志 RPC 就会成功，这时就会把跟随者冲突的日志条目全部删除并且加上领导人的日志。一旦附加日志 RPC 成功，那么跟随者的日志就会和领导人保持一致，并且在接下来的任期里一直继续保持。</p><p><strong>一致性检查流程概括如下：</strong></p><blockquote><ol><li>Leader 初始化 nextIndex 为自己最后一个 log index + 1</li><li>AppendEntries 中的 prevLogTerm 、prevLogindex 来自 logs[nextIndex -1]</li><li>Follower 会将接收到的下标索引与任期与自己的日志信息进行比较，如果一致则返回 true，否则返回 false。</li><li>Leader 收到 Follower 的回复，如果返回值是 false，则 nextIndex -= 1，回到第 2 步进行重试，否则同步 nextIndex 后的所有日志条目。</li></ol></blockquote><p>从一致性检查的过程不难发现，如果 Follower 和 Leader 的日志差异过大会造成 AppendEntries RPC 拒绝次数。但是在实践中，失败是很少发生的并且也不大可能会有这么多不一致的日志。如果一定要优化的话，那么可以采用：当 AppendEntries RPC 请求被拒绝的时候，跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的下标索引。借助这些信息，领导者可以减小 nextIndex 越过所有那个任期冲突的所有日志条目，这样就变成每个任期需要一次 AppendEntries RPC 而不是每个条目一次。</p><p>一致性检查机制非常重要，如果一个跟随者接受了来自领导者的新记录，那么它的日志记录也与领导者的日志记录是完全匹配的。此外，<strong>领导者刚当选时不需要任何特殊的操作来恢复一致性，它只需要进行正常的操作，然后日志就能自动的在回复 AppendEntries RPC 的一致性检查失败的时候自动趋于一致。</strong></p><h1 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h1><p>Raft 的日志在正常操作中不断增长，但在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响系统的可用性。Raft 采用了快照技术进行日志压缩来解决日志过大问题。快照的缺点就是不是增量的，即使内存中某个值没有变，下次做快照的时候同样会被 dump 到磁盘。</p><h2 id="快照结构"><a href="#快照结构" class="headerlink" title="快照结构"></a>快照结构</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-log-compaction.png" alt></p><p>由快照结构可知，服务节点使用一个新的快照替换其日志中提交的日志条目（如上图中：索引1到索引5），快照只存储当前状态（如上图中的变量x和y）。并且快照包含一些元数据，其中 <code>last included index</code>、<code>last included term</code> 分别是快照覆盖的最后一条日志条目的索引以及任期号，这两个值用于 AppendEntries RPC 的一致性检查。此外，为了支持集群成员变更，快照中也保存了最新的配置信息。关于成员变更问题在下文中会有详细说明。</p><p>Raft 中每个节点独立的创建快照，只包括已经应用到状态机的日志条目。一旦节点完成一次快照，就可以删除最后索引位置之前的所有日志和快照了。</p><h2 id="快照发送"><a href="#快照发送" class="headerlink" title="快照发送"></a>快照发送</h2><p>正常情况下，Leader 的日志和 Follower 保持一致，但并不是所有情况都处于正常情况之下，有时可能因为 Follower 的反应缓慢或宕机造成日志不一致的情况，这时就需要 Leader 进行日志复制。如果在复制的过程中，Leader 需要发给 Follower 的日志条目被丢失了（因为 Leader 做了快照），这时会通过 InstallSnapshot RPC 发送快照给 Follower，如果没有丢失则直接从日志中复制即可。</p><p><strong>InstallSnapshot RPC 数据结构的关键字段如下：</strong></p><blockquote><ol><li>term: Leader 的任期</li><li>leaderId: Leader 的id，以便于跟随者重定向请求</li><li>lastIncludedIndex: 快照中包含的最后一条日志条目的索引值</li><li>lastIncludedTerm: 快照中包含的最后一条日志条目的任期号<br>……</li></ol></blockquote><p>当跟随者收到了 InstallSnapshot RPC 发来的快照，它会根据自身的日志进行处理：</p><blockquote><ol><li>Follower 的日志信息不包括快照中的日志信息，或者包含与快照冲突的信息，这种情况直接使用快照内容替代自己的日志。</li><li>快照中的日志仅是 Follower 日志的子集（前缀）（由于网络重传或者错误），那么 Follower 中被快照包括的部分被代替，之后的部分仍然保留。</li></ol></blockquote><h2 id="快照创建"><a href="#快照创建" class="headerlink" title="快照创建"></a>快照创建</h2><p>各节点独立创建快照的方式背离了 Raft 的强领导者原则，因为跟随者可以在不知道领导者的情况下创建快照。虽然快照创建背离 Raft 的领导者原则，但是本质上还是以领导者为中心，并且这种背离是值得的。领导者的存在是为了解决在达成一致性时的冲突，但是在创建快照时一致性已经达成，因为创建快照是基于已经提交的日志条目的，所以没有领导者也是可以的。数据依然是从领导者传给跟随者。</p><p>不使用基于领导者的快照方案，一方面减少网络带宽的使用，降低了快照处理的时间，另一方面降低了 Leader 设计的复杂性。</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p><strong>写入频率问题</strong></p><p>快照不能创建的太频繁，否则会消耗大量磁盘带宽和其它资源。快照创建的频率太低，需要承受耗尽存储容量的风险，同时增加了回放日志的时间。解决上述问题一个简单策略就是设置一个阈值。</p><p><strong>服务暂停问题</strong></p><p>写入快照需要消耗显著的一段时间，并且我们不希望影响到正常的操作。可以通过 Copy-On-Write 技术解决该问题，如利用 Linux 上的 fork 指令复制父进程及所有内存中的状态，在子进程创建快照，父进程继续提供 Raft 基本服务。</p><h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><p>Raft 的安全性是为了保证每一个状态机会按照相同顺序执行相同的指令，即保证每个服务节点上的日志（数据副本）是一致的。如果没有安全性，数据的正确性和一致性就不能得到保证。例如，一个跟随者可能会进入不可用状态，同时领导者已经提交了一些日志条目，如果没有安全性，这个跟随者可能会被选举为领导者并且覆盖这些日志条目。前面的章节主要描述了 Raft 算法是如何选举和复制日志的，其中已经穿插了不少的安全机制，本章节对安全性进行补充。</p><p><strong>选举限制</strong></p><p>Raft 是一种强领导者模型的算法，只有从集群中选举出 Leader 才能处理客户端请求和协调 Raft 内部运行机制（如：心跳、日志复制，以及它们对应的一致性检查等）。</p><p>一个任期内只允许有一个领导者，这是由<strong>一个服务节点某一任期内最多只能投一票</strong> 和 <strong>只有获得 majority 投票的服务节点才会成为 Leader</strong> 这两个原则来保证的。为了实现这种机制，服务节点需要保证将自己的投票信息持久化，这样就能在服务节点崩溃之后也能恢复到之前的状态。否则就会出现服务节点已经作出投票，但在崩溃重启后在同一任期内将票又投给了另外一个不同服务节点的情况。</p><p>当一个候选者发起投票请求，它会包括自身的日志记录信息，索引 index、任期号 term 。当跟随者接收到请求，它会将候选者的日志信息与自己的日志信息进行比较，如果投票者的日志更完整，那么它会拒绝投票。Raft 是通过比较两份日志中最后一条日志条目的索引值和任期号定义哪个日志更新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更新，如果两份日志最后的条目任期号相同，则索引值大的更新。</p><p>Raft 保证所有之前的任期号中已经提交的日志条目都会出现在新的领导者中，不需要传送这些日志条目给领导者。这意味着日志条目是单向传送的，只能从领导者传给跟随者，并且领导者从不会覆盖自身本地日志中已经存在的日志条目。</p><p><strong>当前任期提交</strong></p><p>只要日志条目被复制到大多数的服务节点上，领导者就可以提交当前任期内的这一日志条目。领导者不会根据大多数原则去提交一个之前任期内的日志条目，只会根据大多数提交当前任期的日志条目。一旦当前任期的日志条目被提交，那么根据日志匹配特性，之前的日志条目也都会被间接的提交。如果领导者被选举后迟迟收不到客户端的请求，也就是意味着该领导者还不能确认哪些日志条目被提交，基于这个问题 Raft 通过让每个 Leader 在其任期开始时向日志中提交一个空的没有任何操作的日志条目，立即尝试复制来处理这个问题。</p><p><strong>状态机安全</strong></p><p>Raft 中某个节点将某一位置的日志条目应用到状态机，那么其它节点在同一位置不能应用不同的日志，也就是说，所有节点在同一位置（index）必须应用同样的日志。</p><h1 id="成员变更"><a href="#成员变更" class="headerlink" title="成员变更"></a>成员变更</h1><p>Raft 算法是强领导者模型，领导者选举建立在大多数的基础之上，当集群中的成员变更时就可能同时存在新旧配置的 2 个大多数，进而出现两个领导者，这会破坏 Raft 集群的领导者唯一性，影响了集群的运行。</p><p>尽管可以通过暂停整个集群，更新所有配置，然后重启整个集群的方式来解决因集群变更带来的问题，但是在更改的时候集群会不可用。Raft 通过单节点变更来解决成员变更问题。这里我们需要明确两个定义：</p><p><strong>配置</strong></p><blockquote><p>这里的配置是对集群中节点的描述，包括每台服务节点的 ID 、网络地址等。比如：A、B、C 组成的集群，那么集群的配置就是 [A、B、C] 集合。这些信息都非常重要，因为我们需要用它们来决定多数票的具体数量，从而进行领导者选举或用来提交日志。</p></blockquote><p><strong>单节点变更</strong></p><blockquote><p>单节点变更是利用一次变更一个节点，不会同时存在旧配置和新配置 2 个 大多数的特性，实现成员变更。</p></blockquote><h1 id="节点奔溃"><a href="#节点奔溃" class="headerlink" title="节点奔溃"></a>节点奔溃</h1><p>前面的章节对领导者节点的奔溃进行不同场景的介绍，核心关注点在于领导者节点奔溃的时机，不同时机奔溃集群处理不同，但是关键一点是大多数共识的日志条目不会丢失。跟随者和候选者奔溃后的处理方式相对比较简单，并且它们处理的方式相同。如果跟随者或者候选者奔溃了，后续发送它们的 RPC 消息都会失败。Raft 中处理这种失败就是简单的通过无限重试，如果奔溃的节点恢复了，那么 RPC 消息就会成功。如果一个服务节点完成了一个 RPC 请求，但是还没有响应的时候奔溃了，那么恢复后就会再次收到同样的请求。Raft 的 RPC 都是幂等的，所以这样重试不会造成任何问题。</p><h1 id="客户端协议"><a href="#客户端协议" class="headerlink" title="客户端协议"></a>客户端协议</h1><p><strong>请求领导者</strong></p><p>Raft 中的客户端发送所有请求给领导者，当客户端请求的不是领导者时，那么该服务节点会拒绝客户端的请求并向客户端提供它最近接收到的领导者的信息（AppendEntries RPC包含了领导者的网络地址）。如果领导者已经崩溃了，那么客户端的请求就会超时，客户端之后会再次重试随机挑选服务节点。</p><p><strong>线性语意</strong></p><p>Raft 的目标是要实现线性语义（每一次操作立即执行，只执行一次），但 Raft 是可以执行同一条指令多次的，如领导者提交日志条目后宕机了，那么客户端会和新的领导者重试这条指令，导致这条指令被再次执行。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令。</p><p>Raft 读取的是状态机运算后的数据。Raft 的读操作虽然直接从领导者节点读取，但是在网络分区的情况下可能会返回脏数据，而线性的读操作必须不能返回脏数据，Raft 使用两个额外的措施保证这一点。首先，领导者必须有关于被提交日志的最新信息，领导者完全特性保证了领导者一定拥有所有已经被提交的日志条目，但是在它任期开始的时候，可能还不知道哪些是已经被提交的，为了知道这些信息，它需要在它的任期里提交一条日志条目。Raft 中通过领导者在任期开始的时候提交一个空白的没有任何操作的日志条目到日志中去来实现。第二，领导者在处理只读的请求之前必须检查自己是否已经被废黜了（更新的领导者被选举出来）。Raft 中通过让领导人在响应只读请求之前，先和集群中的大多数节点交换一次心跳信息来处理这个问题。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Raft 算法本质上是通过复制日志来实现共识的，和客户端的交互依赖状态机执行日志条目的指令，集群内部通过选举、心跳、日志复制来协调。Raft 具体的做法是将共识问题分解为多个独立的子问题，高度概括为：先选举出领导者，由它完全负责 <code>replicated log</code> 的管理。此外，接受客户端写请求，然后复制到跟随者节点，并在 <code>安全</code> 的时候执行这些请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Raft 是一个共识算法（consensus algorithm），也称作 Raft 协议。所谓共识就是多个节点就某个事情达成一致，即使是在
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://gentryhuang.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Raft" scheme="https://gentryhuang.com/tags/Raft/"/>
    
      <category term="共识算法" scheme="https://gentryhuang.com/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - 链表</title>
    <link href="https://gentryhuang.com/posts/2362a8ea/"/>
    <id>https://gentryhuang.com/posts/2362a8ea/</id>
    <published>2021-03-16T11:33:59.000Z</published>
    <updated>2021-04-06T08:37:27.429Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol><li><p>redis中的链表</p><p>链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置这中数据结构，所以redis构建了自己的链表实现。</p></li><li><p>redis链表节点的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">  <span class="comment">// 前置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="comment">// 后置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">// 节点的值 (可用于保存各种不同类型的值)</span></span><br><span class="line">  <span class="keyword">void</span> *value</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>redis链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数，用于复制链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数，用于释放链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数，用于对比链表节点所保存的值和其他值是否相等</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>redis链表的特点</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)</span><br><span class="line">- 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点</span><br><span class="line">- 带表头和表尾指针：使用list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)</span><br><span class="line">- 带链表长度计数器：程序使用list结构的len属性标记链表中节点的个数，程序获取链表中节点个数的复杂度为O(1)</span><br><span class="line">- 多态：链表可以保存各种不同类型的值</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>链表在redis中的应用</p><p>链表被广泛用于实现redis的各种功能，如：列表键、发布与订阅、慢查询、监视器，redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;redis中的链表&lt;/p&gt;
&lt;p&gt;链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis数据结构" scheme="https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - 简单动态字符串</title>
    <link href="https://gentryhuang.com/posts/aa1d8127/"/>
    <id>https://gentryhuang.com/posts/aa1d8127/</id>
    <published>2021-03-13T11:00:50.000Z</published>
    <updated>2021-04-06T08:37:12.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h3><ol><li><p>初识动态字符串</p><p>redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS作为redis的默认字符串表示。 <code>在redis中，c字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如日志。当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，redis就会使用SDS来表示字符串值。</code> 值的注意的是，对于redis中的key都是使用SDS来实现的。此外，SDS除了用来保存Redis数据库中的字符串值之外，SDS还被用作缓冲区（buffer）: AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区。</p></li><li><p>sds的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">  <span class="comment">// 记录buf数组中已使用字节的数量等价于sds所保存字符串的长度</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">  <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">  <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>sds遵循c字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在sds的len属性中，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由sds函数自动完成的。遵循空字符结尾的好处是，sds可以直接使用一部分C字符串函数库里面的函数。</p></li><li><p>sds与c字符串的区别</p><p>c语言使用的简单字符串表示方式，并不能满足redis对字符串在安全性、效率以及功能方面的要求。</p><p>3.1  常数复杂度获取字符串长度</p><blockquote><p>因为c字符串并不记录自身的长度信息，所以要获取长度就必须遍历整个字符串，故获取字符串长度的复杂度为O(N)。而redis的sds结构中通过len属性记录了sds的长度，故获取字符串长度的复杂度为O(1)。注意，设置和更新sds长度的工作是由sds的API在执行时自动完成的，使用sds无须进行任何手动修改长度的操作。</p></blockquote><p>3.2 避免缓冲区溢出</p><blockquote><p>c字符串不记录自身长度，很容易造成缓冲区溢出。与c字符串不同，sds的空间分配策略完全杜绝了发生缓冲区溢出的可能性，当sds api需要对sds进行修改时，api会先检查sds的空间是否满足需要，如果不满足的话，api会自动将sds的空间扩展至执行所需的大小，然后才执行实际的修改操作，因此使用sds既不需要手动修改sds的空间大小，也不会出现c字符串中可能出现的缓冲区溢出问题。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line">    <span class="comment">//追加时先进行扩容，后面详细说明</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//拼接字符串</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s:原数组     </span></span><br><span class="line"><span class="comment">//strlen(t) 需拼接的目标数组的长度</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>3.3 内存分配与释放</p><p>因为c字符串的长度和底层数组的长度之间存在着关联性，所以<code>每次增加或者缩短一个c字符串，程序都总要对保存这个c字符串的数字进行一次分配操作</code>，但是内存分配操作涉及到复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，为了避免c字符串的这种缺陷，sds通过未使用空间解除了字符串长度和底层数组长度之间的关联，通过未使用空间，sds实现了空间预分配和惰性空间释放两种优化策略。</p><ul><li><p>空间预分配</p><p>空间预分配用于优化sds的字符串增长操作：当sds的api对一个sds进行修改，并且需要对sds进行空间扩展的时候，程序不仅会为sds分配修改所必须要的空间，还会为sds分配额外的未使用空间。通过空间预分配策略，redis可以减少连续执行字符串增长操作所需的内存重新分配次数，在扩展sds空间之前，sds api 会先检查未使用空间是否足够，如果足够就直接使用未使用空间，而不需要执行内存重新分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis 扩容源码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，</span></span><br><span class="line"><span class="comment"> * buf 至少会有 addlen + 1 长度的空余空间</span></span><br><span class="line"><span class="comment"> * （额外的 1 字节是为 \0 准备的）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *  sds ：扩展成功返回扩展后的 sds</span></span><br><span class="line"><span class="comment"> *        扩展失败返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前的空余空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 最少需要的长度</span></span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class="line">        <span class="comment">// 那么为它分配两倍于所需长度的空间</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足，分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 sds 的空余长度</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 sds</span></span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额外分配未使用空间数量的计算策略：</p><blockquote><ol><li>对sds修改后，sds的长度（即len属性的值）小于1MB，那么程序分配和len属性同样大小的未使用空间，这时sds的len属性的值将和free属性的值相同。例如：修改后sds的len变成10字节，那么程序也会分配10字节的未使用空间，sds的buf数组的实际长度：10 + 10 + 1 = 21字节</li><li>对sds修改后，sds的长度大于等于1MB，那么程序会分配1MB的未使用空间。例如：修改后sds的len变成30MB，那么程序会分配1MB的未使用空间，sds的buf数组的时间长度：30MB + 1MB + 1byte</li></ol></blockquote></li><li><p>惰性空间释放</p><p>惰性空间释放用于优化sds的字符串缩短操作：当sds的api需要缩短sds保存的字符串时，程序并不立即使用内存重分配来回收缩短后多来的字节，而是使用free属性将这些字节的数量纪录起来，用于将来对sds进行增长操作时，这些未使用空间可能就派上用场了。注意，sds也提供了相应的api，可以真正地释放sds的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</p></li></ul><p>3.4 二进制安全</p><blockquote><p>c字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里不能包含空字符，否则在读取的时候会被默认为结束字符，这些限制使得c字符串只能保存文本数据，不能保存图片、音视频、压缩文件这类的二进制数据。sds的api都是二进制安全的，所有的sds api都会以<code>二进制的方式处理sds存放在buf数组里的数据</code>,程序不会对其中的数据做任何限制、过滤，数据写入时是什么样，它被读取时就是什么样。<code>这也是将sds的buf属性称为字节数组的原因，redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据</code>。</p></blockquote></li><li><p>c字符串和sds之间的区别</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         C字符串                                    SDS</span><br><span class="line">- 获取字符串长度的复杂度为O（n）                 获取字符串长度的复杂度O（1）</span><br><span class="line">- API是不安全的，可能造成缓冲区溢出                      API是安全的</span><br><span class="line">- 修改字符串长度N次，必然要执行N次内存重分配     修改字符长度N次，最多执行N次内存重分配</span><br><span class="line">- 只能保存文本数据                                 可以保存文本或者二进制数据</span><br><span class="line">- 可使用&lt;string.h&gt;库中的函数                   可使用一部分&lt;string.h&gt;库中的函数</span><br></pre></td></tr></table></figure></li><li><p>sds更多的api可参考源码</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简单动态字符串&quot;&gt;&lt;a href=&quot;#简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;简单动态字符串&quot;&gt;&lt;/a&gt;简单动态字符串&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初识动态字符串&lt;/p&gt;
&lt;p&gt;redis没有直接使用C语言传统的字符串表示（以空字
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis数据结构" scheme="https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 异步改造</title>
    <link href="https://gentryhuang.com/posts/c812f120/"/>
    <id>https://gentryhuang.com/posts/c812f120/</id>
    <published>2021-02-13T16:00:00.000Z</published>
    <updated>2021-04-06T08:30:21.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从 2.7.0 版本开始，Dubbo 的所有异步编程接口开始以 <code>CompletableFuture</code> 为基础，不仅支持了服务提供方的异步执行，而且对当前的异步调用功能进行了增强。异步改造引入了一些功能接口和实现，以及对部分逻辑进行了调整，但底层逻辑并没有改变，本篇文章将对 Dubbo 的异步演进进行介绍。</p><h1 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h1><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-invoke-model.jpg" alt></p><p><strong>Dubbo 的远程调用中大致可以分为以上 4 种调用方式：</strong></p><ul><li><strong>oneway:</strong> 客户端发送消息后，不需要接收响应。对于不需要关心服务响应结果的请求适合 oneway 通信。</li><li><strong>sync:</strong> Dubbo 默认的通信方式，即同步调用。</li><li><strong>async:</strong> 异步调用范畴，使用 Future 的方式获取结果。</li><li><strong>future:</strong> 异步调用范畴，使用 CompletableFuture 获取结果，也支持通过 Future 的方式获取结果。</li></ul><p><strong>注意：</strong> Dubbo 中的调用方式可以分为两大类，oneway 和 twoway ，对于 Dubbo 协议来说，会对这两种方式做分别处理，对于非 Dubbo 协议不会特别区分。</p><h1 id="Dubbo-2-6-x-异步实现"><a href="#Dubbo-2-6-x-异步实现" class="headerlink" title="Dubbo 2.6.x 异步实现"></a>Dubbo 2.6.x 异步实现</h1><p>Dubbo 2.6.x 的异步实现是针对消费端异步，只需指定调用方式为异步调用，并在需要结果的地方从 <strong>RpcContext</strong> 中取出 <strong>Future</strong> 获取结果即可。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>指定异步调用<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置 async = true，表示异步调用。默认是 false，同步调用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">async</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li>通过上下文取出 Future<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String hello = demoService.sayHello(<span class="string">"world"</span>); <span class="comment">// call remote method</span></span><br><span class="line">Future&lt;String&gt; future = RpcContext.getContext().getFuture();</span><br><span class="line">String result = future.get();</span><br></pre></td></tr></table></figure></li></ol><p>具体调用实现可以参考 <a href="https://gentryhuang.com/posts/26722deb/#%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8">Dubbo异步调用</a> 。</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>Dubbo 2.6.x 提供了一定的异步编程能力，但其异步方式存在以下问题：</p><ul><li>Future 获取方式不够直接，业务方需要从 RpcContext 中获取。如果同时进行多个异步调用，如果使用不当很容易造成上下文污染。</li><li>Future 接口无法实现自动回调，而且定义的 ResponseFure (2.7 已经废弃)虽然支持回调，但支持的异步场景有限，并且不支持 Future 间的相互协调。</li><li>不支持服务端异步。</li></ul><h1 id="Dubbo-2-7-x-异步实现"><a href="#Dubbo-2-7-x-异步实现" class="headerlink" title="Dubbo 2.7.x 异步实现"></a>Dubbo 2.7.x 异步实现</h1><p>Dubbo 2.7.x 异步改造是对 Dubbo 2.6.x 异步功能的增强，引入的 <code>CompletableFuture</code> 既支持 <code>Future</code> 又支持 <code>Callback</code> 的调用方式，使用方可以根据需要自行选择。</p><h2 id="基础模型"><a href="#基础模型" class="headerlink" title="基础模型"></a>基础模型</h2><p>Dubbo 2.7.x 对异步实现进行了改造，引入了相关的接口和实现类，异步实现需要这些相关的基础模型配合完成。下面我们先对基础模型进行介绍。</p><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Result 相关的继承关系如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-invoke-transform-result-uml.jpg" alt></p><p>在 Dubbo 2.6.x 中统一使用 <code>RpcResult</code> 表示调用结果，Dubbo 2.7.x 中废弃了 <code>RpcResult</code> ，采用以下三个对象表示结果状态。</p><ul><li>AsyncRpcResult<blockquote><p>表示的是一个异步的、未完成的RPC调用，是在调用链中实际传递的对象。</p></blockquote></li><li>AppResponse<blockquote><p>表示的是服务端返回的具体响应，相当于 Dubbo 2.6.x 中的 RpcResult 。其子类是 DecodeableRpcResult。</p></blockquote></li><li>CompletableFuture<blockquote><p>表示的是服务端返回的结果，由调用端创建，用于封装 AppResponse 对象。其中 DefaultFuture 继承该类。</p></blockquote></li></ul><p>三者关系：AppResponse -&gt; CompletableFuture -&gt; AsyncResult ，下面我们对其进行介绍。</p><h4 id="AppResponse"><a href="#AppResponse" class="headerlink" title="AppResponse"></a>AppResponse</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppResponse</span> <span class="keyword">implements</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6925924956850004727L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应结果</span></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的异常信息</span></span><br><span class="line">    <span class="keyword">private</span> Throwable exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的附加信息</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; attachments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppResponse</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppResponse</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exception = exception;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">recreate</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 1 异常处理</span></span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// fix issue#619</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// get Throwable class</span></span><br><span class="line">                Class clazz = exception.getClass();</span><br><span class="line">                <span class="keyword">while</span> (!clazz.getName().equals(Throwable<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">                    clazz = clazz.getSuperclass();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// get stackTrace value</span></span><br><span class="line">                Field stackTraceField = clazz.getDeclaredField(<span class="string">"stackTrace"</span>);</span><br><span class="line">                stackTraceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                Object stackTrace = stackTraceField.get(exception);</span><br><span class="line">                <span class="keyword">if</span> (stackTrace == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    exception.setStackTrace(<span class="keyword">new</span> StackTraceElement[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它方法 getter/setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AppResponse</code> 是调用的实际返回类型，相当于 Dubbo 2.6.x 中的 <code>RpcResult</code> ，理论上不需要实现 <code>Result</code> 接口，这样做是为了兼容。 </p><h4 id="DecodeableRpcResult"><a href="#DecodeableRpcResult" class="headerlink" title="DecodeableRpcResult"></a>DecodeableRpcResult</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeableRpcResult</span> <span class="keyword">extends</span> <span class="title">AppResponse</span> <span class="keyword">implements</span> <span class="title">Codec</span>, <span class="title">Decodeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(DecodeableRpcResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 通道</span></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">// 序列化类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> serializationType;</span><br><span class="line">    <span class="comment">// 序列化相关的输入流</span></span><br><span class="line">    <span class="keyword">private</span> InputStream inputStream;</span><br><span class="line">    <span class="comment">// 响应对象</span></span><br><span class="line">    <span class="keyword">private</span> Response response;</span><br><span class="line">    <span class="comment">// 调用信息</span></span><br><span class="line">    <span class="keyword">private</span> Invocation invocation;</span><br><span class="line">    <span class="comment">// 标志是否已经解码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasDecoded;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecodeableRpcResult</span><span class="params">(Channel channel, Response response, InputStream is, Invocation invocation, <span class="keyword">byte</span> id)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(channel, <span class="string">"channel == null"</span>);</span><br><span class="line">        Assert.notNull(response, <span class="string">"response == null"</span>);</span><br><span class="line">        Assert.notNull(is, <span class="string">"inputStream == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.response = response;</span><br><span class="line">        <span class="keyword">this</span>.inputStream = is;</span><br><span class="line">        <span class="keyword">this</span>.invocation = invocation;</span><br><span class="line">        <span class="keyword">this</span>.serializationType = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">+--- DecodeableRpcResult</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 没有解码，则进行解码</span></span><br><span class="line">        <span class="keyword">if</span> (!hasDecoded &amp;&amp; channel != <span class="keyword">null</span> &amp;&amp; inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 解码</span></span><br><span class="line">                decode(channel, inputStream);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Decode rpc result failed: "</span> + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                response.setStatus(Response.CLIENT_ERROR);</span><br><span class="line">                response.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                hasDecoded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">---</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            Thread thread = Thread.currentThread();</span><br><span class="line">            log.debug(<span class="string">"Decoding in thread -- ["</span> + thread.getName() + <span class="string">"#"</span> + thread.getId() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 确定序列化方式，用于反序列化</span></span><br><span class="line">        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">                .deserialize(channel.getUrl(), input);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 读取一个 byte 的标志位，其值可能有 6 种</span></span><br><span class="line">        <span class="keyword">byte</span> flag = in.readByte();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 根据标志位判断当前结果中包含的信息，并调用不同的方法进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE:</span><br><span class="line">                handleValue(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION:</span><br><span class="line">                handleException(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">                handleAttachment(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">                <span class="comment">// 根据 RpcInvocation 中记录的返回值类型读取返回结果，并设置到当前类的 result 字段</span></span><br><span class="line">                handleValue(in);</span><br><span class="line">                <span class="comment">// 读取附加信息并设置到当前类的 attachmetns 中</span></span><br><span class="line">                handleAttachment(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:</span><br><span class="line">                handleException(in);</span><br><span class="line">                handleAttachment(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unknown result flag, expect '0' '1' '2' '3' '4' '5', but received: "</span> + flag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) in).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">---</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleValue</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 返回结果类型</span></span><br><span class="line">            Type[] returnTypes;</span><br><span class="line">            <span class="keyword">if</span> (invocation <span class="keyword">instanceof</span> RpcInvocation) &#123;</span><br><span class="line">                returnTypes = ((RpcInvocation) invocation).getReturnTypes();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                returnTypes = RpcUtils.getReturnTypes(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2 根据返回结果类型获取结果</span></span><br><span class="line">            Object value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (ArrayUtils.isEmpty(returnTypes)) &#123;</span><br><span class="line">                <span class="comment">// This almost never happens?</span></span><br><span class="line">                value = in.readObject();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                value = in.readObject((Class&lt;?&gt;) returnTypes[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = in.readObject((Class&lt;?&gt;) returnTypes[<span class="number">0</span>], returnTypes[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3 设置结果 result</span></span><br><span class="line">            setValue(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            rethrow(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DecodeableRpcResult</code> 主要对响应结果进行解码，从字节流中获取数据对象。</p><h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p><code>CompletableFuture</code> 是 Java 8 提供的异步编程类，Dubbo 2.7.x 中的 <code>DefaultFuture</code> 继承了 CompletableFuture ，Dubbo 协议下对于 twoway 请求都会返回一个 <code>DefaultFuutre</code> 对象。此外，<code>DefaultFuture</code> 支持在请求的时候指定线程池，用来处理请求的响应，具体的我们会在下一篇文章中分析。</p><h4 id="AsyncRpcResult"><a href="#AsyncRpcResult" class="headerlink" title="AsyncRpcResult"></a>AsyncRpcResult</h4><p><code>AsyncRpcResult</code> 是在调用链中实际传递的对象，表示一个异步的，未完成的RPC调用。注意，它并不是实际的调用结果，<code>AppResponse</code> 才是业务结果。</p><h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncRpcResult</span> <span class="keyword">implements</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AsyncRpcResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当回调发生时，RpcContext 可能已经被更改。即执行 AsyncRpcResult 上添加的回调方法的线程可能先后处理过多个不同的 AsyncRpcResult 。</span></span><br><span class="line">    <span class="comment">// 因此，我们应该保留当前RpcContext实例的引用，并在回调执行之前恢复它。</span></span><br><span class="line">    <span class="keyword">private</span> RpcContext storedContext;</span><br><span class="line">    <span class="keyword">private</span> RpcContext storedServerContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此次 RPC 调用关联的线程池</span></span><br><span class="line">    <span class="keyword">private</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此次 RPC 调用关联的 Invocation 对象</span></span><br><span class="line">    <span class="keyword">private</span> Invocation invocation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求返回的对象 （由调用端创建）</span></span><br><span class="line">    <span class="keyword">private</span> CompletableFuture&lt;AppResponse&gt; responseFuture;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在构造方法中除了接收发送请求返回的 CompletableFuture&lt;AppResponse&gt; 对象，还会保存当前的 RPC 上下文</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncRpcResult</span><span class="params">(CompletableFuture&lt;AppResponse&gt; future, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.responseFuture = future;</span><br><span class="line">        <span class="keyword">this</span>.invocation = invocation;</span><br><span class="line">        <span class="keyword">this</span>.storedContext = RpcContext.getContext();</span><br><span class="line">        <span class="keyword">this</span>.storedServerContext = RpcContext.getServerContext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，<code>responseFuture</code> 属性不仅针对 Dubbo 协议，HTTP等协议调用返回结果也是 <code>CompletableFuture</code> 对象，都是由调用端创建。区别在于 Dubbo 协议一般返回的是 <code>DefaultFuture</code> 对象，而 HTTP 等协议会构造一个 <code>CompletableFuture</code> 对象，我们会在下面内容提到。</p><h5 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h5><p><code>AsyncRpcResult</code> 获取结果本质上需要先获取发送请求返回的 <code>CompletableFuture</code> ，也就是 <strong>responseFuture</strong> 属性，然后再从 <strong>responseFuture</strong> 中获取 <code>AppResponse</code> 对象，最后调用其对应的方法。</p><h6 id="获取-CompletableFuture"><a href="#获取-CompletableFuture" class="headerlink" title="获取 CompletableFuture"></a>获取 CompletableFuture</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">   <span class="function"><span class="keyword">public</span> CompletableFuture&lt;AppResponse&gt; <span class="title">getResponseFuture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="获取-AppResponse"><a href="#获取-AppResponse" class="headerlink" title="获取 AppResponse"></a>获取 AppResponse</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">getAppResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果完成，则获取 AppResponse</span></span><br><span class="line">            <span class="keyword">if</span> (responseFuture.isDone()) &#123;</span><br><span class="line">                <span class="keyword">return</span> responseFuture.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// This should not happen in normal request process;</span></span><br><span class="line">            logger.error(<span class="string">"Got exception when trying to fetch the underlying result from AsyncRpcResult."</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取默认的 AppResponse</span></span><br><span class="line">        <span class="keyword">return</span> createDefaultValue(invocation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法将始终在最大 timeout 等待之后返回：</span></span><br><span class="line"><span class="comment">     * 1. 如果value在超时前返回，则正常返回。</span></span><br><span class="line"><span class="comment">     * 2. 如果timeout之后没有返回值，则抛出TimeoutException。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">       <span class="comment">// 针对 ThreadlessExecutor 的特殊处理，这里调用 waitAndDrain() 等待响应</span></span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">            threadlessExecutor.waitAndDrain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseFuture.get(timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">            threadlessExecutor.waitAndDrain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseFuture.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中 <code>ThreadlessExecutor</code> 是一个特殊的线程池，主要用来解决同步调用模式下的响应，是对线程模型的优化，我们在下一篇文章中进行详细说明。</p><h6 id="获取结果-1"><a href="#获取结果-1" class="headerlink" title="获取结果"></a>获取结果</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">recreate</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation rpcInvocation = (RpcInvocation) invocation;</span><br><span class="line">        <span class="comment">//  1 如果是服务端的异步实现，则从上下文中取。</span></span><br><span class="line">        <span class="comment">// 为什么？ 因为接口返回的结果是 CompletableFuture,属于异步范畴（服务端的异步），和消费端异步类似。</span></span><br><span class="line">        <span class="keyword">if</span> (InvokeMode.FUTURE == rpcInvocation.getInvokeMode()) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcContext.getContext().getFuture();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 获取 AppResponse 中的结果</span></span><br><span class="line">        <span class="keyword">return</span> getAppResponse().recreate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AsyncRpcResult.recreate()</code> 方法是获取结果的方法，也就是从 <code>AppResponse</code> 中获取结果。</p><h6 id="添加回调"><a href="#添加回调" class="headerlink" title="添加回调"></a>添加回调</h6><p>回调是 Dubbo 2.7.x 异步改造的重要角色，<code>AsyncRpcResult</code> 支持添加回调方法，而这个回调方法会被包装一层并注册到 <strong>responseFuture</strong> 上，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">whenCompleteWithContext</span><span class="params">(BiConsumer&lt;Result, Throwable&gt; fn)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在responseFuture之上注册回调</span></span><br><span class="line">        <span class="keyword">this</span>.responseFuture = <span class="keyword">this</span>.responseFuture.whenComplete((v, t) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 将当前线程的 RpcContext 记录到临时属性中，然后将构造函数中存储的 RpcContext 设置到当前线程中，为后面的回调执行做准备</span></span><br><span class="line">            beforeContext.accept(v, t);</span><br><span class="line">            <span class="comment">// 执行回调 （使用的 RpcContext 是回调所属服务方法的调用线程的 RpcContext）</span></span><br><span class="line">            fn.accept(v, t);</span><br><span class="line">            <span class="comment">// 恢复线程原有的 RpcContext</span></span><br><span class="line">            afterContext.accept(v, t);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在添加回调时，需要使用 <strong>beforeContext</strong> 和 <strong>afterContext</strong> 来保证执行回调的线程的 RpcContext 是最初创建 <code>AsyncRpcResult</code> 对象的线程对应的 RpcContext，执行完回调后需要将执行回调的线程的 RpcContext 恢复到原有值。其中 <strong>beforeContext</strong> 用于保存执行回调线程的 RpcContext，并将最初创建 <code>AsyncRpcResult</code> 对象的线程的 RpcContext 临时设置到执行回调用线程中，为执行回调做准备。<strong>afterContext</strong> 用于恢复执行回调用的线程原有的 RpcContext 。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="keyword">private</span> RpcContext tmpContext;</span><br><span class="line">    <span class="keyword">private</span> RpcContext tmpServerContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BiConsumer&lt;Result, Throwable&gt; beforeContext = (appResponse, t) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 将当前线程的 RpcContext 记录到 tmpContext 中</span></span><br><span class="line">        tmpContext = RpcContext.getContext();</span><br><span class="line">        tmpServerContext = RpcContext.getServerContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将构造函数中存储的 RpcContext (也就是创建 AsyncRpcResult 线程的 RpcContext) 设置到当前线程中</span></span><br><span class="line">        RpcContext.restoreContext(storedContext);</span><br><span class="line">        RpcContext.restoreServerContext(storedServerContext);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BiConsumer&lt;Result, Throwable&gt; afterContext = (appResponse, t) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 将当前线程的 RpcContext 恢复到原始值</span></span><br><span class="line">        RpcContext.restoreContext(tmpContext);</span><br><span class="line">        RpcContext.restoreServerContext(tmpServerContext);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>如此一来，<code>AsyncRpcResult</code> 就可以随意添加回调，无需担心 RpcContext 被污染。</p><p><code>AsyncRpcResult</code> 整个是为异步请求设计的，但是 Dubbo 中默认的请求方式是同步的，那么 Dubbo 又是如何支持同步调用的呢？Dubbo 进行服务引用时，在 <code>AbstractProtocol.refer()</code> 方法中，Dubbo 会将 <code>AbstractProtocol.protocolBindingRefer()</code> 方法实现返回的 Invoker 对象使用 <code>AsyncToSyncInvoker</code> 封装一层，该对象中的调用逻辑会对同步调用专门处理，我们在下面的内容中进行介绍。相比较而言，Dubbo 2.6.x 在 Dubbo 协议做了异步转同步处理，就是在调用时拿到 <code>DefaultFuture</code> 后立即阻塞等待结果。HTTP 协议就没有异步调用支持，而 Dubbo 2.7.x 使用了 <code>AbstractInvoker</code> 对 <strong>Future</strong> 功能进行统一支持，也就是 HTTP 协议也基本上支持了调用异步。</p><h3 id="Invoker"><a href="#Invoker" class="headerlink" title="Invoker"></a>Invoker</h3><h4 id="AsyncToSyncInvoker"><a href="#AsyncToSyncInvoker" class="headerlink" title="AsyncToSyncInvoker"></a>AsyncToSyncInvoker</h4><p><code>AsyncToSyncInvoker</code> 描述了异步转同步的逻辑，是对 <code>AsyncRpcResult</code> 获取结果的补充，触发时机是在执行调用的时候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncToSyncInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 服务引用的 Invoker</span></span><br><span class="line">    <span class="keyword">private</span> Invoker&lt;T&gt; invoker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncToSyncInvoker</span><span class="params">(Invoker&lt;T&gt; invoker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.invoker = invoker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> invoker.getInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        Result asyncResult = invoker.invoke(invocation);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是同步调用，则调用 get() 方法，阻塞等待响应返回。</span></span><br><span class="line">            <span class="comment">// 调用的是 AsyncRpcResult.get 方法，其底层调用的是 CompletableFuture 的 get 方法</span></span><br><span class="line">            <span class="keyword">if</span> (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * NOTICE!</span></span><br><span class="line"><span class="comment">                 * must call &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get(long, TimeUnit)&#125; because</span></span><br><span class="line"><span class="comment">                 * &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get()&#125; 被证明有严重的性能下降。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Interrupted unexpectedly while waiting for remote result to return!  method: "</span> +</span><br><span class="line">                    invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> TimeoutException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> +</span><br><span class="line">                        invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RemotingException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> +</span><br><span class="line">                        invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.UNKNOWN_EXCEPTION, <span class="string">"Fail to invoke remote method: "</span> +</span><br><span class="line">                        invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非同步调用直接返回调用结果 AsyncRpcResult</span></span><br><span class="line">        <span class="keyword">return</span> asyncResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AsyncToSyncInvoker</code> 是 Invoker 的装饰器，负责将异步调用转换成同步调用，也就是调用 <code>AsyncRpcResult</code> 中的 <code>CompletableFuture.get</code> 方法实现同步等待。相比 Dubbo 2.6.x 还是有很大区别的，Dubbo 2.6.x 使用 <strong>Future.get</strong> 功能阻塞等待，业务线程将处于阻塞等待状态，返回结果时需要消费端 Dubbo 线程池将结果写到 DefaultFuture 中，业务线程才能取出并返回。Dubbo 2.7.x 彻底优化了这种线程模型，关于优化的背景和实现会在下一篇文章中进行介绍，这里先了解即可。</p><h4 id="AbstractProxyInvoker"><a href="#AbstractProxyInvoker" class="headerlink" title="AbstractProxyInvoker"></a>AbstractProxyInvoker</h4><p><code>AbstractProxyInvoker</code> 是 Dubbo 框架在服务暴露过程中创建的对象，由 <code>ProxyFactory.getInvoker</code> 创建，是对服务接口实现的封装。该过程对 Dubbo 中所有协议一致。</p><h4 id="AbstractInvoker"><a href="#AbstractInvoker" class="headerlink" title="AbstractInvoker"></a>AbstractInvoker</h4><p>Dubbo 在服务引用时会创建消费端的 <code>Invoker</code>，对于不同的协议创建的 <code>Invoker</code> 有所不同。下面我们对 <strong>Dubbo 协议</strong> 和 <strong>使用 HTTP 通信的协议</strong> 创建 <code>Invoker</code> 流程进行分析。其中每个协议创建的 <code>Invoker</code> 都会继承 <code>AbstractInvoker</code> 抽象类，该抽象类中定义了通用的执行逻辑，如调用模式的确定。</p><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 Invoker 对象封装的业务接口类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="comment">// 当前 Invoker 关联的 URL 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="comment">// 当前 Invoker 关联的一些附加信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attachment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标志 Invoker 的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> available = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractInvoker</span><span class="params">(Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(type, url, (Map&lt;String, Object&gt;) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractInvoker</span><span class="params">(Class&lt;T&gt; type, URL url, String[] keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(type, url, convertAttachment(url, keys));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractInvoker</span><span class="params">(Class&lt;T&gt; type, URL url, Map&lt;String, Object&gt; attachment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"service type == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"service url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.attachment = attachment == <span class="keyword">null</span> ? <span class="keyword">null</span> : Collections.unmodifiableMap(attachment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="invoke-方法"><a href="#invoke-方法" class="headerlink" title="invoke 方法"></a>invoke 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// if invoker is destroyed due to address refresh from registry, let's allow the current invoke to proceed</span></span><br><span class="line">        <span class="keyword">if</span> (destroyed.get()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Invoker for service "</span> + <span class="keyword">this</span> + <span class="string">" on consumer "</span> + NetUtils.getLocalHost() + <span class="string">" is destroyed, "</span></span><br><span class="line">                    + <span class="string">", dubbo version is "</span> + Version.getVersion() + <span class="string">", this invoker should not be used any longer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcInvocation invocation = (RpcInvocation) inv;</span><br><span class="line">        invocation.setInvoker(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(attachment)) &#123;</span><br><span class="line">            invocation.addObjectAttachmentsIfAbsent(attachment);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 从上下文中取出 附加信息</span></span><br><span class="line">        Map&lt;String, Object&gt; contextAttachments = RpcContext.getContext().getObjectAttachments();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(contextAttachments)) &#123;</span><br><span class="line">            invocation.addObjectAttachments(contextAttachments);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 设置调用模式  SYNC, ASYNC, FUTURE 。注意，oneway 调用方式</span></span><br><span class="line">        <span class="comment">// 根据以下方式确定调用模式：</span></span><br><span class="line">        <span class="comment">// 1) 根据返回值类型是否是 CompletableFuture ，或方法名是 $invokeAsync，则是 FUTURE 模式。这个属于服务端异步。</span></span><br><span class="line">        <span class="comment">// 2) 根据 async 属性，如果设置 async=true ，则是 ASYNC 模式</span></span><br><span class="line">        <span class="comment">// 3) 默认是 SYNC 模式</span></span><br><span class="line">        invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 如果是异步调用的模式，则给本次调用添加一个唯一id (FUTURE 模式不属于)</span></span><br><span class="line">        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">        AsyncRpcResult asyncResult;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 调用子类实现的 doInvoker() 方法</span></span><br><span class="line">            asyncResult = (AsyncRpcResult) doInvoke(invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对调用异常的处理</span></span><br><span class="line">            <span class="comment">// 4.1 创建 CompletableFuture 对象，使用该对象包装 AppResponse 对象</span></span><br><span class="line">            <span class="comment">// 4.2 使用 AppResponse 对象包装异常信息</span></span><br><span class="line">            <span class="comment">// 4.3 使用 AsyncRpcResult 最后包装 CompletableFuture 对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123; <span class="comment">// biz exception</span></span><br><span class="line">            Throwable te = e.getTargetException();</span><br><span class="line">            <span class="keyword">if</span> (te == <span class="keyword">null</span>) &#123;</span><br><span class="line">                asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (te <span class="keyword">instanceof</span> RpcException) &#123;</span><br><span class="line">                    ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);</span><br><span class="line">                &#125;</span><br><span class="line">                asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, te, invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.isBiz()) &#123;</span><br><span class="line">                asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 使用 FutureContext 保存 FutureAdapter，FutureAdapter 中会封装 AsyncRpcResult 中的 CompletableFuture 对象</span></span><br><span class="line">        RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter(asyncResult.getResponseFuture()));</span><br><span class="line">        <span class="keyword">return</span> asyncResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AbstractInvoker</code> 的 <strong>invoke</strong> 方法是调用服务的模版方法，具体调用细节交给具体子类实现。</p><ol><li>设置附加信息到调用信息 Invocation 中。</li><li>设置调用模式<ul><li><strong>FUTURE:</strong> 根据返回值类型是否是 <code>CompletableFuture</code> ，或方法名是否是 <code>$invokeAsync</code>，则是 FUTURE 模式。这个属于服务端异步。</li><li><strong>ASYNC:</strong> 根据 async 属性，如果设置 async=true ，则是 ASYNC 模式。</li><li><strong>SYNC:</strong> 默认调用模式。</li></ul></li><li>异步调用时，给本地调用添加一个唯一id，并设置到附加属性中。</li><li>调用具体子类 Invoker 对象的 <code>doInvoke</code> 方法，不管是哪个子类实现，调用的结果都是 <code>AsyncRpcResult</code> 类型。</li><li>如果调用异常，则对异常进行处理。</li><li>使用上下文保存 FutureAdapter ，其中 FutureAdapter 中会封装 AsyncRpcResult 中的 CompletableFuture 对象。在后续的链路中可以使用 <strong>Future</strong> 的异步功能。</li></ol><p><strong>注意:</strong></p><blockquote><p>相比 Dubbo 2.6.x，<code>AbstractInvoker</code> 的模版方法中实现了异步逻辑，也就是任何协议的服务调用都支持 <code>Future</code> 的异步功能。在 Dubbo 2.6.x 中非 Dubbo 协议大都不支持异步调用特性。</p></blockquote><h2 id="Dubbo协议异步实现"><a href="#Dubbo协议异步实现" class="headerlink" title="Dubbo协议异步实现"></a>Dubbo协议异步实现</h2><h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><p><code>DubboInvoker</code> 是 Dubbo 协议在消费端创建的 Invoker 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取此次调用的方法名</span></span><br><span class="line">        <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 向 Invocation 中添加附加信息，这里将 URL 的 path 和 version 添加到附加信息中</span></span><br><span class="line">        inv.setAttachment(PATH_KEY, getUrl().getPath());</span><br><span class="line">        inv.setAttachment(VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 选择一个 ExchangeClient 实例</span></span><br><span class="line">        ExchangeClient currentClient;</span><br><span class="line">        <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">            currentClient = clients[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4 判断是否是 oneway 调用，不关心服务端的响应结果。调用后直接返回一个空 AsyncRpcResult</span></span><br><span class="line">            <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            <span class="comment">// 根据调用方法名和配置，计算此次调用的超时时间</span></span><br><span class="line">            <span class="keyword">int</span> timeout = calculateTimeout(invocation, methodName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 request() 方法会相应创建 DefaultFuture 对象以及检测超时的定时任务，而 send() 方法则不会创建这些东西。</span></span><br><span class="line">            <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">                <span class="comment">// 是否等待底层 NIO 将请求发出，等待时间默认 1s，1s未发送则抛出异常</span></span><br><span class="line">                <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">                currentClient.send(inv, isSent);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回已完成状态的 AsynRpcResult 即 AsynRpcResult -&gt; CompletableFuture（已完成状态） -&gt; AppResponse（空结果）</span></span><br><span class="line">                <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(invocation);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 需要关注返回值的请求</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5 获取处理响应的线程池 </span></span><br><span class="line">                ExecutorService executor = getCallbackExecutor(getUrl(), inv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6 调用 ExchangeClient.request() 方法，将 Invocation 包装成 Request 请求发送出去，同时会创建相应的 DefaultFuture 返回。</span></span><br><span class="line">                CompletableFuture&lt;AppResponse&gt; appResponseFuture =</span><br><span class="line">                        <span class="comment">// currentClient.request 返回的是 DefaultFuture，DefaultFuture 继承了 CompletableFuture 。</span></span><br><span class="line">                        currentClient.request(inv, timeout, executor)</span><br><span class="line">                                <span class="comment">// 增加了一个回调，取出其中的 AppResponse 对象。</span></span><br><span class="line">                                <span class="comment">// thenApply 是一个回调,obj 是 上一个任务的结果。返回的 AppResponse 表示的是 服务端返回的具体响应。</span></span><br><span class="line">                                .thenApply(obj -&gt; (AppResponse) obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter</span></span><br><span class="line">                FutureContext.getContext().setCompatibleFuture(appResponseFuture);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7 这里将 CompletableFuture （其实是 DefaultFuture） 封装成 AsyncRpcResult 并返回</span></span><br><span class="line">                AsyncRpcResult result = <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, inv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 8 设置处理响应的线程池</span></span><br><span class="line">                result.setExecutor(executor);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 9 返回调用</span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DubboInvoker</code> 进行远程调用时，会分别对 <strong>oneway</strong> 和 <strong>twoway</strong> 进行处理。</p><ul><li>处理 <strong>oneway</strong> 调用方式<blockquote><p>不需要响应结果，直接使用客户端的 <strong>send</strong> 方法即可，该方法不会返回服务端的响应。<code>DubboInvoker</code> 会返回一个空结果的 <code>AsyncRpcResult</code> 对象给业务方。</p></blockquote></li><li>处理 <strong>twoway</strong> 调用方式<blockquote><p>需要响应结果，使用客户端的 <strong>request</strong> 方法发送请求，该方法会创建并返回本次调用的 DefaultFuture 对象，当服务端响应时会更新 DefaultFuture 中的结果信息。此外，Dubbo 对线程模型进行了优化，可以指定处理响应的线程池，特别是同步调用的线程池，这个我们在下一篇文章中详细介绍。</p></blockquote></li></ul><p>相比较 Dubbo 2.6.x 中的 <code>DefaultFuture</code>，引入了 <code>CompletableFuture</code> 可以支持多异步场景，并且支持 <code>Future</code> 间的相互协调，此外提供了良好的回调方法，避免等待响应而阻塞。这是对 <code>ExchangeClient</code> 的改造，将 Dubbo 2.6.x 中异步编程接口都替换成了 <code>CompletableFuture</code> 。介绍完消费端的异步实现后，下面我们来看看服务端的异步实现。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p><code>AbstractProxyInvoker</code> 是 Dubbo 协议在服务端创建的 Invoker，它封装的是服务接口实现。Dubbo 协议下的服务暴露会使用 <code>ProxyFactory#getInvoker</code> 将服务接口实现封装成 <code>AbstractProxyInvoker</code>。当收到请求时，通道处理器链上的每个处理器都会对该请求进行各自逻辑的处理，其中 <code>HeaderExchangeHandler#handleRequest</code> 会将请求交给 <code>DubboProtocol</code> 中的 <code>ExchangeHandler</code> 处理，Dubbo 协议下的服务端异步实现处理逻辑就在这三者中。在分析源码之前，我们先看服务端异步实现的例子：</p><h4 id="异步实现"><a href="#异步实现" class="headerlink" title="异步实现"></a>异步实现</h4><p>服务提供端异步执行将阻塞的业务从 Dubbo 内部线程池切换到业务自定义线程，在一定程度上避免 Dubbo 线程池的过度占用，有助于避免不同服务间的互相影响。</p><h5 id="定义-CompletableFuture-签名接口"><a href="#定义-CompletableFuture-签名接口" class="headerlink" title="定义 CompletableFuture 签名接口"></a>定义 <code>CompletableFuture</code> 签名接口</h5><ul><li>服务接口定义<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line">    <span class="function">CompletableFuture&lt;String&gt; <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>服务实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncServiceImpl</span> <span class="keyword">implements</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        RpcContext savedContext = RpcContext.getContext();</span><br><span class="line">        <span class="comment">// 建议为supplyAsync提供自定义线程池，避免使用JDK公用线程池</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"async response from provider."</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过 <code>return CompletableFuture.supplyAsync()</code> ，业务执行已从 Dubbo 线程切换到业务线程，避免了对 Dubbo 线程池的阻塞。</p><h5 id="服务消费方"><a href="#服务消费方" class="headerlink" title="服务消费方"></a>服务消费方</h5><p> <code>CompletableFuture</code> 签名接口是服务提供方的异步实现，消费端同普通消费一致，Dubbo 内部会根据调用的方法返回值类型等方式确定 <strong>调用模式</strong>，具体的在后面的源码部分介绍。</p><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p>Dubbo 2.7 虽然支持了服务端的异步，但 Dubbo 的线程模型本身就是异步处理的方式，因此服务端的异步特性相对还是有点鸡肋的。</p><p>了解了服务端异步实现后，下面我们从代码层面分析，Dubbo 如何就 <code>CompletableFuture</code> 签名服务接口方法实现异步的。</p><h4 id="HeaderExchangeHandler-处理请求"><a href="#HeaderExchangeHandler-处理请求" class="headerlink" title="HeaderExchangeHandler 处理请求"></a>HeaderExchangeHandler 处理请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+--- HeaderExchangeHandler</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">        <span class="comment">// 省略异常处理代码</span></span><br><span class="line"></span><br><span class="line">        Object msg = req.getData();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 使用上层通道处理器处理消息，其实就是 DubboProtocol 中的 ExchangeHandler </span></span><br><span class="line">            CompletionStage&lt;Object&gt; future = handler.reply(channel, msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 请求处理完成回调，将结果发送到对端</span></span><br><span class="line">            future.whenComplete((appResult, t) -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        res.setStatus(Response.OK);</span><br><span class="line">                        res.setResult(appResult);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">                        res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3 将处理后的结果发送到对端</span></span><br><span class="line">                    channel.send(res);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Send result to consumer failed, channel is "</span> + channel + <span class="string">", msg is "</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">            res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">            channel.send(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>相比较与 Dubbo 2.6.x 中的处理请求逻辑，这里使用了 <code>CompletableFuture</code> 的完成回调，避免了阻塞等待请求完成。这得益于对通道处理 ExchangeHandler 的异步方法的改造，也就是 DubboProtocol 中的 ExchangeHandler 的实现。</p><h4 id="DubboProtocol-的处理器"><a href="#DubboProtocol-的处理器" class="headerlink" title="DubboProtocol 的处理器"></a>DubboProtocol 的处理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"><span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line"></span><br><span class="line">            Invocation inv = (Invocation) message;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取暴露的 Invoker，这里是 AbstractProxyInvoker</span></span><br><span class="line">            Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">           </span><br><span class="line">            RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果服务端异步实现，这里返回的 result 是一个 AsyncRpcResult 类型对象，其中的 AppResonse 中的值并非 CompletableFuture 类型，而是 CompletableFuture 封装的 AppResponse</span></span><br><span class="line">            Result result = invoker.invoke(inv);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result.thenApply(Function.identity());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DubboProtocol 中的 ExchangeHandler 的请求处理方法返回的是 CompletableFuture 对象，这同样是 Dubbo 2.7.x 中的改造，服务方法的结果统一包装成 <code>CompletableFuture</code> 类型，在服务端的 Invoker 的执行逻辑中就可以体现这一点，下面我们就来看 <code>AbstractProxyInvoker</code> 。</p><h4 id="AbstractProxyInvoker-1"><a href="#AbstractProxyInvoker-1" class="headerlink" title="AbstractProxyInvoker"></a>AbstractProxyInvoker</h4><p>服务端的 Invoker，直接封装服务接口实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractProxyInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 执行服务方法，如 DemoService.sayHello </span></span><br><span class="line">            Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 将方法结果以 CompletableFuture 对象形式进行封装。</span></span><br><span class="line">            <span class="comment">// 注意：如果服务方法返回类型是 CompletableFuture ，则无需再使用 CompletableFuture 包装。这个针对服务端的异步实现。</span></span><br><span class="line">            CompletableFuture&lt;Object&gt; future = wrapWithFuture(value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 执行 future 逻辑</span></span><br><span class="line">            CompletableFuture&lt;AppResponse&gt; appResponseFuture = future.handle((obj, t) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4 使用 AppResponse 封装实际结果</span></span><br><span class="line">                AppResponse result = <span class="keyword">new</span> AppResponse();</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t <span class="keyword">instanceof</span> CompletionException) &#123;</span><br><span class="line">                        result.setException(t.getCause());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.setException(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.setValue(obj);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 统一包装成 AsyncRpcResult 对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (RpcContext.getContext().isAsyncStarted() &amp;&amp; !RpcContext.getContext().stopAsync()) &#123;</span><br><span class="line">                logger.error(<span class="string">"Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e.getTargetException(), invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to invoke remote proxy method "</span> + invocation.getMethodName() + <span class="string">" to "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AbstractProxyInvoker</code> 的执行逻辑主要有四点，下面进行总结：</p><ol><li>执行服务接口实例方法，如 demoService.sayhello 方法。</li><li>将服务实例方法的调用结果包装成 <code>CompletableFuture</code> ，<strong>如果是服务端异步实现（服务接口方法返回类型是 CompletableFuture），则无需对结果进行包装，直接使用返回的 <code>CompletableFuture</code></strong> 即可。</li><li>执行 <code>CompletableFuture</code> 的回调方法，将实际结果封装到 AppResponse 中。</li><li>将返回结果包装成 AsyncRpcResult 对象。</li></ol><h2 id="HTTP-协议实现"><a href="#HTTP-协议实现" class="headerlink" title="HTTP 协议实现"></a>HTTP 协议实现</h2><h3 id="消费端-1"><a href="#消费端-1" class="headerlink" title="消费端"></a>消费端</h3><p>Dubbo 中的 HTTP 协议在消费端创建的 Invoker 是一个 <code>AbstractInvoker</code> 匿名对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">+--- AbstractProxyProtocol</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">protocolBindingRefer</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; type, <span class="keyword">final</span> URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 调用子类实现的 doRefer() 方法返回一个目标服务接口的代理对象</span></span><br><span class="line">        <span class="comment">// 2 使用 ProxyFactory.getInvoker() 方法将服务接口的代理对象封装成一个 Invoker ，类型是 AbstractProxyInvoker。</span></span><br><span class="line">        <span class="keyword">final</span> Invoker&lt;T&gt; target = proxyFactory.getInvoker(doRefer(type, url), type, url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 创建 AbstractInvoker 的匿名对象</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = <span class="keyword">new</span> AbstractInvoker&lt;T&gt;(type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 4 调用 AbstractProxyInvoker.invoke 方法，返回的结果是 AsyncRpcResult</span></span><br><span class="line">                    Result result = target.invoke(invocation);</span><br><span class="line">                    <span class="comment">// FIXME result is an AsyncRpcResult instance.</span></span><br><span class="line">                    Throwable e = result.getException();</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Class&lt;?&gt; rpcException : rpcExceptions) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (rpcException.isAssignableFrom(e.getClass())) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> getRpcException(type, url, invocation, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.getCode() == RpcException.UNKNOWN_EXCEPTION) &#123;</span><br><span class="line">                        e.setCode(getErrorCode(e.getCause()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> getRpcException(type, url, invocation, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        invokers.add(invoker);</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Dubbo 协议下的服务调用不仅引入 CompletableFuture ，还对方法等进行改造，如 <code>HeaderExchangeClient.request</code> 方法。<strong>HTTP 协议下的服务调用异步改造力度相对不大</strong>，异步实现主要依赖引入的 CompletableFuture ，以及在 <code>AbstractInvoker</code> 中统一的 <code>Future</code> 异步功能。</p><p><strong>特别说明：</strong></p><blockquote><p>为什么将 <code>doRefer</code> 返回的代理对象通过 <code>ProxyFactory.getInvoker</code> 包装成 <code>AbstractProxyInvoker</code> 对象？因为此代理对象具备和远程服务通信的能力，原则上可以使用该代理对象调用服务接口方法，但是调用信息是存在 <code>Invocation</code> 中，将该代理对象包装成 <code>AbstractProxyInvoker</code> 可以根据 <code>Invocation</code> 中的信息动态选择目标服务方法。本质上和 DubboInvoker 类似，DubboInvoker 和远程服务通信需要使用 <code>ExchangeClient</code>，将调用信息 <code>Invocation</code> 交给它即可实现目标服务的调用，这里的代理对象就相当于 DubboInvoker 中的 <code>ExchangeClient</code> 。</p></blockquote><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p>使用 <code>JsonRpcServer</code> 暴露服务，具体过程可参考：<a href="https://gentryhuang.com/posts/c5a37c18/#%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2-2">HTTP协议服务暴露</a> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--- HttpProtocol.doExport</span><br><span class="line"><span class="comment">// 5 创建 JsonRpcServer，暴露服务</span></span><br><span class="line">JsonRpcServer skeleton = <span class="keyword">new</span> JsonRpcServer(impl, type);</span><br><span class="line">JsonRpcServer genericServer = <span class="keyword">new</span> JsonRpcServer(impl, GenericService<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中的具有服务能力的 <strong>impl</strong> 是 <code>ProxyFactory#getProxy(org.apache.dubbo.rpc.Invoker&lt;T&gt;, boolean)</code>  创建的代理对象，具体逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractProxyProtocol</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 省略无关代码</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String uri = serviceKey(invoker.getUrl());</span><br><span class="line">        Exporter&lt;T&gt; exporter = (Exporter&lt;T&gt;) exporterMap.get(uri);</span><br><span class="line">        <span class="keyword">if</span> (exporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// When modifying the configuration through override, you need to re-expose the newly modified service.</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(exporter.getInvoker().getUrl(), invoker.getUrl())) &#123;</span><br><span class="line">                <span class="keyword">return</span> exporter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其中的 invoker 是由 ProxyFactory#getInvoker 创建</span></span><br><span class="line">        <span class="keyword">final</span> Runnable runnable = doExport(proxyFactory.getProxy(invoker, <span class="keyword">true</span>), invoker.getInterface(), invoker.getUrl());</span><br><span class="line">        exporter = <span class="keyword">new</span> AbstractExporter&lt;T&gt;(invoker) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.unexport();</span><br><span class="line">                exporterMap.remove(uri);</span><br><span class="line">                <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        runnable.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        logger.warn(t.getMessage(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        exporterMap.put(uri, exporter);</span><br><span class="line">        <span class="keyword">return</span> exporter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不难看出最终处理请求的还是上面方法传入的 <code>invoker</code> 对象，该对象中包含真正的服务实例。而传入的 <code>invoker</code> 对象是由 <code>ProxyFactory#getInvoker</code> 创建的，对象类型是 <code>AbstractProxyInvoker</code> ，下面以 <code>JavassistProxyFactory</code> 工厂为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistProxyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Wrapper cannot handle this scenario correctly: the classname contains '$'</span></span><br><span class="line">        <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">'$'</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把前文的 <code>AbstractProxyInvoker</code> 的代码实现粘贴过来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractProxyInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 执行服务方法，如 DemoService.sayHello </span></span><br><span class="line">            Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 将方法结果以 CompletableFuture 对象形式进行封装。</span></span><br><span class="line">            <span class="comment">// 注意：如果服务方法返回类型是 CompletableFuture ，则无需再使用 CompletableFuture 包装。这个针对服务端的异步实现。</span></span><br><span class="line">            CompletableFuture&lt;Object&gt; future = wrapWithFuture(value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 执行 future 逻辑</span></span><br><span class="line">            CompletableFuture&lt;AppResponse&gt; appResponseFuture = future.handle((obj, t) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4 使用 AppResponse 封装实际结果</span></span><br><span class="line">                AppResponse result = <span class="keyword">new</span> AppResponse();</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t <span class="keyword">instanceof</span> CompletionException) &#123;</span><br><span class="line">                        result.setException(t.getCause());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.setException(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.setValue(obj);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 统一包装成 AsyncRpcResult 对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (RpcContext.getContext().isAsyncStarted() &amp;&amp; !RpcContext.getContext().stopAsync()) &#123;</span><br><span class="line">                logger.error(<span class="string">"Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e.getTargetException(), invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to invoke remote proxy method "</span> + invocation.getMethodName() + <span class="string">" to "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于使用 HTTP 协议的服务实现，更多的是在形式上保持统一，和 Dubbo 协议的服务实现类似。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Dubbo 2.6.x 及之前版本中使用 <code>Future</code> 实现异步功能，并且不支持服务端的异步，这在功能设计上存在一些问题，Dubbo 2.7.x 基于 <code>CompletableFuture</code> 对异步功能进行了增强，弥补了功能设计上的一些问题。由于 <code>CompletableFuture</code> 实现了 <code>CompletionStage</code> 和 <code>Future</code> 接口，因此仍然支持 Dubbo 2.6 中通过 <strong>get()</strong> 或者 <strong>isDone()</strong> 方法轮询结果。但是，不建议使用 <strong>get()</strong> 这样阻塞的方式获取结果，因为这样做的的话就丢失了异步操作带来的性能提升。<code>CompletableFuture</code> 提供了良好的回调支持，如 <strong>whenComplete()</strong> 等方法可以在逻辑完成后，执行回调逻辑。同时 <code>CompletableFuture</code> 支持 <code>Future</code> 间的相互协调，如 <strong>thenApply()</strong> 等方法。正是由于 <code>CompletableFuture</code> 强大的功能，我们可以更加流畅地使用回调而无需等待响应而阻塞调用线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;从 2.7.0 版本开始，Dubbo 的所有异步编程接口开始以 &lt;code&gt;CompletableFuture&lt;/code&gt; 为基础，不仅支
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 线程模型改造</title>
    <link href="https://gentryhuang.com/posts/13d5a11a/"/>
    <id>https://gentryhuang.com/posts/13d5a11a/</id>
    <published>2021-02-05T16:00:00.000Z</published>
    <updated>2021-04-06T08:30:05.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://gentryhuang.com/posts/c812f120/">异步改造</a> 中对 Dubbo 2.7.x 中异步调用和异步实现进行了详细说明。其中 Dubbo 协议下，在对异步调用进行分析时，我们发现 <code>ThreadlessExecutor</code> 被多次使用，此外 <code>ExchangeChannel#request</code> 方法支持设置处理响应的线程池。本篇文章我们将对 Dubbo 线程池模型优化进行介绍，其中消费端线程池模型优化就是从这两个方面进行改造的。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 协议下创建 NIO 服务器和客户端都会分别创建各自的线程池。2.7.x 之前版本的线程池的创建是由派发器 <code>Dispatcher</code> 创建的 <code>WrappedChannelHandler</code> 完成的。<code>Dispatcher</code> 和 <code>WrappedChannelHandler</code> 之间的关系可以参考 <a href="https://gentryhuang.com/posts/53cd7ee7/#WrappedChannelHandler">线程模型</a> 。2.7.x 新增了 <code>ExecutorRepository</code> 用于创建和管理线程池。 <code>WrappedChannelHandler</code> 的子类实现了消息派发功能，即决定了 Dubbo 以哪种线程模型处理收到的消息和事件。因为 NIO 服务器端和客户端都会初始化线程池，这意味着服务端和客户端都可能使用自己的线程池来处理本端收到的消息和事件，具体的策略由 <code>WrappedChannelHandler</code> 的子类决定。</p><h1 id="从-Issues-谈起"><a href="#从-Issues-谈起" class="headerlink" title="从 Issues 谈起"></a>从 Issues 谈起</h1><p>点这里：<a href="https://github.com/apache/dubbo/issues/1896" target="_blank" rel="noopener">消费者中建立了太多DubboClientHandler线程</a></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote><p>Dubbo Version: 2.5.3<br>我有一个非常大的provider 集群（30个实例）。然后我们发现在客户端，为每一个实例，都准备了一个独立线程池，所以我们看到有30个线程池以去发起消费请求，这个从jstack堆栈上可以证明，因为里面很多线程组的名字是类似DubboClientHandler-IP1-XXX，其中ip都是不一样的。</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>之所以我们提供如此大的服务集群，是因为我们希望最大化TPS，但现在集群是大了，但是消费者又因此导致巨大的线程消耗（高CPU）。我们能否通过配置改变这个线程的模型，例如用一个共享的线程池去处理所有的服务实例，这样最大的线程数便可控了。</p></blockquote><h2 id="待优化"><a href="#待优化" class="headerlink" title="待优化"></a>待优化</h2><blockquote><p>对 2.7.5 版本之前的 Dubbo 应用，在 <code>WrappedChannelHandler</code> 中会为 <strong>每个客户端连接启动一个线程池</strong>，因为不会根据 URL 复用线程池，这意味着每个消费端都浪费着一定的资源。此外，对于同步调用，业务线程发起调用后要阻塞等待响应，服务端返回响应后需要消费端线程池将结果保存起来然后通知业务线程，这个过程业务线程处于空闲状态，而接收响应却是消费端线程池完成，<strong>被阻塞的业务线程没有被有效利用</strong>。当面临需要消费大量服务且并发数比较大的大流量场景时（典型如网关类场景），经常会出现消费端线程数分配过多的问题。</p></blockquote><h1 id="Dubbo-2-6-x-线程模型"><a href="#Dubbo-2-6-x-线程模型" class="headerlink" title="Dubbo 2.6.x 线程模型"></a>Dubbo 2.6.x 线程模型</h1><p>这里以 Netty 实现为例，Mina 等 NIO 组件类似。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyServer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// ChannelHandlers.wrap方法，用来包装 ChannelHandler，实现Dubbo 线程模型的功能</span></span><br><span class="line">        <span class="comment">// 线程名前缀 DubboServerHandler</span></span><br><span class="line">        <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在创建、启动 Netty 服务时会通过 <code>ChannelHandlers.wrap</code> 方法为传入的 ChannelHandler 依次包装 <code>AllChannelHandler(默认)</code>、<code>HeartbeatHandler</code>以及 <code>MultiMessageHandler</code> 。其中 <code>AllChannelHanlder</code> 是消息派发处理器，其父类 <code>WrappedChannelHandler</code> 会开启一个线程池，也就是每启动一个服务器就创建对应的一个线程池。</p><h2 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyClient</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// wrapChannelHandler方法，包装ChannelHandler，其中实现了 Dubbo 线程模型的功能。</span></span><br><span class="line">        <span class="keyword">super</span>(url, wrapChannelHandler(url, handler));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> ChannelHandler <span class="title">wrapChannelHandler</span><span class="params">(URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 设置线程名前缀，即URL.threadname=xxx ，默认：DubboClientHandler</span></span><br><span class="line">        url = ExecutorUtil.setThreadName(url, CLIENT_THREAD_POOL_NAME);</span><br><span class="line">        <span class="comment">// 2 设置使用的线程池类型，即 URL.threadpool=xxx ，默认： cached。注意这个和Server的区别</span></span><br><span class="line">        url = url.addParameterIfAbsent(Constants.THREADPOOL_KEY, Constants.DEFAULT_CLIENT_THREADPOOL);</span><br><span class="line">        <span class="comment">// 3 包装通道处理器</span></span><br><span class="line">        <span class="keyword">return</span> ChannelHandlers.wrap(handler, url);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在创建、启动 Netty 客户端时会通过 <code>ChannelHandlers.wrap</code> 方法为传入的 ChannelHandler 依次包装 <code>AllChannelHandler(默认)</code>、<code>HeartbeatHandler</code>以及 <code>MultiMessageHandler</code> 。其中 <code>AllChannelHanlder</code> 是消息派发处理器，其父类 <code>WrappedChannelHandler</code> 会开启一个线程池，也就是每创建一个连接就创建对应的一个线程池。</p><h2 id="开启线程池"><a href="#开启线程池" class="headerlink" title="开启线程池"></a>开启线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+--- WrappedChannelHandler</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrappedChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 基于SPI机制创建线程池</span></span><br><span class="line">        executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>().<span class="title">getExecutor</span>(<span class="title">url</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String componentKey = Constants.EXECUTOR_SERVICE_COMPONENT_KEY;</span><br><span class="line">        <span class="comment">// 2 如果是消费端</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(Constants.SIDE_KEY))) &#123;</span><br><span class="line">            componentKey = Constants.CONSUMER_SIDE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 基于SPI机制创建线程池存储对象</span></span><br><span class="line">        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 添加线程池到 DataStore中</span></span><br><span class="line">        <span class="comment">// 注意： AbstractClient 或 AbstractServer 从 DataStore 获得线程池</span></span><br><span class="line">        dataStore.put(componentKey, Integer.toString(url.getPort()), executor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="缓存线程池"><a href="#缓存线程池" class="headerlink" title="缓存线程池"></a>缓存线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataStore 只有一个实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDataStore</span> <span class="keyword">implements</span> <span class="title">DataStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存已有的线程池</span></span><br><span class="line"><span class="comment">     * key1: 表示线程池属于服务端侧还是消费端侧</span></span><br><span class="line"><span class="comment">     * key2: 线程池关联服务的端口</span></span><br><span class="line"><span class="comment">     * value: 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt; data = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码层面上也说明了，在 <code>WrappedChannelHandler</code> 中会为每个连接启动一个线程池，并没有根据 URL 的信息对同一个线程池进行复用，而是直接通过 SPI 机制找到 ThreadPool 具体实现，然后创建线程池。注意，最终缓存的是最新的线程池。</p><h2 id="线程池模型"><a href="#线程池模型" class="headerlink" title="线程池模型"></a>线程池模型</h2><p>注意，创建 Dubbo 线程池都是强调消费端而没有强调服务端，因为一个节点部署 Dubbo 应用，一般只会创建一个 NIO 服务（以主机绑定的ip和port启动NIO服务），对应的线程池也只会初始化一个。</p><p>消费端同步请求的线程模型如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/consumer-threadpool-model-old.png" alt></p><p><strong>请求-响应流程如下：</strong></p><ol><li>业务线程发出请求，拿到一个 <strong>Future</strong> 实例。</li><li>业务线程紧接着调用 <strong>Future.get</strong> 阻塞等待请求结果返回。</li><li>当响应返回之后，交由连接关联的 Consumer 端线程池进行反序列化等处理。</li><li>待处理完成之后，通过 Future.set 方法将业务结果置回，然后通知业务线程取结果。</li></ol><p>当前版本的设计，消费端会维护一个线程池，而且<strong>线程池是按照连接隔离的</strong> ，也就是每个连接独享一个线程池。此外，当面临需要消费大量服务且并发数比较大的场景时，如 网关类场景，可能会导致消费端的线程数不断增加，最终引发CPU飙升、内存溢出。</p><h1 id="Dubbo-2-7-5-线程模型"><a href="#Dubbo-2-7-5-线程模型" class="headerlink" title="Dubbo 2.7.5 线程模型"></a>Dubbo 2.7.5 线程模型</h1><p>为了解决以上两个问题，Dubbo 2.7.5 对线程模型进行了改造，并且引入了 <code>ThreadlessExecutor</code>，以及 <code>ExchangeChannel#request</code> 方法支持设置处理响应的线程池，这样就可以通过 <strong>复用业务端被阻塞的线程，从而避免消费端线程池过度占用</strong>。</p><h2 id="ExecutorRepository"><a href="#ExecutorRepository" class="headerlink" title="ExecutorRepository"></a>ExecutorRepository</h2><p><code>ExecutorRepository</code> 负责创建并管理 Dubbo 中的线程池，该扩展接口只有一个实现。在 Dubbo 2.6.x 中之所以没有复用同一个线程池，很大原因就是没有一个管理 Dubbo 线程池的工具，它仅有一个缓存 Dubbo 线程池的工具。下面我们看看是怎么管理线程池的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultExecutorRepository</span> <span class="keyword">implements</span> <span class="title">ExecutorRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存已有的线程池</span></span><br><span class="line"><span class="comment">     * key1: 表示线程池属于服务端侧还是消费端侧</span></span><br><span class="line"><span class="comment">     * key2: 线程池关联服务的端口</span></span><br><span class="line"><span class="comment">     * value: 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;Integer, ExecutorService&gt;&gt; data = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当服务或客户端初始化时，根据 URL 参数创建相应的线程池并缓存在合适的位置</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">createExecutorIfAbsent</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 根据 URL 中的 side 参数值确定线程池缓存的第一层 key</span></span><br><span class="line">        String componentKey = EXECUTOR_SERVICE_COMPONENT_KEY;</span><br><span class="line">        <span class="keyword">if</span> (CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY))) &#123;</span><br><span class="line">            componentKey = CONSUMER_SIDE;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, ExecutorService&gt; executors = data.computeIfAbsent(componentKey, k -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 根据 URL 中的 port 值确定线程池缓存的第二层 key</span></span><br><span class="line">        Integer portKey = url.getPort();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取或创建线程池</span></span><br><span class="line">        ExecutorService executor = executors.computeIfAbsent(portKey, k -&gt; createExecutor(url));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 如果缓存中相应的线程池已经关闭，则创建新的线程池，并替换掉缓存中已关闭的线程池</span></span><br><span class="line">        <span class="keyword">if</span> (executor.isShutdown() || executor.isTerminated()) &#123;</span><br><span class="line">            executors.remove(portKey);</span><br><span class="line">            executor = createExecutor(url);</span><br><span class="line">            executors.put(portKey, executor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getExecutor</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 根据 URL 中的 side 参数值确定线程池缓存的第一层 key</span></span><br><span class="line">        String componentKey = EXECUTOR_SERVICE_COMPONENT_KEY;</span><br><span class="line">        <span class="keyword">if</span> (CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY))) &#123;</span><br><span class="line">            componentKey = CONSUMER_SIDE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 从缓存中获取线程池</span></span><br><span class="line">        Map&lt;Integer, ExecutorService&gt; executors = data.get(componentKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * It's guaranteed that this method is called after &#123;<span class="doctag">@link</span> #createExecutorIfAbsent(URL)&#125;, so data should already</span></span><br><span class="line"><span class="comment">         * have Executor instances generated and stored.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (executors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">"No available executors, this is not expected, framework should call createExecutorIfAbsent first "</span> +</span><br><span class="line">                    <span class="string">"before coming to here."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Integer portKey = url.getPort();</span><br><span class="line">        ExecutorService executor = executors.get(portKey);</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (executor.isShutdown() || executor.isTerminated()) &#123;</span><br><span class="line">                executors.remove(portKey);</span><br><span class="line">                executor = createExecutor(url);</span><br><span class="line">                executors.put(portKey, executor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 URL 创建线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ExecutorService <span class="title">createExecutor</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过 Dubbo SPI 查找 ThreadPool 接口的扩展实现，并调用 getExecutor() 方法创建线程池。默认使用 FixedThreadPool 扩展实现。</span></span><br><span class="line">        <span class="keyword">return</span> (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>().<span class="title">getExecutor</span>(<span class="title">url</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExecutorRepository</code> 会根据 URL 复用同一个线程，这解决了每个连接（连接同一个节点上服务）都启动一个线程池问题。</p><h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><p>当服务端和客户端启动时会初始化线程池，遵循先缓存后创建的原则。相比 Dubbo 2.6.x ，<code>WrappedChannelHandler</code> 不会在初始化时创建线程池，而是封装了公共的获取线程池的方法。</p><h2 id="获取线程池"><a href="#获取线程池" class="headerlink" title="获取线程池"></a>获取线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrappedChannelHandler</span> <span class="keyword">implements</span> <span class="title">ChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WrappedChannelHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrappedChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线程池，ThreadlessExecutor 或 共享线程池</span></span><br><span class="line"><span class="comment">     * 1. 使用 ThreadlessExecutor ，将回调直接委托给发起调用的线程</span></span><br><span class="line"><span class="comment">     * 2. 使用共享线程池执行回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getPreferredExecutorService</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是响应，尝试从 DefaultFuture 中取出线程池，没有的话再获取共享线程池</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">            Response response = (Response) msg;</span><br><span class="line">            DefaultFuture responseFuture = DefaultFuture.getFuture(response.getId());</span><br><span class="line">            <span class="keyword">if</span> (responseFuture == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> getSharedExecutorService();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果请求关联了线程池，则会获取相关的线程来处理响应</span></span><br><span class="line">                ExecutorService executor = responseFuture.getExecutor();</span><br><span class="line">                <span class="keyword">if</span> (executor == <span class="keyword">null</span> || executor.isShutdown()) &#123;</span><br><span class="line">                    executor = getSharedExecutorService();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> executor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 非响应，则直接使用共享线程池</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getSharedExecutorService();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前服务器或客户端的共享线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getSharedExecutorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从 ExecutorRepository 中获取线程池</span></span><br><span class="line">        ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>()</span>;</span><br><span class="line">        ExecutorService executor = executorRepository.getExecutor(url);</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor = executorRepository.createExecutorIfAbsent(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getExecutorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSharedExecutorService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是 <code>getPreferredExecutorService</code> 方法，如果请求在发送的时候指定了关联的线程池，则收到响应时会优先根据请求 ID 从 <code>DefaultFuture</code> 中取出对应的线程池，可能是 <code>ThreadlessExecutor</code>线程池或共享线程池。</p><h2 id="DefaultFuture"><a href="#DefaultFuture" class="headerlink" title="DefaultFuture"></a>DefaultFuture</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 DefaultFuture</span></span><br><span class="line"><span class="comment"> * 1. 初始化 DefaultFuture</span></span><br><span class="line"><span class="comment"> * 2. 超时检查</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel  channel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request  the request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout  timeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executor 线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new DefaultFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DefaultFuture <span class="title">newFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout, ExecutorService executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, request, timeout);</span><br><span class="line">    future.setExecutor(executor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadlessExecutor 需要持有本次请求关联的 DefaultFuture，主要用于当调用出现异常时（如调用超时），ThreadlessExecutor 可以及时更新 DefaultFuture 的调用状态，避免业务方一直傻傻地等待</span></span><br><span class="line">    <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">        ((ThreadlessExecutor) executor).setWaitingFuture(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为每次请求创建一个超时检查任务 </span></span><br><span class="line">    timeoutCheck(future);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timeoutCheck</span><span class="params">(DefaultFuture future)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 创建超时任务</span></span><br><span class="line">    TimeoutCheckTask task = <span class="keyword">new</span> TimeoutCheckTask(future.getId());</span><br><span class="line">    <span class="comment">// 2 将超时任务加入时间轮，到了指定的超时时间触发任务</span></span><br><span class="line">    future.timeoutCheckTask = TIME_OUT_TIMER.newTimeout(task, future.getTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DefaultFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    <span class="keyword">this</span>.request = request;</span><br><span class="line">    <span class="keyword">this</span>.id = request.getId();</span><br><span class="line">    <span class="keyword">this</span>.timeout = timeout &gt; <span class="number">0</span> ? timeout : channel.getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);</span><br><span class="line">    <span class="comment">// put into waiting map.</span></span><br><span class="line">    FUTURES.put(id, <span class="keyword">this</span>);</span><br><span class="line">    CHANNELS.put(id, channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，Dubbo 协议下 <strong>twoway</strong> 调用不仅会创建一个和本次调用的相关的 <code>DefaultFuture</code> 对象，还会为当前请求创建一个调用超时检测任务，该任务用于当调用超时时及时响应一个超时异常结果给调用方，尽可能减少业务方等待时间，不仅同步调用可以及时收到调用结果，异步调用也是，只是一般情况下异步调用不会立刻阻塞等待结果而已。Dubbo 2.6.x 没有使用时间轮，而是使用定时任务检测任务的超时，本质上是一样的。</p><h3 id="超时任务"><a href="#超时任务" class="headerlink" title="超时任务"></a>超时任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+--- DefaultFuture</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutCheckTask</span> <span class="keyword">implements</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  请求id</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Long requestID;</span><br><span class="line"></span><br><span class="line">        TimeoutCheckTask(Long requestID) &#123;</span><br><span class="line">            <span class="keyword">this</span>.requestID = requestID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 根据请求id取出对应的 DefaultFuture</span></span><br><span class="line">            DefaultFuture future = DefaultFuture.getFuture(requestID);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断 timeout 到了，结果是否返回，没有返回则请求超时了</span></span><br><span class="line">            <span class="keyword">if</span> (future == <span class="keyword">null</span> || future.isDone()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求超时需要响应一个超时结果</span></span><br><span class="line">            <span class="keyword">if</span> (future.getExecutor() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                future.getExecutor().execute(() -&gt; notifyTimeout(future));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                notifyTimeout(future);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyTimeout</span><span class="params">(DefaultFuture future)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 创建一个超时异常响应</span></span><br><span class="line">            Response timeoutResponse = <span class="keyword">new</span> Response(future.getId());</span><br><span class="line">            <span class="comment">// set timeout status.</span></span><br><span class="line">            timeoutResponse.setStatus(future.isSent() ? Response.SERVER_TIMEOUT : Response.CLIENT_TIMEOUT);</span><br><span class="line">            timeoutResponse.setErrorMessage(future.getTimeoutMessage(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理响应</span></span><br><span class="line">            DefaultFuture.received(future.getChannel(), timeoutResponse, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+--- DefaultFuture</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response, <span class="keyword">boolean</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DefaultFuture future = FUTURES.remove(response.getId());</span><br><span class="line">            <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Timeout t = future.timeoutCheckTask;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 请求没有超时，则取消超时任务</span></span><br><span class="line">                <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">                    <span class="comment">// decrease Time</span></span><br><span class="line">                    t.cancel();</span><br><span class="line">                &#125;</span><br><span class="line">                future.doReceived(response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"The timeout response finally returned at "</span></span><br><span class="line">                        + (<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>).format(<span class="keyword">new</span> Date()))</span><br><span class="line">                        + <span class="string">", response status is "</span> + response.getStatus()</span><br><span class="line">                        + (channel == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">", channel: "</span> + channel.getLocalAddress()</span><br><span class="line">                        + <span class="string">" -&gt; "</span> + channel.getRemoteAddress()) + <span class="string">", please check provider side for detailed result."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            CHANNELS.remove(response.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Response res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"response cannot be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常响应结果</span></span><br><span class="line">        <span class="keyword">if</span> (res.getStatus() == Response.OK) &#123;</span><br><span class="line">            <span class="keyword">this</span>.complete(res.getResult());</span><br><span class="line">            <span class="comment">// 超时异常</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123;</span><br><span class="line">            <span class="keyword">this</span>.completeExceptionally(<span class="keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()));</span><br><span class="line">            <span class="comment">// 其它异常</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.completeExceptionally(<span class="keyword">new</span> RemotingException(channel, res.getErrorMessage()));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 已经有了请求结果，但可能是超时异常结果，这种情况下应该通知在 ThreadlessExecutor.queue 上等待的线程，避免其一直等待。</span></span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 通知在 ThreadlessExecutor.queue 上等待的线程返回</span></span><br><span class="line">            <span class="keyword">if</span> (threadlessExecutor.isWaiting()) &#123;</span><br><span class="line">                threadlessExecutor.notifyReturn(<span class="keyword">new</span> IllegalStateException(<span class="string">"The result has returned, but the biz thread is still waiting"</span> +</span><br><span class="line">                        <span class="string">" which is not an expected state, interrupt the thread manually by returning an exception."</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DefaultFuture</code> 处理响应分为两种情况，一种是正常响应结果，另一种是异常响应结果。如果是异常结果，则还需要判断处理响应的线程池类型，如果是 <code>ThreadlessExecutor</code> 且其状态是等待状态，则需要通知阻塞的业务线程返回。此外，如果因为调用超时而返回异常结果时，也会将本次调用相关的 <code>DefaultFuture</code> 移除，当服务提供方返回响应（超时是针对消费端的，服务端不受影响）时是找不到对应的 DefaultFuture 对象的。</p><p>相比较 Dubbo 2.6.x , <code>DefaultFuture</code> 新维护了一个 <code>ExecutorService</code> 线程池，作为处理响应的线程池，可以参考 <code>WrappedChannelHandler.getPreferredExecutorService</code> 方法中的逻辑。</p><h2 id="ThreadlessExecutor"><a href="#ThreadlessExecutor" class="headerlink" title="ThreadlessExecutor"></a>ThreadlessExecutor</h2><p><code>ThreadlessExecutor</code> 是一种特殊类型的线程池，它并不会管理任何线程，以线程池的身份作为一个中间容器使用。其中维护了一个阻塞队列 <strong>queue</strong> 和一个共享线程池 <strong>shareExecutor</strong> 。阻塞队列用来存储响应任务，最终会将响应任务交给等待的业务线程处理。共享线程池主要用于当业务线程不再等待响应时，会由该线程池处理任务。整个核心逻辑在 <strong>execute()</strong> 方法和 <strong>waitAndDrain()</strong> 方法。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadlessExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ThreadlessExecutor<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞队列，用来在 IO线程和业务线程之间传递任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadlessExecutor 底层关联的共享线程池。当业务线程已经不再等待响应时，会由该共享线程执行提交任务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService sharedExecutor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向请求对应的 DefaultFuture</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CompletableFuture&lt;?&gt; waitingFuture;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * finished 和 waiting 字段控制着等待任务的处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> waiting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadlessExecutor</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 判断业务线程是否还在等待响应，不等待则直接交给共享线程池处理</span></span><br><span class="line">            <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">                sharedExecutor.execute(runnable);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 业务线程还在等待，则将任务写入队列，最终由业务线程自己执行（业务线程在 waitAndDrain 方法上等待任务）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.add(runnable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ThreadlessExecutor</code> 重写了 <code>execute(Runnable)</code> 方法，通过该方法提交给这个执行器的任务不会被调度到特定的线程。如果业务线程在等待响应则将任务放入阻塞队列，最终业务线程自己执行。如果业务线程没有等待（可能业务线程已经执行了响应任务），则直接交给共享线程池处理。</p><h3 id="任务等待"><a href="#任务等待" class="headerlink" title="任务等待"></a>任务等待</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadlessExecutor</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitAndDrain</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 检测当前 ThreadlessExecutor 状态</span></span><br><span class="line">        <span class="keyword">if</span> (finished) &#123; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取阻塞队列中的任务</span></span><br><span class="line">        Runnable runnable = queue.take();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 修改waiting 状态</span></span><br><span class="line">            waiting = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果阻塞队列还有其它任务，则需要一起执行</span></span><br><span class="line">        runnable = queue.poll();</span><br><span class="line">        <span class="keyword">while</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.info(t);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            runnable = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记 ThreadlessExecutor 是完成状态，无业务线程等待</span></span><br><span class="line">        finished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法一般与一次 RPC 调用绑定，只会执行一次。存储在阻塞队列中的任务，只有当线程调用该方法时才会执行，执行任务的线程和调用该方法的线程是同一个线程。</p><h3 id="关联-DefaultFuture"><a href="#关联-DefaultFuture" class="headerlink" title="关联 DefaultFuture"></a>关联 DefaultFuture</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWaitingFuture</span><span class="params">(CompletableFuture&lt;?&gt; waitingFuture)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.waitingFuture = waitingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为 <code>ThreadlessExecutor</code> 设置本次调用相关的 <code>DefaultFuture</code> 对象，主要用于同步调用异常（如超时异常）时，可以更新 <code>DefaultFuture</code> 的调用状态，即使用 <code>notifyReturn</code> 方法。</p><h3 id="异常任务通知"><a href="#异常任务通知" class="headerlink" title="异常任务通知"></a>异常任务通知</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知阻塞 &#123;<span class="doctag">@link</span> #waitAndDrain()&#125; 的线程返回，避免调用出现异常还傻傻地等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyReturn</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// an empty runnable task.</span></span><br><span class="line">    execute(() -&gt; &#123;</span><br><span class="line">        waitingFuture.completeExceptionally(t);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h2><h3 id="AsyncToSyncInvoker"><a href="#AsyncToSyncInvoker" class="headerlink" title="AsyncToSyncInvoker"></a>AsyncToSyncInvoker</h3><p>前面已经对该 Invoker 进行了介绍，在服务引用时会使用该类对消费端的 Invoker 进行包装，负责将异步调用转换成同步调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       Result asyncResult = invoker.invoke(invocation);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 如果是同步调用，则调用 get() 方法，阻塞等待响应返回。</span></span><br><span class="line">           <span class="comment">// 调用的是 AsyncRpcResult.get 方法，其底层调用的是 CompletableFuture 的 get 方法</span></span><br><span class="line">           <span class="keyword">if</span> (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * NOTICE!</span></span><br><span class="line"><span class="comment">                * must call &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get(long, TimeUnit)&#125; because</span></span><br><span class="line"><span class="comment">                * &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get()&#125; 被证明有严重的性能下降。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 省略异常处理逻辑</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> asyncResult;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>业务线程进行 Invoker 调用时，会执行到 <code>AsyncToSyncInvoker.invoke</code> 方法，执行完调用后会返回一个 <code>AsyncRpcResult</code> 对象，如果是 SYNC 同步调用模式，则会调用其 <strong>get</strong> 方法，本质上是调用 <code>ThreadlessExecutor</code> 的 <strong>waitAndDrain()</strong> 方法阻塞等待响应任务。 </p><p>Dubbo 2.6.x 的异步转同步是通过 <strong>等待通知机制</strong> 实现的，使用的是 <code>Lock</code> 和 <code>Condition</code> 的组合。Dubbo 2.7.x 的异步转同步也是通过 <strong>等待通知机制</strong> 实现的，等待部分使用的是 <code>LinkedBlockingQueue.take()</code> 方法实现的，通知部分使用的是 <code>LinkedBlockingQueue.add(Runnable)</code> 实现的，由于 <code>LinkedBlockingQueue</code> 底层的实现机制也是基于 <code>Lock</code> 和 <code>Condition</code> 的组合，因此本质上实现机制是一致的。</p><h3 id="AsyncRpcResult"><a href="#AsyncRpcResult" class="headerlink" title="AsyncRpcResult"></a>AsyncRpcResult</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">            threadlessExecutor.waitAndDrain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseFuture.get(timeout, unit);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里可能会有疑问，业务线程调用 <strong>threadlessExecutor.waitAndDrain()</strong> 方法阻塞等待结果时并没有时间限制，那怎么知道调用是否超时呢？这个就是前文介绍的，在创建请求相关的 <code>DefaultFuture</code> 时还会创建一个超时检测任务，当请求超时时会立即返回一个超时异常结果，并且会通知阻塞等待的业务线程。</p><h3 id="DubboInvoker"><a href="#DubboInvoker" class="headerlink" title="DubboInvoker"></a>DubboInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboInvoker</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此次调用的方法名称</span></span><br><span class="line">        <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向 Invocation 中添加附加信息，这里将 URL 的 path 和 version 添加到附加信息中</span></span><br><span class="line">        inv.setAttachment(PATH_KEY, getUrl().getPath());</span><br><span class="line">        inv.setAttachment(VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择一个 ExchangeClient 实例</span></span><br><span class="line">        ExchangeClient currentClient;</span><br><span class="line">        <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">            currentClient = clients[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 是否是 oneway 调用 （不需要返回值）</span></span><br><span class="line">            <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            <span class="comment">// 根据调用方法名和配置，计算此次调用的超时时间</span></span><br><span class="line">            <span class="keyword">int</span> timeout = calculateTimeout(invocation, methodName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不需要关注返回值的请求</span></span><br><span class="line">            <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">              <span class="comment">// 省略调用逻辑</span></span><br><span class="line">               </span><br><span class="line">                <span class="comment">// 需要关注返回值的请求</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1 对于同步请求会使用 ThreadlessExecutor （SYNC 模式）， 对于异步请求，则会使用共享的线程池 （ASYNC 和 FUTURE 模式 ）</span></span><br><span class="line">                ExecutorService executor = getCallbackExecutor(getUrl(), inv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 使用上面选出的 ExchangeClient 执行 request() 方法将请求发出去，并传入线程池 executor。该线程池会作为处理响应的线程池，将保存到 DefaultFuture 中</span></span><br><span class="line">                CompletableFuture&lt;AppResponse&gt; appResponseFuture =</span><br><span class="line">                        <span class="comment">// currentClient.request 返回的是 DefaultFuture，DefaultFuture 继承了 CompletableFuture 。</span></span><br><span class="line">                        currentClient.request(inv, timeout, executor)</span><br><span class="line">                                <span class="comment">// 增加了一个回调，取出其中的 AppResponse 对象。</span></span><br><span class="line">                                <span class="comment">// thenApply 是一个回调,obj 是 上一个任务的结果。返回的 AppResponse 表示的是 服务端返回的具体响应。</span></span><br><span class="line">                                .thenApply(obj -&gt; (AppResponse) obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter</span></span><br><span class="line">                FutureContext.getContext().setCompatibleFuture(appResponseFuture);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3 这里将 CompletableFuture （其实是 DefaultFuture） 封装成 AsyncRpcResult 并返回</span></span><br><span class="line">                AsyncRpcResult result = <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, inv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置处理结果的线程池</span></span><br><span class="line">                result.setExecutor(executor);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>DubboInvoker 在发起调用之前，会先通过 getCallbackExecutor 方法根据调用模式获取不同的线程池实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractInvoker</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ExecutorService <span class="title">getCallbackExecutor</span><span class="params">(URL url, Invocation inv)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 从 ExecutorRepository 中获取线程池</span></span><br><span class="line">        ExecutorService sharedExecutor = ExtensionLoader.getExtensionLoader(ExecutorRepository<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>().<span class="title">getExecutor</span>(<span class="title">url</span>)</span>;</span><br><span class="line">        <span class="comment">// 2 如果是同步请求，则使用 ThreadlessExecutor 线程池，它会对共享线程池进行封装</span></span><br><span class="line">        <span class="keyword">if</span> (InvokeMode.SYNC == RpcUtils.getInvokeMode(getUrl(), inv)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadlessExecutor(sharedExecutor);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 非同步请求，则使用共享线程池</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sharedExecutor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h2><p>端点收到数据时（这里假设是响应数据）先由 IO 线程从二进制流中解码出响应，然后调用 <code>WrappedChannelHandler.received</code> 方法的实现，下面我们以 <code>AllChannelHandler</code> 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- AllChannelHandler</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前端点收到数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取线程池，如果是响应消息则优先获取发送请求时指定的关联线程池</span></span><br><span class="line">        ExecutorService executor = getPreferredExecutorService(message);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2 将消息封装成ChannelEventRunnable任务，提交到第 1 步获取的线程池中</span></span><br><span class="line">            executor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 3 如果线程池满了，请求会被拒绝，这里会根据请求配置决定是否返回一个说明性的响应</span></span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request &amp;&amp; t <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</span><br><span class="line">                sendFeedback(channel, (Request) message, t);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(message, channel, getClass() + <span class="string">" error when process received event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>符合以下条件 <code>getPreferredExecutorService</code> 方法获取的线程池就是 <code>ThreadlessExecutor</code>，否则一律使用共享线程池</strong></p><ol><li>收到的是响应消息。</li><li>响应对应的请求调用模式是 SYNC 同步调用。</li></ol><p><code>ThreadlessExecutor</code> 执行 <strong>execute</strong> 方法时，会将任务提交到阻塞队列中，处于阻塞的业务线程会从阻塞队列中获取任务并执行。</p><h2 id="线程池模型-1"><a href="#线程池模型-1" class="headerlink" title="线程池模型"></a>线程池模型</h2><p>通过复用业务端被阻塞的线程，解决了消费端线程池过度占用问题。同步调用优化后的线程模型如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/consumer-threadpool-model-new.png" alt></p><ol><li>业务线程发出请求后，拿到一个 Future 对象。</li><li>业务线程会调用 <code>ThreadlessExecutor.waitAndDrain()</code> 方法，该方法会使业务线程在阻塞队列上等待，直到队列中被加入任务。</li><li>当收到响应时，IO 线程会生成一个任务并放入 <code>ThreadlessExecutor</code> 阻塞队列中。</li><li>处于阻塞的业务线程将第 3 步添加的任务取出，并在本线程中执行。得到结果之后，调用 <code>Future.set</code> 方法进行设置，然后业务线程从 <strong>waitAndDrain()</strong> 方法返回。</li><li>业务线程继续执行，最后拿到结果值。</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章主要对 Dubbo 的线程模型改造进行了介绍，首先解决了以连接维度的消费端线程池，根据 URL 复用线程池即合理地缓存线程池实现。接着解决了消费端线程池过度占用问题，通过引入 <code>ThreadlessExecutor</code> 复用业务端被阻塞的线程实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/c812f120/&quot;&gt;异步改造&lt;/a&gt; 中对 Dubbo 
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>集合 - CopyOnWriteArrayList</title>
    <link href="https://gentryhuang.com/posts/bd5fd437/"/>
    <id>https://gentryhuang.com/posts/bd5fd437/</id>
    <published>2021-01-24T11:14:17.000Z</published>
    <updated>2021-08-05T05:05:09.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ArrayList 是一个非线程安全集合，需要使用方自行处理线程安全问题，或者使用 <code>Collections.synchronizedList</code> 包装。从 JDK 1.5 开始 JUC 中提供了使用<strong>写时复制</strong>机制实现的并发容器 <code>CopyOnWriteArrayList</code>。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>CopyOnWriteArrayList</code> 遵从 <strong>CopyOnWrite</strong>，顾名思义就是写时复制。简单来说就是当我们操作容器时并不直接操作当前容器，而是先根据当前容器复制出一个新的容器，然后在这个新的容器上操作，完成操作后再将原容器引用指向新容器。</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保护所有更改操作的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部数组。</span></span><br><span class="line"><span class="comment">     * 所有的读操作都是基于当前 array 进行的；所有的写操作都会复制一个新的 array，然后在新复制的数组上执行操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CopyOnWriteArrayList</strong> 核心属性就是以上两个。<code>lock</code> 用于保护所有更改操作，控制并发写操作。<code>array</code> 作为内部数组用于保存数据，读操作都是操作当前 <code>array</code>，写操作都是根据当前 <code>array</code> 复制一个新的 <code>array</code>，然后在这个新的数组中进行操作。</p><h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 1 获得独占锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获得 array 数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获得 array 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 根据当前 array 复制一个新的数组，长度 +1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 将元素加入到新数组</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6 替换旧数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 7 释放独占锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对上述代码流程进行说明：</p><ol><li>使用 <code>ReentrantLock</code> 独占锁保证同时只有一个线程对集合进行写操作。</li><li>数据存储在 <code>CopyOnWriteArrayList</code> 的内部 array 数组中。</li><li>元素并不是直接存储到 array 数组中，而是复制出一个新的数组，并且复制出的数组的长度是旧数组长度+1，然后将元素加入到新数组中，最后再把旧的数组替换成新的数组。</li></ol><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于整个 get 方法是没有加锁的，而 <code>CopyOnWriteArrayList</code> 的写操作是通过复制出新的数组来完成操作的，这可能会导致读写的短暂不一致。</p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       <span class="comment">// 1 获得独占锁</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 2 获得当前 数组 array</span></span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 3 根据下标，获得旧的元素</span></span><br><span class="line">           E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 4 如果旧的元素不等于新的元素，等同于 add 方法，不过这里没有增加数组容量大小</span></span><br><span class="line">           <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">               <span class="keyword">int</span> len = elements.length;</span><br><span class="line">               Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">               newElements[index] = element;</span><br><span class="line">               setArray(newElements);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 5 为了保证 volatile 语义，即使元素没有改变也要替换成新的数组</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">               setArray(elements);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 6 释放独占锁</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>和 add 方法类似，不同的是对要修改的元素进行判断。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">// 1 获取独占锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2 获取对应下标元素</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            E oldValue = get(elements, index);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3 确定调整位置，并根据该位置移动元素</span></span><br><span class="line">            <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3.1 要删除的元素在末尾</span></span><br><span class="line">            <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">                setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3.2 要删除的元素在数组中间</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">                System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                        numMoved);</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 4 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除方法和其它修改方法类似，先是获取独占锁来保证线程安全，接着判断要删除的元素是否是最后一个，如果是最后一个则复制出一个长度-1的新数组然后替换掉旧数组；如果要删除的元素不是最后一个，则分两次复制，随后替换旧数组。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 迭代器</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 数据快照</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 遍历数组元素的游标</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">           cursor = initialCursor;</span><br><span class="line">           snapshot = elements;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 判断是否还有下一个元素</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 判断是否有上一个元素</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取下个元素</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!hasNext())</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">           <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">           <span class="keyword">return</span> (E) snapshot[--cursor];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 不支持写操作</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当获取迭代器时，内部会调用 <code>COWIterator</code> 的构造方法，该构造方法有两个参数，一个是 array 数组，另一个是下标 0 。构造方法中会把 array 数组赋值给 <code>snapshot</code> 变量，当其他线程进行了增删改的操作，旧的数组会被新的数组给替换掉，但是 <code>snapshot</code> 还是原来旧的数组的引用。当我们使用迭代器遍历 CopyOnWriteArrayList 的时候，不能保证拿到的数据是最新的，这是弱一致性问题。</p><h1 id="设计特点"><a href="#设计特点" class="headerlink" title="设计特点"></a>设计特点</h1><p>CopyOnWriteArrayList 仅适用于<strong>写操作非常少的场景，而且能够容忍读写的短暂不一致</strong>。虽然采用了读写分离思想，但写操作时内存里会同时存在两个对象的内存，若这些对象占用内存较大，可能会带来系列问题，如造成频繁 GC。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>CopyOnWriteArrayList 是 Java 并发包中相对比较简单的一个实现，它的核心思想是写时复制机制，支持并发读写，但带来的后果是内存 double 和数据一致性问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;ArrayList 是一个非线程安全集合，需要使用方自行处理线程安全问题，或者使用 &lt;code&gt;Collections.synchroniz
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="CopyOnWrite" scheme="https://gentryhuang.com/tags/CopyOnWrite/"/>
    
  </entry>
  
  <entry>
    <title>集合 - ConcurrentHashMap</title>
    <link href="https://gentryhuang.com/posts/218dc61f/"/>
    <id>https://gentryhuang.com/posts/218dc61f/</id>
    <published>2021-01-18T12:30:35.000Z</published>
    <updated>2021-08-03T07:35:24.263Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="ConcurrentHashMap" scheme="https://gentryhuang.com/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>集合 - HashMap</title>
    <link href="https://gentryhuang.com/posts/8c0fc113/"/>
    <id>https://gentryhuang.com/posts/8c0fc113/</id>
    <published>2021-01-10T12:30:35.000Z</published>
    <updated>2021-08-03T09:37:22.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HashMap 是基于哈希表实现的，外层是一个数组，数组中的每个元素封装了一个 <code>key-value</code> 及其他元数据信息，这些元数据信息是为了更好的管理数组中某个位置中的元素，如使用单链表或红黑树组织元素，元素数据信息就是对应的指针等信息。对 HashMap 进行增、删、改、查都需要经历两个必须的步骤，先计算 <code>key</code> 的 <code>hash</code> 值，接着根据 <code>hash</code> 值计算出当前键值对位于数组的哪个位置。HashMap 虽然基础，但是其中的思想值得学习。本篇文章将分别对 JDK 7、8 版本下的 HashMap 进行介绍。</p><h1 id="JDK-7-HashMap"><a href="#JDK-7-HashMap" class="headerlink" title="JDK 7 HashMap"></a>JDK 7 HashMap</h1><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-7-struct.jpg" alt></p><p>JDK 1.7 的 HashMap 结构如上图所示。内部存储结构是数组和链表的结合，在实例化 HashMap 时会创建一个长度为 Capacity 的 Entry 数组，这个长度被称为容量，数组中可以存放元素的位置我们称为<strong>桶（bucket）</strong>，每个 bucket 都有自己的索引下标，系统可以根据索引下标快速查找 bucket 中的元素。每个 bucket 中存储一个元素，即一个 Entry 对象，但每一个 Entry 对象都可以通过指针链接下一个元素，因此，在一个 bucket 中就有可能生成一个 Entry 链。</p><h2 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化化容量, 16  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//最大容量，即2的30次方  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认负载因子  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap内部的存储结构是一个数组，此处数组为空，即没有初始化之前的状态  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 空的存储实体  </span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//实际存储的 key-value 键值对的个数。注意和容量的区分。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。</span></span><br><span class="line"><span class="comment">// HashMap在进行扩容时需要参考threshold</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子，代表了table的填充度有多少，默认是0.75。</span></span><br><span class="line"><span class="comment">// 为什么是 0.75 ，是根据 泊松统计定义的</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的 threshold 值  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</span><br></pre></td></tr></table></figure><p>注意，HashMap 数组的每一个元素不止是一个 Entry 对象，也是一个链表的头节点。每一个 Entry 对象通过 next 指针指向它的下一个 Entry 节点。当新来的 Entry 映射到冲突的数组位置时，只需要插入到对应的链表即可。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过初始容量和负载因子构造HashMap  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +                                             initialCapacity);  </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;  </span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +  </span><br><span class="line">                                           loadFactor);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别赋值 负载因子 和 扩容阈值</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;  </span><br><span class="line">    threshold = initialCapacity;  </span><br><span class="line">    <span class="comment">//init方法在HashMap中没有实际实现</span></span><br><span class="line">    init();</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过扩容阈值构造 HashMap,容量是默认值 16  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子取0.75，容量取16，构造HashMap  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过其他 Map 来初始化HashMap,容量通过其他Map的size来计算，装载因子取0.75  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);  </span><br><span class="line">    <span class="comment">//初始化HashMap底层的数组结构  </span></span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">    <span class="comment">//添加m中的元素  </span></span><br><span class="line">    putAllForCreate(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Put方法原理"><a href="#Put方法原理" class="headerlink" title="Put方法原理"></a>Put方法原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当插入第一个元素的时候，根据情况先初始化数组大小</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 key 为 null，最终会将这个 entry 放到 table[0] 中</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 求 key 的 hash 值</span></span><br><span class="line">    <span class="comment">// 对 key 的 hashcode 进一步计算，确保散列均匀</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 找到对应的数组下标</span></span><br><span class="line">    <span class="comment">// i = h &amp; (table.length-1)，效果同取模运算</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在， 如果有，直接覆盖，put 方法返回旧值就结束了</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 不存在重复的 key，新增一个 entry 并添加到链表中</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述方法可知，确定一个元素的存储位置需要以下步骤：</p><ol><li>通过元素的 key 获取对应的 hash 值，其中使用到了 key 的 hashcode 值。</li><li>通过 hash 值和数组 length 信息计算得到存储的下标索引位置。</li><li>知道了对应的下标索引位置后就可以取出对应的元素了，如果该位置的元素有多个，那么需要遍历获取。</li></ol><h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 保证数组大小一定是 2 的 n 次方，采用向上取整的策略。如 new HashMap(20)，那么处理成初始数组大小是 32</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 2 计算扩容阈值：capacity * loadFactor</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3 创建数组</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); <span class="comment">//ignore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保证数组大小一定是 2^n 是为了实现一个尽量均匀分布的 Hash 函数。HashMap 采用类似如下的公式计算元素对应的数组位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HashCode 并不是 key 的直接 hashcode 值，而是对其处理后的值</span><br><span class="line">&#x2F;&#x2F; length 是 HashMap 的长度</span><br><span class="line">index &#x3D; HashCode(key) &amp; (lenght -1)</span><br></pre></td></tr></table></figure><p>可以看到，HashMap 的作者采用了位运算的方式代替取模运算，只要数组大小是 2^n 就可以保证 length - 1 的值的二进制位全是 1，这种情况下，index 的结果等同于 HashCode 后几位的值。只要输入的 HashCode 本身分布均匀，Hash算法的结果就是均匀的。</p><h3 id="添加节点到链表中"><a href="#添加节点到链表中" class="headerlink" title="添加节点到链表中"></a>添加节点到链表中</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 如果当前 HashMap 大小已经达到了阈值，并且新键值对要插入的数组位置已经有元素了，那么要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.1 扩容，后面会介绍一下</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">// 1.2 扩容以后，重新计算 hash 值</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 1.3 重新计算扩容后的新的下标</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 如果需要扩容，是先扩容再插入元素</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新的键值对放到链表的表头，然后 size++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取待插入位置元素</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里执行链接操作，使得新插入的元素指向原有元素。这保证了新插入的元素总是在链表的头  </span></span><br><span class="line">    <span class="comment">// e 赋值给 Entry 中的 next</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素个数+1</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在添加元素的过程中需要先判断是否需要扩容，扩容的标准是<strong>当前 HashMap 元素大小达到扩展阈值且要插入的位置已经有元素了</strong>。需要扩容的话先进行扩容，然后再将这个新的键值对插入到扩容后的数组的相应位置处的链表的表头。</p><p>注意，新的 Entry 节点插入链表时使用的是 <strong>头插法</strong>，作者认为后插入的 Entry 被查找的可能性更大。</p><h2 id="Get方法原理"><a href="#Get方法原理" class="headerlink" title="Get方法原理"></a>Get方法原理</h2><p>相比较 put 过程，get 过程是非常简单的，主要过程如下：</p><ol><li>根据 key 计算 hash 值</li><li>计算相应的数组下标： index = hash &amp; (length - 1)</li><li>遍历该数组位置处的链表，直到找到相同的 key 或为 null</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 走查找流程</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回对应的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 通过 hash 函数计算 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 确定数组下标，然后从头开始遍历链表，直到找到为止</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 在对应的数组位置没有找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>HashMap 的容量是有限的，当经过多次元素插入会使得 HashMap 达到一定饱和度时，key 映射位置发生冲突的几率会逐渐提高，这时 HashMap 需要进行扩容。在 put 的过程，如果当前 HashMap 元素个数 size 已经达到了阈值且要插入的数组位置上已经有元素了，那么就会触发扩容，扩容后数组大小是原来的 2 倍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 保存旧数组 </span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 保存旧容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 如果旧容量已经是系统默认最大容量了，那么将阈值设置成整型的最大值，退出</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 扩容，创建一个新的空数组，长度是原数组的 2 倍</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5 将原来数组中的键值对迁移到新的更大的数组中</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6 扩容完毕后，用新的数组指向 table</span></span><br><span class="line">    table = newTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7 计算新的扩容阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 作用：将旧数组上的数据（键值对）转移到新 table 中，从而完成扩容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 容量</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两层循环</span></span><br><span class="line">        <span class="comment">// 外层 for 循环 用于遍历数组</span></span><br><span class="line">        <span class="comment">// 内层 while 循环 用于遍历数组中对应位置的链表</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123; </span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123; </span><br><span class="line"></span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;  </span><br><span class="line">                <span class="comment">//如果是重新 Hash，则需要重新计算hash值  </span></span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);  </span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算元素 e 在新数组中的位置</span></span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 头插入，newTable[i]的值总是最新插入的值</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e; </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 继续下一个元素  </span></span><br><span class="line">                e = next;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上扩容代码相对还是比较直观的，整个扩容分为两个步骤：扩容和rehash。</p><p>我们知道，在多线程环境中 HashMap 是不安全的，其中一个很大的问题就是数组中某个位置的链表可能成环，这个问题就是发生在 rehash 过程。下面我们对该现象详细分析。</p><h2 id="链表成环"><a href="#链表成环" class="headerlink" title="链表成环"></a>链表成环</h2><p>假设一个 HashMap 已经到了扩容的临界点，此时刚好有两个线程 A 和 B 在同一时刻对 HashMap 进行 put 操作，那么两个线程各自进行扩容：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-1.png" alt></p><p>接着两个线程都来到 <code>transfer</code> 方法中，其中线程 B 遍历到 Entry3 对象，刚执行完以下代码时就被挂起了。此时线程 B 的状态数据，e = Entry3，next = Entry2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br></pre></td></tr></table></figure><p>而在线程 B 被挂起期间，线程 A 成功完成了 rehash 过程，结果如下（图中的 e 和 next 分别代表线程 B 持有的两个 Entry 引用）。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-2.png" alt></p><p><strong>第一轮</strong></p><p>当线程 A 完成 rehash 后线程 B 恢复，继续执行属于它的 rehash 过程。接着执行以下代码，确认 e 对应的元素应该位于新数组哪个索引位置，毫无疑问地 i = 3，因为刚才线程 A 对 Entry3 的映射结果就是 3 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算元素 e 在新数组中的位置</span></span><br><span class="line"><span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br></pre></td></tr></table></figure><p>接续执行后续的代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头插入，newTable[i]的值总是最新插入的值</span></span><br><span class="line">e.next = newTable[i];</span><br><span class="line">newTable[i] = e; </span><br><span class="line"></span><br><span class="line"><span class="comment">//继续下一个元素  </span></span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure><p>对应的情况如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-3.png" alt></p><p>至此，第一轮执行完毕，此时线程 B 将 Entry3 rehash 到了自己的新数组中，且它的 e 和 next 指针同时指向 Entry2 。注意，线程 B 操作的 Entry 节点还是原来的节点，虽然原来的 Entry 节点被线程 A 进行了 rehash ，但是引用指向没有变。</p><p><strong>第二轮</strong></p><p>接着执行新的一轮，此时又执行到以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br></pre></td></tr></table></figure><p>此时，e = Entry2，next = Entry3 ，整体情况如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-4.png" alt></p><p>接着继续执行以下三行代码，采用头插法把 Entry2 插入到线程 B 的数组的头节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 头插入，newTable[i]的值总是最新插入的值</span></span><br><span class="line"> e.next = newTable[i];</span><br><span class="line"> newTable[i] = e; </span><br><span class="line"></span><br><span class="line"> <span class="comment">//继续下一个元素  </span></span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure><p>整体情况如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-5.png" alt></p><p>至此，第二轮执行完毕，此时线程 B 将 Entry2 rehash 到了自己的新数组中，且它的 e 和 next 指针同时指向 Entry3 。</p><p><strong>第三轮</strong></p><p>接着执行新的一轮，此时又执行到以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br></pre></td></tr></table></figure><p>此时，e = Entry3,next = null，接着继续执行以下代码，做头插法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头插入，newTable[i]的值总是最新插入的值</span></span><br><span class="line">e.next = newTable[i];</span><br></pre></td></tr></table></figure><p>此时，链表出现了环形。相关数据关系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newTable[i] = Entry2</span><br><span class="line">e = Entry3</span><br><span class="line">Entry2.next = Entry3</span><br><span class="line">Entry3.next = Entry2</span><br></pre></td></tr></table></figure><p>整体情况如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-rehash-error-6.png" alt></p><p>最后，执行以下代码将新元素设为头，也就是将 Entry3 设置为头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newTable[i] = e;</span><br></pre></td></tr></table></figure><p>至此，第三轮执行完毕，此时线程 B 将 Entry3 和 Entry2 互相使用 next 指针链接起来形成了一个环。由于 next = null ，因此在下一轮开始判断的时候不满足条件，结束数组当前位置数据的 rehash 。</p><p>此时，坑已经埋好了，就等调用 get 查找一个不存在的 key ，而这个 key 的 hash 结果恰好等于 3 的时候，由于位置 3 带有环形链表，因此程序会进入死循环。</p><p>值得说明的是，在一定程度上链表头插法会<strong>颠倒</strong>原来一个位置上链表的顺序。在并发的时候原来的顺序被线程 A 颠倒了，而被挂起的线程 B 恢复后拿到挂起前的节点和顺序继续完成 rehash，这个过程会将线程 A rehash 后的链表顺序重新排列，最终形成了环。JDK 1.8 之后就不再采用头插法了，而是直接插入链表尾部，因此不会形成环形链表形成死循环，但是在多线程的情况下仍然是不安全的，在put数据时如果出现两个线程同时操作，可能会发生数据覆盖，引发线程不安全。</p><h1 id="JDK-8-HashMap"><a href="#JDK-8-HashMap" class="headerlink" title="JDK 8 HashMap"></a>JDK 8 HashMap</h1><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-8-struct.jpg" alt></p><p>JDK 1.8 的 HashMap 结构大体上如上图所示，具体细节并没有展示，比如红黑树中的链接指针没有全部显示。JDK 1.7 的 HashMap 采用 <strong>数组+链表</strong> 的方式在大部分情况下都能有不错的性能，但在极端的情况下可能会退化成一个链表，造成 HashMap 性能急剧下降。因此在 JDK 1.8 中采用了 <strong>数组+链表+红黑树</strong>的方式来组织数据，新增红黑树是为了解决哈希碰撞，避免过长链表效率低的问题。</p><h2 id="关键属性-1"><a href="#关键属性-1" class="headerlink" title="关键属性"></a>关键属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认容量大小 16，大小必须是 2^N</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大容量，当两个构造函数中任何一个带参数的函数隐式指定较大的值时使用。一定是2 &lt;= 1&lt;&lt;30的幂。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认负载因子 在构造函数中未指定时使用的负载因子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 桶的树化阈值： 使用红黑树时元素个数的阈值。在存储数据时，当链表长度 &gt;= 8时，则将链表转换成红黑树。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 桶的链表还原阈值：红黑树转链表阈值。</span></span><br><span class="line"><span class="comment">     * 当在扩容时，在重新计算存储位置后，当原有的红黑树内数量 &lt;= 6时，则将 红黑树转换成链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小树形化容量阈值：使用红黑树时最小的表容量。当 HashMap 中的容量 &gt; 该值时，才允许树形化链表即将链表转成红黑树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储数据的 Node 数组，长度是 2 的幂。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K, V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * table 容纳的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap 被改变的次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容的阈值（当前 HashMap 所能容纳键值对数量的最大值，超过该值则需要扩容），等于 capacity * loadFactory</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负载因子，默认为 0.75</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TREEIFY_THRESHOLD</code> 和 <code>UNTREEIFY_THRESHOLD</code> 两个参数是控制链表和红黑树相互转换的阈值，它们中间有个差值 7 可以有效防止链表和树频繁转换。其它属性和 JDK 1.7 版本中的类似。值得说明的是桶数组 table 被申明为 transient ，也就是不会被默认的序列化机制序列化。但 HashMap 通过实现 <code>readObject/writeObject</code> 两个方法自定义了序列化的内容，也就是将键值对序列化，后续可以根据键值对数据重建 HashMap。</p><p>这里不直接将 table 进行序列化是为了避免以下问题：</p><ol><li>table 多数情况下是无法被存满的，序列化未使用的部分，浪费空间</li><li>同一个键值对在不同 JVM 下所处的桶位置可能是不同的，这种情况下反序列化 table 可能会发生错误。</li></ol><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * HashMap 中元素项，用于链表的情况。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="comment">// key 对应的 hash 值</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">      <span class="comment">// key</span></span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">      <span class="comment">// value</span></span><br><span class="line">      V value;</span><br><span class="line">      <span class="comment">// 下一个元素的指针</span></span><br><span class="line">      Node&lt;K, V&gt; next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * HashMap 中元素项，用于红黑树的情况</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      TreeNode&lt;K, V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">      TreeNode&lt;K, V&gt; left;</span><br><span class="line">      TreeNode&lt;K, V&gt; right;</span><br><span class="line">      TreeNode&lt;K, V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">      <span class="keyword">boolean</span> red;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定容量大小和负载因子的构造函数，是最基础的构造函数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                   initialCapacity);</span><br><span class="line">       <span class="comment">// HashMap的最大容量只能是MAXIMUM_CAPACITY</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                   loadFactor);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置负载因子</span></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 取大于 cap 且最近的2的整数次幂的数作为扩容的阈值</span></span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 指定容量大小</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用默认属性</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用给定的数据源初始化 HashMap</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="确定桶位置"><a href="#确定桶位置" class="headerlink" title="确定桶位置"></a>确定桶位置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab[(n -<span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure><p>计算方式和 JDK 1.7 HashMap 是一致的。HashMap 的数组长度 <code>length</code> 总是 2^n ，因此 <code>(n - 1) &amp; hash</code> 等价于对 <code>length</code> 取余，由于取余运算效率没有位运算高，这里做了一个优化。此外，<code>length - 1</code> 正好相当于一个低位掩码，<code>&amp;</code> 操作的结果就是 <code>hash</code> 值的高位全部归零，只保留对应的低位值，即定位数组桶的位置取决于 <code>hash</code> 值的低几位。</p><h2 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述方法计算 hash 值没有直接使用 key 的 hashCode 方法生成的 hash 值，而是通过位运算重新计算出一个 hash 值。在 Java 中 hashCode 方法产生的 hash 是 int 类型，也就是 32 位。由于确定数组的桶位置是通过 <code>(n - 1) &amp; hash</code> 计算得到的，这就要求计算 <code>hash</code> 值的算法要具有随机性。因此，在计算 key 的 hashCode 时用其自身 hashCode 与其低 16 位做 <code>^</code> 操作，这让高位也参与到 hash 值的计算中来，进而降低了哈希冲突的风险又不会带来太大的性能问题。此外，重新计算 hash 的另一个好处是可以增加 hash 的复杂度。当我们覆写 hashCode 方法时，可能会写出分布性不佳的 hashCode 方法，进而导致 hash 的冲突率比较高。通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。计算过程如下：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/hash-map-8-hash-process.png" alt></p><h2 id="Get方法原理-1"><a href="#Get方法原理-1" class="headerlink" title="Get方法原理"></a>Get方法原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据 key 获取对应 value</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      Node&lt;K, V&gt; e;</span><br><span class="line">      <span class="comment">// 根据 key 的 hashCode 计算得到 hash 值，然后利用 pos = （n-1）&amp; hash 计算其在数组中的位置</span></span><br><span class="line">      <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">      Node&lt;K, V&gt;[] tab;</span><br><span class="line">      Node&lt;K, V&gt; first, e;</span><br><span class="line">      <span class="keyword">int</span> n;</span><br><span class="line">      K k;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1 如果 key 对应的数组位置有元素</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">              (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 1.1 先在头节点中找</span></span><br><span class="line">          <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                  ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              <span class="keyword">return</span> first;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 1.2 头节点不是目标元素</span></span><br><span class="line">          <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 1.2.1 如果是红黑树，则去红黑树中找</span></span><br><span class="line">              <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                  <span class="keyword">return</span> ((TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 1.2.2 如果不是红黑树，则说明是链表，那么就从链中找</span></span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                          ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">return</span> e;</span><br><span class="line">              &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Get方法逻辑还是比较简单的。先定位键所在的桶的位置，然后再对链表或红黑树进行查找。</p><h2 id="Put方法原理-1"><a href="#Put方法原理-1" class="headerlink" title="Put方法原理"></a>Put方法原理</h2><p>Put方法先定位要插入的键值对属于哪个桶，定位到桶后，再判断桶是否为空。如果为空，则将键值对存入即可。如果不为空，则需将键值对插入到链表最后一个位置或红黑树中，或者更新键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加键值对</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 通过 hash(key) 计算 key 的 hash 值</span></span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 尾插法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> hash         key 的 hash</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key          the key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value        the value to put</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> onlyIfAbsent 如果为 true ，那么只有在不存在该 key 时才会进行 put 操作，默认是 false 即覆盖</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> evict        if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">      Node&lt;K, V&gt;[] tab;</span><br><span class="line">      Node&lt;K, V&gt; p;</span><br><span class="line">      <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 初始化数组 table，table 被延迟到插入新数据时再进行初始化</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// key 映射的数组桶位置为空，则创建一个 Node 填充到对应位置即可</span></span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// key 映射的数组桶位置有数据</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          Node&lt;K, V&gt; e;</span><br><span class="line">          K k;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 在该位置的第一个数据的 key 和要插入 遇到相同的 key 了</span></span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                  ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              e = p;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 在红黑树中插入节点</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">              e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 在链表中插入节点</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 对链表进行遍历，并统计链表长度</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 链表中不包含要插入的键值对节点，则插入到链表的最后，即尾插法</span></span><br><span class="line">                  <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 如果链表长度大于或等于树化阈值，则进行树化操作，也就是将链表转换为红黑树</span></span><br><span class="line">                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                          treeifyBin(tab, hash);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 如果在链表中找到了相同的 key</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                          ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="comment">// 此时 break，那么 e 为链表中与要插入的新值的 key 相同的 node</span></span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 用于遍历下一个</span></span><br><span class="line">                  p = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 判断要插入的键值对是否存在 HashMap 中</span></span><br><span class="line">          <span class="comment">// e != null 说明存在旧值的 key 与要插入的 key 相同</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">              V oldValue = e.value;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值</span></span><br><span class="line">              <span class="comment">// key 相同进行值覆盖</span></span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 返回旧值</span></span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 增加修改次数</span></span><br><span class="line">      ++modCount;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line"></span><br><span class="line">      afterNodeInsertion(evict);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>下面对 Put逻辑进行小结：</p><ol><li>当桶数组 table 为空时，通过扩容的方式初始化 table</li><li>查找要插入的键值对是否已经存在，存在的话根据条件判断是否用新值替换旧值</li><li>如果不存在，则将键值对插入红黑树或链表中，其中插入到链表的过程还会根据链表的长度决定是否将链表转为红黑树。具体转换会在下文进行介绍。</li><li>判断键值对数量是否大于阈值，大于的话则进行扩容操作</li></ol><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><p>在 HashMap 中，桶数组的长度均是 2^n ，当键值对数量超过扩容阈值时，需要进行扩容。HashMap 按当前桶数组长度的 2 倍进行扩容，扩容阈值也更新为原来的 2 倍。扩容之后，需要重新计算键值对的位置，并把它们移动到合适的位置上去。和 JDK 1.7 不同的是，JDK 1.7 是先判断是否需要扩容后插入新值，JDK 1.8 是先插入值再判断是否需要扩容，并且前者是头插法后者是尾插法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化数组或数组扩容</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">      Node&lt;K, V&gt;[] oldTab = table;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// table 旧的容量，最开始 table 为空</span></span><br><span class="line">      <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 扩容阈值</span></span><br><span class="line">      <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">      <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// oldCap &gt; 0 ，说明是对数组扩容</span></span><br><span class="line">      <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 超过最大容量，则使用 Integer.MAX_VALUE 的值，不再进行扩容</span></span><br><span class="line">          <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">              threshold = Integer.MAX_VALUE;</span><br><span class="line">              <span class="keyword">return</span> oldTab;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 将 数组扩大一倍</span></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">              <span class="comment">// 将 扩容阈值 也增大一倍</span></span><br><span class="line">              newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候初始容量设置为 threshold</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">          newCap = oldThr;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候初始容量使用默认值</span></span><br><span class="line">      <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          <span class="comment">// 计算扩容阈值，为 12</span></span><br><span class="line">          newThr = (<span class="keyword">int</span>) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// newThr 为 0 时，按阈值计算公式进行计算</span></span><br><span class="line">      <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">float</span> ft = (<span class="keyword">float</span>) newCap * loadFactor;</span><br><span class="line">          newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>) MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>) ft : Integer.MAX_VALUE);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新扩容阈值</span></span><br><span class="line">      threshold = newThr;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用新的数组大小初始化新的数组</span></span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span>&#125;)</span><br><span class="line">      Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node[newCap];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果非扩容而是初始化数组，执行到这里就结束了</span></span><br><span class="line">      table = newTab;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 扩容，进行数据迁移</span></span><br><span class="line">      <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 遍历原数组，将键值对映射到新的桶数组中</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">              Node&lt;K, V&gt; e;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 取出下标 j 的元素</span></span><br><span class="line">              <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">// 如果当前数组位置上只有一个 Node 元素，简单迁移即可</span></span><br><span class="line">                  <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                      <span class="comment">// 通过 hash 值计算出在新数组中所属的位置</span></span><br><span class="line">                      newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 如果是红黑树，需要对红黑树进行拆分</span></span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                      ((TreeNode&lt;K, V&gt;) e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 链表处理</span></span><br><span class="line">                  <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 将当前链表拆分成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line"></span><br><span class="line">                      <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表</span></span><br><span class="line">                      Node&lt;K, V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K, V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                      Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class="line">                      <span class="keyword">do</span> &#123;</span><br><span class="line">                          next = e.next;</span><br><span class="line"></span><br><span class="line">                          <span class="comment">// 根据e的 hash 值和旧的容量做位与运算是否为 0 来拆分当前链表进行分组，注意之前是 e.hash &amp; (oldCap - 1)</span></span><br><span class="line">                          <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                  loHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  loTail.next = e;</span><br><span class="line">                              loTail = e;</span><br><span class="line"></span><br><span class="line">                          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                  hiHead = e;</span><br><span class="line">                              <span class="keyword">else</span></span><br><span class="line">                                  hiTail.next = e;</span><br><span class="line">                              hiTail = e;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 将分组后的链表映射到新桶中</span></span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 第一条链表</span></span><br><span class="line">                      <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j] = loHead;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 第二条链表的新的位置是 j + oldCap</span></span><br><span class="line">                      <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                          hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                          newTab[j + oldCap] = hiHead;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>下面对上述代码流程进行总结：</p><ol><li>计算新桶数组的容量 newCap 和新扩容阈值 newThr</li><li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li><li>将遍历的桶数组的键值对节点重新映射到新的桶数组中。如果节点是 TreeNode 类型，则需要拆分红黑树进行分组然后映射；如果是普通节点，也就是链表，则同样需要分组然后映射。注意，以上分组的依据是根据节点的 hash 值和旧的容量做位与运算是否为 0 来限定的。</li></ol><p>在 JDK 1.8 中，重新映射节点需要考虑节点类型。对于树形节点，需要先拆分分组然后映射；对于链表类型节点，也需要先拆分分组，然后映射。需要注意的是，分组后，组内节点相对位置保持不变。相对与 JDK 1.7 ，JDK 1.8 采用尾插法且以分组的方式进行重新映射，避免了链表成环的问题。</p><h2 id="树化、链化与拆分"><a href="#树化、链化与拆分" class="headerlink" title="树化、链化与拆分"></a>树化、链化与拆分</h2><p>JDK 1.8 对 HashMap 实现进行了改进。最大的改进莫过于引入红黑树处理频繁的碰撞，同时也增加了代码实现的复杂度。本小结将对 HashMap 中 <code>链表树化</code>、<code>红黑树链化</code>以及<code>红黑树拆分</code> 进行说明。</p><h3 id="链表树化"><a href="#链表树化" class="headerlink" title="链表树化"></a>链表树化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K, V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, index;</span><br><span class="line">        Node&lt;K, V&gt; e;</span><br><span class="line">        <span class="comment">// 数组容量小于 MIN_TREEIFY_CAPACITY，优先进行扩容而不是树化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出数组对应位置的头节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// hd 为头节点(head)，tl 为尾节点（tail）</span></span><br><span class="line">            TreeNode&lt;K, V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 将普通节点替换成树形节点</span></span><br><span class="line">                TreeNode&lt;K, V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将普通链表转成由树形节点链表</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将树形链表转换成红黑树</span></span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For treeifyBin</span></span><br><span class="line">    <span class="function">TreeNode&lt;K, V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K, V&gt; p, Node&lt;K, V&gt; next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>将链表转为红黑树需要满足以下两个条件：</p><blockquote><ol><li>链表长度大于等于 <code>TREEIFY_THRESHOLD</code> 8</li><li>桶数组容量大于等于 <code>MIN_TREEIFY_CAPACITY</code> 64</li></ol></blockquote><p>上述方法主要的过程是，先将链表转成由 <code>TreeNode</code> 类型节点组成的链表，并在最后调用 <code>treeify</code> 将该链表转为红黑树。TreeNode 继承自 Node ，所以 TreeNode 仍然包含 next 引用，原链表的节点顺序最终通过 next 引用被保存下来。</p><h3 id="红黑树拆分"><a href="#红黑树拆分" class="headerlink" title="红黑树拆分"></a>红黑树拆分</h3><p>在扩容的过程，普通节点需要重新映射，红黑树节点同样也需要。在将普通链表转成红黑树时，HashMap 通过两个额外的引用 next 和 prev 保留了原链表的节点顺序。这样再对红黑树进行重新映射时，完全可以按照映射链表的方式进行，这样就避免了将红黑树转成链后再映射的过程，在一定程度上提高了效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K, V&gt; map, HashMap.Node&lt;K, V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; b = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新链接到 lo 和 hi 列表，保持顺序</span></span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 红黑树节点仍然保留了 next 引用，因此仍可以按链表方式遍历红黑树。下面的循环是对红黑树节点进行分组，与上面类似</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (HashMap.TreeNode&lt;K, V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">            next = (HashMap.TreeNode&lt;K, V&gt;) e.next;</span><br><span class="line">            e.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                    loHead = e;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    loTail.next = e;</span><br><span class="line">                loTail = e;</span><br><span class="line">                ++lc;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                    hiHead = e;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    hiTail.next = e;</span><br><span class="line">                hiTail = e;</span><br><span class="line">                ++hc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 loHead 不为空，且链表长度小于等于 6，则将红黑树转成链表</span></span><br><span class="line">        <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                tab[index] = loHead.untreeify(map);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = loHead;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// hiHead == null 时，表明扩容后，所有节点仍在原位置，树结构不变，无需重新树化</span></span><br><span class="line">                <span class="comment">// 否则，将 TreeNode 链表树化</span></span><br><span class="line">                <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                    loHead.treeify(tab);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与上面类似</span></span><br><span class="line">        <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index + bit] = hiHead;</span><br><span class="line">                <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                    hiHead.treeify(tab);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看到，重新映射红黑树的逻辑和重新映射链表的逻辑基本一致。不同的地方在于，重新映射后，会将红黑树拆分成两条由 TreeNode 组成的链表。如果链表长度小于等于 <code>UNTREEIFY_THRESHOLD</code>，则将链表转换成普通链表。否则根据条件重新将 TreeNode 链表树化。</p><h3 id="红黑树链化"><a href="#红黑树链化" class="headerlink" title="红黑树链化"></a>红黑树链化</h3><p>红黑树中仍然保留了原链表节点顺序，有了这个基础再将红黑树转成链表就简单多了，仅需要将 <code>TreeNode</code> 链表转成 Node 类型的链表即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 红黑树中仍然保留了原链表节点顺序。有个这个特点，再将红黑树转成链表就简单多了，仅需将 TreeNode 链表转成 Node 类型的链表即可。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> HashMap.<span class="function">Node&lt;K, V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K, V&gt; map)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 用于组织链表的头、尾指针</span></span><br><span class="line">       HashMap.Node&lt;K, V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 遍历 TreeNode 链表，并用 Node 替换</span></span><br><span class="line">       <span class="keyword">for</span> (HashMap.Node&lt;K, V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 替换节点类型</span></span><br><span class="line"><span class="comment">            *    Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">            *            return new Node&lt;&gt;(p.hash, p.key, p.value, next);</span></span><br><span class="line"><span class="comment">            *       &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           HashMap.Node&lt;K, V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">               hd = p;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               tl.next = p;</span><br><span class="line">           tl = p;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> hd;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>感觉没什么可总结的~</p><p><strong>参考</strong></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&mid=2653191907&idx=1&sn=876860c5a9a6710ead5dd8de37403ffc&chksm=8c990c39bbee852f71c9dfc587fd70d10b0eab1cca17123c0a68bf1e16d46d71717712b91509&scene=21#wechat_redirect" target="_blank" rel="noopener">什么是HashMap</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;HashMap 是基于哈希表实现的，外层是一个数组，数组中的每个元素封装了一个 &lt;code&gt;key-value&lt;/code&gt; 及其他元数据信
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="HashMap" scheme="https://gentryhuang.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java基础 - JDK动态代理</title>
    <link href="https://gentryhuang.com/posts/d38b32e5/"/>
    <id>https://gentryhuang.com/posts/d38b32e5/</id>
    <published>2021-01-03T12:30:35.000Z</published>
    <updated>2021-06-30T07:37:40.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java 中代理分为两大类，一类是静态代理，另一类是动态代理。静态代理是针对需要被代理的类在编译之前就已经写好了对应的代理类，也就是说代理关系在编译之前就确立了。动态代理是针对目标类在程序运行期间自动生成的代理类，细分为有接口的代理类和无接口的代理类。JDK动态代理支持目标类有接口的情况，目标类没有接口无法为其生成代理类，能够为没有接口生成代理类的工具如 CGLIB 等。本篇文章将对JDK动态代理实现原理进行介绍。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPrintf</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintfImpl</span> <span class="keyword">implements</span> <span class="title">IPrintf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"print: "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代理对象"><a href="#代理对象" class="headerlink" title="代理对象"></a>代理对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IPrintf PRINTF = <span class="keyword">new</span> PrintfImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JDK 生成代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> $Proxy0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPrintf <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> (IPrintf) Proxy.newProxyInstance(</span><br><span class="line">                <span class="comment">// 类加载器，在程序运行时将生成的代理类加载到JVM中</span></span><br><span class="line">                PRINTF.getClass().getClassLoader(),</span><br><span class="line">                <span class="comment">// 被代理类的所有接口信息，用来确定生成的代理类可以具有哪些方法</span></span><br><span class="line">                PRINTF.getClass().getInterfaces(),</span><br><span class="line">                <span class="comment">// 调用处理器，每个代理对象都具有一个关联的调用处理器，用于指定动态生成的代理类需要完成的具体操作。</span></span><br><span class="line">                <span class="comment">// 该接口中有一个 invoke 方法，代理对象调用任何目标接口的方法时都会调用该 invoke 方法，该方法中会通过反射调用目标方法。</span></span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> method 代理对象当前调用的方法</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span> 方法执行的结果（无返回值则为 null）</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Throwable 异常</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        <span class="comment">// 前置逻辑</span></span><br><span class="line">                        System.out.println(<span class="string">"before action ... "</span>);</span><br><span class="line">                        <span class="comment">// 将方法派发给目标方法</span></span><br><span class="line">                        Object result = method.invoke(PRINTF, args);</span><br><span class="line">                        <span class="comment">// 后置逻辑</span></span><br><span class="line">                        System.out.println(<span class="string">"after action ... "</span>);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IPrintf proxy = Client.getProxy();</span><br><span class="line">        proxy.print(<span class="string">"hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印结果"><a href="#打印结果" class="headerlink" title="打印结果"></a>打印结果</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/java-base-proxy-test.jpg" alt></p><h2 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h2><p>通过阿里开源 Java 应用诊断工具 Arthas 反编译代理类，结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decompiled with CFR.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.code.proxy.IPrintf;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy4</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Proxy</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">IPrintf</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态属性，每个属性对应接口中的一个方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，入参类型为 InvocationHandler</span></span><br><span class="line">    <span class="keyword">public</span> $Proxy4(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="comment">// 调用父类 Proxy 的构造方法</span></span><br><span class="line">        <span class="keyword">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块中通过反射初始化Method属性</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="comment">// Object 中的三大方法</span></span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 目标类的接口中的方法</span></span><br><span class="line">            m3 = Class.forName(<span class="string">"com.code.proxy.IPrintf"</span>).getMethod(<span class="string">"print"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(noSuchMethodException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(classNotFoundException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;object&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m2, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m0, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标类的打印方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// this.h 是 Proxy 中的属性，即调用 Proxy.newProxyInstance 方法传入的 InvocationHandler 对象</span></span><br><span class="line">            <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;string&#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过上面反编译后的代理类代码不难看出，JDK 动态代理实现具有以下特点：</strong></p><ol><li>生成的代理类继承了 <strong>Proxy</strong> 类且实现了 <strong>目标类的接口</strong>，有参构造方法的参数类型是 <strong>InvocationHandler</strong> ，反射创建代理对象执行的就是该构造方法。</li><li>代理类通过反射为目标接口（接口列表）中的每个方法都映射一个 <strong>Method</strong> 对象。</li><li>代理类对接口中方法的实现逻辑都是通过 <strong>InvocationHandler.invoke</strong> 方法派发执行的，代理对象调用任何目标接口的方法时都会调用这个<strong>invoke</strong>方法，该方法中进行目标类的目标方法的调用，即每个方法执行逻辑都由第 2 步中的 <strong>Method</strong> 对象执行。</li></ol><p>关于 JDK 动态代理使用就介绍完毕了，下面我们对底层实现原理进行说明。实现原理中的部分描述信息会引用到上述代码片段。</p><h1 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h1><p>Java 中需要在运行期动态的生成一个类并创建其对象，一般需要使用字节码技术和反射机制。JDK 动态代理通过<code>java.lang.reflect.Proxy</code>提供了一种原生的动态代理模式，其底层通过<strong>对字节码的操作</strong>和<strong>反射的使用</strong>组装代理类，如前文中的 <strong>$Proxy4</strong>，最后通过反射创建代理对象。</p><p>JDK通过调用静态方法 <code>Proxy.newProxyInstance()</code> 创建动态代理，该方法需要三个参数：</p><ol><li>类加载器<br>通常可以从已经被加载的对象中获取其类加载器。</li><li>接口列表<br>预期代理实现的接口列表。</li><li><strong>InvocationHandler</strong> 接口的实现<br>作为动态代理对象的调用处理器，即动态代理可以将所有调用派发到该调用处理器。因此，通常会向调用处理器的构造器中传入一个目标对象的引用，从而使得调用处理器在执行中介任务时可以将请求转发。</li></ol><p>介绍完代理相关的概念和使用方式后，下面我们对 JDK 动态代理实现原理进行说明。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+--- java.lang.reflect.Proxy</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法参数类型，就是 InvocationHandler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams = &#123;InvocationHandler<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理类的缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">            proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理对象调用的处理器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prohibits instantiation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供生成的动态代理类调用，也就是 Proxy 的子类。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h 用于代理对象的调用处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy 中有 3 个核心属性，下面简单介绍：</p><ol><li><strong>constructorParams</strong><br>Proxy 中的有参构造器的参数，是个固定值即调用处理器 <code>InvocationHandler</code>，生成的代理类都会调用 <code>Proxy</code> 这个父类的构造方法。</li><li><strong>proxyClassCache</strong><br>缓存生成的代理类，用于提高效率。需要注意的是，KeyFactory 和 ProxyClassFactory 都是 Proxy 的内部类，前者用于返回接口对应的弱引用，后者根据指定的类加载器和接口列表生成代理类。</li><li><strong>h</strong><br>调用处理器，该处理器会将代理对象的方法调用派发给目标方法。</li></ol><h3 id="内部类-KeyFactory"><a href="#内部类-KeyFactory" class="headerlink" title="内部类 KeyFactory"></a>内部类 KeyFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyFactory</span></span></span><br><span class="line">        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回接口对应的弱引用信息。Key1、Key2 以及 KeyX 都持有 WeakReference</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">apply</span><span class="params">(ClassLoader classLoader, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (interfaces.length) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Key1(interfaces[<span class="number">0</span>]); <span class="comment">// the most frequent</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Key2(interfaces[<span class="number">0</span>], interfaces[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> key0;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> KeyX(interfaces);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KeyFactory 就一个工作，返回接口对应的弱引用信息，KeyN 继承了 <code>WeakReference</code> 类。</p><h3 id="内部类-ProxyClassFactory"><a href="#内部类-ProxyClassFactory" class="headerlink" title="内部类 ProxyClassFactory"></a>内部类 ProxyClassFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">           implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 代理类名称前缀，具体名称为： $Proxy + Num</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 生成代理名称的序号，是自增原子类</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 生成代理类的逻辑</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> loader     类加载器</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> interfaces 接口集合</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> 代理类</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">           Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">           <span class="comment">// 遍历接口集合</span></span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 1 验证类加载器是否将当前接口名称解析为相同的类对象</span></span><br><span class="line">               Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                           intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 2 判断是否是接口</span></span><br><span class="line">               <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                           interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 3 验证接口是否重复加载</span></span><br><span class="line">               <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                           <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 4 代理所在包的名称</span></span><br><span class="line">           String proxyPkg = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 5 记录非public类型的接口，如果是非public类型的接口，则会将代理类定义在该对应的包中。当且仅当所有非public类型的接口都在一个包中才行，否则不合法</span></span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">               <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">               <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                   accessFlags = Modifier.FINAL;</span><br><span class="line">                   String name = intf.getName();</span><br><span class="line">                   <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                   String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                   <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       proxyPkg = pkg;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                               <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 6 如果接口是public类型的，则使用固定的包名： com.sun.proxy</span></span><br><span class="line">           <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">               proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 7 组装代理类名称，格式：proxyPkg + $Proxy + Num</span></span><br><span class="line">           <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">           String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 8 根据代理类名和接口列表使用 ProxyGenerator 生成指定的代理类，可能返回null （配置了虚拟机参数，将代理类字节信息输出到文件）</span></span><br><span class="line">           <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 9 调用native方法，返回代理类</span></span><br><span class="line">               <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 排除代理类生成代码中的bug，提供给代理类创建的参数存在其他问题(例如超出了虚拟机限制)。</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>ProxyClassFactory 完成生成字节码的操作，是生成代理类的完整流程，具体工作如下：</strong></p><ol><li>根据目标类的接口类型确定生成代理类全路径名</li><li>执行 <strong>ProxyGenerator.generateProxyClass</strong> 方法，根据代理类名和接口生成代理类字节码数组或文件形式</li><li>调用 <strong>native</strong> 方法将代理类字节码数据转化为代理类 Class</li></ol><h2 id="ProxyGenerator"><a href="#ProxyGenerator" class="headerlink" title="ProxyGenerator"></a>ProxyGenerator</h2><p><strong>ProxyClassFactory.apply</strong> 通过调用 <strong>ProxyGenerator.generateProxyClass</strong> 方法组装代理类，对接口的 <code>Class</code> 对象、<code>Method</code> 对象进行拆解、封装进而生成字节码层面的方法、构造方法以及静态代码块。</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"></span><br><span class="line">  <span class="comment">// JVM参数，是否将生成的代理类保存到文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles = (Boolean) AccessController.doPrivileged(<span class="keyword">new</span> GetBooleanAction(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object 三大方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method hashCodeMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method equalsMethod;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method toStringMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理类全路径名</span></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="comment">// 接口数组</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] interfaces;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> accessFlags;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ProxyGenerator 中的常量池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ProxyGenerator.ConstantPool cp = <span class="keyword">new</span> ProxyGenerator.ConstantPool();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录方法标识，用于生成代理类中的方法的属性。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ProxyGenerator.FieldInfo&gt; fields = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成的方法信息集合，包括构造方法、静态代码块。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ProxyGenerator.MethodInfo&gt; methods = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法签名到方法代理对象的映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;ProxyGenerator.ProxyMethod&gt;&gt; proxyMethods = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> proxyMethodCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 反射获取三大方法对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hashCodeMethod = Object.class.getMethod("hashCode");</span><br><span class="line">            equalsMethod = Object.class.getMethod("equals", Object.class);</span><br><span class="line">            toStringMethod = Object.class.getMethod("toString");</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var1.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var1 代理类名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var2 目标类接口集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ProxyGenerator</span><span class="params">(String var1, Class&lt;?&gt;[] var2, <span class="keyword">int</span> var3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = var1;</span><br><span class="line">        <span class="keyword">this</span>.interfaces = var2;</span><br><span class="line">        <span class="keyword">this</span>.accessFlags = var3;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>JDK 动态代理涉及到的基础类先介绍到这里，下面我们从 <code>Proxy.newProxyInstance</code> 入口出发，根据调用链逐步分析源代码。</p><h2 id="newProxyInstance"><a href="#newProxyInstance" class="headerlink" title="newProxyInstance"></a>newProxyInstance</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">+--- Proxy</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader     代理类的加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces 目标类的接口列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h          代理对象方法调用都会分派给该调用处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用处理器是必传参数</span></span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接口列表</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 查找或生成指定的代理类。</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 对生成的代理类进行安全检查</span></span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 获取代理类的指定构造方法，即参数类型为 InvocationHandler 的构造方法</span></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 保证代理类的构造方法 cons 具有访问权限，便于后续反射创建代理对象</span></span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 反射创建代理对象，注意参数为 InvocationHandler</span></span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong><code>Proxy.newProxyInstance</code> 方法是生成代理对象的入口，下面对该方法的逻辑进行简单说明：</strong></p><ol><li>调用 <code>getProxyClass0</code> 方法根据指定的类加载器和接口列表获取代理类。这一步是整个代理逻辑的核心实现。</li><li>反射获取参数为 <code>InvocationHandler</code>的代理类的构造方法，并保证该构造方法是可访问的。</li><li>通过 <strong>newInstance</strong> 方法反射创建代理对象，参数类型为 <code>InvocationHandler</code> 。</li></ol><p>第 2、3 步都很容易理解，下面我们重点来分析获取代理类的 <code>getProxyClass0</code> 方法。</p><h2 id="getProxyClass0"><a href="#getProxyClass0" class="headerlink" title="getProxyClass0"></a>getProxyClass0</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--- Proxy</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成代理类。在调用此方法之前，必须调用checkProxyAccess方法来执行权限检查。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取代理类：</span></span><br><span class="line"><span class="comment">         * 1. 如果代理类存在则返回缓存的副本。</span></span><br><span class="line"><span class="comment">         * 2. 不存在，则通过 ProxyClassFactory 创建代理类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前文中有提到代理类缓存属性 <code>WeakCache proxyClassCache</code> ，它的主要作用就是先查找对应的代理类缓存，没有的话就通过 <code>java.lang.reflect.Proxy.ProxyClassFactory#apply</code> 方法创建代理类，该方法在前文中已经详细说明。下面我们对 <strong><code>ProxyGenerator.generateProxyClass</code> 根据代理类名和接口生成代理类字节码数组或文件形式</strong> 这一步骤进行说明。</p><h2 id="generateProxyClass"><a href="#generateProxyClass" class="headerlink" title="generateProxyClass"></a>generateProxyClass</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成代理类-字节码形式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var0 代理类名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var1 目标类接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line"></span><br><span class="line">        ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">        <span class="comment">// 生成目标类的接口信息的字节码</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加JVM 参数 sun.misc.ProxyGenerator.saveGeneratedFiles ，则保存到文件</span></span><br><span class="line">        <span class="keyword">if</span> (saveGeneratedFiles) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> var1 = var0.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                        Path var2;</span><br><span class="line">                        <span class="keyword">if</span> (var1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 创建目录</span></span><br><span class="line">                            Path var3 = Paths.get(var0.substring(<span class="number">0</span>, var1).replace(<span class="string">'.'</span>, File.separatorChar));</span><br><span class="line">                            Files.createDirectories(var3);</span><br><span class="line"></span><br><span class="line">                            var2 = var3.resolve(var0.substring(var1 + <span class="number">1</span>, var0.length()) + <span class="string">".class"</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            var2 = Paths.get(var0 + <span class="string">".class"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 保存到文件</span></span><br><span class="line">                        Files.write(var2, var4, <span class="keyword">new</span> OpenOption[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var4x) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"I/O exception saving generated file: "</span> + var4x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var4;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>generateProxyClass 方法用于根据代理类名称和接口列表生成预期的代理类的字节码（数组）信息，最后通过 JDK 的本地方法转化为具体的代理类。该方法支持通过配置<strong>JVM参数</strong>将目标代理类输出到文件中。</p><p>在分析 <code>ProxyGenerator.generateClassFile</code> 方法之前，我们先对涉及的核心类和方法进行简单说明。注意该方法整个流程比较复杂，本文只对整体逻辑进行说明，具体细节可以参考源代码。</p><h2 id="ProxyMethod"><a href="#ProxyMethod" class="headerlink" title="ProxyMethod"></a>ProxyMethod</h2><p>方法代理类，用于拆解、封装 <strong>Method</strong> 的信息，作为后续方法字节码生成的数据来源。</p><h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyMethod</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法名</span></span><br><span class="line">        <span class="keyword">public</span> String methodName;</span><br><span class="line">        <span class="comment">// 参数类型</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line">        <span class="comment">// 返回值类型</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; returnType;</span><br><span class="line">        <span class="comment">// 异常类型</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt;[] exceptionTypes;</span><br><span class="line">        <span class="comment">// 方法所在接口</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; fromClass;</span><br><span class="line">        <span class="comment">// 当前方法对应的序列号，如 m0</span></span><br><span class="line">        <span class="keyword">public</span> String methodFieldName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ProxyMethod</span><span class="params">(String var2, Class&lt;?&gt;[] var3, Class&lt;?&gt; var4, Class&lt;?&gt;[] var5, Class&lt;?&gt; var6)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.methodName = var2;</span><br><span class="line">            <span class="keyword">this</span>.parameterTypes = var3;</span><br><span class="line">            <span class="keyword">this</span>.returnType = var4;</span><br><span class="line">            <span class="keyword">this</span>.exceptionTypes = var5;</span><br><span class="line">            <span class="keyword">this</span>.fromClass = var6;</span><br><span class="line">            <span class="keyword">this</span>.methodFieldName = <span class="string">"m"</span> + ProxyGenerator.<span class="keyword">this</span>.proxyMethodCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其它代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="generateMethod"><a href="#generateMethod" class="headerlink" title="generateMethod"></a>generateMethod</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyMethod</span><br><span class="line"> <span class="keyword">private</span> ProxyGenerator.<span class="function">MethodInfo <span class="title">generateMethod</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">// 方法签名 如：toString 方法的描述信息 Ljava/lang/reflect/Method;  void print(String message) 描述信息 (Ljava/lang/String;)V</span></span><br><span class="line">            String var1 = ProxyGenerator.getMethodDescriptor(<span class="keyword">this</span>.parameterTypes, <span class="keyword">this</span>.returnType);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 MethodInfo 对象，同时会初始化 ByteArrayOutputStream 对象</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 方法名 + 方法签名</span></span><br><span class="line">            ProxyGenerator.MethodInfo var2 = ProxyGenerator.<span class="keyword">this</span>.<span class="keyword">new</span> MethodInfo(<span class="keyword">this</span>.methodName, var1, <span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 方法参数</span></span><br><span class="line">            <span class="keyword">int</span>[] var3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.parameterTypes.length];</span><br><span class="line">            <span class="keyword">int</span> var4 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var3.length; ++var5) &#123;</span><br><span class="line">                var3[var5] = var4;</span><br><span class="line">                var4 += ProxyGenerator.getWordsPerType(<span class="keyword">this</span>.parameterTypes[var5]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span> var7 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过字节输出流 ByteArrayOutputStream 写入方法的二进制信息，即 MethodInfo 中的输出流中</span></span><br><span class="line">            DataOutputStream var9 = <span class="keyword">new</span> DataOutputStream(var2.code);</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.code_aload(<span class="number">0</span>, var9);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 写入接口方法的 InvocationHandler.invoke 处理逻辑</span></span><br><span class="line">            var9.writeByte(<span class="number">180</span>);</span><br><span class="line">            var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getFieldRef(<span class="string">"java/lang/reflect/Proxy"</span>, <span class="string">"h"</span>, <span class="string">"Ljava/lang/reflect/InvocationHandler;"</span>));</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.code_aload(<span class="number">0</span>, var9);</span><br><span class="line">            var9.writeByte(<span class="number">178</span>);</span><br><span class="line">            var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getFieldRef(ProxyGenerator.dotToSlash(ProxyGenerator.<span class="keyword">this</span>.className), <span class="keyword">this</span>.methodFieldName, <span class="string">"Ljava/lang/reflect/Method;"</span>));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.parameterTypes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ProxyGenerator.<span class="keyword">this</span>.code_ipush(<span class="keyword">this</span>.parameterTypes.length, var9);</span><br><span class="line">                var9.writeByte(<span class="number">189</span>);</span><br><span class="line">                var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/Object"</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> var10 = <span class="number">0</span>; var10 &lt; <span class="keyword">this</span>.parameterTypes.length; ++var10) &#123;</span><br><span class="line">                    var9.writeByte(<span class="number">89</span>);</span><br><span class="line">                    ProxyGenerator.<span class="keyword">this</span>.code_ipush(var10, var9);</span><br><span class="line">                    <span class="keyword">this</span>.codeWrapArgument(<span class="keyword">this</span>.parameterTypes[var10], var3[var10], var9);</span><br><span class="line">                    var9.writeByte(<span class="number">83</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var9.writeByte(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            var9.writeByte(<span class="number">185</span>);</span><br><span class="line">            var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getInterfaceMethodRef(<span class="string">"java/lang/reflect/InvocationHandler"</span>, <span class="string">"invoke"</span>, <span class="string">"(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;"</span>));</span><br><span class="line">            var9.writeByte(<span class="number">4</span>);</span><br><span class="line">            var9.writeByte(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 返回类型</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.returnType == Void.TYPE) &#123;</span><br><span class="line">                var9.writeByte(<span class="number">87</span>);</span><br><span class="line">                var9.writeByte(<span class="number">177</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.codeUnwrapReturnValue(<span class="keyword">this</span>.returnType, var9);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 写入方法处理异常字节信息</span></span><br><span class="line">            <span class="keyword">short</span> var6;</span><br><span class="line">            <span class="keyword">short</span> var8 = var6 = (<span class="keyword">short</span>) var2.code.size();</span><br><span class="line">            List var13 = ProxyGenerator.computeUniqueCatchList(<span class="keyword">this</span>.exceptionTypes);</span><br><span class="line">            <span class="keyword">if</span> (var13.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Iterator var11 = var13.iterator();</span><br><span class="line">                <span class="keyword">while</span> (var11.hasNext()) &#123;</span><br><span class="line">                    Class var12 = (Class) var11.next();</span><br><span class="line">                    var2.exceptionTable.add(<span class="keyword">new</span> ProxyGenerator.ExceptionTableEntry(var7, var8, var6, ProxyGenerator.<span class="keyword">this</span>.cp.getClass(ProxyGenerator.dotToSlash(var12.getName()))));</span><br><span class="line">                &#125;</span><br><span class="line">                var9.writeByte(<span class="number">191</span>);</span><br><span class="line">                var6 = (<span class="keyword">short</span>) var2.code.size();</span><br><span class="line">                var2.exceptionTable.add(<span class="keyword">new</span> ProxyGenerator.ExceptionTableEntry(var7, var8, var6, ProxyGenerator.<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/Throwable"</span>)));</span><br><span class="line">                ProxyGenerator.<span class="keyword">this</span>.code_astore(var4, var9);</span><br><span class="line">                var9.writeByte(<span class="number">187</span>);</span><br><span class="line">                var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/UndeclaredThrowableException"</span>));</span><br><span class="line">                var9.writeByte(<span class="number">89</span>);</span><br><span class="line">                ProxyGenerator.<span class="keyword">this</span>.code_aload(var4, var9);</span><br><span class="line">                var9.writeByte(<span class="number">183</span>);</span><br><span class="line">                var9.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/reflect/UndeclaredThrowableException"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"(Ljava/lang/Throwable;)V"</span>));</span><br><span class="line">                var9.writeByte(<span class="number">191</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var2.code.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"code size limit exceeded"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var2.maxStack = <span class="number">10</span>;</span><br><span class="line">                var2.maxLocals = (<span class="keyword">short</span>) (var4 + <span class="number">1</span>);</span><br><span class="line">                var2.declaredExceptions = <span class="keyword">new</span> <span class="keyword">short</span>[<span class="keyword">this</span>.exceptionTypes.length];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> var14 = <span class="number">0</span>; var14 &lt; <span class="keyword">this</span>.exceptionTypes.length; ++var14) &#123;</span><br><span class="line">                    var2.declaredExceptions[var14] = ProxyGenerator.<span class="keyword">this</span>.cp.getClass(ProxyGenerator.dotToSlash(<span class="keyword">this</span>.exceptionTypes[var14].getName()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> var2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>generateMethod 方法根据 <code>ProxyMethod</code> 信息，按照方法的构造组装代表字节码信息的 <code>MethodInfo</code>，最终将该信息写入到输出流中。</p><h2 id="MethodInfo"><a href="#MethodInfo" class="headerlink" title="MethodInfo"></a>MethodInfo</h2><p>ProxyMethod 对象经过解析后会组装成 MethodInfo 对象，该对象封装了代理类中方法的字节码信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> accessFlags;</span><br><span class="line">        <span class="comment">// 方法名</span></span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="comment">// 方法签名</span></span><br><span class="line">        <span class="keyword">public</span> String descriptor;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">short</span> maxStack;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">short</span> maxLocals;</span><br><span class="line">        <span class="comment">// 输出流，方法字节码会写入到该流中</span></span><br><span class="line">        <span class="keyword">public</span> ByteArrayOutputStream code = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="keyword">public</span> List&lt;ProxyGenerator.ExceptionTableEntry&gt; exceptionTable = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">short</span>[] declaredExceptions;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MethodInfo</span><span class="params">(String var2, String var3, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = var2;</span><br><span class="line">            <span class="keyword">this</span>.descriptor = var3;</span><br><span class="line">            <span class="keyword">this</span>.accessFlags = var4;</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(var2);</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(var3);</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(<span class="string">"Code"</span>);</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(<span class="string">"Exceptions"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略写入输出流逻辑</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="FieldInfo"><a href="#FieldInfo" class="headerlink" title="FieldInfo"></a>FieldInfo</h2><p>FieldInfo 用于封装方法在代理类中的静态属性信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldInfo</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> accessFlags;</span><br><span class="line">        <span class="comment">// m + N，方法在代理类中的字段名</span></span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">        <span class="comment">// 固定值 Ljava/lang/reflect/Method;</span></span><br><span class="line">        <span class="keyword">public</span> String descriptor;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FieldInfo</span><span class="params">(String var2, String var3, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = var2;</span><br><span class="line">            <span class="keyword">this</span>.descriptor = var3;</span><br><span class="line">            <span class="keyword">this</span>.accessFlags = var4;</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(var2);</span><br><span class="line">            ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(var3);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入输出流</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutputStream var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            var1.writeShort(<span class="keyword">this</span>.accessFlags);</span><br><span class="line">            var1.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(<span class="keyword">this</span>.name));</span><br><span class="line">            var1.writeShort(ProxyGenerator.<span class="keyword">this</span>.cp.getUtf8(<span class="keyword">this</span>.descriptor));</span><br><span class="line">            var1.writeShort(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>介绍完必要的前置概念和类信息后，我们回到 <code>ProxyGenerator.generateClassFile</code> 方法，继续接着流程往下分析。</p><h2 id="generateClassFile"><a href="#generateClassFile" class="headerlink" title="generateClassFile"></a>generateClassFile</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</span><br><span class="line">        <span class="comment">// 1. 将 Object 中的三大方法对象Method拆解，组装成 ProxyMethod 对象</span></span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(hashCodeMethod, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(equalsMethod, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(toStringMethod, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将目标类的接口中的方法对象Method拆解，组装成 ProxyMethod 对象</span></span><br><span class="line">        Class[] var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">        <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line">        <span class="keyword">int</span> var3;</span><br><span class="line">        Class var4;</span><br><span class="line">        <span class="comment">// 2.1 遍历接口</span></span><br><span class="line">        <span class="keyword">for</span> (var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            var4 = var1[var3];</span><br><span class="line">            <span class="comment">// 2.3 获取接口中的方法列表</span></span><br><span class="line">            Method[] var5 = var4.getMethods();</span><br><span class="line">            <span class="keyword">int</span> var6 = var5.length;</span><br><span class="line">            <span class="comment">// 2.4 遍历当前接口中的方法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> var7 = <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">                Method var8 = var5[var7];</span><br><span class="line">                <span class="comment">// 2.5 对接口中的方法拆解、组装成 ProxyMethod 对象，然后加入缓存 proxyMethods 中</span></span><br><span class="line">                <span class="keyword">this</span>.addProxyMethod(var8, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取缓存的方法代理对象 ProxyMethod 集合</span></span><br><span class="line">        Iterator var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line">        <span class="comment">// 校验相同方法签名的返回类型</span></span><br><span class="line">        List var12;</span><br><span class="line">        <span class="keyword">while</span> (var11.hasNext()) &#123;</span><br><span class="line">            var12 = (List) var11.next();</span><br><span class="line">            checkReturnTypes(var12);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator var15;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 生成构造方法字节码信息并加入到 methods 缓存起来</span></span><br><span class="line">            <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateConstructor());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 遍历方法代理对象列表，生成方法字节码信息并缓存到 methods 中</span></span><br><span class="line">            var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line">            <span class="keyword">while</span> (var11.hasNext()) &#123;</span><br><span class="line">                var12 = (List) var11.next();</span><br><span class="line">                var15 = var12.iterator();</span><br><span class="line">                <span class="keyword">while</span> (var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod) var15.next();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.1 生成方法的 FieldInfo 并加入到 fields 集合中，即代理类中方法Method的字段属性</span></span><br><span class="line">                    <span class="keyword">this</span>.fields.add(<span class="keyword">new</span> ProxyGenerator.FieldInfo(var16.methodFieldName, <span class="string">"Ljava/lang/reflect/Method;"</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4.2 生成方法的 MethodInfo 并加入到 methods 集合中，注意 MethodInfo 中的 ByteArrayOutputStream</span></span><br><span class="line">                    <span class="keyword">this</span>.methods.add(var16.generateMethod());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 生成静态代码块字节码信息（根据 proxyMethods 中的信息）</span></span><br><span class="line">            <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateStaticInitializer());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"unexpected I/O Exception"</span>, var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 方法数量限制</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.methods.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"method limit exceeded"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.fields.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"field limit exceeded"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 代理类字节码组装</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.1. 处理代理类 和 Proxy 的全路径类，并入放入常量池 cp 中</span></span><br><span class="line">            <span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className));</span><br><span class="line">            <span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/Proxy"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.2. 处理代理类的接口，并放入常量池 cp 中</span></span><br><span class="line">            var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">            var2 = var1.length;</span><br><span class="line">            <span class="keyword">for</span> (var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                var4 = var1[var3];</span><br><span class="line">                <span class="keyword">this</span>.cp.getClass(dotToSlash(var4.getName()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.cp.setReadOnly();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7.3. 字节类型数据的输出流，内存操作流</span></span><br><span class="line">            ByteArrayOutputStream var13 = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            DataOutputStream var14 = <span class="keyword">new</span> DataOutputStream(var13);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var14.writeInt(-<span class="number">889275714</span>);</span><br><span class="line">                var14.writeShort(<span class="number">0</span>);</span><br><span class="line">                var14.writeShort(<span class="number">49</span>);</span><br><span class="line">                <span class="keyword">this</span>.cp.write(var14);</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.accessFlags);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7.3.1 写入代理类名称信息</span></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className)));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7.3.2 写入Proxy名称信息</span></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/Proxy"</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7.3.4 写入接口列表</span></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.interfaces.length);</span><br><span class="line">                Class[] var17 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">                <span class="keyword">int</span> var18 = var17.length;</span><br><span class="line">                <span class="comment">// 遍历接口列表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> var19 = <span class="number">0</span>; var19 &lt; var18; ++var19) &#123;</span><br><span class="line">                    Class var22 = var17[var19];</span><br><span class="line">                    <span class="comment">// 写入接口信息</span></span><br><span class="line">                    var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(var22.getName())));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/// 7.3.5 写入字段信息，即接口方法的标识，如 m1、m2</span></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.fields.size());</span><br><span class="line">                var15 = <span class="keyword">this</span>.fields.iterator();</span><br><span class="line">                <span class="keyword">while</span> (var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo) var15.next();</span><br><span class="line">                    var20.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7.3.6 写入方法，包括构造方法、静态代码块</span></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.methods.size());</span><br><span class="line">                var15 = <span class="keyword">this</span>.methods.iterator();</span><br><span class="line">                <span class="keyword">while</span> (var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo) var15.next();</span><br><span class="line">                    var21.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line">                var14.writeShort(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4 返回字节数组信息</span></span><br><span class="line">                <span class="keyword">return</span> var13.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"unexpected I/O Exception"</span>, var9);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>generateClassFile 方法逻辑还是比较复杂的，下面对主要流程进行说明：</strong></p><ol><li>将 Object 中的三大方法对象解析、组装成 ProxyMethod 对象。</li><li>将目标类的接口中的方法对象解析、组装成 ProxyMethod 对象。</li><li>生成构造方法字节码信息并封装到 MethodInfo 对象中。</li><li>将第 1、2 步骤中组装的 ProxyMethod 对象进行解析，生成代表该方法字段标识的 FieldInfo 对象并缓存起来，解析为该方法的字节码信息的 MethodInfo 对象并缓存起来。</li><li>根据第 1、2 步骤中组装的 ProxyMethod 对象生成静态代码块字节码信息并封装到 MethodInfo 对象中并缓存起来。</li><li>对代理类中的方法数量做限制。</li><li>依次将代理类相关类路径、接口路径、代理类名、Proxy名、接口名、FieldInfo信息、MehodInfo信息写入到字节输出流中。</li><li>生成代理类字节码数组</li></ol><p>整个过程介绍完毕，下面对该过程中涉及的核心方法进行说明。</p><h3 id="addProxyMethod"><a href="#addProxyMethod" class="headerlink" title="addProxyMethod"></a>addProxyMethod</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将方法对象拆解，组装成 ProxyMethod 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var1 方法对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var2 方法所在接口/类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addProxyMethod</span><span class="params">(Method var1, Class&lt;?&gt; var2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 方法名</span></span><br><span class="line">        String var3 = var1.getName();</span><br><span class="line">        <span class="comment">// 2 方法参数类型</span></span><br><span class="line">        Class[] var4 = var1.getParameterTypes();</span><br><span class="line">        <span class="comment">// 3 方法返回类型</span></span><br><span class="line">        Class var5 = var1.getReturnType();</span><br><span class="line">        <span class="comment">// 4 方法异常类型</span></span><br><span class="line">        Class[] var6 = var1.getExceptionTypes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 方法签名，如 hashCode()、equals(Ljava/lang/Object;)，最为缓存的 key</span></span><br><span class="line">        String var7 = var3 + getParameterDescriptors(var4);</span><br><span class="line"></span><br><span class="line">        Object var8 = (List) <span class="keyword">this</span>.proxyMethods.get(var7);</span><br><span class="line">        <span class="keyword">if</span> (var8 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator var9 = ((List) var8).iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (var9.hasNext()) &#123;</span><br><span class="line">                ProxyGenerator.ProxyMethod var10 = (ProxyGenerator.ProxyMethod) var9.next();</span><br><span class="line">                <span class="keyword">if</span> (var5 == var10.returnType) &#123;</span><br><span class="line">                    ArrayList var11 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                    collectCompatibleTypes(var6, var10.exceptionTypes, var11);</span><br><span class="line">                    collectCompatibleTypes(var10.exceptionTypes, var6, var11);</span><br><span class="line">                    var10.exceptionTypes = <span class="keyword">new</span> Class[var11.size()];</span><br><span class="line">                    var10.exceptionTypes = (Class[]) var11.toArray(var10.exceptionTypes);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var8 = <span class="keyword">new</span> ArrayList(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">this</span>.proxyMethods.put(var7, var8);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 ProxyMethod 对象，并保存到 proxyMethods 中</span></span><br><span class="line">        ((List) var8).add(<span class="keyword">new</span> ProxyGenerator.ProxyMethod(var3, var4, var5, var6, var2));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述方法用于将 <code>Method</code> 对象拆解、组装为 <code>ProxyMethod</code> 对象，为后续组装代理类的方法字节码做准备。</p><h3 id="generateConstructor"><a href="#generateConstructor" class="headerlink" title="generateConstructor"></a>generateConstructor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line">    <span class="keyword">private</span> ProxyGenerator.<span class="function">MethodInfo <span class="title">generateConstructor</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建构造方法字节码的 MethodInfo</span></span><br><span class="line">        ProxyGenerator.MethodInfo var1 = <span class="keyword">new</span> ProxyGenerator.MethodInfo(<span class="string">"&lt;init&gt;"</span>, <span class="string">"(Ljava/lang/reflect/InvocationHandler;)V"</span>, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入 MethodInfo 的输出流中</span></span><br><span class="line">        DataOutputStream var2 = <span class="keyword">new</span> DataOutputStream(var1.code);</span><br><span class="line">        <span class="keyword">this</span>.code_aload(<span class="number">0</span>, var2);</span><br><span class="line">        <span class="keyword">this</span>.code_aload(<span class="number">1</span>, var2);</span><br><span class="line">        var2.writeByte(<span class="number">183</span>);</span><br><span class="line">        var2.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/reflect/Proxy"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"(Ljava/lang/reflect/InvocationHandler;)V"</span>));</span><br><span class="line">        var2.writeByte(<span class="number">177</span>);</span><br><span class="line">        var1.maxStack = <span class="number">10</span>;</span><br><span class="line">        var1.maxLocals = <span class="number">2</span>;</span><br><span class="line">        var1.declaredExceptions = <span class="keyword">new</span> <span class="keyword">short</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> var1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>generateConstructor 方法用于生成构造方法的字节码信息。</p><h3 id="generateStaticInitializer"><a href="#generateStaticInitializer" class="headerlink" title="generateStaticInitializer"></a>generateStaticInitializer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">+--- ProxyGenerator</span><br><span class="line"> <span class="keyword">private</span> ProxyGenerator.<span class="function">MethodInfo <span class="title">generateStaticInitializer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ProxyGenerator.MethodInfo var1 = <span class="keyword">new</span> ProxyGenerator.MethodInfo(<span class="string">"&lt;clinit&gt;"</span>, <span class="string">"()V"</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">byte</span> var2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">byte</span> var4 = <span class="number">0</span>;</span><br><span class="line">        DataOutputStream var6 = <span class="keyword">new</span> DataOutputStream(var1.code);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取方法列表</span></span><br><span class="line">        Iterator var7 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line">        <span class="comment">// 根据方法信息初始化对应的字段</span></span><br><span class="line">        <span class="keyword">while</span> (var7.hasNext()) &#123;</span><br><span class="line">            List var8 = (List) var7.next();</span><br><span class="line">            Iterator var9 = var8.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (var9.hasNext()) &#123;</span><br><span class="line">                ProxyGenerator.ProxyMethod var10 = (ProxyGenerator.ProxyMethod) var9.next();</span><br><span class="line">                <span class="comment">// 方法字段初始化</span></span><br><span class="line">                var10.codeFieldInitialization(var6);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        var6.writeByte(<span class="number">177</span>);</span><br><span class="line">        <span class="keyword">short</span> var3;</span><br><span class="line">        <span class="keyword">short</span> var5 = var3 = (<span class="keyword">short</span>) var1.code.size();</span><br><span class="line">        var1.exceptionTable.add(<span class="keyword">new</span> ProxyGenerator.ExceptionTableEntry(var4, var5, var3, <span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/NoSuchMethodException"</span>)));</span><br><span class="line">        <span class="keyword">this</span>.code_astore(var2, var6);</span><br><span class="line">        var6.writeByte(<span class="number">187</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/NoSuchMethodError"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">89</span>);</span><br><span class="line">        <span class="keyword">this</span>.code_aload(var2, var6);</span><br><span class="line">        var6.writeByte(<span class="number">182</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/Throwable"</span>, <span class="string">"getMessage"</span>, <span class="string">"()Ljava/lang/String;"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">183</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/NoSuchMethodError"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"(Ljava/lang/String;)V"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">191</span>);</span><br><span class="line">        var3 = (<span class="keyword">short</span>) var1.code.size();</span><br><span class="line">        var1.exceptionTable.add(<span class="keyword">new</span> ProxyGenerator.ExceptionTableEntry(var4, var5, var3, <span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/ClassNotFoundException"</span>)));</span><br><span class="line">        <span class="keyword">this</span>.code_astore(var2, var6);</span><br><span class="line">        var6.writeByte(<span class="number">187</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/NoClassDefFoundError"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">89</span>);</span><br><span class="line">        <span class="keyword">this</span>.code_aload(var2, var6);</span><br><span class="line">        var6.writeByte(<span class="number">182</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/Throwable"</span>, <span class="string">"getMessage"</span>, <span class="string">"()Ljava/lang/String;"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">183</span>);</span><br><span class="line">        var6.writeShort(<span class="keyword">this</span>.cp.getMethodRef(<span class="string">"java/lang/NoClassDefFoundError"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"(Ljava/lang/String;)V"</span>));</span><br><span class="line">        var6.writeByte(<span class="number">191</span>);</span><br><span class="line">        <span class="keyword">if</span> (var1.code.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"code size limit exceeded"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            var1.maxStack = <span class="number">10</span>;</span><br><span class="line">            var1.maxLocals = (<span class="keyword">short</span>) (var2 + <span class="number">1</span>);</span><br><span class="line">            var1.declaredExceptions = <span class="keyword">new</span> <span class="keyword">short</span>[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> var1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>generateStaticInitializer 方法用于生成代理类的静态代码块信息。</p><p>至此，JDK 动态代理的整个流程介绍完毕。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JDK 动态代理是针对接口做的代理，目标类没有实现接口是无法通过这个方式创建代理对象。通过拼接字节码生成类是十分灵活的，理论上不管是有接口的类还是普通类都是可以实现代理的，CGLIB 就是通过拼接字节码来实现非接口类的代理逻辑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Java 中代理分为两大类，一类是静态代理，另一类是动态代理。静态代理是针对需要被代理的类在编译之前就已经写好了对应的代理类，也就是说代理关
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="代理" scheme="https://gentryhuang.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>并发 - 线程池工具类</title>
    <link href="https://gentryhuang.com/posts/9e3a7d05/"/>
    <id>https://gentryhuang.com/posts/9e3a7d05/</id>
    <published>2020-12-09T16:00:00.000Z</published>
    <updated>2020-12-24T13:19:46.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章 <a href="https://gentryhuang.com/posts/d7cef21d/">线程池</a> 对线程池的原理进行了说明，并对线程池的源码进行了深入分析，本篇文章对线程工具类 Executors 进行分析，需要说明的是 Executors 中除了并行计算的 WorkStealingPool 线程池，其它的都是直接基于 ThreadPoolExecutor 来实现的。本篇文章主要说明 Executors 基于 ThreadPoolExecutor 创建的线程池。</p><h1 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h1><p>FixedThreadPool 属于固定线程数的线程池，使用 Executors.newFixedThreadPool()  方法创建。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li>指定线程数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建固定数量的线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nThreads 核心线程数 = 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>指定线程数和线程工厂<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建固定数量的线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nThreads      核心线程数 = 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory 线程工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">            threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>核心线程数和最大线程数一致，并且使用的任务队列为无界队列。线程池中的线程数随着任务的提交会从 0 增加到核心线程数 nThreads，完成预热之后，线程池中的线程数将会保持 nThreads，之后的任务提交一律放入任务队列中，由空闲的核心线程从队列取出并执行。如果有工作线程退出，线程池将会创建新的工作线程以补足执行的数目 nThreads 。此外，由于使用的是无界队列，隐藏的默认拒绝策略是无效的，并且默认情况下线程池是不会回收核心线程数内的线程，keepAliveTime 同样是个无效参数。</p><h2 id="运行示意图"><a href="#运行示意图" class="headerlink" title="运行示意图"></a>运行示意图</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/concurrent-threadpool-fixed.jpg" alt></p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>适用于为了满足资源管理的需求，而需要限制线程数量的应用场景。</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>由于使用了无界的任务队列，当大量的任务提交到线程池，可能会造成任务堆积，而线程池的拒绝策略又处于失效状态，从而导致 OOM 。</p><h1 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h1><p>SingleThreadExecutor 属于固定线程数的线程池，使用 Executors.newSingleThreadExecutor()  方法创建。</p><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建单个线程的线程池</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">             <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">             <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建单个线程的线程池</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> threadFactory 线程工厂</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">             <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">             <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">             threadFactory));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>SingleThreadExecutor 和 FixedThreadPool 基本一致，区别在于前者的核心线程数和最大线程数固定为 1 ，并且是一个包装 ThreadPoolExecutor 的线程池，支持调用 finalize() 方法通知垃圾收集器时关闭线程池。</p><h2 id="运行示意图-1"><a href="#运行示意图-1" class="headerlink" title="运行示意图"></a>运行示意图</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/concurrent-threadpool-single.jpg" alt></p><h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h2><p>保证了所有任务都是被顺序执行，任意时间点最多会有一个任务处于活动状态。</p><h2 id="存在问题-1"><a href="#存在问题-1" class="headerlink" title="存在问题"></a>存在问题</h2><p>和 FixedThreadPool 是一样的问题，使用了无界的任务队列，当大量的任务提交到线程池，可能会造成任务堆积，而线程池的拒绝策略又处于失效状态，从而导致 OOM 。</p><h1 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h1><p>CachedThreadPool 属于缓冲线程池，会根据需要创建新线程。使用 Executors.newCachedThreadPool()  方法创建。</p><h2 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">            <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">            <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">            threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><p>核心线程数为 0 ，最大线程数为 <strong>Integer.MAX_VALUE</strong>，可以认为是无界的。使用的任务队列是没有容量的 <strong>SynchronousQueue</strong> ，即线程池使用这个队列意味着每次都要创建新的线程来处理任务。 keepAliveTime 被设置为 60L，单位为 TimeUnit.SECONDS ，意味着 CachedThreadPool 中的空闲线程等待任务的最大时长为 60s 。</p><p>CachedThreadPool 总体上有以下几个特点：</p><ol><li>无核心线程数，且最大的线程数是 <strong>Integer.MAX_VALUE</strong> 。</li><li>任务队列并不会存储任务，如果有空闲线程则队列会把任务交给空闲线程执行，如果没有空闲线程则迫使线程池尝试创建一个新的线程执行任务。这个特点是任务队列 <strong>SynchronousQueue</strong> 提供的。</li><li>由于 keepAliveTime 被设置为 60L，因此会在该时间内缓存线程，被缓存的线程会等待 <strong>SynchronousQueue</strong> 队列中的任务。</li><li>线程池长时间闲置得话也不会消耗什么资源，因为线程池中的线程都是可回收的，和固定线程数的线程池不同，核心线程会不断轮询任务（不开启回收核心线程）。</li></ol><h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>一个比较特殊的阻塞队列，其本身不存储元素。每个插入操作必须等待另一个线程执行移除操作，反之亦然。如果使用该阻塞队列，只有当两个线程执行相反模式的操作才能配对成功，否则先执行的一方只能等待。下图是对线程池使用该队列处理任务过程的描述：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-syncronousqueue.jpg" alt></p><h2 id="运行示意图-2"><a href="#运行示意图-2" class="headerlink" title="运行示意图"></a>运行示意图</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/concurrent-threadpool-cacheed.jpg" alt></p><h2 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h2><p>处理大量短时间任务，或者负载较轻的服务器。</p><h2 id="存在问题-2"><a href="#存在问题-2" class="headerlink" title="存在问题"></a>存在问题</h2><p>由于允许创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程最终超过了操作系统的上限而无法创建新线程，容易导致 CPU 飙升和 OOM。</p><h1 id="Executors-创建线程问题"><a href="#Executors-创建线程问题" class="headerlink" title="Executors 创建线程问题"></a>Executors 创建线程问题</h1><p>Executors 工具类创建的线程池都会存在一定的风险，相比较而言手动创建线程池更加合理，因为可以根据不同的场景对线程池进行定制，来提升程序的性能和减少资源消耗。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>无论是使用 Executors 工具类还是定制线程池，都应该避免任务大量堆积，否则可能出现 OOM ；还应该避免过度创建新线程，否则可能由于创建大量线程导致系统崩溃。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇文章 &lt;a href=&quot;https://gentryhuang.com/posts/d7cef21d/&quot;&gt;线程池&lt;/a&gt; 对线程池的原
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
  </entry>
  
</feed>
