<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gentryhuang‘s blog</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gentryhuang.com/"/>
  <updated>2020-12-10T16:10:13.822Z</updated>
  <id>https://gentryhuang.com/</id>
  
  <author>
    <name>gentryhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发 - 线程池工具类</title>
    <link href="https://gentryhuang.com/posts/9e3a7d05/"/>
    <id>https://gentryhuang.com/posts/9e3a7d05/</id>
    <published>2020-12-09T16:00:00.000Z</published>
    <updated>2020-12-10T16:10:13.822Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇文章 <a href="https://gentryhuang.com/posts/d7cef21d/">线程池</a> 对线程池的原理进行了说明，并对线程池的源码进行了深入分析，本篇文章对线程工具类 Executors 进行分析，需要说明的是 Executors 中除了并行计算的 WorkStealingPool 线程池，其它的都是直接基于 ThreadPoolExecutor 来实现的。</p><h1 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h1><p>FixedThreadPool 属于固定线程数的线程池，使用 Executors.newFixedThreadPool()  方法创建。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li>指定线程数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建固定数量的线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nThreads 核心线程数 = 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>指定线程数和线程工厂<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建固定数量的线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nThreads      核心线程数 = 最大线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> threadFactory 线程工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">            threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>核心线程数和最大线程数一致，并且使用的任务队列为无界队列。线程池中的线程数随着任务的提交会从 0 增加到核心线程数 nThreads，完成预热之后，线程池中的线程数将会保持 nThreads，之后的任务提交一律放入任务队列中，由空闲的核心线程从队列取出并执行。如果有工作线程退出，线程池将会创建新的工作线程以补足执行的数目 nThreads 。此外，由于使用的是无界队列，隐藏的默认拒绝策略是无效的，并且默认情况下线程池是不会回收核心线程数内的线程，keepAliveTime 同样是个无效参数。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>适用于为了满足资源管理的需求，而需要限制线程数量的应用场景。</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>由于使用了无界的任务队列，当大量的任务提交到线程池，可能会堆积大量请求，而线程池的拒绝策略又处于失效状态，从而导致 OOM 。</p><h1 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h1><p>SingleThreadExecutor 属于固定线程数的线程池，使用 Executors.newSingleThreadExecutor()  方法创建。</p><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><p>指定线程数</p></li><li><p>指定线程数和线程工厂</p></li></ul><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><h2 id="存在问题-1"><a href="#存在问题-1" class="headerlink" title="存在问题"></a>存在问题</h2><h1 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h1><p>。。。</p><h2 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><p>指定线程数</p></li><li><p>指定线程数和线程工厂</p></li></ul><h2 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h2><h2 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h2><h2 id="存在问题-2"><a href="#存在问题-2" class="headerlink" title="存在问题"></a>存在问题</h2><h1 id="SingleThreadScheduledExecutor"><a href="#SingleThreadScheduledExecutor" class="headerlink" title="SingleThreadScheduledExecutor"></a>SingleThreadScheduledExecutor</h1><p>。。。</p><h2 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><p>指定线程数</p></li><li><p>指定线程数和线程工厂</p></li></ul><h2 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h2><h2 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h2><h2 id="存在问题-3"><a href="#存在问题-3" class="headerlink" title="存在问题"></a>存在问题</h2><h1 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h1><p>。。。</p><h2 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><p>指定线程数</p></li><li><p>指定线程数和线程工厂</p></li></ul><h2 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h2><h2 id="优势-3"><a href="#优势-3" class="headerlink" title="优势"></a>优势</h2><h2 id="存在问题-4"><a href="#存在问题-4" class="headerlink" title="存在问题"></a>存在问题</h2><h1 id="WorkStealingPool"><a href="#WorkStealingPool" class="headerlink" title="WorkStealingPool"></a>WorkStealingPool</h1><p>。。。</p><h2 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><p>指定线程数</p></li><li><p>指定线程数和线程工厂</p></li></ul><h2 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h2><h2 id="优势-4"><a href="#优势-4" class="headerlink" title="优势"></a>优势</h2><h2 id="存在问题-5"><a href="#存在问题-5" class="headerlink" title="存在问题"></a>存在问题</h2><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>可以通过线程池参数可以配置…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇文章 &lt;a href=&quot;https://gentryhuang.com/posts/d7cef21d/&quot;&gt;线程池&lt;/a&gt; 对线程池的原
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>并发 - 线程池</title>
    <link href="https://gentryhuang.com/posts/d7cef21d/"/>
    <id>https://gentryhuang.com/posts/d7cef21d/</id>
    <published>2020-12-02T16:00:00.000Z</published>
    <updated>2020-12-10T14:59:28.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最初的时候并没有线程池的概念，而是先有线程。每个任务都需要对应一个线程，任务少的情况没有太大问题，任务过多就出现了各种性能和资源开销问题，更重要的是可创建线程的数量是有上限的，不可能无限的创建。</p><p>针对上述问题，于是诞生了线程池，用来平衡线程与系统资源之间的关系。线程池解决问题思路如下：</p><ol><li>对于反复创建线程开销问题，线程池采用固定数量的线程一直保持工作状态并能反复执行任务。</li><li>对于创建过多线程占用太多资源问题，线程池会根据需要创建线程，灵活地控制线程数量，避免使用过多资源。</li></ol><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>线程池是应用场景最多的并发框架之一，几乎所有需要异步或并发执行任务的应用程序都可以使用线程池，合理地使用线程池可以带来可观得性能提升和响应速度。具体好处如下：</p><ul><li>解耦：线程的创建与任务执行完全分开。</li><li>降低资源消耗：线程的复用降低了线程创建和销毁带来的资源销毁。</li><li>提高响应速度：大多情况下（线程池预热后），到达的任务可以不需要等待线程创建就能立即执行，消除了线程创建所带来的延迟，提升了响应速度。</li><li>便于线程管理：线程是稀缺资源，不能无限制地创建，使用线程池可以对线程进行统一分配、调优和监控。</li></ul><p>关于线程池的概述就介绍这么多，下面我们依次介绍线程池的实现原理，最后分析线程的核心源码。本篇文章涉及到的接口和实现类如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-threadpoolexecutor-base-uml.jpg" alt></p><p>需要说明的是，关于<strong>Scheduled类型</strong>的线程池继承体系本篇文章没有介绍到，它是基于本篇文章着重介绍的 <strong>ThreadPoolExecutor</strong> 的扩展实现，支持时间纬度执行任务。</p><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-principle.jpg" alt></p><p>上图描述了线程池的主要处理流程，下面进行说明：</p><ol start="0"><li>主线程提交任务到线程池。</li><li>如果当前线程池中的线程少于核心线程数，则创建新的线程来执行任务。</li><li>如果线程池中的线程达到或超过核心线程数，则将任务加入到阻塞队列中。</li><li>如果在第 2 步中无法将任务加入阻塞队列，则依据最大线程数创建新的线程来处理任务。</li><li>如果在第 3 步创建新线程会使线程池中线程数超出最大线程数，任务将被拒绝并使用饱和策略处理（拒绝策略）。</li></ol><p>其中第 1 步和第 3 步涉及到创建线程，该过程需要获取全局锁，因为关闭线程池也需要获取这个全局锁。当线程池完成了<strong>预热</strong>即核心线程数创建完毕，在一定程度上就不需要频繁创建线程，也就降低了获取全局锁的频次，对于线程池来说全局锁是一个严重的可伸缩瓶颈。关于流程中的概念下文会陆续说明。</p><h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><p>任务的执行不一定非要通过开启新线程，任务在线程执行之前它也是一个实现类，也有对应的方法。因此我们可以定义出方法级别调用和线程级别调用。</p><h3 id="线程级别调用"><a href="#线程级别调用" class="headerlink" title="线程级别调用"></a>线程级别调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">      &#125;).start();</span><br></pre></td></tr></table></figure><h3 id="方法级别调用"><a href="#方法级别调用" class="headerlink" title="方法级别调用"></a>方法级别调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((Runnable) () -&gt; &#123;</span><br><span class="line">          <span class="comment">//..</span></span><br><span class="line">        &#125;).run();</span><br></pre></td></tr></table></figure><p>线程池对任务的处理最终是通过方法级别调用的来完成，在后面分析源码的时候可以看到。</p><h1 id="Executor-框架"><a href="#Executor-框架" class="headerlink" title="Executor 框架"></a>Executor 框架</h1><h2 id="两级调度模型"><a href="#两级调度模型" class="headerlink" title="两级调度模型"></a>两级调度模型</h2><p>Java 的线程既是任务体也是执行机制，从 在 JDK 5 开始，把任务体和执行机制进行了分离。任务体包括 Runnable 和 Callable，而执行机制由 Executor 框架提供。</p><p>Java 线程会被一对一映射为操作系统线程，在 Java 线程启动时创建对应的操作系统线程，同样地，当该 Java 线程终止时，对应的操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的 CPU 。对于计算复杂的应用，通常会将其拆解为若干个任务并交给 Java 多个线程，这个动作是由用户级别的调度器 Executor 框架完成的，它会将这若干个任务映射为对应数量的线程。在底层，操作系统内核将这些线程映射到硬件处理器上。</p><p>这个过程属于两级调度模型，对应的示意图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-executor.jpg" alt></p><p>从示意图可看出，应用程序通过 Executor 框架控制上层的调度。而下层的调度由操作系统内核控制，应用程序是无法控制的。</p><h2 id="Executor-框架结构"><a href="#Executor-框架结构" class="headerlink" title="Executor 框架结构"></a>Executor 框架结构</h2><p>Executor 框架主要由三大部分组成，具体如下：</p><ul><li>任务体<br>包括 Runnable 接口和 Callable 接口及其实现。</li><li>任务的执行<br>包括任务执行机制的核心接口 Executor，继承 Executor 的 ExecutorService 接口和它的实现们。</li><li>异步计算结果<br>包括核心接口 Future 以及对应的实现们，特别是 FutureTask 实现类。</li></ul><h2 id="Executor-框架成员"><a href="#Executor-框架成员" class="headerlink" title="Executor 框架成员"></a>Executor 框架成员</h2><p>Executor 框架是线程池实现的基础，它的主要成员有 ThreadPoolExecutor、ScheduledThreadPoolExecutor、Executors、Runnable、Callable 以及 Future 。</p><p>下面正式进入到代码层面的介绍，定时任务实现类 ScheduledThreadPoolExecutor 继承自 ThreadPoolExecutor ，用于实现定时执行，本文暂不介绍它的实现。</p><h1 id="Executor-接口"><a href="#Executor-接口" class="headerlink" title="Executor 接口"></a>Executor 接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Runable 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executor 接口仅定义了一个方法，参数是 Runnable 类型，该方法的目的是将任务提交和任务执行细节解耦。需要注意的是，该接口是没有返回值的，也就意味着无法判断提交的任务是否被线程池执行成功。</p><h1 id="ExecutorService-接口"><a href="#ExecutorService-接口" class="headerlink" title="ExecutorService 接口"></a>ExecutorService 接口</h1><p>ExecutorService 接口继承自 Executor 接口，一般我们自定义线程池时使用的就是这个接口，该接口中定义的方法加上继承过来的 <strong>execute</strong> 方法在很多场景中已经可以满足需求了。该接口中的方法如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-executorservice-method.jpg" alt></p><p>上图中的方法大致分类如下：</p><ol><li>向线程池提交任务方法</li></ol><p><strong>submit</strong> 方法和前文中的 <strong>Executor</strong> 接口中的 <strong>execute</strong> 方法有所不同，虽然也是向线程池提交任务，但是有返回值 Future ，并且参数类型不仅支持 <strong>Runnable</strong> 类型还支持 Callable 类型。<br>2. 执行任务方法<br><strong>invokeAll</strong> 方法用于执行多个任务，同时支持设置超时时间。<strong>invokeAny</strong> 方法用于执行多个方法中的一个即可，任务执行完成就可以返回，同样支持设置超时时间。这两类方法的底层需要依赖 execute 方法。<br>3. 关闭线程池方法<br><strong>shutdown</strong> 和 <strong>shutdownNow</strong> 方法用于关闭线程池，这里先不展开说明。<br>4. 判断线程池是否终止方法<br><strong>isTerminated</strong> 和 <strong>awaitTermination</strong> 方法用于判断线程池是否终止。只有在调用关闭方法后才有调用的意义。</p><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>Future 的继承体系如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-future-hierarchy.jpg" alt></p><p>由上图的UML可知，FutureTask 通过 RunnableFuture 间接实现了 Runnable 接口，因此 Executor#execute 方法支持将 FutureTask 提交到线程池。接下来介绍 AbstractExecutorService 抽象实现类就能很清晰看出 FutureTask 的作用。</p><h1 id="AbstractExecutorService-实现"><a href="#AbstractExecutorService-实现" class="headerlink" title="AbstractExecutorService 实现"></a>AbstractExecutorService 实现</h1><p>AbstractExecutorService 抽象类实现自 ExecutorService 接口，在其基础上实现了几个常用的方法，这些方法共子类进行调用。具体方法如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-abstract-method.jpg" alt></p><p>由于 <strong>invokeAll</strong> 方法和 <strong>invokeAny</strong> 方法更多的是执行将任务提交给线程池前的工作，它们并没有将任务提交给线程池，需要通过 Executor 中的 execute 方法实现，而 execute 方法最终要交给具体子类实现。因此，不再对这两类方法展开说明。下面重点介绍下 <strong>newTaskFor</strong> 方法和 <strong>submit</strong> 方法。</p><h2 id="newTaskFor-方法"><a href="#newTaskFor-方法" class="headerlink" title="newTaskFor 方法"></a>newTaskFor 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractExecutorService</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 Runnable 包装成 FutureTask</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value    任务执行成功的返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 Callable 包装成 FutureTask</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable 任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，<strong>newTaskFor</strong>  方法用于将 Runnable 和 Callable 类型的任务统一包装成 FutureTask ，FutureTask 又间接继承了 Runnable 接口。我们知道，Runnable 的 <strong>void run()</strong> 方法是没有返回值的， 而 Callable 的 <strong>V call()</strong> 方法是有返回值的，但 Executor 中的 <strong>void execute(Runnable command)</strong>方法是不关心返回结果的，它只负责处理 Runnable 类型的任务。综上，不难看出 <strong>newTaskFor</strong> 方法就是为了屏蔽不同类型任务的差异，以达到统一交给 <strong>Executor#execute</strong> 执行的目的。下面我们继续看提交任务的另外一种方式。</p><h2 id="submit-提交任务"><a href="#submit-提交任务" class="headerlink" title="submit 提交任务"></a>submit 提交任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractExecutorService</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交 Runnable 任务，不需要返回结果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交 Runnable 任务，任务执行成功的返回结果为 result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交 Callable 任务，任务执行成功返回结果是Callable#call 方法返回值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Runnable 的 <strong>void run()</strong> 方法没有返回值，但是有的时候我们需要返回值，这个时候 <strong>submit</strong> 方法就可以实现，只需在该方法的第二个参数传入预期结果，当任务执行完成后会自动返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span></span><br></pre></td></tr></table></figure><p>此外，我们可以看出 <strong>submit</strong> 方法提交任务的能力是通过 <strong>execute</strong> 方法实现的。定义于最上层接口 Executor 中的 <strong>void execute(Runnable command)</strong> 方法不会返回执行结果，想要执行结果就需要通过 FutureTask 包装任务，然后将包装后的任务 <strong>FutureTask</strong> 交给 <strong>Executor#execute</strong> 方法执行，执行后的结果也会保存到 <strong>FutureTask</strong> 中。关于 Future 的继承体系不展开分析，下面概述下 submit 提交任务的原理。</p><ol><li>调用 newTaskFor 方法将 Runnable 和 Callable 类型的任务统一包装成 FutureTask 对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callable</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;      </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Runnable</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将 Runnable 适配成 Callable</span></span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;      </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>包装的本质是将任务统一适配为Callable类型，因为Callable类型任务可以通过call方法返回执行结果。</li><li>当任务执行的时候，FutureTask 中的 run 方法会执行，这个过程是最关键的一步。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">           !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                        <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Callable&lt;V&gt; c = callable;</span><br><span class="line">           <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">               V result;</span><br><span class="line">               <span class="keyword">boolean</span> ran;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 被适配的Runnable 和 Callable 方法级别调用</span></span><br><span class="line">                   result = c.call();</span><br><span class="line">                   ran = <span class="keyword">true</span>;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                   result = <span class="keyword">null</span>;</span><br><span class="line">                   ran = <span class="keyword">false</span>;</span><br><span class="line">                   setException(ex);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (ran)</span><br><span class="line">                   <span class="comment">// 将执行结果保存到 FutureTask 中</span></span><br><span class="line">                   set(result);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">           <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">           runner = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">           <span class="comment">// leaked interrupts</span></span><br><span class="line">           <span class="keyword">int</span> s = state;</span><br><span class="line">           <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">               handlePossibleCancellationInterrupt(s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>通过FutureTask#get方法从 FutureTask 中取出任务执行结果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> s = state;</span><br><span class="line">      <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">          s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">      <span class="comment">// 从 FutureTask 中取出任务执行结果</span></span><br><span class="line">      <span class="keyword">return</span> report(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">int</span> s = state;</span><br><span class="line">      <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">          (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">     <span class="comment">// 从 FutureTask 中取出任务执行结果</span></span><br><span class="line">      <span class="keyword">return</span> report(s);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="提交任务方式"><a href="#提交任务方式" class="headerlink" title="提交任务方式"></a>提交任务方式</h2><p>最上层接口 Executor 中的 <strong>void execute(Runnable)</strong> 不需要获取结果，不会使用 FutureTask 包装任务。抽象实现类 AbstractExecutorService 中的 <strong>Future&lt;?&gt; submit()</strong> 需要获取结果，因此使用了 FutureTask 包装任务。</p><blockquote><p>需要获取任务结果用 submit 方法，不需要获取结果用 execute 方法。</p></blockquote><h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>线程池核心实现就在 <strong>ThreadPoolExecutor</strong> 实现类中，该类实现了线程池所需的各个方法，包括最核心的 <strong>execute</strong> 方法。开发者可以基于该实现类来进行功能上的扩展，定时任务实现类 ScheduledThreadPoolExecutor 就是基于 ThreadPoolExecutor 扩展的功能。</p><p>在介绍 ThreadPoolExecutor 之前，先来看看线程池的核心参数和属性。</p><h2 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // 核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize, // 最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime, // 空闲线程存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit, // 空闲线程存活时间的单位</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory, // 线程工厂</span></span></span><br><span class="line"><span class="function"><span class="params">                           RejectedExecutionHandler handler // 饱和策略</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;<span class="comment">//...&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>corePoolSize</strong><blockquote><p>核心线程数，线程池的基本大小。当提交一个任务到线程池时，线程池会创建一个基本线程来执行任务，即使其它空闲的基本线程能够执行新任务也会创建线程，只有线程池预热完毕（线程池中线程数达到核心线程数）才不再创建核心线程。</p></blockquote></li></ul><p><strong>特别说明：</strong></p><ol><li>核心线程并不是特指某一个或某几个线程，而是针对设置的核心线程数而言，任何一个线程都可以是核心线程。</li><li>corePoolSize 表示的是线程池的常驻线程数，如果设置为 0 则表示在没有任何任务时需要销毁线程池。如果大于 0 ，即使没有任务时也会保证线程池的线程数等于此值。</li><li>关于此值设置的合理性，如果设置的较小，则会频繁的创建和销毁线程（非核心线程）；设置过大，则会浪费资源。</li></ol><ul><li><p><strong>maximumPoolSize</strong></p><blockquote><p>最大线程数，线程池允许创建的最大线程数，最大线程数 = 核心线程数 + 非核心线程数。此值只有在任务比较多且阻塞队列放不下时才会用到。</p></blockquote></li><li><p><strong>keepAliveTime</strong></p><blockquote><p>空闲线程存活时间，线程池中的线程空闲时间超过该值也没任务可做那么就需要关闭。如果设置为 0，表示一旦空闲立即回收。该参数一般只会对非核心线程起作用，核心线程不会因为空闲太长时间而被关闭，当最大线程数等于核心线程数时，那么线程池在空闲的时候也不会销毁任何线程。但是可通过调用 allowCoreThreadTimeOut(true) 方法使核心线程数内的线程也可以被回收。</p></blockquote></li><li><p><strong>unit</strong></p><blockquote><p>和 keepAliveTime 参数一起使用，是时间单位。如：天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）等。</p></blockquote></li><li><p><strong>workQueue</strong></p><blockquote><p>用于存放等待执行的任务的阻塞队列，是 BlockingQueue 接口的实现。当线程池中的线程数大于等于核心线程数时才会用到该队列，注意和有没有空闲核心线程无关。</p></blockquote></li><li><p><strong>threadFactory</strong></p><blockquote><p>线程工厂，线程池中的线程就由它创建。如果设置就使用默认的线程工厂。</p></blockquote></li><li><p><strong>handler</strong></p><blockquote><p>饱和策略（拒绝策略），当阻塞队列和线程池都满了，说明线程池处于饱和状态，需要采取一种策略处理提交的新任务，默认是直接抛出异常。</p></blockquote></li></ul><p>通过配置不同的参数，就可以创建出行为不同的线程池，这也是线程池高度灵活性的基础。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>线程池中的阻塞队列参数非常重要，不同的阻塞队列对线程池有不同影响，下面对线程池常用的阻塞队列进行说明。</p><ul><li><p><strong>ArrayBlockingQueue</strong><br>基于数组结构的有界阻塞队列，该队列按照先进先出原则对元素进行排序。</p></li><li><p><strong>LinkedBlockingQueue</strong><br>基于链表结构的无界阻塞队列，该队列按照先进先出规则对元素进行排序。</p></li><li><p><strong>SynchronousQueue</strong><br>一个比较特殊的阻塞队列，其本身不存储元素。每个插入操作必须等待另一个线程执行移除操作，反之亦然。如果使用该阻塞队列，只有当两个线程执行相反模式的操作才能配对成功，否则先执行的一方只能等待。下图是对线程池使用该队列处理任务过程的描述：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-syncronousqueue.jpg" alt></p></li><li><p><strong>PriorityBlockingQueue</strong><br>具有优先级的无界阻塞队列。</p></li></ul><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>线程池采用的是 <strong>Integer.SIZE</strong> 32 位的整数来存放线程池的<strong>状态</strong>和池中的<strong>线程数</strong>，其中高 3 位表示线程池状态即可以表示 7 种状态，低 29 位表示线程数即可以存放 5 亿多个线程。这种设计思想对整数赋予了双重角色，通过高低位的不同，既表示线程池状态，又表示工作线程数目，这是一个典型的高效优化。这种方式在其它框架中也多有使用，如 Dubbo 协议就使用 16 个字节共 128 位，每一位用来表示不同意义的数值。</p><h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><p>线程池的状态表示如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-threadpoolexecutor-ctl.jpg" alt></p><p>线程池的状态和线程的执行密切相关，下面分别说明线程池的状态及其状态流转。</p><h3 id="RUNNING"><a href="#RUNNING" class="headerlink" title="RUNNING"></a>RUNNING</h3><ul><li><strong>状态说明</strong><br>线程池处于 RUNNING 状态允许接受新的任务，处理等待队列中的任务。</li><li><strong>状态转换</strong><br>线程池一旦被创建就处于 RUNNING 状态，并且线程池中的线程数为 0 。</li></ul><h3 id="SHUTDOWN"><a href="#SHUTDOWN" class="headerlink" title="SHUTDOWN"></a>SHUTDOWN</h3><ul><li><strong>状态说明</strong><br>线程池处于 SHUTDOWN 状态时，不接收新任务，但能处理任务队列中的任务。</li><li><strong>状态转换</strong><br>调用线程池的shutdown()方法时，线程池由RUNNING -&gt; SHUTDOWN 。</li></ul><h3 id="STOP"><a href="#STOP" class="headerlink" title="STOP"></a>STOP</h3><ul><li><strong>状态说明</strong><br>线程池处在 STOP 状态时，不接收新任务，不处理任务队列中的任务，并且会中断正在处理的任务的线程。</li><li><strong>状态转换</strong><br>调用线程池的shutdownNow()方法时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP 。</li></ul><h3 id="TIDYING"><a href="#TIDYING" class="headerlink" title="TIDYING"></a>TIDYING</h3><ul><li><strong>状态说明</strong><br>当所有的任务已终止，任务数量为 0 ，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子方法terminated()。若用户需要在线程池变为TIDYING时，进行相应的处理；可以通过重写terminated()方法来实现。 </li><li><strong>状态转换</strong><br>当线程池在 SHUTDOWN 状态下时，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在 STOP 状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。</li></ul><h3 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h3><ul><li><strong>状态说明</strong><br>线程池彻底终止，就变成 TERMINATED 状态。</li><li><strong>状态转换</strong><br>线程池处在TIDYING状态时，执行完 terminated() 方法之后，就会由 TIDYING -&gt; TERMINATED。</li></ul><p>下面进行小结，线程池状态及流转如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-status.jpg" alt></p><h2 id="ThreadPoolExecutor-属性"><a href="#ThreadPoolExecutor-属性" class="headerlink" title="ThreadPoolExecutor 属性"></a>ThreadPoolExecutor 属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">--- ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">     <span class="comment">//======= 约定使用32位表示线程池状态和数量，高三位表示状态 ，低29位表示数量 =============/</span></span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池初始化状态码，状态为 RUNNING，线程数为 0</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 这里 COUNT_BITS 设置为 29 (0001 1101)，即约定高三位用于存放线程状态，低29位用于存放线程数</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池允许最大线程池临界值，1 * 2^29 = 536870912</span></span><br><span class="line"><span class="comment">      * 过程：（1）001 （2）左移29位得到001后跟29个0 -&gt; 0010 0000 0000 0000 0000 0000 0000 0000 （3）减去1得0001 1111 1111 1111 1111 1111 1111 1111</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 运行状态：111 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 关闭状态：000 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN = <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 停止状态：001 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 整理状态：010 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING = <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 终止状态：011 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 获取线程池的状态。将整数 c 的低 29 位置为 0 就得到了线程池的状态</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &amp; ~CAPACITY;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 用于计算线程池中线程数量。将整数 c 的高 3 位置为 0，就得到了线程池中的线程数</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// 获取线程池状态码</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> rs | wc;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 比较状态</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &lt; s;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 当前线程池是否处于运行状态</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 增加线程池中的线程数量</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndIncrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 减少线程池中的线程数量</span></span><br><span class="line"><span class="comment">      * Attempts to CAS-decrement the workerCount field of ctl.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndDecrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementWorkerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">         &#125; <span class="keyword">while</span> (!compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池阻塞队列</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池全局锁</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 用于保存线程池创建的Worker，动态变化</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 全局锁条件 - 等待队列</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 追踪线程池最大值，仅在获取到全局锁条件下执行</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程池完成任务数量</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 线程工厂</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 饱和策略</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 保活时间，即最大允许空闲时间</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 是否允许线程池被回收</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 核心线程池数，不会被回收，即 workers的最小值。除非设置 allowCoreThreadTimeOut 。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 最大线程数</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 默认的饱和策略，直接抛出异常</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> AbortPolicy();</span><br></pre></td></tr></table></figure><p>上面的属性都很重要，其中还包含了部分属性的操作方法，这些都会在下面的源码分析中不断出现。</p><h2 id="ThreadPoolExecutor-构造方法"><a href="#ThreadPoolExecutor-构造方法" class="headerlink" title="ThreadPoolExecutor 构造方法"></a>ThreadPoolExecutor 构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Public constructors and methods 构造方法们</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">              Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">              threadFactory, defaultHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">              <span class="comment">// 当没有指定线程工厂时，使用默认的线程创建工厂</span></span><br><span class="line">              Executors.defaultThreadFactory(), handler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">              maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">              maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">              keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">      <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">              <span class="keyword">null</span> :</span><br><span class="line">              AccessController.getContext();</span><br><span class="line">      <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">      <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">      <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">      <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">      <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">      <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>创建线程池时如果不指定线程工厂则会使用默认的线程工厂，默认线程工厂创建的线程都属于同一个线程组，拥有相同的优先级，并且都是非守护线程，具体代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">--- Executors</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            <span class="comment">// 线程组</span></span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                  Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                          poolNumber.getAndIncrement() +</span><br><span class="line">                         <span class="string">"-thread-"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 创建线程</span></span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 设置为非守护线程</span></span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 设置优先级</span></span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上构造方法相关参数在前文已经详细说明就不再介绍，接下来看看 ThreadPoolExecutor 的内部类 Worker 。</p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务执行的真正线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主线程提交任务到线程池，任务就会存放到这里。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于存放当前线程完成的任务数。注意和 completedTaskCount 的区别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker 唯一的构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask 任务，可能为 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// 设置状态值为 -1，防止在启动线程之前，其它操作拿到全局锁</span></span><br><span class="line">        setState(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 使用工厂创建线程，注意创建出来的线程的任务体就是 Worker 本身。这意味着当线程启动时，Worker#run方法就会执行</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker 实现了 Runnable 接口，重写了run() 方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里调用了外部类的 runWorker 方法</span></span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------- Worker 继承了 AQS类，下面的核心方法是重写了 AQS的方法，使用独占锁获得执行权 -----------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 独占式获取资源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * unlock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中断线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池在创建线程时，会将线程封装成工作线程 Worker，该工作线程有点特别，下面对其简单说明：</p><ol><li><p>继承了 AQS ，实现了一套独占锁机制。</p><blockquote><p>在线程执行任务期间，会进行加锁，加锁的目的是告诉系统它在执行任务，并不是处于空闲状态，防止误回收自己。</p></blockquote></li><li><p>实现了 Runnable 接口，它是一个任务体并重写的 run 方法，该方法是线程池执行任务的关键。</p><blockquote><p>在创建 Worker 成功后，紧接着就会启动 Worker 封装的真实 Thread ，启动成功后 Worker 中的 run 方法就会执行。</p></blockquote></li><li><p>内部封装了用来执行任务的真正线程。 </p><blockquote><p>内部封装的线程是线程池的工厂创建出来的，它的使命就是执行 Worker 中的 run 方法中的任务。那业务任务谁来执行？ 同样地，也是该线程执行，只不过它使用的是方法级别的调用。</p></blockquote></li><li><p>线程复用</p><blockquote><p>一个 Worker 对应线程池中的一个线程，线程复用的逻辑实现是在 Worker 类中的 run 方法中执行 runWorker 方法。由上面的第 2、3 两个说明，很容易得出，当 Worker 中的线程启动后会执行 Worker 这个任务体的 run 方法，进而该线程就会执行 runWorker 方法，实现线程的复用。</p></blockquote></li></ol><p>扯了那么多，下面终于可以瞅见 ThreadPoolExecutor 的 execute 方法了，有了前面的基础后再来看这个核心方法就简单了很多。前文也提到目前线程池支持两种方式提交任务，分别是 <strong>execute 方法</strong>和 <strong>submit 方法</strong> ，而后者依赖于前者。</p><h2 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute 方法"></a>execute 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 任务体不允许为 null</span></span><br><span class="line">     <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取线程池的状态码,该值包含了线程池的状态和线程数</span></span><br><span class="line">     <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 1 如果当前线程数少于核心线程数，则创建一个 Worker 来执行任务，即创建一个线程并将 command 作为该线程的第一个任务</span></span><br><span class="line">     <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">         <span class="comment">// 返回 false 说明线程池不允许创建线程，可能原因：（1）线程池关闭（2）当前线程数已经达到临界值</span></span><br><span class="line">         <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         <span class="comment">// 创建失败，再次更新线程池状态码</span></span><br><span class="line">         c = ctl.get();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2 如果线程池处于运行状态，则尝试将任务添加到阻塞队列 workQueue 中</span></span><br><span class="line">     <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">         <span class="comment">// 再次获取线程池状态码</span></span><br><span class="line">         <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">         <span class="comment">// 双重检查，再次判断线程池状态。如果线程状态变了（非运行状态）就需要从阻塞队列移除任务，同时执行拒绝策略。防止线程池关闭。</span></span><br><span class="line">         <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">             reject(command);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 如果线程池状态仍然是运行状态，并且线程池为空则创建一个非核心线程来执行任务，防止线程提交到阻塞队列后线程都关闭了。</span></span><br><span class="line">             <span class="comment">// 一般这种情况是设置核心线程数为 0 </span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">             addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 3 如果任务队列满了，则根据 maximumPoolSize 创建非核心线程。如果创建失败，说明当前线程数已经达到 maximumPoolSize 或线程池关闭，需要执行拒绝策略</span></span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">         reject(command);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>execute 方法逻辑体现了提交任务到线程池的流程，上面代码已经详细注释。需要强调的是，符合将任务加入阻塞队列中的情况，会进行双重检查线程池的状态，因为是直接将任务入队，和前后两种情况不一样，即使任务成功排队，也有可能出现线程池关闭或线程池为空的情况。</p><p>下面通过一张图进行阐述正常流（不考虑线程池关闭等情况）的流程：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-process.jpg" alt></p><p>如果说 execute 方法逻辑体现了提交任务到线程池的流程，那么 addWorker 方法则体现了线程池执行任务的开端，即接收任务、创建线程、启动线程。</p><h2 id="addWorker-方法"><a href="#addWorker-方法" class="headerlink" title="addWorker 方法"></a>addWorker 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//-------------------------------  1 创建线程前的检测工作 -------------------------------------/</span></span><br><span class="line">     <span class="comment">// for 跳出标志</span></span><br><span class="line">     retry:</span><br><span class="line">     <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//------------------------- 1.1 创建线程前，对线程池状态和队列进行检查，判断是否还可以创建线程 ----------------------/</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取线程池状态码</span></span><br><span class="line">         <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取线程池状态</span></span><br><span class="line">         <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          * 如果线程池状态范围是：[SHUTDOWN，TERMINATED]，出现下列任一种情况都不允许创建Worker:</span></span><br><span class="line"><span class="comment">          * 1 firstTask != null</span></span><br><span class="line"><span class="comment">          * 2 workQueue 为空</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          *小结：</span></span><br><span class="line"><span class="comment">          * 1 线程池处于 SHUTDOWN 状态时，不允许提交任务，但是已经存在的任务需要继续执行。</span></span><br><span class="line"><span class="comment">          *  1.1 当 firstTask == null 时且阻塞队列不为空，说明非提交任务创建线程，执行阻塞队列中的任务，允许创建 Worker</span></span><br><span class="line"><span class="comment">          *  1.2 当 firstTask == null 但阻塞队为，不能创建 Worker</span></span><br><span class="line"><span class="comment">          *  1.3 当 firstTask ！= null 时，不能创建</span></span><br><span class="line"><span class="comment">          * 2 线程池状态大于 SHUTDOWN 状态时，不允许提交任务，且中断正在执行的任务。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                 !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">//---------------------------- 2 创建线程前，对线程池中线程数检查，判断是否还可以创建线程 ---------------------/</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">             <span class="comment">// 获取线程池线程数</span></span><br><span class="line">             <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 判断线程池线程数是否达到边界值：1 临界值 2 核心线程数或最大线程数</span></span><br><span class="line">             <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 增加线程池中线程数如果成功，则表示创建 Worker 前的校验工作完成，可以进行创建 Worker 流程了。</span></span><br><span class="line">             <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                 <span class="keyword">break</span> retry;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 增加线程数失败，说明可能其它线程也在尝试创建Worker，就需要回到起点，重新校验。</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">//并发影响，需要重新获取线程池状态码</span></span><br><span class="line">             c = ctl.get();</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 确定是否其它线程操作导致的 CAS 失败，如果是则需要重新校验。</span></span><br><span class="line">             <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                 <span class="keyword">continue</span> retry;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//----------------------------------   创建 Worker 流程     ------------------------------------/</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// Worker 中的线程是否启动的标志</span></span><br><span class="line">     <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Worker 是否添加到 workers 集合中的标志</span></span><br><span class="line">     <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     Worker w = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 创建 Worker，将任务传入。注意，如果是非提交任务创建Worker的话，firstTask 为null</span></span><br><span class="line">         w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将创建的Worker中的线程临时保存到 t，这个是真正的线程，Worker 只是对线程进行了包装。</span></span><br><span class="line">         <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Worker 中的线程创建成功</span></span><br><span class="line">         <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 加锁，注意这个锁的粒度是全局的。也就是说，当这里获取到锁，线程池不能关闭，因为线程池关闭也需要锁。</span></span><br><span class="line">             <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">             mainLock.lock();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 再次获取线程池状态</span></span><br><span class="line">                 <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 如果线程池是运行状态，或者是关闭状态且传入的任务为null(不接收新任务，但是会继续执行任务队列中的任务)，符合条件</span></span><br><span class="line">                 <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 提前检查新创建的Worker中的线程是否是启动状态</span></span><br><span class="line">                     <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 将新创建的 Worker 加入到 workers 集合</span></span><br><span class="line">                     workers.add(w);</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 更新 largestPoolSize 的值，该值用于追踪线程池中的线程大小</span></span><br><span class="line">                     <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                     <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                         largestPoolSize = s;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 更新标记值</span></span><br><span class="line">                     workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="comment">// 全局锁释放，注意全局锁释放的时机</span></span><br><span class="line">                 mainLock.unlock();</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 添加到Worker集合后</span></span><br><span class="line">             <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                 <span class="comment">// 启动Worker中的线程，这一步的意义重大</span></span><br><span class="line">                 t.start();</span><br><span class="line">                 <span class="comment">// 标记线程启动成功</span></span><br><span class="line">                 workerStarted = <span class="keyword">true</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 线程启动失败，需要清理工作</span></span><br><span class="line">         <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">             addWorkerFailed(w);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> workerStarted;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>addWorker 方法注释的如此详细，还需要强调一点，该方法只是接收了任务（提交任务请求的前提下）并创建启动线程，但是线程还没有执行任务。再分析执行任务逻辑之前，先来看看创建 Worker 的异常流程。</p><h2 id="addWorkerFailed-方法"><a href="#addWorkerFailed-方法" class="headerlink" title="addWorkerFailed 方法"></a>addWorkerFailed 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得全局锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 从 workers 缓存中移除启动失败的 Worker</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少线程池中线程数，因为在此之前递增了</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试终止线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法名非常直观，就是执行 addWorker 失败的处理方法。该方法主要做了以下工作：</p><ol><li>从 Worker 缓存集合中移除启动失败的 Worker 。</li><li>递减线程池中线程数，在校验允许创建 Worker 时递增了线程数，这里需要递减。</li><li>尝试终止线程池</li></ol><h2 id="runWorker-方法"><a href="#runWorker-方法" class="headerlink" title="runWorker 方法"></a>runWorker 方法</h2><p>Worker 中的线程启动成功后，其 run 方法会调用 runWorker 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Worker 实现了 Runnable 接口，重写了run() 方法。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里调用了外部类的 runWorker 方法</span></span><br><span class="line">     runWorker(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>runWorker 方法是执行提交任务和阻塞队列中等待任务的核心实现，接下来我们分析它的具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 当前线程，即 w 中的线程</span></span><br><span class="line">      Thread wt = Thread.currentThread();</span><br><span class="line">      <span class="comment">// 获取该线程的第一个任务，可能没有。如果有的话，优先执行该任务。</span></span><br><span class="line">      Runnable task = w.firstTask;</span><br><span class="line">      w.firstTask = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 允许中断，在关闭线程池的时候会中断[空闲的]线程 。设置状态值为 0。</span></span><br><span class="line">      w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 循环调用getTask() 方法从任务队列中获取任务并执行</span></span><br><span class="line">          <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123; </span><br><span class="line"></span><br><span class="line">              <span class="comment">// 上锁，同时标志着自己处于工作状态。</span></span><br><span class="line">              w.lock();</span><br><span class="line"></span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * 出现以下任何一种情况都需要中断线程：</span></span><br><span class="line"><span class="comment">               * 1 如果线程池状态大于等于 STOP，并且当前线程没有被中断</span></span><br><span class="line"><span class="comment">               * 2 如果当前线程被中断了并且线程池状态大于等于 STOP 状态（恢复中断标识）</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">              <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                      (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                  <span class="comment">// 中断当前线程</span></span><br><span class="line">                  wt.interrupt();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// ThreadPoolExecutor 的扩展方法</span></span><br><span class="line">                  beforeExecute(wt, task);</span><br><span class="line"></span><br><span class="line">                  Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 执行目标任务,方法级别调用。</span></span><br><span class="line">                      task.run();</span><br><span class="line"></span><br><span class="line">                  &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                      thrown = x;</span><br><span class="line">                      <span class="keyword">throw</span> x;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                      thrown = x;</span><br><span class="line">                      <span class="keyword">throw</span> x;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                      thrown = x;</span><br><span class="line">                      <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      <span class="comment">// ThreadPoolExecutor 的扩展方法</span></span><br><span class="line">                      afterExecute(task, thrown);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="comment">// 置空 task,为下一个任务做准备</span></span><br><span class="line">                  task = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="comment">// 更新完成任务数</span></span><br><span class="line">                  w.completedTasks++;</span><br><span class="line">                  <span class="comment">// 释放Worker 独占锁</span></span><br><span class="line">                  w.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// while 循环没有出现异常，completedAbruptly 才会被设置为 false</span></span><br><span class="line">          completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 线程退出 while 循环后需要进行回收，可能情况如下：</span></span><br><span class="line"><span class="comment">           * 1 任务队列中已经没有要执行的任务了</span></span><br><span class="line"><span class="comment">           * 2 任务执行过程出现异常</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          processWorkerExit(w, completedAbruptly);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>执行任务逻辑已经详细注释，下面对该方法简要分析：</p><ol><li>线程执行任务有两个途径，通过取 Worker 的 firstTask 或者调用 getTask 方法从阻塞队列中取出待执行的任务。</li><li>线程通过调用任务的 <strong>run</strong> 方法来执行对应的任务，而不是启动线程，这个正是前文特别说明的方法级别调用。</li><li>线程复用得益于对线程的封装，封装后的线程不再局限于执行当前任务，而是处于一个任务循环中，反复获取任务，然后执行任务，从而实现了线程的复用。</li><li>当 Worker 封装的线程退出循环后，就需要对该线程进行回收。</li><li>可以通过重写 beforeExecute() 和 afterExecute() 方法来实现 ThreadPoolExecutor 的扩展功能。</li></ol><p>我们回到 getTask 方法，看看 Worker 封装的线程是如何获取任务的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 返回null 表示可以对当前线程进行回收</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取线程池状态码</span></span><br><span class="line">         <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">         <span class="comment">// 获取线程池状态</span></span><br><span class="line">         <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 线程池状态为SHUTDOWN且队列为空 或 线程池状态为 STOP，应该回收线程。这个条件不仅可以回收非核心线程，也可以回收核心线程。todo 核心线程唯一回收条件</span></span><br><span class="line">         <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">             <span class="comment">// 减少线程池中的线程数</span></span><br><span class="line">             decrementWorkerCount();</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 线程池中的线程数</span></span><br><span class="line">         <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 允许核心线程数内的线程回收，或线程池中的线程数超过了核心线程数，那么有可能发生超时关闭</span></span><br><span class="line">         <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果线程池中的线程数大于最大线程数或获取任务超时（不设置 allowCoreThreadTimeOut，核心线程没有超时概念），并且任务队列为空，则应该回收当前线程。</span></span><br><span class="line">         <span class="comment">// wc &gt; maximumPoolSize ，可能是执行 setMaximumPoolSize 方法修改了最大值。</span></span><br><span class="line">         <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">             <span class="comment">// 减少工作线程数</span></span><br><span class="line">             <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 从队列中取出任务</span></span><br><span class="line">             Runnable r = timed ?</span><br><span class="line">                     <span class="comment">// 超时获取任务，因为线程超时要被回收。如果线程在等待的过程发生了中断，会抛出中断异常</span></span><br><span class="line">                     workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                     <span class="comment">// 不需要超时</span></span><br><span class="line">                     workQueue.take();</span><br><span class="line">             <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                 <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 获取任务超时，进行重试</span></span><br><span class="line">             timedOut = <span class="keyword">true</span>;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">             <span class="comment">// 发生中断重置超时标记</span></span><br><span class="line">             timedOut = <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该方法用于从阻塞队列中拉取待执行的任务，下面对主要逻辑进行说明：</p><ol><li>该方法返回 null 时，表示当前线程可以被回收了，包括核心线程。</li><li>在没有设置 allowCoreThreadTimeOut 时，核心线程数的线程会阻塞等待任务，不会被回收。</li><li>超时回收，在 keepAliveTime 对应的具体时间内都没有任务，应该回收非核心线程。</li><li>以下情况需要返回 null，回收当前线程<ul><li>线程池处于 SHUTDOWN 状态，且阻塞队列为空</li><li>线程池处于 STOP 状态</li><li>线程池中的线程数大于最大线程数</li></ul></li></ol><p>从阻塞队列中获取任务的方法分析完毕后，我们再回到 <strong>processWorkerExit(w, completedAbruptly)</strong> 方法，该方法不仅会回收退出循环拉取任务方法的线程，还会向空闲线程发送中断信号，协助线程池回收空闲线程。下面我们就来详细看看该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 线程执行任务抛出了异常</span></span><br><span class="line">       <span class="keyword">if</span> (completedAbruptly)</span><br><span class="line">           <span class="comment">// 减少线程池中线程数量</span></span><br><span class="line">           decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取全局锁</span></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">       mainLock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 累计线程池完成的任务数量</span></span><br><span class="line">           completedTaskCount += w.completedTasks;</span><br><span class="line">           <span class="comment">// 将线程从缓存集合中删除</span></span><br><span class="line">           workers.remove(w);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 释放全局锁</span></span><br><span class="line">           mainLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 尝试终止线程池</span></span><br><span class="line">       tryTerminate();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="comment">// 如果线程池状态小于 STOP 状态，说明还可以处理任务</span></span><br><span class="line">       <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">           <span class="comment">// 当前线程处理任务没有出现异常</span></span><br><span class="line">           <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">               <span class="comment">// 获取核心线程数，如果设置了允许回收核心线程数，则返回 0，否则取核心线程数</span></span><br><span class="line">               <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">               <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; !workQueue.isEmpty())</span><br><span class="line">                   min = <span class="number">1</span>;</span><br><span class="line">               <span class="comment">// 线程池中线程数大于 min ，说明无需创建线程。在设置了 corePoolSize 为 0 或 allowCoreThreadTimeOut 为 true 的时候。</span></span><br><span class="line">               <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                   <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 执行到这里的可能情况：1 线程池中没有线程执行任务队列中的任务，需要创建线程取执行。 2 当前线程执行任务过程出现异常，而且当前线程被回收了，为了确保有线程执行任务，这里需要创建线程。</span></span><br><span class="line">           addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>processWorkerExit 方法主要做了三件事情，下面进行说说明：</p><ol><li>回收 Worker ，即当前线程</li><li>尝试终止线程池</li><li>做补偿，防止运行中的线程池中无线程处理任务</li></ol><p>前文也出现了 <strong>tryTerminate()</strong> 方法的调用，该方法主要用于中断空闲线程和尝试终止线程池。在每次回收线程时都会调用该方法，主要用来中断任意一个空闲线程，加快线程池回收空闲线程，但是如果中断的线程不能响应中断是不能保证被回收的。虽然每次进行线程回收时会调用该方法尝试终止线程池，但是大多情况下不会成功。下面会介绍到关闭线程池的方法，关闭线程池时也会调用该方法。</p><p>至此，提交任务到线程池、线程池创建线程、线程执行任务、回收线程的代码实现已经介绍完毕，下面对该过程使用流程图的形式进行总结，流程图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-worker-process.jpg" alt></p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>线程池的拒绝策略属于一种限流保护机制，防止线程池崩溃。线程池拒绝任务的时机如下：</p><ol><li>执行关闭方法后线程池处于关闭状态及以上状态</li><li>线程池处于运行状态，但是没有能力（阻塞队列已满，线程数达到最大值）处理新提交的任务了。</li></ol><p>JDK 内置了 4 种拒绝策略，默认使用 AbortPolicy 策略。拒绝策略如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/threadpool-rejectedexecutionhandler.jpg" alt></p><h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 直接抛出异常（默认策略）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 直接抛出异常</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> r 任务</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> e te</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                   <span class="string">" rejected from "</span> +</span><br><span class="line">                   e.toString());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 由提交任务的线程自己来执行任务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 只要线程池没有被关闭，就由提交任务的线程自己来执行这个任务。</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 线程池没有关闭</span></span><br><span class="line">          <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">              <span class="comment">// 方法级别调用</span></span><br><span class="line">              r.run();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 直接忽略任务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 直接忽略</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将阻塞队列头的任务扔掉，然后将当前任务提交到线程池尝试执行。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将队列都任务移除，并将当前任务提交到线程池</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">               e.getQueue().poll();</span><br><span class="line">               e.execute(r);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>自定义拒局策略只需要实现 RejectedExecutionHandler 接口，重写 rejectedExecution 方法即可。如果不自定义拒绝策略，线程池将使用默认的拒绝策略。</p><h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>关闭线程池可以通过调用线程池的 shutdown 或 shutdownNow 方法来关闭线程池，两者的原理有点差异，下面我们分别说明这两个方法。</p><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 全局锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">     mainLock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         checkShutdownAccess();</span><br><span class="line">         <span class="comment">// 设置线程池状态为 SHUTDOWN</span></span><br><span class="line">         advanceRunState(SHUTDOWN);</span><br><span class="line">         <span class="comment">// 尝试中断线程池中闲置的线程</span></span><br><span class="line">         interruptIdleWorkers();</span><br><span class="line">         <span class="comment">// hook</span></span><br><span class="line">         onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         mainLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 尝试终止线程池</span></span><br><span class="line">     tryTerminate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>shutdown() 方法可以安全地关闭一个线程池，体现在下面几个方面：</p><ol><li>只是将线程池的状态置为 SHUTDOWN ，这意味着线程池不能接收新的任务，再有新的任务被提交则根据拒绝策略进行处理。</li><li>会执行完正在执行的任务和队列中等待的任务，任务全部结束后才会彻底关闭线程池。</li><li>尝试中断线程池中闲置的线程</li></ol><h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     List&lt;Runnable&gt; tasks;</span><br><span class="line">     <span class="comment">// 全局锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">     mainLock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         checkShutdownAccess();</span><br><span class="line">         <span class="comment">// 设置线程池状态为 STOP</span></span><br><span class="line">         advanceRunState(STOP);</span><br><span class="line">         <span class="comment">// 尝试中断线程池中所有启动状态的线程</span></span><br><span class="line">         interruptWorkers();</span><br><span class="line">         <span class="comment">// 将阻塞队列中正在等待的所有任务进行备份，然后清空阻塞队列并返回备份。有了这个备份，可以根据需要做补救措施。</span></span><br><span class="line">         tasks = drainQueue();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         mainLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 尝试终止线程池</span></span><br><span class="line">     tryTerminate();</span><br><span class="line">     <span class="keyword">return</span> tasks;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>shutdownNow() 方法表示立即关闭线程池。首先会将线程池状态置为 STOP 状态，接着会给线程池中所有启动的线程发送中断信号，尝试中断任务的执行，然后清空阻塞队列并返回等待执行的任务备份。最后尝试终止线程池。</p><p>对于 <strong>tryTerminate()</strong> 方法的调用，前文也出现了，两种关闭线程池的方法最后也调用了该方法，下面我们来看看这个方法的具体逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 线程池状态码</span></span><br><span class="line">          <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 线程池是运行状态，或大于等于 TIDYING 状态，或是 SHUTDOWN 状态且阻塞队列非空。这些条件是不允许关闭线程池的</span></span><br><span class="line">          <span class="keyword">if</span> (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; !workQueue.isEmpty()))</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 线程池中线程数量不为 0，向任意空闲线程发出中断信号。所有被阻塞的线程，最终都会被一个个唤醒，回收。todo</span></span><br><span class="line">          <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">              interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 全局锁</span></span><br><span class="line">          <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">          mainLock.lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 设置线程池状态码为 TIDYING</span></span><br><span class="line">              <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">// 状态设置成功后执行 terminated() 钩子方法</span></span><br><span class="line">                      terminated();</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 设置线程池状态码为 TERMINATED 终止状态</span></span><br><span class="line">                      ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                      termination.signalAll();</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              mainLock.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// else retry on failed CAS</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>tryTerminate() 方法包含了多方面的信息，下面进行总结：</p><ol><li>判断线程池是否可以终止，原则是线程池处于关闭状态、队列中没有任务的情况下可以关闭。</li><li>向空闲线程发送中断信号，期望中断任务的执行。</li><li>符合终止线程池的条件时，会先将线程池状态置为 TIDYING 状态，设置成功后会执行 terminated() 钩子方法，最后将线程池状态设置为 TERMINATED 状态。</li></ol><p>线程池中虽然多处使用中断来期望中断任务的执行，但由于 Java 中不推荐强行停止线程的机制的限制，即使调用了 shutdownNow 方法，如果被中断的线程对于中断信号不敏感，那么依然有可能导致任务不会停止。</p><h1 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h1><p>线程池太大或太小都会导致麻烦，选择一个合适的线程池大小是非常有必要的，通常我们需要根据任务执行的性质来确定的。</p><ul><li>CPU 密集型任务<br>如果任务主要进行大量复杂的计算，那么意味着 CPU 的处理能力是稀缺的资源，应当分配较少的线程，通常按照 CPU 核数 或者 CPU 核数 + 1 进行设置。 如果分配线程过多，反而可能导致大量的上下文切换开销。</li><li>IO 密集型任务<br>如果任务普遍需要较长时间等待，如 I/O 操作比较多，那么可以配置适当多的线程，如 CPU 核数 * 2 。也可以参考大神推荐的计算方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程数 &#x3D; CPU核数 × 目标CPU利用率 ×（1 + 平均等待时间&#x2F;平均工作时间）</span><br></pre></td></tr></table></figure></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对线程池核心点进行了详细分析，先是简单介绍了线程池产生的背景，接着说明了线程池的优势，最后对线程池源码进行了分析。从任务提交到线程池，到线程池创建线程并处理任务，到最后线程被回收，最后简单介绍了线程池的配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最初的时候并没有线程池的概念，而是先有线程。每个任务都需要对应一个线程，任务少的情况没有太大问题，任务过多就出现了各种性能和资源开销问题，更
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - 链表</title>
    <link href="https://gentryhuang.com/posts/2362a8ea/"/>
    <id>https://gentryhuang.com/posts/2362a8ea/</id>
    <published>2020-10-20T11:33:59.000Z</published>
    <updated>2020-11-05T15:46:20.745Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol><li><p>redis中的链表</p><p>链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置这中数据结构，所以redis构建了自己的链表实现。</p></li><li><p>redis链表节点的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">  <span class="comment">// 前置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="comment">// 后置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">// 节点的值 (可用于保存各种不同类型的值)</span></span><br><span class="line">  <span class="keyword">void</span> *value</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>redis链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数，用于复制链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数，用于释放链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数，用于对比链表节点所保存的值和其他值是否相等</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>redis链表的特点</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)</span><br><span class="line">- 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点</span><br><span class="line">- 带表头和表尾指针：使用list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)</span><br><span class="line">- 带链表长度计数器：程序使用list结构的len属性标记链表中节点的个数，程序获取链表中节点个数的复杂度为O(1)</span><br><span class="line">- 多态：链表可以保存各种不同类型的值</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>链表在redis中的应用</p><p>链表被广泛用于实现redis的各种功能，如：列表键、发布与订阅、慢查询、监视器，redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;redis中的链表&lt;/p&gt;
&lt;p&gt;链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis数据结构" scheme="https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - 简单动态字符串</title>
    <link href="https://gentryhuang.com/posts/aa1d8127/"/>
    <id>https://gentryhuang.com/posts/aa1d8127/</id>
    <published>2020-10-18T11:00:50.000Z</published>
    <updated>2020-11-05T15:46:20.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h3><ol><li><p>初识动态字符串</p><p>redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS作为redis的默认字符串表示。 <code>在redis中，c字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如日志。当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，redis就会使用SDS来表示字符串值。</code> 值的注意的是，对于redis中的key都是使用SDS来实现的。此外，SDS除了用来保存Redis数据库中的字符串值之外，SDS还被用作缓冲区（buffer）: AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区。</p></li><li><p>sds的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">  <span class="comment">// 记录buf数组中已使用字节的数量等价于sds所保存字符串的长度</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">  <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">  <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>sds遵循c字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在sds的len属性中，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由sds函数自动完成的。遵循空字符结尾的好处是，sds可以直接使用一部分C字符串函数库里面的函数。</p></li><li><p>sds与c字符串的区别</p><p>c语言使用的简单字符串表示方式，并不能满足redis对字符串在安全性、效率以及功能方面的要求。</p><p>3.1  常数复杂度获取字符串长度</p><blockquote><p>因为c字符串并不记录自身的长度信息，所以要获取长度就必须遍历整个字符串，故获取字符串长度的复杂度为O(N)。而redis的sds结构中通过len属性记录了sds的长度，故获取字符串长度的复杂度为O(1)。注意，设置和更新sds长度的工作是由sds的API在执行时自动完成的，使用sds无须进行任何手动修改长度的操作。</p></blockquote><p>3.2 避免缓冲区溢出</p><blockquote><p>c字符串不记录自身长度，很容易造成缓冲区溢出。与c字符串不同，sds的空间分配策略完全杜绝了发生缓冲区溢出的可能性，当sds api需要对sds进行修改时，api会先检查sds的空间是否满足需要，如果不满足的话，api会自动将sds的空间扩展至执行所需的大小，然后才执行实际的修改操作，因此使用sds既不需要手动修改sds的空间大小，也不会出现c字符串中可能出现的缓冲区溢出问题。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line">    <span class="comment">//追加时先进行扩容，后面详细说明</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//拼接字符串</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s:原数组     </span></span><br><span class="line"><span class="comment">//strlen(t) 需拼接的目标数组的长度</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>3.3 内存分配与释放</p><p>因为c字符串的长度和底层数组的长度之间存在着关联性，所以<code>每次增加或者缩短一个c字符串，程序都总要对保存这个c字符串的数字进行一次分配操作</code>，但是内存分配操作涉及到复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，为了避免c字符串的这种缺陷，sds通过未使用空间解除了字符串长度和底层数组长度之间的关联，通过未使用空间，sds实现了空间预分配和惰性空间释放两种优化策略。</p><ul><li><p>空间预分配</p><p>空间预分配用于优化sds的字符串增长操作：当sds的api对一个sds进行修改，并且需要对sds进行空间扩展的时候，程序不仅会为sds分配修改所必须要的空间，还会为sds分配额外的未使用空间。通过空间预分配策略，redis可以减少连续执行字符串增长操作所需的内存重新分配次数，在扩展sds空间之前，sds api 会先检查未使用空间是否足够，如果足够就直接使用未使用空间，而不需要执行内存重新分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis 扩容源码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，</span></span><br><span class="line"><span class="comment"> * buf 至少会有 addlen + 1 长度的空余空间</span></span><br><span class="line"><span class="comment"> * （额外的 1 字节是为 \0 准备的）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *  sds ：扩展成功返回扩展后的 sds</span></span><br><span class="line"><span class="comment"> *        扩展失败返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前的空余空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 最少需要的长度</span></span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class="line">        <span class="comment">// 那么为它分配两倍于所需长度的空间</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足，分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 sds 的空余长度</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 sds</span></span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额外分配未使用空间数量的计算策略：</p><blockquote><ol><li>对sds修改后，sds的长度（即len属性的值）小于1MB，那么程序分配和len属性同样大小的未使用空间，这时sds的len属性的值将和free属性的值相同。例如：修改后sds的len变成10字节，那么程序也会分配10字节的未使用空间，sds的buf数组的实际长度：10 + 10 + 1 = 21字节</li><li>对sds修改后，sds的长度大于等于1MB，那么程序会分配1MB的未使用空间。例如：修改后sds的len变成30MB，那么程序会分配1MB的未使用空间，sds的buf数组的时间长度：30MB + 1MB + 1byte</li></ol></blockquote></li><li><p>惰性空间释放</p><p>惰性空间释放用于优化sds的字符串缩短操作：当sds的api需要缩短sds保存的字符串时，程序并不立即使用内存重分配来回收缩短后多来的字节，而是使用free属性将这些字节的数量纪录起来，用于将来对sds进行增长操作时，这些未使用空间可能就派上用场了。注意，sds也提供了相应的api，可以真正地释放sds的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</p></li></ul><p>3.4 二进制安全</p><blockquote><p>c字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里不能包含空字符，否则在读取的时候会被默认为结束字符，这些限制使得c字符串只能保存文本数据，不能保存图片、音视频、压缩文件这类的二进制数据。sds的api都是二进制安全的，所有的sds api都会以<code>二进制的方式处理sds存放在buf数组里的数据</code>,程序不会对其中的数据做任何限制、过滤，数据写入时是什么样，它被读取时就是什么样。<code>这也是将sds的buf属性称为字节数组的原因，redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据</code>。</p></blockquote></li><li><p>c字符串和sds之间的区别</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         C字符串                                    SDS</span><br><span class="line">- 获取字符串长度的复杂度为O（n）                 获取字符串长度的复杂度O（1）</span><br><span class="line">- API是不安全的，可能造成缓冲区溢出                      API是安全的</span><br><span class="line">- 修改字符串长度N次，必然要执行N次内存重分配     修改字符长度N次，最多执行N次内存重分配</span><br><span class="line">- 只能保存文本数据                                 可以保存文本或者二进制数据</span><br><span class="line">- 可使用&lt;string.h&gt;库中的函数                   可使用一部分&lt;string.h&gt;库中的函数</span><br></pre></td></tr></table></figure></li><li><p>sds更多的api可参考源码</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简单动态字符串&quot;&gt;&lt;a href=&quot;#简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;简单动态字符串&quot;&gt;&lt;/a&gt;简单动态字符串&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初识动态字符串&lt;/p&gt;
&lt;p&gt;redis没有直接使用C语言传统的字符串表示（以空字
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis数据结构" scheme="https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>并发 - Java并发工具类</title>
    <link href="https://gentryhuang.com/posts/37f29896/"/>
    <id>https://gentryhuang.com/posts/37f29896/</id>
    <published>2020-10-05T16:00:00.000Z</published>
    <updated>2020-12-10T10:33:19.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 JDK 的并发包中提供了几个非常有用的并发工具类。 <code>CountDownLatch</code>、<code>CyclicBarrier</code> 和 <code>Semaphore</code> 工具类提供了并发流程控制的手段，它们都是对 AQS 应用。本篇文章将介绍其简单使用以及内部原理。</p><table><thead><tr><th align="left">工具类</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td align="left">Semaphore</td><td>信号量，通过控制 ‘许可证’ 的数量来协调各个线程，以保证合理的使用公共资源。</td><td>线程只有拿到 ‘许可证’ 才能继续运行</td></tr><tr><td align="left">CyclicBarrier</td><td>循环栅栏，让一组线程到达一个栅栏（同步点）时被阻塞，直到最后一个线程到达栅栏时，被栅栏拦截的线程才会继续运行。</td><td>强调一组线程都到达同步点才会继续往下执行</td></tr><tr><td align="left">CountDownLatch</td><td>门栓，等待多线程完成</td><td>强调一个或多个线程等待其它线程完成操作</td></tr></tbody></table><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><p><strong>场景</strong></p><blockquote><p>加工厂生产产品，产品需要三道工序进行检测，只有三道工序检测通过才能进入下一个环节。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定线程数线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品质量检测</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要3个工人进行检测，就用3来初始化一个 CountDownLatch</span></span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> no = i;</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 检测</span></span><br><span class="line">                            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                            log.info(<span class="string">"No."</span> + no + <span class="string">" 完成检测。"</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">// 调用 countDown() 代表完成。这里指某个员工完成检测任务</span></span><br><span class="line">                            latch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"产品质量检测中....."</span>);</span><br><span class="line">        <span class="comment">// 调用await() 代表线程阻塞等待其它线程完成，即同步状态 state 减为 0。这里指产品等待检测完成</span></span><br><span class="line">        latch.await();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"产品质量检测完毕，进入下一个环节。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[main] INFO com.code.juc.tool.CountDownLatchDemo - 产品质量检测中.....</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.CountDownLatchDemo - No.2 完成检测。</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.CountDownLatchDemo - No.3 完成检测。</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CountDownLatchDemo - No.1 完成检测。</span><br><span class="line">[main] INFO com.code.juc.tool.CountDownLatchDemo - 产品质量检测完毕，进入下一个环节。</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>以上例子中，main 线程调用了 <code>latch.await()</code> 进行阻塞等待，即它阻塞在门栓上（叫啥无所谓，中文是门栓、栅栏），只有当条件满足时（其它线程调用 <code>latch.countDown()</code> 递减 state 为0）它才能通过这个门栓。这个例子比较简单，只有一个线程调用 <code>await</code> 方法等待其它线程完成，这属于 <code>一对多</code> 关系。CountDownLatch 还可以实现复杂的 <code>多对多</code> 关系的场景，有 m 个线程在门栓上等待 n 个线程完成任务，直到 n 个线程都完成任务，这 m 个线程才能同时通过门栓。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-1.jpg" alt></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>根据 CountDownLatch 的使用例子分析源码，按照执行流程逐一分析。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Synchronization control For CountDownLatch. // 继承AQS的内部类</span></span><br><span class="line"><span class="comment">     * Uses AQS state to represent count. // 使用 AQS 的状态表示 数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 有参构造方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> count 数量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="comment">// 调用父类方法，设置状态值</span></span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取数量</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 调用父类方法，获取状态值</span></span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 覆写父类方法 （获取同步状态（这里表示数量） - 共享方式）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 覆写父类方法（释放同步状态（这里表示数量） - 共享方式）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> releases 没有意义的参数，用不到</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="comment">// 执行递减数量时，如果数量已经是 0 ，则直接返回 false，说明状态已经被其它线程递减为 0 了，当前线程无需唤醒 await() 阻塞的线程（们）</span></span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> nextc = c - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，需要一个 &gt;= 0 的整数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count the number of times &#123;<span class="doctag">@link</span> #countDown&#125; must be invoked</span></span><br><span class="line"><span class="comment">     *              before threads can pass through &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> count&#125; is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch 类是对 AQS 共享模式的使用。既然是使用 AQS 框架，那么就是一个固定的模式，AQS 已经处理好了同步状态的获取与释放以及阻塞与唤醒，自定义组件只需继承 AQS 以及根据同步状态获取方式（独占/共享）实现模版方法即可。前面也说了，AQS 准备好了一切，只需要条件触发就可以执行对应的任务，而实现的模版方法正是触发条件。</p><p>CountDownLatch 主要有两个核心方法，<code>await</code> 和 <code>countDown</code> 。<code>countDown</code> 方法每次调用都会将 <code>state</code> 减 1 ，直到 <code>state</code> 的值为 0。<code>await</code> 方法可以被多个线程调用，调用 <code>await</code> 方法的线程进入 AQS 的阻塞队列中并挂起，当且仅当 <code>state</code> 为 0 时，线程会从阻塞队列中依次被唤醒过来。</p><h4 id="await-等待"><a href="#await-等待" class="headerlink" title="await 等待"></a>await 等待</h4><p>await 方法是一个阻塞方法，当且仅当同步状态 state 减至 0，该方法才会返回，否则调用该方法的线程将阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--- CountDownLatch</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 可中断获取同步状态</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="comment">// 中断则抛出中断异常</span></span><br><span class="line">      <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// main 线程调用 await 时，state = 3，条件成立 </span></span><br><span class="line">      <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 接下来就是 AQS 的工作了，共享方式可中断获取同步状态</span></span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch 的 await 方法简单，直接传入数量值为 1 尝试获取同步状态（其实传入值是没有意义的，用不到）。CountDownLatch 覆写了模版方法即条件，条件成立则 AQS 完成阻塞任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 入队 ，即当前线程加入阻塞队列，共享方式</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 尝试获取前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// CountDownLatch 实现的条件，state != 0 时，返回 -1</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 找大哥，找到大哥就挂起自己，然后等待大哥唤醒自己。没有找到则继续找，直到找到或其前驱节点是 head 节点，找到则挂起等待，是 head 则尝试获取同步状态。</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="comment">// 线程被中断则抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch 的 await 方法到此就结束了，下面总结下该方法的核心步骤。</p><ul><li><p>main 线程没有获取到同步状态会进入阻塞队列<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-2.jpg" alt><br>main 线程对应的节点入队完成，如上图。需要注意的是，因为 main 线程对应节点入队时阻塞队列为空，因此需要构建阻塞队列，使用一个虚节点作为 head 。如果节点在入队时已经存在阻塞队列，那么直接挂到阻塞队列尾部即可。</p></li><li><p>尝试获取同步状态<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-3.jpg" alt><br>入队后进入for 循环，此时main线程对应的节点的前驱节点是 head，但 tryAcquireShared 返回 -1,此时进入 <code>找大哥</code> 的流程中。<code>找大哥</code> 就是将当前节点的<strong>有效</strong>前驱节点等待状态 waitStatus 设置为 -1。这里是将 main 线程对应节点的前驱节点 head 的 waitStatus 设置为 -1。</p></li><li><p>挂起，等待前置节点唤醒<br>找到大哥后挂起自己，等待大哥（有效前置节点）唤醒自己。</p></li></ul><br>以上是 main 线程获取同步状态失败后，进入阻塞队列等待唤醒的过程。需要说明的是，CountDownLatch 可以有多个线程等待其它线程完成，例子中只是使用一个线程等待而已。<h4 id="countDown-唤醒"><a href="#countDown-唤醒" class="headerlink" title="countDown 唤醒"></a>countDown 唤醒</h4><p>countDown 方法每次调用都会将同步状态 state 减 1，直到减少至 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">--- CountDownLatch</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放同步状态</span></span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有当 state 减到 0 时， tryReleaseShared 方法才返回 true，否则仅是将 state 减 1 并返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            <span class="comment">// state == 0 时，唤醒阻塞的线程。 注意，这里是 t1 线程唤醒阻塞的线程即 main 线程</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// t1 线程执行到这里，唤醒阻塞队列中等待的 main 线程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">            <span class="comment">// 将当前 head 保存起来，因为其它线程可能会占领它，此时是虚节点</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="comment">// main 线程入队时已经把 head 当作大哥了，即 将 head 的 waitStatus 设置为 -1 (Node.SIGNAL)</span></span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                     <span class="comment">// cas 将 head 的 waitStatus 设置 为 0。</span></span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 唤醒 head 下一个有效节点。这里是 main 线程对应的节点</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">            </span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面代码只是正常情况下一个完整流程，即 main 线程加入阻塞队列并挂起后，t2、t3、t1 分别执行 <code>countDown</code> 方法递减 <code>state</code> 的值，到了 t1 调用该方法时，刚好 <code>state</code> 的值被减至 0 ，然后线程 t1 执行唤醒阻塞队列中的线程逻辑。下面对该过程进行总结。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-4.jpg" alt></p><p>至此，唤醒条件已经具备，即 <code>state = 0</code> ，下面我们回到之前线程挂起的代码处，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 尝试获取前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// CountDownLatch 实现的条件，state != 0 时，返回 -1</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 2 main 占据 head 并继续唤醒后置阻塞的线程</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// 1 线程 t1 唤醒阻塞的 main 线程，该方法返回，即 main 线程继续执行尝试再次获取同步状态</span></span><br><span class="line">                    parkAndCheckInterrupt())  </span><br><span class="line">                    <span class="comment">// 如果线程被中断则抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>main 线程被唤醒后从 parkAndCheckInterrupt 方法返回，如果没有被中断，则继续尝试获取同步状态，此时可以获取到同步状态（r &gt;= 0 成立）。接下来 main 线程会进入到 setHeadAndPropagate 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将当前 head 保存起来，因为其它线程可能会占领它</span></span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below </span></span><br><span class="line">        <span class="comment">// node 节点占领 head，即 main 线程占领 head</span></span><br><span class="line">        setHead(node); </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里条件判断对应的场景比较多，毕竟是 AQS 统一处理方法，因此考虑的情况比较全面。对于 CountDownLatch ，就是唤醒 node 之后的有效节点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点的后置节点</span></span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="comment">// 如果为 null 或者 是共享方式的节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                <span class="comment">// 接着唤醒阻塞线程 （共享式）。注意，这里是醒来的阻塞线程继续唤醒后置还在阻塞的线程。</span></span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 占领 head </span></span><br><span class="line"><span class="comment">     * Sets head of queue to be node, thus dequeuing. Called only by</span></span><br><span class="line"><span class="comment">     * acquire methods.  Also nulls out unused fields for sake of GC</span></span><br><span class="line"><span class="comment">     * and to suppress unnecessary signals and traversals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>setHeadAndPropagate 方法主要做了两件事，node 占领 head 并唤醒 node 后置的<strong>有效</strong>节点。由于例子中只有 main 线程进入了阻塞队列，它后面没有等待唤醒的线程节点，但为了研究源码我们假设 main 线程对应节点后面还有一个 线程 t 节点等待唤醒，那么 main 线程会执行 doReleaseShared 方法来唤醒线程 t ，此时 head 是 main 线程对应的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 将当前 head 保存起来，因为其它线程可能会占领它</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//  h == null 说明阻塞队列为空，h == tail 说明头节已经是最后一个节点或者是刚刚初始化的节点，这对应 CountDownLatch 来说都应该结束。</span></span><br><span class="line">        <span class="comment">//  按照例子走到这里，head 就 main线程对应的节点，同时 tail 也是 main 线程对应的节点。不过我们假设了 线程 t ，因此条件是成立的</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="comment">// h 的状态，即 main 线程对应节点状态，由入队方法可知，t 线程对应节点会把 main 线程对应节点作为 大哥节点，即 waitStatus 设置为 -1（Node.SIGNAL)</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 可能会失败</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唤醒 h 的后置节点，也就是阻塞队列中的第一个节点。这里是线程 t 对应的节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; </span><br><span class="line">                          <span class="comment">// todo 这里可能会失败 </span></span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">          &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 线程执行到这里，如果唤醒的线程已经占领了 head，此时 h != head，当前线程继续循环。如果 h == head ，说明，唤醒的线程还没有占领 head，当前线程退出循环</span></span><br><span class="line">        <span class="comment">// 这里可能 main 线程执行到这里时，main 线程唤醒的线程 t 已经占领了 head ,此时 h != head </span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setHeadAndPropagate 方法和 doReleaseShared 方法配合，依次唤醒阻塞的线程，即 执行 doReleaseShared 方法的线程唤醒它的后置阻塞线程，醒来的线程会再次尝试获取同步状态然后进入到 setHeadAndPropagate 方法中先占领 head，然后调用 doReleaseShared 方法继续唤醒它的后置阻塞节点。需要说明的是，AQS 的 <code>doReleaseShared</code> 方法极端场景还是挺多的，这里结合 CountDownLatch 来说明。</p><p>我们抛开给出的例子，根据以下场景分析几个特殊的情况</p><blockquote><p>要进行体能测试，每组三个同学进行短跑，在体育老师发出起跑指令前，这三个同学都要在起跑线待着，当体育老师准备完毕后会发出开始跑的指令，那这三个同学就会一起跑向终点的测试仪。这里 CountDownLatch 的数量 为 1，即同步状态为 1 。</p></blockquote><ul><li><p><strong>h != head 的情况</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-5.jpg" alt><br>当 t1 被唤醒后，唤醒 t1 的线程 t 执行到上图中的代码处，还没有退出循环，t1 已经占领了 head（此时图中的 head 要指向 t1 线程对应的节点，且 t1 线程节点 thread 置空，prev 置空。图中没有体现出来），此时 head != h ，线程 t 将会进行下一轮循环。</p></li><li><p><strong>compareAndSetWaitStatus(h, Node.SIGNAL, 0) 失败</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-6.jpg" alt><br>线程 t 进行第二轮循环时，刚好被唤醒的线程 t1 也进入该循环，此时两个线程并发执行，假设线程 t CAS 操作成功，然后退出循环，线程 t1 失败，将会进行下一轮循环。注意，此时虚节点的 next 指针还存在，因为我们假设的是 t1 线程失败了，t 线程成功退出了，t 线程不属于阻塞队列中的线程，它不会维护阻塞队列节点关系，如果是 t1 线程成功并退出循环就会清除它上一个节点的 next ，这里就是虚节点。</p></li><li><p><strong>执行 else if (ws == 0 &amp;&amp;..) 分支</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-7.jpg" alt><br>t1 线程第二次循环时，唤醒的 t2 线程还没有占领 head，此时的 head 还是 t1 线程对应的节点，但是 waitStatus 被之前的 t 线程通过 CAS 设置为 0 了，因此进入到 else if 分支，然后再次把节点 watiStatus 设置为 -3 。执行到 h == head 判断处时，假设 t2 还是没有占领 head ，此时 t1 退出循环，然后清除其前置节点的 next 指针，即虚节点。</p></li><li><p><strong>compareAndSetWaitStatus(h, 0, Node.PROPAGATE) 失败</strong><br>进入这个方法的前提是 ws == 0，即 head 的 waitStatus 出现了 0，此时如果 CAS 失败，一般有两种可能，一种是线程并发执行 CAS 只有一个会成功，另一种是其它的线程把该节点的 waitStatus 值修改了，此时能改 head 的状态值的很可能是节点入队引起的修改，因为新节点要把有效的前驱节点状态值设置为 -1 。在 CountDownLatch 中一般不会发生第二种可能，因为一旦唤醒条件成立，就不会再有节点需要入队阻塞了。</p></li></ul><p>剩下的 t2 线程、t3 线程依次会被唤醒，需要注意的是 t3 线程被唤醒占领头节点后也会进入到 doReleaseShared 方法的循环中，此时它对应的节点既是 head 又是 tail，就直接退出循环，结束整个流程了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>CountDownLatch 的构造函数需要一个 int 类型的参数作为数量（用来计数），如果想等待 N 个任务完成（N 个线程执行完任务），就需要传入 N 。CountDownLatch 的 countDown 方法用于将 N 减 1 ,await 方法会阻塞当前调用线程（阻塞在门栓上，门栓是一个同步点的概念），直到 N 减至 0 被阻塞的线程才会继续往下执行。此外，CountDownLatch 还提供了一个带有指定时间的 await 方法，用于等待超时的场景，超过等待时间就不会再等，被阻塞线程继续往下执行。这个方法很简单，就是在 await 方法的基础上增加了超时判断，下面粘贴下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">--- CountDownLatch</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">            doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared timed mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanosTimeout max wait time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 计算出等待的最迟时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 计算出等待剩余时间</span></span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="comment">// 超过等待时间，则不再等待，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// 执行挂起的最小时间粒度</span></span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    <span class="comment">// 挂起 nanosTimeout 时间后自动醒来</span></span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意，N 值必须 大于等于 0，如果 N 等于 0 ，调用 await 方法时当前线程不会被阻塞，此外 CountDownLatch 不支持重新初始化，也不支持修改数量的值。</p></blockquote><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="使用例子-1"><a href="#使用例子-1" class="headerlink" title="使用例子"></a>使用例子</h3><p><strong>场景</strong></p><blockquote><p>某个公司部门举办团建活动，需要员工自行拼车前往目的地，司机会在指定的地点等待拼车的 4 个人到齐后才发车。我们假设该部门某个团队有 8 个人，那么就需要拼 2 辆车前往目的地。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定线程数线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要等待 4 个同学到齐，到齐后发车，因此这里初始化一个带有 Runnable 参数的 CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, () -&gt; log.info(<span class="string">"4人已到齐，请系好安全带，现在出发赶往目的地 !"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8个人，需要 2 辆车。这里会循环使用 CyclicBarrier</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 赶往拼车地点</span></span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">                    log.info(<span class="string">"到达指定拼车地点 !"</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                   </span><br><span class="line">                    <span class="comment">// 一组人员全部到达后，才能出发。 即 一组线程全部到达栅栏后，被阻塞的线程才能继续执行</span></span><br><span class="line">                    log.info(<span class="string">"出发了 !"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException exception) &#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CyclicBarrierDemo - 4人已到齐，请系好安全带，现在出发赶往目的地 !</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-8] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-7] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-7] INFO com.code.juc.tool.CyclicBarrierDemo - 4人已到齐，请系好安全带，现在出发赶往目的地 !</span><br><span class="line">[pool-1-thread-7] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-8] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>以上例子中，使用循环体和线程池模拟 8 个线程执行任务，其中每 4 个线程为一组，只有这 4 个线程都到达栅栏，例子中是到达指定拼车点，才能继续往下执行，否则都会阻塞在栅栏上等待其它线程到达栅栏。到达栅栏的定义是 线程调用 await 方法。一组线程都到达栅栏后，由最后到达的线程执行及时任务，没有任务则不执行。CyclicBarrier 是可循环使用的栅栏，当一组线程都到齐后，CyclicBarrier 进行下一个循环，下一组线程进行同样的操作。</p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>CyclicBarrier 的字面意思是可循环使用的栅栏，因为它的栅栏可以重复使用（通过重置关键属性）。它要做的事情是，让一组线程到达一个栅栏（是一个同步点）时被阻塞，直到最后一个线程到达栅栏时，栅栏才会打开，所有被栅栏拦截的线程才能继续运行。它的功能是通过组合 <code>ReentrantLock</code> 和 <code>Condition</code> 来达到的。我们还是基于使用例子来分析源码。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cb-1.jpg" alt></p><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栅栏所处的代。栅栏上阻塞的线程被唤醒或者栅栏被重置，就开启新的一代</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 栅栏是否被打破，默认为 false</span></span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁对应的条件，阻塞线程在栅栏或者唤醒阻塞在栅栏上的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栅栏要拦截的线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一组线程都到达栅栏后优先执行的任务，即如果设置这个这个任务，那么被阻塞在栅栏上的线程要等这个任务结束后才能被唤醒。注意，这个任务是被最后到达的线程执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前栅栏所处的代，如果第一次就是 1 代，如果第2次使用就是 2 代</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 还要等待的线程数，即还没有到栅栏的线程数。这个初始值 是 parties 值，每个线程到栅栏就减 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CyclicBarrier 高级构造函数，支持优先执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CyclicBarrier 默认的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier 默认的构造方法的参数表示栅栏拦截的线程数，每个线程调用 await 方法都会告诉 CyclicBarrier 我已经到达栅栏，此时栅栏要把拦截的线程数减 1 ，然后阻塞当前线程，直到要拦截的线程都到达栅栏时，栅栏才会打开，即最后到达的线程唤醒阻塞在栅栏上的线程，然后这组线程都从 await 方法处继续往下执行。 CyclicBarrier 还提供一个高级构造函数，用于在最后一个线程到达栅栏时，优先执行的任务，便于处理复杂的业务场景。注意，<strong>执行优先任务先于唤醒阻塞线程</strong> ，代码中所有体现。</p><h4 id="下一代栅栏"><a href="#下一代栅栏" class="headerlink" title="下一代栅栏"></a>下一代栅栏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---CyclicBarrier</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启下一代栅栏</span></span><br><span class="line"><span class="comment">     * 1 唤醒阻塞在上一代栅栏上的线程</span></span><br><span class="line"><span class="comment">     * 2 重置 count 和 generation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// signal completion of last generation</span></span><br><span class="line">        trip.signalAll();</span><br><span class="line">        <span class="comment">// set up next generation</span></span><br><span class="line">        count = parties;</span><br><span class="line">        generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>开启下一代栅栏很好理解，因为要开启下一代栅栏了，当前代栅栏上阻塞的线程需要被唤醒，同时初始化好下一代栅栏。</p><h4 id="打破栅栏"><a href="#打破栅栏" class="headerlink" title="打破栅栏"></a>打破栅栏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---CyclicBarrier</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 打破栅栏</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 设置栅栏已破标志</span></span><br><span class="line">          generation.broken = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">// 重置 count</span></span><br><span class="line">          count = parties;</span><br><span class="line">          <span class="comment">// 唤醒阻塞在栅栏上的线程</span></span><br><span class="line">          trip.signalAll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打破栅栏需要标记当前代的栅栏不可用，并且要唤醒阻塞在这个不可用的栅栏上的线程，因为这里不进行唤醒的话，阻塞的线程将一直挂起。这里重制 count 不明白是干嘛的。</p><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">--- CyclicBarrier</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不带超时机制的方法，例子中使用的就是这个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// false , 0</span></span><br><span class="line">            <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 带有超时机制的方法，如果超过等待时间，当前线程没有被唤醒则 抛出 TimeoutException</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">               BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier 提供了 await 两个重载方法，一个是不带超时机制的方法，另一个是带有超时机制的方法。下面我们分析 CyclicBarrier 核心代码 <code>dowait</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">--- CyclicBarrier</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用可重入锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取标志着当前栅栏的 代</span></span><br><span class="line">            <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查当前代的栅栏是否被打破，如果当前代的栅栏被打破需要 抛出 BrokenBarrierException 异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查当前线程中断状态，如果被中断了，则要抛出 InterruptedException 异常，并且打破栅栏</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递减 count 的值</span></span><br><span class="line">            <span class="keyword">int</span> index = --count;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果 count 递减后的值为 0 ，说明当前代的栅栏要拦截的最后一个线程也到达栅栏</span></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 标志优先任务是否失败，默认是 false</span></span><br><span class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果指定了优先任务，就交给最后到达的线程执行</span></span><br><span class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 设置标志</span></span><br><span class="line">                    ranAction = <span class="keyword">true</span>;</span><br><span class="line">                   </span><br><span class="line">                    <span class="comment">// 唤醒当前代的栅栏上阻塞的任务，并开启下一代 （栅栏可以重复使用）</span></span><br><span class="line">                    nextGeneration();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果执行优先任务失败，则打破栅栏</span></span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// ---------------------- 执行到这里的线程不是最后一个线程，因此需要阻塞，等待最后一个线程到来并唤醒自己 ---------------/</span></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 不带超时机制</span></span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        <span class="comment">// 释放锁，加入等待队列 (ConditionObject)</span></span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="comment">// 带超时机制，并且超时时间 &gt; 0</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        <span class="comment">// 释放锁，加入等待队列 (ConditionObject)，如果到时间还没有被唤醒则不再阻塞</span></span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 执行到这里说明，线程进入等待队列后被中断了</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="comment">// 栅栏仍是进入等待队列的前的栅栏，此时应该打破栅栏，并且抛出中断异常</span></span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 1 g != generation，说明新一代的栅栏生成了，即最后一个线程也到达了栅栏，此时只需复位被中断线程的中断标志</span></span><br><span class="line">                        <span class="comment">// 2 栅栏被打破了（一定要抛出异常），被打破异常交由后续逻辑处理，此时只需复位被中断线程的中断标志</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 线程被唤醒后，还没从 await 方法返回栅栏就被打破了，直接抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 这个方法很重要，被唤醒后的线程正常逻辑都会从该方法返回出去</span></span><br><span class="line"><span class="comment">                 * 1 最后一个线程到达后会做三件事：执行优先任务、唤醒当前代的栅栏上阻塞的线程、开启栅栏的下一代</span></span><br><span class="line"><span class="comment">                 * 2 当前所在的方法是加了 ReentrantLock 锁的，因此我们要知道以下信息：</span></span><br><span class="line"><span class="comment">                 *   1）最后一个到达线程在没有执行完三件事前，是不会释放锁的</span></span><br><span class="line"><span class="comment">                 *   2）唤醒的阻塞线程并不能马上从 await 方法返回，它需要先去竞争锁，获取锁后才能从 await 方法返回</span></span><br><span class="line"><span class="comment">                 *   3）即使最后一个线程开启了栅栏的下一代，在它没有释放锁前，其它组的线程也要阻塞，比如例子中的后四个线程</span></span><br><span class="line"><span class="comment">                 * 3 被最后一个线程唤醒的线程执行到这里时，新一代的栅栏一定已经存在了。注意，这里说的是被最后一个线程唤醒的线程，并不是由于超时机制醒来的线程</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 超时机制醒来的线程，如果发现已经超时了，则打破栅栏，抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>涉及到的源码已经分析过了，下面结合使用例子简单分析下过程</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cb-2.jpg" alt></p><p>CyclicBarrier 整个过程还是挺清晰的，没有使用 CAS 重试等机制，因为栅栏等待线程的 await 方法直接使用了ReentrantLock 锁，线程要到达栅栏必须拿到锁才行，整个过程是串行化的。分析完核心方法后，我们再看下其它几个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">--- CyclicBarrier</span><br><span class="line">    <span class="comment">// 重置栅栏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">            nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在栅栏上等待线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parties - count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断栅栏是否被打破</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generation.broken;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>CyclicBarrier 和 CountDownLatch 还是有点像的，前者强调的是一组线程到达同步点即栅栏，后者强调的是阻塞在同步点的线程等待其它线程完成任务。具体区别如下：</p><ul><li>作用不同<br>CyclicBarrier 要等固定数量线程到达同步点，CountDownLatch 等待的不是线程而是同步状态state递减为 0。前者针对线程，后者针对事件/任务（根据需要调用 countDown 方法）。</li><li>重用性不同<br>CyclicBarrier 可以重复使用，上一代使用完后自动初始化下一代，也可以调用 reset 方法重置。 CountDownLatch 只能使用一次，在同步状态减为 0 后门栓打开后，就不能再次使用，想要使用需要新建实例。</li><li>唤起任务数不同<br>CyclicBarrier 只能唤醒一个任务，CountDownLatch 可以唤醒多个任务</li></ul><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="使用例子-2"><a href="#使用例子-2" class="headerlink" title="使用例子"></a>使用例子</h3><p><strong>场景</strong></p><blockquote><p>有一些加工厂是对环境有很大污染的，如果要生产产品必须要有关机构申请生产许可证，拿到许可证后才可以生产，完成一定规模后需要归还许可证，便于其它工厂可以申请。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定线程数线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有 3 个许可证书，每个加工厂公平获取。</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有 6 个加工厂想要获取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取许可证</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    log.info(<span class="string">"拿到了许可证"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理任务</span></span><br><span class="line">                    log.warn(<span class="string">"凭借许可证处理任务..."</span>);</span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log.info(<span class="string">"归还许可证"</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-1] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-2] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-3] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-4] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-5] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-6] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>以上例子中，使用循环体和线程池模拟 6 个线程，即 6 个加工厂获取生产许可证。Semaphore 的许可证数量为 3，即监管部门目前只有 3 个生产许可证，此时 6 个工厂只能有其中三个可以获取到，另外 3 个工厂只能等待生产许可证的归还，如果不归还将一直等着。</p><h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><p>Semaphore 是用来控制同时访问特定资源的线程数量，它通过协调各个线程来保证合理的使用有限的公共资源。Semaphore 也是对 AQS 共享模式的使用，因此套路也是一样的。它接收一个整形的数字 permits，也是 AQS 的 state，表示可用的许可证数量，即允许 permits 个线程获取许可证，也就是最大并发数是 permits。因为是共享模式的使用，因此需要重写对应的模版方法 <code>tryAcquireShared</code> 和 <code>tryReleaseShared</code> ，前者用来判断能否获取到许可证，后者用来判断能否归还许可整（总是返回true）。此外，Semaphore 在此基础上增加了公平和非公平获取同步状态的功能。Semaphore 的用法很简单，它的 <code>acquire</code> 方法获取许可证，<code>release</code> 方法归还许可证，获取不到许可证的线程就加入阻塞队列中，等待其它线程释放许可证。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-1.jpg" alt></p><h4 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h4><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-2.jpg" alt></p><p>前面也提到了，Semaphore 是对 AQS 共享模式的使用，并且支持公平和非公平的状态管理方式，即对同步状态 state 的操作。通过上图的 UML 类图更加清晰，Semaphore 既可以公平实现方式创建对象，又能以非公平方式创建对象。</p><h4 id="Sync-内部类"><a href="#Sync-内部类" class="headerlink" title="Sync 内部类"></a>Sync 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 AQS 的内部类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信号量的同步实现。使用 AQS 的同步状态 state 表示许可证。分为 公平和非公平两种实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法，设置 AQS 的同步状态 state。对于 Semaphore 来说表示许可证</span></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取同步状态，即许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非公平实现，共享式获取许可证。返回剩余许可证数量</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式释放同步状态方法，即归还许可证。该方法总是返回 true</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="comment">// 归还 releases 个许可证 (注意，如果不获取先释放的话，许可证会变多的)</span></span><br><span class="line">                <span class="keyword">int</span> next = current + releases;</span><br><span class="line">                <span class="comment">// 这里判断归还数量不能小于 0</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                <span class="comment">// CAS 更新 state （AQS 中的方法 ）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync 内部类首先对同步状态 state 进行了初始化，先确定同步状态 state 的值，即表示的意义，这里指许可证。第二个是获取同步状态 - tryAcquireShared，这里指获取许可证，Sync 中没有进行实现而是交给了两个子类。第三个是释放同步状态 - tryReleaseShared，这里指归还许可证，Sync 中统一实现了这个逻辑。下面我们分别看下其子类实现。</p><h4 id="NonfairSync-内部类"><a href="#NonfairSync-内部类" class="headerlink" title="NonfairSync 内部类"></a>NonfairSync 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 AQS 的内部类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信号量的同步实现。使用 AQS 的同步状态 state 表示许可证。分为 公平和非公平两种实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法，设置 AQS 的同步状态 state。对于 Semaphore 来说表示许可证</span></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取同步状态，即许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非公平实现要执行的方法，共享式获取许可证。返回剩余许可证数量</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式释放同步状态方法，即归还许可证。该方法总是返回 true</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="comment">// 归还 releases 个许可证 (注意，如果不获取先释放的话，许可证会变多的)</span></span><br><span class="line">                <span class="keyword">int</span> next = current + releases;</span><br><span class="line">                <span class="comment">// 这里判断归还数量不能小于 0</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                <span class="comment">// CAS 更新 state （AQS 中的方法 ）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式获取同步状态的方法，这里是非公平方式获取许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NonfairSync 内部类只做了一件事情，重写 AQS 的 tryAcquireShared 方法，需要注意它的非公平性，也就是不关心阻塞队列中有没有还在等待的线程，直接尝试获取许可证。</p><h4 id="FairSync-内部类"><a href="#FairSync-内部类" class="headerlink" title="FairSync 内部类"></a>FairSync 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 AQS 的内部类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信号量的同步实现。使用 AQS 的同步状态 state 表示许可证。分为 公平和非公平两种实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法，设置 AQS 的同步状态 state。对于 Semaphore 来说表示许可证</span></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取同步状态，即许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非公平实现，共享式获取许可证。返回剩余许可证数量</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式释放同步状态方法，即归还许可证。该方法总是返回 true</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="comment">// 归还 releases 个许可证 (注意，如果不获取先释放的话，许可证会变多的)</span></span><br><span class="line">                <span class="keyword">int</span> next = current + releases;</span><br><span class="line">                <span class="comment">// 这里判断归还数量不能小于 0</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                <span class="comment">// CAS 更新 state （AQS 中的方法 ）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式获取同步状态的方法，这里是非公平方式获取许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式获取同步状态的方法， 这里是 公平方式获取许可证。返回剩余许可证数</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="comment">// 是否有线程在排队等待许可证</span></span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FairSync 内部类同样只做了一件事情，重写 AQS 的 tryAcquireShared 方法，以公平的方式实现，也就是线程在获取许可证之前，先判断阻塞队列中是否还有等待的线程，有的话就直接返回 -1 进入阻塞队列中等待。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 以非公平方式创建 Semaphore</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">     sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 可选择公平/非公平方式创建 Semaphore</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">     sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>和 ReentrantLock 有点类似，实现了公平和非公平方式，默认使用非公平实现。</p><h4 id="acquire-系列方法"><a href="#acquire-系列方法" class="headerlink" title="acquire 系列方法"></a>acquire 系列方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">--- Semaphore</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可响应中断地获取许可证（获取一个许可证）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 的方法</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">       <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- Semaphore</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取许可证（获取一个许可证），对中断不敏感</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 的方法</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 内部会调用 doReleaseShared 方法</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- Semaphore</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 Semaphore 获取给定数量的许可证，不够就阻塞等待，对中断敏感</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        sync.acquireSharedInterruptibly(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 Semaphore 获取给定数量的许可证，不够就阻塞等待，对中断不敏感</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        sync.acquireShared(permits);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过 acquire 方法也可以看出，AQS 框架在实现共享式获取同步状态时，当且仅当同步状态处理结果小于 0 时，线程才会走入队流程。因为都是共享式实现，AQS 底层处理是一样的，因此后续的入队、找有效前驱节点以及挂起操作和 CountDownLatch 是一样的，就不再分析了。继续看它的释放同步状态的方法。</p><h4 id="release-系列方法"><a href="#release-系列方法" class="headerlink" title="release 系列方法"></a>release 系列方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">--- Semaphore</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归还许可证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 方法</span></span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归还给定数量的许可证到 Semaphore</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">         <span class="comment">// AQS 方法</span></span><br><span class="line">        sync.releaseShared(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Semaphore 实现的释放同步状态方法</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过 release 系列方法也可以看出，AQS 框架在实现共享式释放同步状态时，当且仅当同步状态处理结果为 true 时，才会唤醒阻塞队列的线程。因为都是共享式实现，AQS 底层处理是一样的，因此唤醒的流程和 CountDownLatch 是一样的。</p><h4 id="例子流程"><a href="#例子流程" class="headerlink" title="例子流程"></a>例子流程</h4><ul><li><p>Semaphore 初始化 3 个 许可证<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-3.jpg" alt><br>同一个JVM进程中，某一时刻对 resource 访问的最大并发请求数为3</p></li><li><p>某一时刻t1、t2、t3获取到许可证，t4进入阻塞队列等待<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-4.jpg" alt><br>线程t1、t2、t3拿到许可证去访问资源，此时 Semaphore 中已经没有可用的许可证了，t4只能加入阻塞队列等待许可证的释放。这里 t4 要入队。</p></li><li><p>t3 访问资源后归还许可证，t4 获取到获取到许可证<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-5.jpg" alt><br>这个过程可能会有多种情况，如，t4 在没有挂起之前，t3 已经归还了许可证，此时 t4 直接就可以拿到。如果 t4 不太幸运的话，会挂起然后等待t3来唤醒。Semaphore 的一些特殊情况可以参考 CountDownLatch。</p></li><li><p>其它线程获取许可证依次类推</p></li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Semaphore 使用的注意事项：</p><ol><li>获取和释放的许可证数量必须一致，否则随着许可证的获取和归还流程推进，最后会导致许可证数量不够，将出现程序卡死。</li><li>在初始化 Semaphore 的时候可以设置释放公平，这个可以根据情景选择，一般设置为 true 更合理，因为 Semaphore 本身就是限制同时请求量的，不针对某个请求的。</li><li>获取和释放许可证不一定非要同一个线程来完成，可以是 线程 A 获取，线程 B 释放，逻辑合理即可。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是 ReentrantLock，还是 CountDownLatch、CyclicBarrier、Semaphore 等 ，它们都是对 AQS 应用，至于是实现锁的功能，还是实现同步组件根据具体场景进行设计。本质上都离不开同步状态 <code>state</code>、独占方式 <code>tryAcquire-tryRelease</code> 获取与释放方法，共享方式 <code>tryAcquireShared-tryReleaseShared</code> 获取与释放方法，此外 AQS 也支持自定义同步组件同时实现独占和共享两种方式，以及公平和非公平实现，不同组件表示的意义是不同的。AQS 还提供了 <code>等待队列</code> 机制，ReentrantLock 就基于该机制实现了等待与唤醒机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 JDK 的并发包中提供了几个非常有用的并发工具类。 &lt;code&gt;CountDownLatch&lt;/code&gt;、&lt;code&gt;CyclicBa
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 本地暴露</title>
    <link href="https://gentryhuang.com/posts/751c0982/"/>
    <id>https://gentryhuang.com/posts/751c0982/</id>
    <published>2020-08-04T16:00:00.000Z</published>
    <updated>2020-11-05T15:21:22.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有了前面一系列文章铺垫，再来看服务暴露与服务引用就简单很多了。本地暴露需要配置、SPI、动态代理、协议等知识，其中协议部分会在后面的文章中着重分析。</p><h2 id="配置承载"><a href="#配置承载" class="headerlink" title="配置承载"></a>配置承载</h2><p>无论是服务暴露还是服务引用，Dubbo 框架都会根据配置覆盖策略对配置项进行聚合处理，配置覆盖策略参见<a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/xml.html" target="_blank" rel="noopener">官网</a> 。Dubbo 支持动态添加配置项即服务治理，其中不允许 Provider 端配置项透传到客户端的都会进行特殊处理. </p><h2 id="服务暴露配置"><a href="#服务暴露配置" class="headerlink" title="服务暴露配置"></a>服务暴露配置</h2><ul><li>仅本地暴露<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"local"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li>仅远程暴露<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"remote"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li>本暴露和远程暴露<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在不配置 scope 的情况下，默认两种方式都暴露</span><br></pre></td></tr></table></figure></li><li>不暴露<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"none"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="服务暴露机制"><a href="#服务暴露机制" class="headerlink" title="服务暴露机制"></a>服务暴露机制</h2><p>Dubbo 服务暴露分为两部分，先将持有的服务信息（服务对象，服务接口，服务 URL信息）通过动态代理工厂转换成 Invoker ，再把 Invoker 通过具体的协议转成 Exporter（注意，这里涉及到多协议的知识后面文章会详细分析） 。Dubbo 框架在进行服务暴露时，无论是 API 配置、XML 配置还是注解配置，最终都会转成 ServiceBean，它继承自 ServiceConfig ，注意这里是指使用 Spring 环境时，如果仅使用 Dubbo API 配置的话，会转成 ServiceConfig 。因为 Spring 是主流，下面没有特别说明都是在 Spring 环境下。</p><h2 id="服务暴露方式"><a href="#服务暴露方式" class="headerlink" title="服务暴露方式"></a>服务暴露方式</h2><p>Dubbo 支持两种服务暴露方式，分为延迟暴露和立即暴露。延迟暴露的入口是 ServiceBean 的 afterPropertiesSet 方法，立即暴露的入口是 ServiceBean 的 onApplicationEvent 方法。</p><h3 id="Spring支持的-Dubbo-IOC"><a href="#Spring支持的-Dubbo-IOC" class="headerlink" title="Spring支持的 Dubbo IOC"></a>Spring支持的 Dubbo IOC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="comment">// 为Spring拓展工厂注入上下文 ,用于Dubbo IOC</span></span><br><span class="line">        SpringExtensionFactory.addApplicationContext(applicationContext);</span><br><span class="line">        <span class="keyword">if</span> (applicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SPRING_CONTEXT = applicationContext;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method method = applicationContext.getClass().getMethod(<span class="string">"addApplicationListener"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;ApplicationListener<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">// backward compatibility to spring 2.0.1</span></span><br><span class="line">                method.invoke(applicationContext, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">                <span class="comment">// 当前Spring容器是否支持上下文监听</span></span><br><span class="line">                supportedApplicationListener = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (applicationContext <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Method method = AbstractApplicationContext.class.getDeclaredMethod("addListener", new Class&lt;?&gt;[]&#123;ApplicationListener.class&#125;); // backward compatibility to spring 2.0.1</span><br><span class="line">                        <span class="keyword">if</span> (!method.isAccessible()) &#123;</span><br><span class="line">                            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(applicationContext, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">                        supportedApplicationListener = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean#setApplicationContext 方法用于将 Spring 的上下文设置设置到 SpringExtensionFactory 中，这样 Dubbo IOC 就可以使用 Spring 管理的对象了。</p><h3 id="延迟暴露"><a href="#延迟暴露" class="headerlink" title="延迟暴露"></a>延迟暴露</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务暴露的入口，非延迟暴露 。收到 Spring 容器的刷新事件执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否有延迟暴露 &amp;&amp; 是否已暴露 &amp;&amp; 是不是已被取消暴露</span></span><br><span class="line">        <span class="keyword">if</span> (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"The service ready on spring started. service: "</span> + getInterface());</span><br><span class="line">            &#125;</span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 delay</span></span><br><span class="line">        Integer delay = getDelay();</span><br><span class="line">        ProviderConfig provider = getProvider();</span><br><span class="line">        <span class="keyword">if</span> (delay == <span class="keyword">null</span> &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果前面获取的 delay 为空，这里继续获取</span></span><br><span class="line">            delay = provider.getDelay();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 判断 delay 是否为空，或者等于 -1，当 delay 为空，或者等于-1时，该方法返回 true，而不是 false</span></span><br><span class="line"><span class="comment">         * 2 supportedApplicationListener 变量用于表示当前的 Spring 容器是否支持 ApplicationListener，这个值初始为 false。</span></span><br><span class="line"><span class="comment">         * 在 Spring 容器将自己设置到 ServiceBean 中时，ServiceBean 的 setApplicationContext 方法会检测 Spring 容器是否支持 ApplicationListener,若支持，则将 supportedApplicationListener 置为 true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> supportedApplicationListener &amp;&amp; (delay == <span class="keyword">null</span> || delay == -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置项</span></span><br><span class="line">        <span class="keyword">return</span> delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的 isDelay 方法，当方法返回 true 时，表示无需延迟导出。返回 false 时，表示需要延迟导出，与字面意思是相反的。</p><h3 id="立即暴露"><a href="#立即暴露" class="headerlink" title="立即暴露"></a>立即暴露</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务暴露的入口，延迟暴露</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"deprecation"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getProvider() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Map&lt;String, ProviderConfig&gt; providerConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (providerConfigMap != <span class="keyword">null</span> &amp;&amp; providerConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> ((protocolConfigMap == <span class="keyword">null</span> || protocolConfigMap.size() == <span class="number">0</span>)</span><br><span class="line">                        &amp;&amp; providerConfigMap.size() &gt; <span class="number">1</span>) &#123; <span class="comment">// backward compatibility</span></span><br><span class="line">                    List&lt;ProviderConfig&gt; providerConfigs = <span class="keyword">new</span> ArrayList&lt;ProviderConfig&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() != <span class="keyword">null</span> &amp;&amp; config.isDefault().booleanValue()) &#123;</span><br><span class="line">                            providerConfigs.add(config);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!providerConfigs.isEmpty()) &#123;</span><br><span class="line">                        setProviders(providerConfigs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ProviderConfig providerConfig = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate provider configs: "</span> + providerConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                            &#125;</span><br><span class="line">                            providerConfig = config;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        setProvider(providerConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getApplication() == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getApplication() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (applicationConfigMap != <span class="keyword">null</span> &amp;&amp; applicationConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ApplicationConfig applicationConfig = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (ApplicationConfig config : applicationConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate application configs: "</span> + applicationConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        applicationConfig = config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    setApplication(applicationConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getModule() == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getModule() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (moduleConfigMap != <span class="keyword">null</span> &amp;&amp; moduleConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ModuleConfig moduleConfig = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (ModuleConfig config : moduleConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate module configs: "</span> + moduleConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        moduleConfig = config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    setModule(moduleConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((getRegistries() == <span class="keyword">null</span> || getRegistries().isEmpty())</span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getRegistries() == <span class="keyword">null</span> || getProvider().getRegistries().isEmpty())</span><br><span class="line">                &amp;&amp; (getApplication() == <span class="keyword">null</span> || getApplication().getRegistries() == <span class="keyword">null</span> || getApplication().getRegistries().isEmpty())) &#123;</span><br><span class="line">            Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (registryConfigMap != <span class="keyword">null</span> &amp;&amp; registryConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                List&lt;RegistryConfig&gt; registryConfigs = <span class="keyword">new</span> ArrayList&lt;RegistryConfig&gt;();</span><br><span class="line">                <span class="keyword">for</span> (RegistryConfig config : registryConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        registryConfigs.add(config);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (registryConfigs != <span class="keyword">null</span> &amp;&amp; !registryConfigs.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">super</span>.setRegistries(registryConfigs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getMonitor() == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getMonitor() == <span class="keyword">null</span>)</span><br><span class="line">                &amp;&amp; (getApplication() == <span class="keyword">null</span> || getApplication().getMonitor() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Map&lt;String, MonitorConfig&gt; monitorConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (monitorConfigMap != <span class="keyword">null</span> &amp;&amp; monitorConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                MonitorConfig monitorConfig = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (MonitorConfig config : monitorConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (monitorConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate monitor configs: "</span> + monitorConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        monitorConfig = config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (monitorConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    setMonitor(monitorConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((getProtocols() == <span class="keyword">null</span> || getProtocols().isEmpty())</span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getProtocols() == <span class="keyword">null</span> || getProvider().getProtocols().isEmpty())) &#123;</span><br><span class="line">            Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (protocolConfigMap != <span class="keyword">null</span> &amp;&amp; protocolConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                List&lt;ProtocolConfig&gt; protocolConfigs = <span class="keyword">new</span> ArrayList&lt;ProtocolConfig&gt;();</span><br><span class="line">                <span class="keyword">for</span> (ProtocolConfig config : protocolConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        protocolConfigs.add(config);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (protocolConfigs != <span class="keyword">null</span> &amp;&amp; !protocolConfigs.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">super</span>.setProtocols(protocolConfigs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getPath() == <span class="keyword">null</span> || getPath().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; beanName.length() &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; getInterface() != <span class="keyword">null</span> &amp;&amp; getInterface().length() &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; beanName.startsWith(getInterface())) &#123;</span><br><span class="line">                setPath(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟暴露</span></span><br><span class="line">        <span class="keyword">if</span> (!isDelay()) &#123;</span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean#afterPropertiesSet 的方法不仅支持延迟暴露，还会在 Spring 生命周期内把 Dubbo 的核心配置承载对象设置到 ServiceBean 中（或其父类中）。ServiceBean 配置继承关系如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>AbstractConfig</span><br><span class="line"><span class="bullet">  - </span>AbstractMethodConfig</span><br><span class="line"><span class="bullet">    - </span>AbstractInterfaceConfig</span><br><span class="line"><span class="bullet">      - </span>AbstractServiceConfig</span><br><span class="line"><span class="bullet">        - </span>ServiceConfig</span><br><span class="line"><span class="bullet">          - </span>ServiceBean</span><br></pre></td></tr></table></figure><p>关于配置在之前的文章中应详细介绍，可以参考 <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 。</p><h2 id="服务暴露过程"><a href="#服务暴露过程" class="headerlink" title="服务暴露过程"></a>服务暴露过程</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-local.jpg" alt></p><p>上图是服务本地暴露的主要流程，配置检查和初始化完成后，生成 URL，然后将服务导出到 JVM 中。配置加载及配置承载对象的初始对应的三种方式在前面的文章中已经详细分析过，可以参考 <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 、<a href="https://gentryhuang.com/posts/a8d76a91/">XML配置</a> 、<a href="https://gentryhuang.com/posts/1a889dcd/">注解配置</a> 。下面分析具体源码。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>以延迟暴露的方式进行分析，默认情况下就是延迟暴露的方式。ServiceBean 是 Dubbo 框架与 Spring 框架进行整合的关键，可以看做是两个框架之间的桥梁。ReferenceBean 具有同样的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类 ServiceConfig 的 export 方法进行服务暴露</span></span><br><span class="line">        <span class="keyword">super</span>.export();</span><br><span class="line">        <span class="comment">// 发布服务暴露完成的事件</span></span><br><span class="line">        publishExportEvent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publishExportEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceBeanExportedEvent exportEvent = <span class="keyword">new</span> ServiceBeanExportedEvent(<span class="keyword">this</span>);</span><br><span class="line">        applicationEventPublisher.publishEvent(exportEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean 中的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">213195494150089726L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">transient</span> ApplicationContext SPRING_CONTEXT;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo 服务注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> Service service;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String beanName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否支持 Spring 上下文监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">boolean</span> supportedApplicationListener;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 事件发布对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.service = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceBean</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(service);</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getSpringContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SPRING_CONTEXT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入事件发布对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationEventPublisher</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.6.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在服务暴露之前，Dubbo 需要检查配置，或者补充缺省配置。配置检查完毕后，会根据配置组装 URL 。在 Dubbo 中，URL 十分重要，详细参见 <a href="https://gentryhuang.com/posts/46f95e97/">URL统一模型</a> 。</p><h4 id="检查配置"><a href="#检查配置" class="headerlink" title="检查配置"></a>检查配置</h4><p>我们继续从入口看起，ServiceBean 的父类 ServiceConfig 类，下面我们先看下这个类中的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3033787999037024738L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应 Protocol 实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应 ProxyFactory 实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; RANDOM_PORT_MAP = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时暴露线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService delayExportExecutor = Executors.newSingleThreadScheduledExecutor(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboServiceDelayExporter"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务URL集合</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务配置暴露的Exporter:</span></span><br><span class="line"><span class="comment">     * URL: Exporter 不一定是 1:1 的关系，需要看scope的值：</span></span><br><span class="line"><span class="comment">     * 1 scope 未设置时，会暴露Local + Remote两个，也就是URL : Exporter = 1:2</span></span><br><span class="line"><span class="comment">     * 2 scope设置为空时，不会暴露，也就是URL:Exporter = 1:0</span></span><br><span class="line"><span class="comment">     * 3 scope甚至为local 或 Remote 任一个时，会暴露对应的，也就是URL:Exporter = 1:1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Exporter&lt;?&gt;&gt; exporters = <span class="keyword">new</span> ArrayList&lt;Exporter&lt;?&gt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非配置，通过interfaceName 通过反射获得</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; interfaceClass;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口的实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T ref;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法配置对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;MethodConfig&gt; methods;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供者配置对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ProviderConfig provider;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exported;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否未暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> unexported;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String generic;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceConfig</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        appendAnnotation(Service<span class="class">.<span class="keyword">class</span>, <span class="title">service</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们从 ServiceConfig#export 方法继续进行分析，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 暴露服务入口，加jvm锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 当export 或者 delay 未配置时，从ProviderConfig对象读取</span></span><br><span class="line">       <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (export == <span class="keyword">null</span>) &#123;</span><br><span class="line">               export = provider.getExport();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (delay == <span class="keyword">null</span>) &#123;</span><br><span class="line">               delay = provider.getDelay();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 不暴露服务(export = false),则不进行暴露服务逻辑</span></span><br><span class="line">       <span class="keyword">if</span> (export != <span class="keyword">null</span> &amp;&amp; !export) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 延迟暴露的话，就是使用任务线程池ScheduledExecutorService处理</span></span><br><span class="line">       <span class="keyword">if</span> (delay != <span class="keyword">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           delayExportExecutor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   doExport();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           doExport();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果我们只是想本地启动服务进行一些调试工作，这个时候我们并不希望把本地启动的服务暴露出去，此时，我们就可以通过配置 export 禁止服务暴露，如：</p><blockquote><p>&lt;dubbo:provider export=”false” /&gt;</p></blockquote><p>我们继续跟进 doExport 方法，该方法主要进行配置的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 服务暴露，jvm锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 检查是否可以暴露，若可以，标记已经暴露然后执行服务暴露逻辑</span></span><br><span class="line">       <span class="keyword">if</span> (unexported) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already unexported!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果已经暴露了直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (exported) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 标记已经暴露过了</span></span><br><span class="line">       exported = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">// 校验interfaceName 是否合法，即接口名非空</span></span><br><span class="line">       <span class="keyword">if</span> (interfaceName == <span class="keyword">null</span> || interfaceName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"&lt;dubbo:service interface=\"\" /&gt; interface not allow null!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 校验provider是否为空(为空则新建一个)并拼接属性配置（环境变量 + .properties文件中的 属性）到ProviderConfig对象</span></span><br><span class="line">       checkDefault();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检测application，module等核心配置类对象是否为空，若为空则尝试从其他配置类对象中获取对应的实例。即： 从ProviderConfig 对象中，读取application,module,registries,monitor,protocols配置对象</span></span><br><span class="line">       <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (application == <span class="keyword">null</span>) &#123;</span><br><span class="line">               application = provider.getApplication();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">module</span> = provider.getModule();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">               registries = provider.getRegistries();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               monitor = provider.getMonitor();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (protocols == <span class="keyword">null</span>) &#123;</span><br><span class="line">               protocols = provider.getProtocols();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 从ModuleConfig 对象中，读取registries,monitor配置对象</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">               registries = <span class="keyword">module</span>.getRegistries();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               monitor = <span class="keyword">module</span>.getMonitor();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 从ApplicationConfig 对象中，读取registries,monitor配置对象</span></span><br><span class="line">       <span class="keyword">if</span> (application != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">               registries = application.getRegistries();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               monitor = application.getMonitor();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检测ref是否泛化接口的实现</span></span><br><span class="line">       <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> GenericService) &#123;</span><br><span class="line">           <span class="comment">// 设置 interfaceClass 为 GenericService.class</span></span><br><span class="line">           interfaceClass = GenericService<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isEmpty(generic)) &#123;</span><br><span class="line">               <span class="comment">// 设置 generic = "true"</span></span><br><span class="line">               generic = Boolean.TRUE.toString();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 普通接口的实现</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 通过反射获取对应的接口的Class</span></span><br><span class="line">               interfaceClass = Class.forName(interfaceName, <span class="keyword">true</span>, Thread.currentThread()</span><br><span class="line">                       .getContextClassLoader());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 检验接口和方法 （接口非空，方法都在接口中定义）</span></span><br><span class="line">           checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 校验引用ref是否实现了当前接口</span></span><br><span class="line">           checkRef();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 标记为非泛化实现</span></span><br><span class="line">           generic = Boolean.FALSE.toString();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** 处理服务接口客户端本地代理,即本地存根。目前已经废弃，此处主要用于兼容，使用stub属性. todo 服务端没有意义 &#123;<span class="doctag">@link</span> StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125; */</span></span><br><span class="line">       <span class="keyword">if</span> (local != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果local属性设置为ture，表示使用缺省代理类名，即：接口名 + Local 后缀</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="string">"true"</span>.equals(local)) &#123;</span><br><span class="line">               local = interfaceName + <span class="string">"Local"</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           Class&lt;?&gt; localClass;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 获取本地存根类</span></span><br><span class="line">               localClass = ClassHelper.forNameWithThreadContextClassLoader(local);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法</span></span><br><span class="line">           <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(localClass)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The local implementation class "</span> + localClass.getName() + <span class="string">" not implement interface "</span> + interfaceName);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** 处理服务接口客户端本地代理(stub 属性)相关，即本地存根。目的：想在客户端【服务消费方】执行需要的逻辑，不局限服务提供的逻辑。本地存根类编写方式是固定。todo 服务端没有意义 &#123;<span class="doctag">@link</span> StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125;*/</span></span><br><span class="line">       <span class="keyword">if</span> (stub != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果stub属性设置为ture，表示使用缺省代理类名，即：接口名 + Stub 后缀</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="string">"true"</span>.equals(stub)) &#123;</span><br><span class="line">               stub = interfaceName + <span class="string">"Stub"</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           Class&lt;?&gt; stubClass;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 获取本地存根类</span></span><br><span class="line">               stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 判断interfaceClass 是否是 stubClass 的接口，即 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法</span></span><br><span class="line">           <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(stubClass)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The stub implementation class "</span> + stubClass.getName() + <span class="string">" not implement interface "</span> + interfaceName);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 校验ApplicationConfig配置</span></span><br><span class="line">       checkApplication();</span><br><span class="line">       <span class="comment">// 校验RegistryConfig配置</span></span><br><span class="line">       checkRegistry();</span><br><span class="line">       <span class="comment">// 校验ProtocolConfig配置数组</span></span><br><span class="line">       checkProtocol();</span><br><span class="line">       <span class="comment">// 读取环境变量和properties配置到ServiceConfig对象（自己）</span></span><br><span class="line">       appendProperties(<span class="keyword">this</span>);</span><br><span class="line">       <span class="comment">// 校验Stub和Mock相关的配置</span></span><br><span class="line">       checkStubAndMock(interfaceClass);</span><br><span class="line">       <span class="comment">// 服务路径，缺省是接口名</span></span><br><span class="line">       <span class="keyword">if</span> (path == <span class="keyword">null</span> || path.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           path = interfaceName;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 暴露服务</span></span><br><span class="line">       doExportUrls();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 1 ProviderModel 表示服务提供者模型，此对象中存储了和服务提供者相关的信息，比如服务的配置信息，服务实例等。每个被导出的服务对应一个 ProviderModel</span></span><br><span class="line"><span class="comment">        * 2 ApplicationModel 持有所有的 ProviderModel</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       ProviderModel providerModel = <span class="keyword">new</span> ProviderModel(getUniqueServiceName(), <span class="keyword">this</span>, ref);</span><br><span class="line">       ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以上就是配置检查的相关分析，下面对配置检查的主要逻辑进行简单的总结，如下：</p><ol><li>检测 <a href="dubbo:service">dubbo:service</a> 标签的 interface 属性合法性，不合法则抛出异常</li><li>检测 ProviderConfig、ApplicationConfig 等核心配置类对象是否为空，若为空，则尝试创建或从其他配置类对象中获取相应的实例。</li><li>检测并处理泛化服务和普通服务类</li><li>检测本地存根配置，并进行相应的处理</li><li>对 ApplicationConfig、RegistryConfig 等配置类进行检测，并读取环境变量和properties配置到配置承载对象中</li></ol><p>设置配置到配置承载对象在之前的文章中详细说明了，可以参见 <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 。</p><h4 id="多协议多注册中心暴露"><a href="#多协议多注册中心暴露" class="headerlink" title="多协议多注册中心暴露"></a>多协议多注册中心暴露</h4><p>Dubbo 允许使用不同的协议暴露服务，也支持向多个注册中心注册服务，Dubbo 在 ServiceConifg#doExportUrls 中对多协议，多注册中心进行了支持，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 加载注册中心URL 数组 【协议已经处理过，不再是配置的注册中心协议 如：zookeeper ,而是统一替换成了registry】</span></span><br><span class="line">       List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">// 遍历协议集合，支持多协议暴露。</span></span><br><span class="line">       <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">           doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面代码比较简单，首先是通过 loadRegistries 加载注册中心URL，然后再遍历 ProtocolConfig 集合使用具体的协议导出每个服务。并在导出服务的过程中，将服务注册到注册中心。下面，我们先来看一下 loadRegistries 方法的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 加载注册中心URL数组</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> provider 是否是服务提供者</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> URL数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> List&lt;URL&gt; <span class="title">loadRegistries</span><span class="params">(<span class="keyword">boolean</span> provider)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 校验RegistryConfig 配置数组，不存在会抛出异常，并且该方法会初始化RegistryConfig的配置属性【见API与属性配置】</span></span><br><span class="line">       checkRegistry();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建注册中心URL数组</span></span><br><span class="line">       List&lt;URL&gt; registryList = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">       <span class="keyword">if</span> (registries != <span class="keyword">null</span> &amp;&amp; !registries.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 遍历RegistryConfig 数组</span></span><br><span class="line">           <span class="keyword">for</span> (RegistryConfig config : registries) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 获取注册中心的地址</span></span><br><span class="line">               String address = config.getAddress();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 地址为空就使用 0.0.0.0 任意地址</span></span><br><span class="line">               <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                   address = Constants.ANYHOST_VALUE;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 如果配置了启动参数的注册中心地址，它的优先级最高，就进行覆盖</span></span><br><span class="line">               String sysaddress = System.getProperty(<span class="string">"dubbo.registry.address"</span>);</span><br><span class="line">               <span class="keyword">if</span> (sysaddress != <span class="keyword">null</span> &amp;&amp; sysaddress.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   address = sysaddress;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 选择有效的注册中心地址</span></span><br><span class="line">               <span class="keyword">if</span> (address.length() &gt; <span class="number">0</span> &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 创建参数集合map,用于 URL的构建</span></span><br><span class="line">                   Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 将应用配置对象和注册中心配置对象的属性添加到参数集合map中</span></span><br><span class="line">                   appendParameters(map, application);</span><br><span class="line">                   <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 需要注意的是：RegistryConfig 的 getAddress方法上使用了 <span class="doctag">@Parameter</span>(excluded = true)注解，因此它的address属性不会加入到参数集合map中</span></span><br><span class="line"><span class="comment">                    *  <span class="doctag">@Parameter</span>(excluded = true)</span></span><br><span class="line"><span class="comment">                    *  public String getAddress() &#123;return address;&#125;</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   appendParameters(map, config);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 添加 path,dubbo,timestamp,pid 到参数集合map中</span></span><br><span class="line">                   map.put(<span class="string">"path"</span>, RegistryService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>; <span class="comment">// 这里的path要和服务暴露逻辑中的path区分，注册中心的URL中的path为RegistryService的全路径名</span></span><br><span class="line">                   map.put(<span class="string">"dubbo"</span>, Version.getProtocolVersion());</span><br><span class="line">                   map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                   <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 参数集合map中不存在 protocol 参数【以上配置对象的属性中没有有效的协议protocol参数】，就默认 使用 dubbo 作为 协议protocol的值</span></span><br><span class="line">                   <span class="keyword">if</span> (!map.containsKey(<span class="string">"protocol"</span>)) &#123;</span><br><span class="line">                       <span class="comment">// todo remote扩展实现已经不存在了，不需考虑这种情况</span></span><br><span class="line">                       if (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension("remote")) &#123;</span><br><span class="line">                           map.put(<span class="string">"protocol"</span>, <span class="string">"remote"</span>);</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           map.put(<span class="string">"protocol"</span>, <span class="string">"dubbo"</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 解析地址，创建 URL数组，注意address可能包含多个注册中心ip, 【数组大小可能为一】</span></span><br><span class="line">                   List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 循环 dubbo Register url</span></span><br><span class="line">                   <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                       <span class="comment">// 设置 registry=$&#123;protocol&#125;参数,设置到注册中心的 URL的参数部分的位置上，并且是追加式的添加</span></span><br><span class="line">                       url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());</span><br><span class="line">                       <span class="comment">// 重置 URL中的 protocol属性为 'registry',即将URL的协议头设置为'registry'</span></span><br><span class="line">                       url = url.setProtocol(Constants.REGISTRY_PROTOCOL);</span><br><span class="line">                       <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        * 通过判断条件，决定是否添加url到registryList中，条件如下：</span></span><br><span class="line"><span class="comment">                        * 1 如果是服务提供者,是否只订阅不注册，如果是就不添加到注册中心URL数组中</span></span><br><span class="line"><span class="comment">                        * 2 如果是服务消费者，是否是只注册不订阅，如果是就不添加到注册中心URL数组中</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                       <span class="keyword">if</span> ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class="keyword">true</span>)) || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, <span class="keyword">true</span>))) &#123;</span><br><span class="line">                           registryList.add(url);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> registryList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析注册中心地址，创建 URL数组</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> address</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> defaults</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;URL&gt; <span class="title">parseURLs</span><span class="params">(String address, Map&lt;String, String&gt; defaults)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 判断注册中心地址的有效性</span></span><br><span class="line">       <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 注册中心地址address 可以使用"|"或";"作为分割符，设置多个注册中心分组。注意：一个注册中心集群是一个分组而不是多个。</span></span><br><span class="line">       String[] addresses = Constants.REGISTRY_SPLIT_PATTERN.split(address);</span><br><span class="line">       <span class="keyword">if</span> (addresses == <span class="keyword">null</span> || addresses.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//here won't be empty</span></span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;URL&gt; registries = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">       <span class="comment">// 遍历注册中心分组</span></span><br><span class="line">       <span class="keyword">for</span> (String addr : addresses) &#123;</span><br><span class="line">           registries.add(parseURL(addr, defaults));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> registries;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析单个 URL，将defaults属性集合 里的参数合并到 注册中心地址address中，合并逻辑：</span></span><br><span class="line"><span class="comment">    * 使用 defaults 集合对注册中心urL的属性 进行 '查漏补缺', 即 将defaults集合中不在 注册中心url上的属性 设置到url上，存在则忽略</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> address  注册中心地址</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> defaults 参数集合</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> Dubbo URL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> URL <span class="title">parseURL</span><span class="params">(String address, Map&lt;String, String&gt; defaults)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String url;</span><br><span class="line">       <span class="keyword">if</span> (address.indexOf(<span class="string">"://"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           url = address;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           String[] addresses = Constants.COMMA_SPLIT_PATTERN.split(address);</span><br><span class="line">           url = addresses[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">if</span> (addresses.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">               StringBuilder backup = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; addresses.length; i++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                       backup.append(<span class="string">","</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   backup.append(addresses[i]);</span><br><span class="line">               &#125;</span><br><span class="line">               url += <span class="string">"?"</span> + Constants.BACKUP_KEY + <span class="string">"="</span> + backup.toString();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       String defaultProtocol = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"protocol"</span>);</span><br><span class="line">       <span class="keyword">if</span> (defaultProtocol == <span class="keyword">null</span> || defaultProtocol.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           defaultProtocol = <span class="string">"dubbo"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String defaultUsername = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"username"</span>);</span><br><span class="line">       String defaultPassword = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"password"</span>);</span><br><span class="line">       <span class="keyword">int</span> defaultPort = StringUtils.parseInteger(defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"port"</span>));</span><br><span class="line">       String defaultPath = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"path"</span>);</span><br><span class="line">       Map&lt;String, String&gt; defaultParameters = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> HashMap&lt;String, String&gt;(defaults);</span><br><span class="line">       <span class="keyword">if</span> (defaultParameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">           defaultParameters.remove(<span class="string">"protocol"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"username"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"password"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"host"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"port"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"path"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 分离url中的各个参数，然后根据各个参数构建标准的Dubbo URL -&gt; protocol://username:password@host:port/path?key=value&amp;key=value...</span></span><br><span class="line">       URL u = URL.valueOf(url);</span><br><span class="line">       <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">       String protocol = u.getProtocol();</span><br><span class="line">       String username = u.getUsername();</span><br><span class="line">       String password = u.getPassword();</span><br><span class="line">       String host = u.getHost();</span><br><span class="line">       <span class="keyword">int</span> port = u.getPort();</span><br><span class="line">       String path = u.getPath();</span><br><span class="line">       Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(u.getParameters());</span><br><span class="line">       <span class="keyword">if</span> ((protocol == <span class="keyword">null</span> || protocol.length() == <span class="number">0</span>) &amp;&amp; defaultProtocol != <span class="keyword">null</span> &amp;&amp; defaultProtocol.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           changed = <span class="keyword">true</span>;</span><br><span class="line">           protocol = defaultProtocol;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((username == <span class="keyword">null</span> || username.length() == <span class="number">0</span>) &amp;&amp; defaultUsername != <span class="keyword">null</span> &amp;&amp; defaultUsername.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           changed = <span class="keyword">true</span>;</span><br><span class="line">           username = defaultUsername;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((password == <span class="keyword">null</span> || password.length() == <span class="number">0</span>) &amp;&amp; defaultPassword != <span class="keyword">null</span> &amp;&amp; defaultPassword.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           changed = <span class="keyword">true</span>;</span><br><span class="line">           password = defaultPassword;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (port &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (defaultPort &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               changed = <span class="keyword">true</span>;</span><br><span class="line">               port = defaultPort;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               changed = <span class="keyword">true</span>;</span><br><span class="line">               port = <span class="number">9090</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (path == <span class="keyword">null</span> || path.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (defaultPath != <span class="keyword">null</span> &amp;&amp; defaultPath.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               changed = <span class="keyword">true</span>;</span><br><span class="line">               path = defaultPath;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (defaultParameters != <span class="keyword">null</span> &amp;&amp; defaultParameters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : defaultParameters.entrySet()) &#123;</span><br><span class="line">               String key = entry.getKey();</span><br><span class="line">               String defaultValue = entry.getValue();</span><br><span class="line">               <span class="keyword">if</span> (defaultValue != <span class="keyword">null</span> &amp;&amp; defaultValue.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   String value = parameters.get(key);</span><br><span class="line">                   <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                       changed = <span class="keyword">true</span>;</span><br><span class="line">                       parameters.put(key, defaultValue);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 根据标准构建的Ddubbo URL中的参数的值是否有效，会重新构建Dubbo URL，区别在于之前无效的参数都是用默认值替换</span></span><br><span class="line">       <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">           u = <span class="keyword">new</span> URL(protocol, username, password, host, port, path, parameters);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> u;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，本文主要分析 Dubbo 的本地暴露，本地暴露不会向注册中心注册服务，因为仅用于 JVM 内部调用，相关信息放在内存中。在下一篇远程暴露时会用到，这里为了完整就提前分析了。</p><p>加载注册中心URL代码还是挺复杂的，主要逻辑如下：</p><ol><li>检测是否存在注册中心配置类，不存在则抛出异常。存在则初始化RegistryConfig的配置属性。</li><li>组装参数集合，应用于注册中心URL的属性 ‘查漏补缺’。</li><li>构建注册中心URL列表</li></ol><p>有关注册中心URL构建还有一个数据流向操作，上面代码中也注释了，比较简单，因为会在远程暴露时用到，这里简单介绍下，以 Redis 注册中心为例进行说明，更常用 Zookeeper 作为注册中心。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-registry.jpg" alt></p><h4 id="组装-URL"><a href="#组装-URL" class="headerlink" title="组装 URL"></a>组装 URL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用不同的协议，逐个向注册中心分组暴露服务。该方法中包含了本地和远程两种暴露方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> protocolConfig 协议配置对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registryURLs   处理过的注册中心分组集合【已经添加了ApplicationConfig和RegistryConfig的参数】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 协议名</span></span><br><span class="line">        String name = protocolConfig.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 协议名为空时，缺省设置为 dubbo</span></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            name = <span class="string">"dubbo"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建参数集合map，用于Dubbo URL 的构建（服务提供者URL）</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将side,dubbo,timestamp,pid参数，添加到map集合中</span></span><br><span class="line">        map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class="line">        map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());</span><br><span class="line">        map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射将各种配置对象中的属性添加到map集合中，map用于URL的构建【注意属性覆盖问题】</span></span><br><span class="line">        appendParameters(map, application);</span><br><span class="line">        appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">        appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">        appendParameters(map, protocolConfig);</span><br><span class="line">        appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将MethodConfig 对象数组添加到 map 集合中。就是将每个MethodConfig和其对应的ArgumentConfig对象数组添加到map中【处理方法相关的属性到map】</span></span><br><span class="line">        <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// methods 为 MethodConfig 集合，MethodConfig 中存储了 &lt;dubbo:method&gt; 标签的配置信息</span></span><br><span class="line">            <span class="keyword">for</span> (MethodConfig method : methods) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 将MethodConfig对象的属性添加到map集合中，其中属性键 = 方法名.属性名。如：</span></span><br><span class="line"><span class="comment">                 * &lt;dubbo:method name="sleep" retries="2"&gt;&lt;/dubbo:method&gt;对应的MethodConfig，属性到map的格式：&#123;"sleep.retries":2&#125;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                appendParameters(map, method, method.getName());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当配置了 MehodConfig.retry = false 时，强制禁用重试</span></span><br><span class="line">                String retryKey = method.getName() + <span class="string">".retry"</span>;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class="line">                    String retryValue = map.remove(retryKey);</span><br><span class="line">                    <span class="comment">// 检测 MethodConfig retry 是否为 false，若是，则设置重试次数为0</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"false"</span>.equals(retryValue)) &#123;</span><br><span class="line">                        map.put(method.getName() + <span class="string">".retries"</span>, <span class="string">"0"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将MethodConfig下的ArgumentConfig 对象数组即&lt;dubbo:argument&gt; 标签中的配置信息，添加到 map 集合中</span></span><br><span class="line">                List&lt;ArgumentConfig&gt; arguments = method.getArguments();</span><br><span class="line">                <span class="keyword">if</span> (arguments != <span class="keyword">null</span> &amp;&amp; !arguments.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (ArgumentConfig argument : arguments) &#123;</span><br><span class="line">                        <span class="comment">// 检测type 属性是否为空</span></span><br><span class="line">                        <span class="keyword">if</span> (argument.getType() != <span class="keyword">null</span> &amp;&amp; argument.getType().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 通过反射取出接口的方法列表</span></span><br><span class="line">                            Method[] methods = interfaceClass.getMethods();</span><br><span class="line">                            <span class="comment">// 遍历接口中的方法列表</span></span><br><span class="line">                            <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">                                    String methodName = methods[i].getName();</span><br><span class="line">                                    <span class="comment">// 比对方法名，查找目标方法</span></span><br><span class="line">                                    <span class="keyword">if</span> (methodName.equals(method.getName())) &#123;</span><br><span class="line">                                        <span class="comment">// 通过反射取出目标方法的参数类型列表</span></span><br><span class="line">                                        Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();</span><br><span class="line">                                        <span class="comment">// 若果配置index配置项，且值不为-1</span></span><br><span class="line">                                        <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123;</span><br><span class="line">                                            <span class="comment">// 从argtypes数组中获取下标index处的元素argType，并检测ArgumentConfig中的type属性与argType名称是否一致，不一致则抛出异常</span></span><br><span class="line">                                            <span class="keyword">if</span> (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                <span class="comment">// 将ArgumentConfig对象的属性添加到map集合中，键前缀=方法名.index，如：map = &#123;"sleep.2":true&#125;</span></span><br><span class="line">                                                appendParameters(map, argument, method.getName() + <span class="string">"."</span> + argument.getIndex());</span><br><span class="line">                                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config error : the index attribute and type attribute not match :index :"</span> + argument.getIndex() + <span class="string">", type:"</span> + argument.getType());</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                            <span class="comment">// 遍历参数类型数组argtypes，查找argument.type类型的参数</span></span><br><span class="line">                                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; argtypes.length; j++) &#123;</span><br><span class="line">                                                Class&lt;?&gt; argclazz = argtypes[j];</span><br><span class="line">                                                <span class="comment">// 从参数类型列表中查找类型名称为argument.type的参数</span></span><br><span class="line">                                                <span class="keyword">if</span> (argclazz.getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                    <span class="comment">// 将ArgumentConfig对象的属性添加到map集合中</span></span><br><span class="line">                                                    appendParameters(map, argument, method.getName() + <span class="string">"."</span> + j);</span><br><span class="line">                                                    <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span> &amp;&amp; argument.getIndex() != j) &#123;</span><br><span class="line">                                                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config error : the index attribute and type attribute not match :index :"</span> + argument.getIndex() + <span class="string">", type:"</span> + argument.getType());</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 用户未配置 type 属性，但配置了index属性，且index != -1</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123; <span class="comment">// 指定单个参数的位置</span></span><br><span class="line">                            <span class="comment">// 将ArgumentConfig对象的属性添加到map集合中</span></span><br><span class="line">                            appendParameters(map, argument, method.getName() + <span class="string">"."</span> + argument.getIndex());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config must set index or type attribute.eg: &lt;dubbo:argument index='0' .../&gt; or &lt;dubbo:argument type=xxx .../&gt;"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// end of methods for</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//--- 检测 generic 是否 为 true ,并根据检测结果向map中添加不同的信息 ---/</span></span><br><span class="line">        <span class="comment">// 将 generic,methods,revision 加入到数组</span></span><br><span class="line">        <span class="keyword">if</span> (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">            map.put(Constants.GENERIC_KEY, generic);</span><br><span class="line">            map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先从MAINFEST.MF 中获取版本号，若获取不到，再从jar包命名中可能带的版本号作为结果，如 2.6.5.RELEASE。若都不存在，返回默认版本号【源码运行可能会没有】</span></span><br><span class="line">            String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">            <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                map.put(<span class="string">"revision"</span>, revision); <span class="comment">// 修订号</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为接口生成包裹类 Wrapper，Wrapper 中包含了接口的详细信息，如接口方法，字段信息等</span></span><br><span class="line">            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加方法名到 map 中，如果包含多个方法名，则用逗号隔开，比如：method=a,b</span></span><br><span class="line">            <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.warn(<span class="string">"NO method found in service interface "</span> + interfaceClass.getName());</span><br><span class="line">                <span class="comment">// 没有方法名就添加 method=*</span></span><br><span class="line">                map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将逗号作为分隔符连接方法名，并将连接后的字符串放入 map 中</span></span><br><span class="line">                map.put(Constants.METHODS_KEY, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">","</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// token 【使暴露出去的服务更安全，使用token做安全校验】</span></span><br><span class="line">        <span class="keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">                map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(Constants.TOKEN_KEY, token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 协议为injvm时，不注册，不通知</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) &#123;</span><br><span class="line">            protocolConfig.setRegister(<span class="keyword">false</span>);</span><br><span class="line">            map.put(<span class="string">"notify"</span>, <span class="string">"false"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得基础路径</span></span><br><span class="line">        String contextPath = protocolConfig.getContextpath();</span><br><span class="line">        <span class="keyword">if</span> ((contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span>) &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            contextPath = provider.getContextpath();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---------------------------- 主机绑定 -------------------------------------/</span></span><br><span class="line">        <span class="comment">// 获得注册到注册中心的服务提供者host，并为map设置bind.ip , anyhost 两个key</span></span><br><span class="line">        String host = <span class="keyword">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">        <span class="comment">// 获取端口，并为map设置bing.port key</span></span><br><span class="line">        Integer port = <span class="keyword">this</span>.findConfigedPorts(protocolConfig, name, map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建Dubbo URL对象 【注意这里的 path 的值】</span></span><br><span class="line"><span class="comment">         * 1 name: 协议名</span></span><br><span class="line"><span class="comment">         * 2 host: 主机名</span></span><br><span class="line"><span class="comment">         * 3 port: 端口</span></span><br><span class="line"><span class="comment">         * 4 path: 【基础路径】/path</span></span><br><span class="line"><span class="comment">         * 5 parameters: 属性集合map</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(name, host, port, (contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span> ? <span class="string">""</span> : contextPath + <span class="string">"/"</span>) + path, map);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码比较复杂，不过总体上是将配置承载对象中的属性添加到参数集合中用于构建 Dubbo URL 。其中涉及到的将配置对象的属性添加到参数集合的 appendParameters 方法可以参见  <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 。</p><h3 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h3><p>服务暴露的准备工作完成后，接下来就可以执行服务暴露工作了。服务暴露，分为本地暴露和远程暴露。我们先不研究细节，先从宏观层面上看一下服务暴露逻辑。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用不同的协议，逐个向注册中心分组暴露服务。该方法中包含了本地和远程两种暴露方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> protocolConfig 协议配置对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registryURLs   处理过的注册中心分组集合【已经添加了ApplicationConfig和RegistryConfig的参数】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果存在当前协议对应的 ConfiguratorFactory 扩展实现，就创建配置规则器 Configurator，将配置规则应用到url todo 这里应该不会存在把？</span></span><br><span class="line">        <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">url</span>.<span class="title">getProtocol</span>())) </span>&#123;</span><br><span class="line">            <span class="comment">// 加载ConfiguratorFactory ，并生成Configurator，将配置规则应用到url中</span></span><br><span class="line">            url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">url</span>.<span class="title">getProtocol</span>()).<span class="title">getConfigurator</span>(<span class="title">url</span>).<span class="title">configure</span>(<span class="title">url</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从URL中获取暴露方式</span></span><br><span class="line">        String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 scope = none，则不进行暴露，直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// scope != remote，本地暴露</span></span><br><span class="line">            <span class="keyword">if</span> (!Constants.SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                exportLocal(url);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// scope != local，远程暴露，包含了服务暴露和服务注册两个过程</span></span><br><span class="line">            <span class="keyword">if</span> (!Constants.SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to url "</span> + url);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (registryURLs != <span class="keyword">null</span> &amp;&amp; !registryURLs.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 遍历注册中心URL数组</span></span><br><span class="line">                    <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                        <span class="comment">// dynamic属性：服务是否动态注册，如果设为false,注册后将显示disable状态，需要人工启用，并且服务提供者停止时，也不会自动下线，需要人工禁用</span></span><br><span class="line">                        url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 获取监控中心URL</span></span><br><span class="line">                        URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 监控URL不能空，就将监控中心的URL作为monitor参数添加到服务提供者的URL中，并且需要编码。通过这样方式，服务提供者的URL中就包含了监控中心的配置</span></span><br><span class="line">                            url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(<span class="string">"Register dubbo service "</span> + interfaceClass.getName() + <span class="string">" url "</span> + url + <span class="string">" to registry "</span> + registryURL);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                     </span><br><span class="line">                        <span class="comment">// 获取配置的动态代理的生成方式 &lt;dubbo:service proxy=""/&gt;,可选jdk/javassist,默认使用javassist</span></span><br><span class="line">                        String proxy = url.getParameter(Constants.PROXY_KEY);</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                            registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);</span><br><span class="line">                        &#125;</span><br><span class="line">                     </span><br><span class="line">                        <span class="comment">// 使用ProxyFactory 创建 AbstractProxyInvoker 对象</span></span><br><span class="line">                        Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(</span><br><span class="line">                                ref,</span><br><span class="line">                                (Class) interfaceClass,</span><br><span class="line">                                registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString())</span><br><span class="line">                        );</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 创建 DelegateProviderMetaDataInvoker 对象，在Invoker对象基础上，增加了当前服务提供者ServiceConfig对象，即把Invoker和ServiceConfig结合在了一起</span></span><br><span class="line">                        DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line">                        <span class="comment">// 暴露服务，生成Exporter:</span></span><br><span class="line">                        Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 添加到 Exporter 集合</span></span><br><span class="line">                        exporters.add(exporter);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 无效注册中心，仅暴露服务</span></span><br><span class="line">                    <span class="comment">// 使用ProxyFactory 创建 Invoker 对象</span></span><br><span class="line">                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                    <span class="comment">// 创建 DelegateProviderMetaDataInvoker 对象</span></span><br><span class="line">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 使用Protocol 暴露Invoker 对象</span></span><br><span class="line">                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                    <span class="comment">// 添加到 Exporter 集合</span></span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从宏观层面上看，服务暴露的方式取决于 scope 参数，该参数值在文章前面有具体说明。</p><h3 id="创建-Invoker"><a href="#创建-Invoker" class="headerlink" title="创建 Invoker"></a>创建 Invoker</h3><p>不管是本地暴露，还是远程暴露，进行服务暴露之前，都需要先创建 Invoker ，这一点非常重要。在 Dubbo 中，Invoker 是一个非常重要的模型，无论是在服务提供端，还是服务消费端均会出现 Invoker。Dubbo 官方文档中对 Invoker 进行了说明。</p><blockquote><p>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p></blockquote><p>Invoker 是由 ProxyFactory 创建的，Dubbo 默认的 ProxyFactory 实现类是 JavassistProxyFactory ，在 <a href="https://gentryhuang.com/posts/c2df2fc6/">Javassist动态代理</a> 中进行了详细的说明。</p><h3 id="本地暴露"><a href="#本地暴露" class="headerlink" title="本地暴露"></a>本地暴露</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 本地暴露</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportLocal</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 1 若果URl的协议头是injvm，说明已经暴露到本地了，无需再次暴露</span></span><br><span class="line"><span class="comment">       * 2 非injvm协议就基于原有的URL构建协议为injvm，主机地址 127.0.0.1，端口为0 的新的 URL</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">          URL local = URL.valueOf(url.toFullString())</span><br><span class="line">                  .setProtocol(Constants.LOCAL_PROTOCOL)</span><br><span class="line">                  .setHost(LOCALHOST)</span><br><span class="line">                  .setPort(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 添加服务接口的实现类【仅用于RestProtocol协议】到线程变量中</span></span><br><span class="line">          ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 创建 Invoker，这里 proxyFactory 会在运行时执行 JavassistProxyFactory 的 getInvoker 方法 （默认情况，也可通过参数指定）</span></span><br><span class="line">          Invoker invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, local);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 这里的 protocol 会在运行时调用 InjvmProtocol 的 export 方法</span></span><br><span class="line">          Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 添加到Exporter集合中</span></span><br><span class="line">          exporters.add(exporter);</span><br><span class="line"></span><br><span class="line">          logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to local registry"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>本地暴露的代码比较简单，下面总结下流程：</p><ol><li>根据 URL 协议头决定是否暴露服务，如果需要暴露就创建 injvm 协议的 URL</li><li>然后通过 SPI 机制分别获取运行时的 proxyFactory 和 protocol 扩展实现，这就是 Dubbo SPI 自适应的好处</li><li>使用proxyFactory创建 Invoker(AbstractProxyInvoker) </li><li>使用protocol进行服务暴露</li></ol><p>以上流程的前 3 步已经分析过，下面对第 4 步进行分析。</p><h4 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h4><p>本地暴露涉及的 Protocol 类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-local-protocol.jpg" alt></p><p>由上图的 UML 类图可知，Protocol 有两个 Wrapper 类，由 Dubbo SPI 机制我们知道执行 Protocol#export 方法的顺序：</p><blockquote><p>Protocol$Adaptive =&gt; ProtocolListenerWrapper ==&gt; ProtocolFilterWrapper =&gt; InjvmProtocol</p></blockquote><p>下面对执行链进行分析，其中 Protocol 自适应扩展对象原理在 <a href="https://gentryhuang.com/posts/3e0b5964/">自适应扩展</a> 中已经详细分析。这里说明下，上图的 UML 类图中其它的先不做分析，只关注本地暴露相关的， Dubbo 中的多协议部分会单独作为一个模块分析。</p><h4 id="ProtocolListenerWrapper"><a href="#ProtocolListenerWrapper" class="headerlink" title="ProtocolListenerWrapper"></a>ProtocolListenerWrapper</h4><p>实现 Protocol 接口，是 Protocol 的 Wrapper 类，在服务暴露时用于给 Exporter 添加监听器，监听 Exporter 暴露和取消。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolListenerWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolListenerWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker Service invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// registry协议开头的服务暴露逻辑，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 服务暴露，创建 Exporter</span></span><br><span class="line">        Exporter&lt;T&gt; export = protocol.export(invoker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 ExporterListener</span></span><br><span class="line">        List&lt;ExporterListener&gt; exporterListeners = Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">getActivateExtension</span>(<span class="title">invoker</span>.<span class="title">getUrl</span>(), <span class="title">Constants</span>.<span class="title">EXPORTER_LISTENER_KEY</span>))</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 ListenerExporterWrapper 包装 Exporter，为 Exporter邦定监听器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListenerExporterWrapper&lt;T&gt;(export, exporterListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProtocolListenerWrapper 在服务暴露流程中的逻辑如下：</p><ol><li>判断当前Invoker对应的URL协议是否为 registry，远程暴露时需要用到注册中心，执行到这里时协议会为 registry，这种情况就无需绑定监听器。</li><li>使用具体协议暴露服务，创建 Exporter</li><li>获取ExporterListener，用户可以自行实现监听器。注意，实现的监听器是自动激活类型</li><li>将获取的监听器绑定到服务暴露生成的Exporter</li></ol><h4 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a>Exporter</h4><p>Exporter 是 Invoker 服务在 Protocol 上的对象。更多可以参考 <a href="https://gentryhuang.com/posts/e2577ca1/">Dubbo项目结构总览</a> 。本地暴露涉及到的 UML 类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-local-exporter.jpg" alt></p><h5 id="InjvmExporter"><a href="#InjvmExporter" class="headerlink" title="InjvmExporter"></a>InjvmExporter</h5><p>实现 AbstractExporter 抽象类，Injvm Exporter 实现类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InjvmExporter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractExporter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exporter 集合</span></span><br><span class="line"><span class="comment">     * key : 服务键</span></span><br><span class="line"><span class="comment">     * 该值实际就是 &#123;<span class="doctag">@link</span> com.alibaba.dubbo.rpc.protocol.AbstractProtocol#exporterMap&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，发起暴露</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 服务键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporterMap AbstractExporter的缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    InjvmExporter(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) &#123;</span><br><span class="line">        <span class="keyword">super</span>(invoker);</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.exporterMap = exporterMap;</span><br><span class="line">        <span class="comment">// 加入到Exporter集合[会把自己加入到AbstractProtocol中的Map中]</span></span><br><span class="line">        exporterMap.put(key, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.unexport();</span><br><span class="line">        <span class="comment">// 移除 key对应的Exporter</span></span><br><span class="line">        exporterMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InjvmExporter 会将自身的对象放入到其父类 AbstractExporter 和自身的缓存中，这也是本地暴露的本质。</p><h5 id="ListenerExporterWrapper"><a href="#ListenerExporterWrapper" class="headerlink" title="ListenerExporterWrapper"></a>ListenerExporterWrapper</h5><p>实现 Exporter 接口，具有监听器功能的 Exporter 的 Wrapper 类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ListenerExporter</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 实现 Exporter接口，具有监听器功能的Exporter包装器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerExporterWrapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Exporter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ListenerExporterWrapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真实的Exporter 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exporter&lt;T&gt; exporter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exporter 监听器数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExporterListener&gt; listeners;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListenerExporterWrapper</span><span class="params">(Exporter&lt;T&gt; exporter, List&lt;ExporterListener&gt; listeners)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"exporter == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.exporter = exporter;</span><br><span class="line">        <span class="keyword">this</span>.listeners = listeners;</span><br><span class="line">        <span class="comment">// 执行监听器</span></span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) &#123;</span><br><span class="line">            RuntimeException exception = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (ExporterListener listener : listeners) &#123;</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 事件触发【服务导出后】回调，可以进行自定义实现ExporterListener，重新该方法</span></span><br><span class="line">                        listener.exported(<span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException t) &#123;</span><br><span class="line">                        logger.error(t.getMessage(), t);</span><br><span class="line">                        exception = t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消服务暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exporter.unexport();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 执行监听器</span></span><br><span class="line">            <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) &#123;</span><br><span class="line">                RuntimeException exception = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (ExporterListener listener : listeners) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            listener.unexported(<span class="keyword">this</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RuntimeException t) &#123;</span><br><span class="line">                            logger.error(t.getMessage(), t);</span><br><span class="line">                            exception = t;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> exception;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ListenerExporterWrapper是一个 Wrapper 类，是用来给 Exporter 绑定 ExporterListener 监听器的。</p><h5 id="ExporterListener"><a href="#ExporterListener" class="headerlink" title="ExporterListener"></a>ExporterListener</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExporterListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The exporter exported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当服务暴露完成</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Protocol#export(Invoker)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exported</span><span class="params">(Exporter&lt;?&gt; exporter)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The exporter unexported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当服务取消完成</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Exporter#unexport()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unexported</span><span class="params">(Exporter&lt;?&gt; exporter)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exporter 的监听器，是一个扩展点。用户可以自定义实现，用来监听服务暴露。</p><h4 id="ProtocolFilterWrapper"><a href="#ProtocolFilterWrapper" class="headerlink" title="ProtocolFilterWrapper"></a>ProtocolFilterWrapper</h4><p>实现 Protocol 接口，是 Protocol 的 Wrapper 类，用于给 Invoker 增加过滤链。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolFilterWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolFilterWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建带Filter链的Invoker 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker Invoker对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     URL中参数名 【如：用于获得ServiceConfig或ReferenceConfig配置的自定义过滤器】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> group   分组 【暴露服务时：group=provider; 引用服务时：group=consumer】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 在执行的时候执行Filter </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Invoker&lt;T&gt; last = invoker;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类上带有@Active注解的过滤器集合</span></span><br><span class="line">        List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter<span class="class">.<span class="keyword">class</span>).<span class="title">getActivateExtension</span>(<span class="title">invoker</span>.<span class="title">getUrl</span>(), <span class="title">key</span>, <span class="title">group</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒序循环 Filter，递归包装Invoker，就是一个链表结构： Xx1Filter-&gt;Xx2Filter-&gt;Xx3Filter-&gt;...-&gt;Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (!filters.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Filter filter = filters.get(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br><span class="line">                <span class="comment">// 创建新的Invoker 对象， 用于包装 next</span></span><br><span class="line">                last = <span class="keyword">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.getInterface();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.getUrl();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.isAvailable();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 调用Invoker的invoke方法的时候会执行</span></span><br><span class="line"><span class="comment">                     *  1 调用Filter#invoke(invoker,invocation)方法，不断执行过滤器逻辑</span></span><br><span class="line"><span class="comment">                     *  2 在Filter中会调用Invoker#invoker(invocation)方法，最后会执行到Invoker【如：InjvmInvoker,DubboInvoker等】的invoke方法</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> filter.invoke(next, invocation);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        invoker.destroy();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.getDefaultPort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 Invoker的URL中 protocol=registry,说明是注册中心的协议，这种情况无需创建Filter过滤器。</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立带有Filter 过滤链的 Invoker，再暴露服务</span></span><br><span class="line">        <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProtocolFilterWrapper 在服务暴露时就做了一件事，为 Invoker 增加过滤链。其中key和group参数是用来获取自定义过滤器的，具体规则参见 <a href="https://gentryhuang.com/posts/5d81f464/#getActivateExtension-%E6%96%B9%E6%B3%95">Dubbo SPI</a> 。过滤器链如下，包含 Dubbo 自带过滤器和用户自定义过滤器。</p><blockquote><p>EchoFilter - 回声探测过滤器<br>ClassLoaderFilter - 类加载器切换过滤器<br>GenericFilter - 服务提供者的泛化调用过滤器<br>ContextFilter - 服务提供者的上下文过滤器<br>TraceFilter - 追踪过滤器<br>TimeoutFilter - 服务提供者的超时过滤器<br>MonitorFilter - 监控过滤器<br>ExceptionFilter - 加工异常过滤器<br>XxxFilter - 自定义过滤器</p></blockquote><p>构建 Invoker 的过器滤链过程如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-invoker-filter-chain.jpg" alt></p><p>需要注意的是，返回的 Invoker 是一个匿名内部类对象，该对象的 invoke 方法没有其它逻辑，仅用来执行 <code>Filter.invoke</code> 方法。当向该 Invoker 发起调用时，会先执行过滤器链，只有当过滤器链执行完毕后，才会执行真正的 Invoker 的逻辑。</p><h4 id="InjvmProtocol"><a href="#InjvmProtocol" class="headerlink" title="InjvmProtocol"></a>InjvmProtocol</h4><p>实现 AbstractProtocol 抽象类，Injvm 协议实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * InjvmProtocol</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjvmProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = Constants.LOCAL_PROTOCOL;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例：在Dubbo SPI中，被初始化有且仅有一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InjvmProtocol INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InjvmProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        INSTANCE = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得单例子</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InjvmProtocol <span class="title">getInjvmProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">InjvmProtocol</span>.<span class="title">NAME</span>)</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_PORT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行服务暴露，创建InjvmExporter[并把自己-&gt;Exporter存入到父类的 &#123;<span class="doctag">@link</span> #exporterMap&#125; 属性中，key:当前服务键，value:Exporter]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker Service invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Exporter，并且把自己添加到 exporterMap 中，exporterMap 是父类属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>injvm 协议暴露服务比较简单，直接创建 InjvmExporter 对象，然后放入内存中即可，没有其它逻辑。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章详细分析了 Dubbo 本地服务导出过程，包括配置检测，URL 组装，Invoker 创建过程等，下一篇文章将分析远程暴露。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有了前面一系列文章铺垫，再来看服务暴露与服务引用就简单很多了。本地暴露需要配置、SPI、动态代理、协议等知识，其中协议部分会在后面的文章中着
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 优雅停机</title>
    <link href="https://gentryhuang.com/posts/ef4cfe7a/"/>
    <id>https://gentryhuang.com/posts/ef4cfe7a/</id>
    <published>2020-07-25T16:00:00.000Z</published>
    <updated>2020-11-24T09:53:59.366Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>优雅停机仅存在于服务重启、下线这样的部署阶段，优雅停机是一个应用生命周期的一部分，它保障了应用的健壮性。dubbo是通过jdk的ShutdownHook来完成优雅停机的，所以如果用户使用 kill -9 pid 等强制关闭指令，是不会执行优雅停机的，只有通过 kill pid 即正常退出进程，才会执行。</p><h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><ul><li>优雅停机的服务端有正在处理中的请求，不能被停机指令中断，除非超时</li><li>优雅停机的消费端不应该再发起新的请求</li><li>消费端不应该请求已经下线的服务提供者</li></ul><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>应用的重新启动、停机等操作，避免了对业务的连续性造成影响，如：集群中的某个应用存在逻辑上的bug，需要修改程序，这时候就可以使用优雅停机平滑下线，不会造成调用方异常问题。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/shutdownhook.png" alt></p><p><font color="#c7254e"> dubbo中实现优雅停机主要包含以下步骤 </font></p><ol><li>收到kill 9 进程退出信号时，spring容器会触发容器销毁事件  (其实是spring注册的jvm钩子程序执行的，后面会看到)</li><li>provider端会取消注册服务元数据信息</li><li>consumer端会收到最新地址列表（准备停机地址不在该地址列表中）</li><li>dubbo协议会发送readonly事件报文通知consumer服务不可用</li><li>服务端等待已经执行的任务结束并不再处理新的请求</li></ol><p><strong>说明</strong></p><ul><li>上图中的流程是使用spring构建的dubbo应用</li><li>上图中的流程没有体现出优雅停机的消费端角色，该角色做的工作相对简单，主要是不再发起新的调用请求和等待响应返回，超时才会强制关闭</li><li>注册中心已经通知了最新服务列表，发送readonly事件主要考虑到注册中心推送服务有网络延迟以及客户端计算服务列表也需要时间。消费端收到后会设置对应的provider为不可用状态，下次负载均衡就不会调用这个下线的服务</li></ul><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>dubbo对优雅停机的实现在不同的版本中有所差异，下面从2.5.x、2.6.x以及2.7.x这三个版本分别分析。</p><h4 id="2-5-x的优雅停机"><a href="#2-5-x的优雅停机" class="headerlink" title="2.5.x的优雅停机"></a>2.5.x的优雅停机</h4><p>注册shutdown hook</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 省略其它代码    </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Run shutdown hook now."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 销毁资源</span></span><br><span class="line"><span class="comment">                     * 1 注册中心数据销毁： 删除注册中心中本节点对应的提供者地址以及订阅数据</span></span><br><span class="line"><span class="comment">                     * 2 协议流程数据销毁： 取消该协议所有已经暴露和引用的服务，释放协议所占用的所有资源，比如连接和端口</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    ProtocolConfig.destroyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"DubboShutdownHook"</span>));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p> ProtocolConfig.destroyAll()方法是用来释放资源的，由于dubbo支持多注册中心和多协议，因此具体销毁实现细节取决于具体的注册中心和具体的协议，这里不再展开说明。</p><h4 id="2-6-x的优雅停机"><a href="#2-6-x的优雅停机" class="headerlink" title="2.6.x的优雅停机"></a>2.6.x的优雅停机</h4><p> spring也依赖shutdown hook完成优雅停机，其注册jvm钩子的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a shutdown hook with the JVM runtime, closing this context</span></span><br><span class="line"><span class="comment"> * on JVM shutdown unless it has already been closed at that time.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Delegates to &#123;<span class="doctag">@code</span> doClose()&#125; for the actual closing procedure.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Runtime#addShutdownHook</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #close()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doClose()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No shutdown hook registered yet.</span></span><br><span class="line"><span class="keyword">this</span>.shutdownHook = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (startupShutdownMonitor) &#123;</span><br><span class="line">doClose();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// 注册jvm钩子</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">this</span>.shutdownHook);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring的shutdownhook具体任务如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Actually performs context closing: publishes a ContextClosedEvent and</span></span><br><span class="line"><span class="comment">  * destroys the singletons in the bean factory of this application context.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;Called by both &#123;<span class="doctag">@code</span> close()&#125; and a JVM shutdown hook, if any.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> org.springframework.context.event.ContextClosedEvent</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #destroyBeans()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #close()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #registerShutdownHook()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.active.get() &amp;&amp; <span class="keyword">this</span>.closed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Closing "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LiveBeansView.unregisterApplicationContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Publish shutdown event   // 注意容器关系事件的发布</span></span><br><span class="line">publishEvent(<span class="keyword">new</span> ContextClosedEvent(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception thrown from ApplicationListener handling ContextClosedEvent"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop all Lifecycle beans, to avoid delays during individual destruction.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleProcessor != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.lifecycleProcessor.onClose();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception thrown from LifecycleProcessor on context close"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy all cached singletons in the context's BeanFactory.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close the state of this context itself.</span></span><br><span class="line">closeBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let subclasses do some final clean-up if they wish...</span></span><br><span class="line">onClose();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.active.set(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dubbo2.6.x支持使用spring构建dubbo应用时，能够安全使用优雅停机。由于dubbo注册了jvm停止的钩子，<font color="#c7254e"> spring可能 </font> 也注册了jvm停机的钩子，这种情况下两个并发执行的线程可能引用已经销毁的资源，导致优雅停机失效。比如，dubbo正在执行的任务需要引用spring中的bean，但此时spring钩子已经关闭spring上下文，导致访问spring资源都会报错。因此对于这种情况，dubbo在2.6.3中新增ShutdownHookListener 类用来解决并发问题，该类实现了ApplicationListener接口，当进程退出时jvm钩子会被触发，此时spring和dubbo注册的jvm钩子都会被回调，spring注册的jvm钩子程序中spring发出容器关闭事件，ShutdownHookListener接收到关闭事件后执行dubbo的jvm钩子程序进行资源的释放，这样就避免使用无效spring bean的问题，从而完成优雅停机。</p><p><font color="#c7254e"> ShutdownHookListener </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHookListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            <span class="comment">// 使用spring框架时也不应该删除dubbo shutdown hook，因为spring可能没有注册ContextClosed 事件</span></span><br><span class="line">            DubboShutdownHook shutdownHook = DubboShutdownHook.getDubboShutdownHook();</span><br><span class="line">            shutdownHook.destroyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#c7254e"> AbstractConfig中依然保留JVM停止钩子 </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 省略无关代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.name"</span>, <span class="string">"dubbo.service.protocol"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.host"</span>, <span class="string">"dubbo.service.server.host"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.port"</span>, <span class="string">"dubbo.service.server.port"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.threads"</span>, <span class="string">"dubbo.service.max.thread.pool.size"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.consumer.timeout"</span>, <span class="string">"dubbo.service.invoke.timeout"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.consumer.retries"</span>, <span class="string">"dubbo.service.max.retry.providers"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.consumer.check"</span>, <span class="string">"dubbo.service.allow.no.provider"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.service.url"</span>, <span class="string">"dubbo.service.address"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this is only for compatibility</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Dubbo 的优雅停机 ShutdownHook 在 AstractConfig 的静态代码块中，这保证了ShutdownHook能够给被初始化。</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 1 Dubbo 是 通过 JDK的ShutdownHook来完成优雅停机的</span></span><br><span class="line"><span class="comment">         * 2 ShutdownHook本质上是一个线程，任务体在对应的run方法中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><font color="#c7254e">DubboShutdownHook </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboShutdownHook</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DubboShutdownHook<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShutdownHook,类属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DubboShutdownHook dubboShutdownHook = <span class="keyword">new</span> DubboShutdownHook(<span class="string">"DubboShutdownHook"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DubboShutdownHook <span class="title">getDubboShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dubboShutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Has it already been destroyed or not?</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 是否已经被销毁标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean destroyed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DubboShutdownHook</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShutdownHook的任务体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Run shutdown hook now."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        destroyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Destroy all the resources, including registries and protocols.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 销毁所有的资源，包括 Registry相关 和 Protocol相关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果已经销毁则忽略</span></span><br><span class="line">        <span class="keyword">if</span> (!destroyed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁所有的 Registry,取消应用程序中的服务提供者和消费者的订阅与注册</span></span><br><span class="line">        AbstractRegistryFactory.destroyAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 销毁所有的 Protocol</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 这里的Protocol比较多，大体上可以分两类：</span></span><br><span class="line"><span class="comment">         * 1 和Registry相关的Protocol，RegistryProtocol关注服务的注册</span></span><br><span class="line"><span class="comment">         * 2 具体协议，如 DubboProtocol、httpProtocol等,关注服务的暴露和引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (String protocolName : loader.getLoadedExtensions()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Protocol protocol = loader.getLoadedExtension(protocolName);</span><br><span class="line">                <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    protocol.destroy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#c7254e">DubboShutdownHook与protocol、registry的关系图 </font></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/shutdownhook-process.jpg" alt></p><p><font color="#c7254e"> 图解(以dubbo协议和zookeeper注册中心为例) <font></font></font></p><p><font color="#c7254e"> Registry相关 <font></font></font></p><ul><li>AbstractRegistryFactory#destroyAll方法，遍历所有的Registry并调用Registry#destroy方法。然后清空Registry缓存集合。</li><li>AbstractRegistry 实现了公用的销毁逻辑：取消注册和订阅。服务提供者和消费者都会执行注册和订阅，因此都需要进行取消。</li><li>FailbackRegistry实现销毁公用的重试任务</li><li>ZookeeperRegistry销毁其对应的客户端连接</li></ul><p><font color="#c7254e"> Protocol相关 <font></font></font></p><ul><li>AbstractProtocol#destroy方法，销毁协议对应的服务消费者拥有的Invoker， 销毁协议对应的服务提供者的所有Exporter。</li><li>DubboProtocol销毁所有通信 ExchangeClient 和 ExchangeServer</li></ul><p><strong>小结</strong></p><ul><li>dubbo2.6.3在spring环境中注册两个钩子的情况，ShutdownHookListener解决了并发执行问题</li><li>使用ShutdownHookListener也不能移除调dubbo注册的jvm钩子，因为不能保证应用中一定会注册spring的shutdown hook</li></ul><h4 id="2-7-x优雅停机"><a href="#2-7-x优雅停机" class="headerlink" title="2.7.x优雅停机"></a>2.7.x优雅停机</h4><p>从dubbo的2.6.3版本开始，解决了使用spring构建的dubbo可能发生优雅停机并发执行shutdown hook的问题。但是还是存在一个问题，那就是如果在spring环境下没有注册spring的jvm钩子，虽然没有大问题，但是还是有不完整的。dubbo2.7.x进行显示地注册spring的jvm钩子，并且移除dubbo的jvm钩子，解决了当前问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ApplicationContext&gt; CONTEXTS = <span class="keyword">new</span> ConcurrentHashSet&lt;ApplicationContext&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ApplicationListener SHUTDOWN_HOOK_LISTENER = <span class="keyword">new</span> ShutdownHookListener();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addApplicationContext</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        CONTEXTS.add(context);</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ConfigurableApplicationContext) &#123;</span><br><span class="line">            <span class="comment">// 显示注册spring的jvm钩子</span></span><br><span class="line">            ((ConfigurableApplicationContext) context).registerShutdownHook();</span><br><span class="line">            <span class="comment">// 显示移除dubbo的jvm钩子</span></span><br><span class="line">            DubboShutdownHook.getDubboShutdownHook().unregister();</span><br><span class="line">        &#125;</span><br><span class="line">        BeanFactoryUtils.addApplicationListener(context, SHUTDOWN_HOOK_LISTENER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHookListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">                DubboShutdownHook shutdownHook = DubboShutdownHook.getDubboShutdownHook();</span><br><span class="line">                shutdownHook.doDestroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>dubbo2.7.x优雅停机的实现，解决了spring环境下两个钩子并发的问题，并且显示注册spring的jvm钩子。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优雅停机并不是java中的概念，也不是只有dubbo框架进行了扩展实现，springboot、docker等都有涉及到优雅停机。dubbo中的优雅停机是不断优化的，2.5.x中的存在一定的问题，2.6.x在一般场景下是没有问题的，2.7.x是对之前版本的完善和优化。如果 ShutdownHook 不能生效，可以在需要的时机自行调用DubboShutdownHook.destroyAll()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;优雅停机仅存在于服务重启、下线这样的部署阶段，优雅停机是一个应用生命周期的一部分，它保障了应用的健壮性。dubbo是通过jdk的Shutdo
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="JDK" scheme="https://gentryhuang.com/tags/JDK/"/>
    
      <category term="Spring" scheme="https://gentryhuang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 信息交换层</title>
    <link href="https://gentryhuang.com/posts/26722deb/"/>
    <id>https://gentryhuang.com/posts/26722deb/</id>
    <published>2020-06-17T16:00:00.000Z</published>
    <updated>2020-12-15T05:57:56.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面的几篇文章详细介绍了 Dubbo Remoting 中的 Transport 层，它是 Dubbo 中的端到端的统一网络传输实现。本篇文章中将介绍 Transport 层的上一层 Exchange 层，同时它也是 Dubbo Remoting 层中的最顶层，是 Transport 层的使用者。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>信息交换层 Exchange ，建立Request-Response模型，封装请求响应模式，实现了同步转异步。以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer 。一次 RPC 调用，请求 Request 关注的是响应 Response，而 Transport 层以 Message 为中心提供网络通信功能，无法满足 RPC 的诉求，因此 Dubbo 在 Transport 层之上又构建了 Exchange 层，后者在前者的 Message 之上建立了具有语意的 Request-Response 模型。</p><p>Exchange 层代码结构如下图所示：</p><p><img src="/posts/26722deb/dubbo-remoting-exchange-outline.jpg" alt></p><p>Exchange 层构建于 Transport 层之上，是 Transport 层的使用者，再结合上图中的代码结构不难发现，Exchange 层同样具备端点 Endpoint（Server 和 Client）、通道 Channel、处理器 Handler 以及编解码器 Codec 等组件，区别在于 Exchange 层将 Transport 层的 Message 分成了 Request 和 Response 两种类型，且所有组件都是以这两个模型为中心进行实现。接下来我们从 Request 和 Response 这一对基础类开始，依次介绍 Exchange 层涉及的核心接口和实现类。</p><h1 id="Request-Response-模型"><a href="#Request-Response-模型" class="headerlink" title="Request-Response 模型"></a>Request-Response 模型</h1><p>Exchange 层的 Request 和 Response 是对请求和响应的抽象。</p><h2 id="Request-模型"><a href="#Request-模型" class="headerlink" title="Request 模型"></a>Request 模型</h2><p>对一次 RPC 调用的请求进行抽象。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEARTBEAT_EVENT = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只读事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String READONLY_EVENT = <span class="string">"R"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求编号自增序列，注意当递增到Long.MAX_VALUE之后，会溢出到Long.MIN_VALUE，但是这不影响继续使用该负数作为消息ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong INVOKE_ID = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求编号 ，注意这个编号用来和该请求对应的响应Response关联，Response中的mId就是该请求的mId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> mId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求版本号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String mVersion;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求是否需要响应： true-&gt; 需要  false-&gt; 不需要</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mTwoWay = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件标识，如心跳请求、只读请求。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mEvent = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否异常的请求，主要用于：</span></span><br><span class="line"><span class="comment">     * 服务端收到请求后，如果使用 DecodeHandler 将二进制数据解码成Request对象，这个解码过程可能会出现异常，</span></span><br><span class="line"><span class="comment">     * 如果出现异常，那么就用该属性进行标识，其它 ChannelHandler 可以根据该标志做进一步处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mBroken = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求体，可以是任何类型的数据，也可以是null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object mData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对请求编号进行赋值</span></span><br><span class="line">    mId = newId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入请求编号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    mId = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM进程内唯一，原子自增</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">newId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INVOKE_ID.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 判断是否是心跳请求条件：</span></span><br><span class="line"><span class="comment">  * 1. 需要是事件请求</span></span><br><span class="line"><span class="comment">  * 2. 判断请求体是否为 null</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeartbeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> mEvent &amp;&amp; HEARTBEAT_EVENT == mData;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 设置心跳请求信息</span></span><br><span class="line"><span class="comment">  * 1. 设置 mEvent = true ，标志是事件</span></span><br><span class="line"><span class="comment">  * 2. 设置 mData = null</span></span><br><span class="line"><span class="comment">  * 3. 以上两者共同确定是心跳请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> isHeartbeat</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeartbeat</span><span class="params">(<span class="keyword">boolean</span> isHeartbeat)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (isHeartbeat) &#123;</span><br><span class="line">         setEvent(HEARTBEAT_EVENT);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是否是事件请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> mEvent;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 请求体是否不合法（解码请求体失败时会设置 mBroken = true）</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> mBroken;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="Response-模型"><a href="#Response-模型" class="headerlink" title="Response 模型"></a>Response 模型</h2><p>对一次 RPC 响应进行抽象。</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEARTBEAT_EVENT = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只读事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String READONLY_EVENT = <span class="string">"R"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> OK = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端侧超时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> CLIENT_TIMEOUT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端超时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> SERVER_TIMEOUT = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略其它响应状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应编号，和对应的 Request 的 mId 一致。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mId = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前协议的版本号，与请求版本号一致</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String mVersion;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应状态码，有 OK、CLIENT_TIMEOUT、SERVER_TIMEOUT 等十多种， 默认是OK。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> mStatus = OK;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件标识。注意，只读事件不需要响应，也就不会使用到该属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mEvent = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误响应消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String mErrorMsg;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object mResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 无参构造函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Response</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 响应编号，和对应的请求编号一致</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> id 响应编号</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Response</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">     mId = id;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> id      响应编号，和对应的请求编号一致</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> version 当前协议版本号，和对应的请求版本号一致</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Response</span><span class="params">(<span class="keyword">long</span> id, String version)</span> </span>&#123;</span><br><span class="line">     mId = id;</span><br><span class="line">     mVersion = version;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="核心方法-1"><a href="#核心方法-1" class="headerlink" title="核心方法"></a>核心方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 判断是否是心跳事件</span></span><br><span class="line"><span class="comment">  * 1. 需要是事件</span></span><br><span class="line"><span class="comment">  * 2. 判断响应体是否为 null</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeartbeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> mEvent &amp;&amp; HEARTBEAT_EVENT == mResult;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 只读请求是不需要响应的，心跳请求需要响应</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> isHeartbeat</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Deprecated</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeartbeat</span><span class="params">(<span class="keyword">boolean</span> isHeartbeat)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (isHeartbeat) &#123;</span><br><span class="line">         setEvent(HEARTBEAT_EVENT);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是否是事件</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> mEvent;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Exchange 层为框架引入的 Request 和 Response 语义就介绍到这里，需要再次说明，这两个对象是 Exchange 层的核心，整个 Exchange 层都是围绕这两个对象进行任务的处理，在后面的分析过程中会看到。</p><h1 id="MultiMessage"><a href="#MultiMessage" class="headerlink" title="MultiMessage"></a>MultiMessage</h1><p>MultiMessage 是对多个消息的封装，实现了 Iterable 接口，支持对封装的消息集合进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiMessage</span> <span class="keyword">implements</span> <span class="title">Iterable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多消息的封装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List messages = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messages.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><p>信息交换接口，是 Dubbo 的扩展接口，默认扩展名为 <strong>header</strong> ，对应的默认扩展实现为 HeaderExchanger ，同时也是 Exchanger 接口的唯一有效实现。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(HeaderExchanger.NAME)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Exchanger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定一个服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 数据交换处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message server  服务器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.EXCHANGER_KEY&#125;)</span><br><span class="line">    <span class="function">ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接服务器，即创建一个客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 数据交换处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message channel  客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.EXCHANGER_KEY&#125;)</span><br><span class="line">    <span class="function">ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，Exchanger 接口和 Transporter 接口极其相似，因为 Exchanger 是对 Transporter 的封装，接下来通过 HeaderExchanger 就能验证这一点。</p><h1 id="HeaderExchanger"><a href="#HeaderExchanger" class="headerlink" title="HeaderExchanger"></a>HeaderExchanger</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchanger</span> <span class="keyword">implements</span> <span class="title">Exchanger</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"header"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接服务，创建客户端。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 数据交换处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeClient(Transporters.connect(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 数据交换处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码可以看出，Exchanger 创建的 HeaderExchangeServer 和 HeaderExchangeClient 分别是对 Transporter 创建的 Server 和 Client 的封装，是 Exchange 层的服务器和客户端，下面对这两个过程进行说明：</p><ul><li>创建 HeaderExchangeClient <blockquote><ol><li>默认启动心跳检测</li><li>处理器的顺序为：Transporter层的Handler链 =&gt; DecodeHandler =&gt; HeaderExchangeHandler =&gt; ExchangeHandler</li><li>将Transporter创建的客户端封装到HeaderExchangeClient中</li></ol></blockquote></li><li>创建 HeaderExchangeServer<blockquote><ol><li>默认启动心跳检测</li><li>处理器的顺序为：Transporter层的Handler链 =&gt; DecodeHandler =&gt; HeaderExchangeHandler =&gt; ExchangeHandler</li><li>将Transporter创建的服务封装到HeaderExchangeServer中</li></ol></blockquote></li></ul><p>需要说明的是，截止到 HeaderExchanger 对服务和客户端的创建，一次 RPC 调用 Remoting 层的通道处理器 Handler 已经全部创建完毕，在 Dubbo 的整个网络通信中发挥着巨大作用。分析完 Exchanger 数据交换接口后，我们继续看 Exchanger 的访问入口类 Exchangers 。</p><h1 id="Exchangers"><a href="#Exchangers" class="headerlink" title="Exchangers"></a>Exchangers</h1><p>Exchangers 数据交换门面类，属于外观模式的实现。<strong>对于 Exchange 的上层来说，Exchange 层的入口正是 Exchangers 这个门面类</strong>，其中提供了多个 bind() 和 connect() 方法的重载，这些方法最终会通过 Dubbo SPI 机制获取 Exchanger 接口的扩展实现。<strong>整体流程和 Transport 层一致，Transport 层的入口也是要通过 Transports 门面类</strong>。下面我们简单看看它的代码实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exchangers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// check duplicate jar package</span></span><br><span class="line">        Version.checkDuplicate(Exchangers<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Exchangers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     URL串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 数据交换处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeServer <span class="title">bind</span><span class="params">(String url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bind(URL.valueOf(url), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">"exchange"</span>);</span><br><span class="line">        <span class="keyword">return</span> getExchanger(url).bind(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     URL串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 数据交换处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeClient <span class="title">connect</span><span class="params">(String url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connect(URL.valueOf(url), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">"exchange"</span>);</span><br><span class="line">        <span class="keyword">return</span> getExchanger(url).connect(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 Exchanger 扩展实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger <span class="title">getExchanger</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从 URL 中获取 exchanger 的值，默认为 header</span></span><br><span class="line">        String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);</span><br><span class="line">        <span class="keyword">return</span> getExchanger(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1 获取Exchanger，默认为 HeaderExchanger。</span></span><br><span class="line"><span class="comment">     * 2 紧接着调用 HeaderExchanger的bind方法创建 ExchangeServer实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 扩展名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger <span class="title">getExchanger</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Exchanger<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">type</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于目前 Dubbo 的 Exchanger 有效扩展实现只有 HeaderExchanger ，因此 Exchangers 中只保留了和 HeaderExchanger 关联的代码。</p><p>了解了 Exchange 层的 Request-Response 模型以及入口后，下面我们分别对 Exchange 层的端点 Endpoint、通道 Channel、处理器 Handler 以及编解码器 Codec2 进行详细说明。</p><h1 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h1><p>Exchange 层通道 Channel 继承关系如下图所示：</p><p><img src="/posts/26722deb/dubbo-remoting-exchange-channel-hierarchy.jpg" alt></p><p>在前面的文章中已经详细介绍了 Channel 接口以及 Transport 层对 Channel 接口的实现。Exchange 层基于 Channel 接口抽象出了 ExchangeChannel 接口，表示该层的网路连接，用来发送请求等操作。</p><p>ExchangeChannel 接口中的方法如下图所示：</p><p><img src="/posts/26722deb/dubbo-remoting-exchange-channel-method.jpg" alt></p><p>上图中的灰色方法继承自 Endpoint 和 Channel 接口，其中 4 个白色的方法是 Exchange 层定义出的方法，request() 方法负责发送请求，getExchangeHandler() 方法用于获取信息交换处理器，close() 方法用于关闭通道。ExchangeChannel 接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExchangeChannel</span> <span class="keyword">extends</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> future</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> future</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得信息交换处理器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ExchangeHandler <span class="title">getExchangeHandler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优雅关闭</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExchangeChannel 接口本身新定义了请求发送 request() 方法、获得信息交换处理器 getExchangeHandler() 方法以及关闭方法，其它方法分别继承自 Endpoint 和 Channel 接口中的方法。下面我们继续看它的 HeaderExchangeChannel 实现类。</p><h2 id="HeaderExchangeChannel"><a href="#HeaderExchangeChannel" class="headerlink" title="HeaderExchangeChannel"></a>HeaderExchangeChannel</h2><p>HeaderExchangeChannel 实现了 ExchangeChannel 接口，基于消息头的信息交换通道实现类。它本身是 Channel 的装饰器，封装了一个 Channel 对象，send() 和 request() 方法的实现都委托给这个 Channel 对象。</p><h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeChannel</span> <span class="keyword">implements</span> <span class="title">ExchangeChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HeaderExchangeChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 作为 channel 的属性 key，value 是 HeaderExchangeChannel 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private static final String CHANNEL_KEY = HeaderExchangeChannel.class.getName() + ".CHANNEL";</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被装饰的 Channel，如 NettyChannel、NettyClient</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HeaderExchangeChannel 是传入channel的装饰器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 被装饰的 Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HeaderExchangeChannel(Channel channel) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"channel == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HeaderExchangeChannel 中有 3 个属性，这三个属性都有各自的作用：</p><ol><li>CHANNEL_KEY: 静态常量，作为 Channel 存储 HeaderExchangeChannel 对象的 key，保证了同一个 Channel 创建唯一的 HeaderExchangeChannel 对象。</li><li>channel: HeaderExchangeChannel 装饰的 Channel，此 channel 中会存储 HeaderExchangeChannel 对象，key 就是 CHANNEL_KEY 这个常量值。</li><li>closed: 用于标记通道是否关闭，request() 和 send() 方法受该值影响。</li></ol><h3 id="获取-HeaderExchangeChannel"><a href="#获取-HeaderExchangeChannel" class="headerlink" title="获取 HeaderExchangeChannel"></a>获取 HeaderExchangeChannel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">--- HeaderExchangeChannel</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建HeaderExchangeChannel 对象。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ch Channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> HeaderExchangeChannel <span class="title">getOrAddChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过 ch.getAttribute(CHANNEL_KEY) ，保证 ch 绑定唯一的 HeaderExchangeChannel 对象</span></span><br><span class="line">        HeaderExchangeChannel ret = (HeaderExchangeChannel) ch.getAttribute(CHANNEL_KEY);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ret = <span class="keyword">new</span> HeaderExchangeChannel(ch);</span><br><span class="line">            <span class="comment">// ch 必须是已连接状态，否则不会绑定对应的 HeaderExchangeChannel 对象</span></span><br><span class="line">            <span class="keyword">if</span> (ch.isConnected()) &#123;</span><br><span class="line">                ch.setAttribute(CHANNEL_KEY, ret);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>getOrAddChannel() 方法用于获取传入的 Channel 对应的 HeaderExchangeChannel 对象，并且 HeaderExchangeChannel 对象会对传入的 Channel 进行封装、装饰。不难看出两者期望是相互绑定关系，但要求 Channel 一方必须是处于连接状态。</p><h3 id="移除-HeaderExchangeChannel"><a href="#移除-HeaderExchangeChannel" class="headerlink" title="移除 HeaderExchangeChannel"></a>移除 HeaderExchangeChannel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- HeaderExchangeChannel</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeChannelIfDisconnected</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ch 断开了连接，则解除邦定的 HeaderExchangeChannel 对象</span></span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span> &amp;&amp; !ch.isConnected()) &#123;</span><br><span class="line">            ch.removeAttribute(CHANNEL_KEY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>removeChannelIfDisconnected() 方法用于解除处于断开连接状态的 Channel 绑定的 HeaderExchangeChannel 对象。</p><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 优雅关闭</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果已经关闭，就直接返回</span></span><br><span class="line">     <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 设置关闭标识，防止发起新的请求</span></span><br><span class="line">     closed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 等待请求完成</span></span><br><span class="line">     <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">          <span class="comment">// 请求处理完或者关闭超时，则结束</span></span><br><span class="line">         <span class="keyword">while</span> (DefaultFuture.hasFuture(channel) &amp;&amp; System.currentTimeMillis() - start &lt; timeout) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 Thread.sleep(<span class="number">10</span>);</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 logger.warn(e.getMessage(), e);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 关闭通道</span></span><br><span class="line">     close();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 关闭通道</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 执行 channel 的关闭动作</span></span><br><span class="line">         channel.close();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         logger.warn(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>HeaderExchangeChannel 优雅关闭主要过了三件事：</p><ol><li>设置关闭标志 closed ，防止发起新的请求。</li><li>等待请求被处理完成，除非关闭超时。</li><li>关闭被装饰的 channel </li></ol><h3 id="send-方法"><a href="#send-方法" class="headerlink" title="send 方法"></a>send 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Endpoint 方法</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="comment">// 默认不等待消息发出就返回</span></span><br><span class="line">     send(message, getUrl().getParameter(Constants.SENT_KEY, <span class="keyword">false</span>));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Endpoint 方法</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> sent    true: 会等待消息发出，消息发送失败会抛出异常；  false: 不等待消息发出，将消息放入IO队列，即可返回</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="comment">// 如果处于关闭状态，则抛出异常</span></span><br><span class="line">     <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">"Failed to send message "</span> + message + <span class="string">", cause: The channel "</span> + <span class="keyword">this</span> + <span class="string">" is closed!"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果消息是 Request、Response、String 类型，直接交给 Channel.send() 方法</span></span><br><span class="line">     <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request</span><br><span class="line">             || message <span class="keyword">instanceof</span> Response</span><br><span class="line">             || message <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">         channel.send(message, sent);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 构建 Request 对象，并且不需要响应</span></span><br><span class="line">         Request request = <span class="keyword">new</span> Request();</span><br><span class="line">         request.setVersion(Version.getProtocolVersion());</span><br><span class="line">         request.setTwoWay(<span class="keyword">false</span>);</span><br><span class="line">         request.setData(message);</span><br><span class="line">         channel.send(request, sent);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>HeaderExchangeChannel 中的 send() 方法实现是 Endpoint 接口中的方法，该方法比较简单，总体上是直接将消息通过被装饰的 Channel 发送出去，<strong>不关心响应结果</strong> 。</p><h3 id="request-方法"><a href="#request-方法" class="headerlink" title="request 方法"></a>request 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发送请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="comment">// 请求超时时间，默认 1000</span></span><br><span class="line">     <span class="keyword">return</span> request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发送请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> timeout 请求超时时间</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="comment">// 如果已经关闭，不能发起请求</span></span><br><span class="line">     <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">"Failed to send request "</span> + request + <span class="string">", cause: The channel "</span> + <span class="keyword">this</span> + <span class="string">" is closed!"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 创建请求，并初始化请求编号</span></span><br><span class="line">     Request req = <span class="keyword">new</span> Request();</span><br><span class="line">     <span class="comment">// Dubbo 版本</span></span><br><span class="line">     req.setVersion(Version.getProtocolVersion());</span><br><span class="line">     <span class="comment">// 需要响应</span></span><br><span class="line">     req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">     <span class="comment">// 具体数据 为 RpcInvocation</span></span><br><span class="line">     req.setData(request);</span><br><span class="line">     <span class="comment">// 创建DefaultFuture 对象,该对象表示此次请求-响应是否完成</span></span><br><span class="line">     DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, req, timeout);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 使用被装饰的 Channel 发送请求</span></span><br><span class="line">         channel.send(req);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">         <span class="comment">// 发送请求失败就取消 DefaultFuture</span></span><br><span class="line">         future.cancel();</span><br><span class="line">         <span class="keyword">throw</span> e;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 返回 DefaultFuture 对象</span></span><br><span class="line">     <span class="keyword">return</span> future;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>request() 方法非常重要，下面对该方法进行说明：</p><ol><li>创建 Request 对象，创建的过程会初始化一个请求编号，该编号标志当前请求</li><li>该方法需要响应，也就是说服务器收到请求后要给对端发送处理后的结果</li><li>创建 DefaultFuture 对象，该对象表示此次请求-响应是否完成</li><li>请求的发送使用的是被装饰的 Channel</li><li>请求失败就取消 DefaultFuture，并抛出异常</li></ol><p>发送请求的 request() 方法依赖 DefaultFuture ，关心响应结果，这也是和 send() 方法最大的不同。</p><p><strong>特别说明：</strong></p><ol><li>send() 方法本身不关心响应结果; request() 方法关心响应结果，通过 DefaultFuture 对象来传递响应结果。</li><li>Dubbo 支持同步和异步两种调用方式，默认使用同步调用方式，若要使用异步调用，需要服务消费方手动进行配置。其中异步调用还可细分为<strong>有返回值的异步调用</strong>和<strong>无返回值的异步调用</strong>。</li><li>Dubbo 的同步调用发送请求的方法是 request()；无返回值的异步调用发送请求的方法是 send()；有返回值的异步调用发送请求的方法是 request()。</li><li>Dubbo 的同步调用和有返回值的异步调用都关心调用结果，因此需要使用关心响应结果的 request() 方法来发送请求。而无返回值的异步调用不关心调用结果，使用不关心响应结果的 send() 方法即可。</li></ol><p>综上，是同步调用还是异步调用，需要调用结果还是不需要调用结果，这取决于 Exchange 的使用方。request() 方法会返回一个 DefaultFuture 对象，该对象并不是请求的结果，而是对此次请求-响应的管理。这意味着可以从 DefaultFuture 对象中获取请求对应的响应信息，只不过在响应结果没有返回之前获取动作会处于阻塞状态（除非超时或结果返回），因此，对于同步调用一般是获取到返回的 DefaultFuture 对象后立即从该对象中获取响应结果，对于异步调用一般是在合适的时机才会从该对象中获取响应结果。</p><p>有关同步调用和异步调用详细细节会在后面的文章中进行介绍，下面对 Exchange 层的 DefaultFuture 相关体系进行详细分析。</p><h1 id="ResponseFuture"><a href="#ResponseFuture" class="headerlink" title="ResponseFuture"></a>ResponseFuture</h1><p><img src="/posts/26722deb/dubbo-remoting-exchange-future.jpg" alt></p><p>Dubbo 中的 Future 关联关系如上图所示，DefaultFuture 实现了 ResponseFuture 接口，request() 方法返回值就是 ResponseFuture 类型，这也意味着对于 request() 方法来说无论是同步调用还是异步调用，只有返回 ResponseFuture 才算发送操作完成。需要注意，request() 方法其实是基于 send() 方法的，我们知道 send() 方法是没有返回值的，因此 request() 方法引入了 DefaultFuture 对象来管理 Request 和 Response 关系，从上面的继续关系中就可以明确这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseFuture</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取响应结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> result.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在指定的时间内获取结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeoutInMillis timeout.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> result.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> timeoutInMillis)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(ResponseCallback callback)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否完成</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> done or not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ResponseFuture 有点类似 JDK 中的 Future 接口，支持获取响应结果、判断响应结果是否返回，其中设置回调方法 <strong>setCallback(ResponseCallback callback)</strong> 会在 FutureFilter 中使用，主要用于事件通知，在后面的文章中会进行介绍，这里不进行展开说明。</p><h2 id="DefaultFuture"><a href="#DefaultFuture" class="headerlink" title="DefaultFuture"></a>DefaultFuture</h2><p>DefaultFuture 表示一次请求-响应的结果，每一个请求（通过request()方法发送的请求）都对应一个 DefaultFuture 对象，DefaultFuture 同时也是所有 DefaultFuture 的管理容器。<strong>需要特别说明的是，Dubbo 框架底层数据传输使用的 NIO 组件处理请求理论上是异步的，但是 Dubbo 框架做了异步转同步的处理，DefaultFuture 在这个过程中扮演着重要角色。</strong></p><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Request 编号到 Dubbo通道的映射</span></span><br><span class="line"><span class="comment">   * key: 请求编号</span></span><br><span class="line"><span class="comment">   * value: Dubbo 抽象的通道，用来发送请求</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, Channel&gt; CHANNELS = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, Channel&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Request 编号到 DefaultFuture 的映射</span></span><br><span class="line"><span class="comment">   * key: 请求编号</span></span><br><span class="line"><span class="comment">   * value: DefaultFuture</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, DefaultFuture&gt; FUTURES = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, DefaultFuture&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 启动扫描响应超时任务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      Thread th = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RemotingInvocationTimeoutScan(), <span class="string">"DubboResponseTimeoutScanTimer"</span>);</span><br><span class="line">      <span class="comment">// 守护线程</span></span><br><span class="line">      th.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">      th.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>前面说到 DefaultFuture 自身就是个管理容器，原因就在 <strong>FUTURES</strong> 属性上。当 DefaultFuture 加载时会启动扫描响应超时任务线程，下面我们就来看看 <strong>RemotingInvocationTimeoutScan</strong> 这个任务体的逻辑。</p><h3 id="扫描超时请求"><a href="#扫描超时请求" class="headerlink" title="扫描超时请求"></a>扫描超时请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RemotingInvocationTimeoutScan</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 遍历请求关联的 DefaultFuture 集合</span></span><br><span class="line">                  <span class="keyword">for</span> (DefaultFuture future : FUTURES.values()) &#123;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 如果 future 为空，或请求已经响应则进行下一个</span></span><br><span class="line">                      <span class="keyword">if</span> (future == <span class="keyword">null</span> || future.isDone()) &#123;</span><br><span class="line">                          <span class="keyword">continue</span>;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">// 请求没有响应，判断是否超时（请求时间 - 请求超时时间），超时就进入超时处理流程</span></span><br><span class="line">                      <span class="keyword">if</span> (System.currentTimeMillis() - future.getStartTimestamp() &gt; future.getTimeout()) &#123;</span><br><span class="line">                          <span class="comment">// 创建 Request 对应的 超时 Response 对象</span></span><br><span class="line">                          Response timeoutResponse = <span class="keyword">new</span> Response(future.getId());</span><br><span class="line">                          <span class="comment">// 设置响应状态，如果请求已经发送则是服务端超时，否则客户端超时</span></span><br><span class="line">                          timeoutResponse.setStatus(future.isSent() ? Response.SERVER_TIMEOUT : Response.CLIENT_TIMEOUT);</span><br><span class="line">                          <span class="comment">// 异常信息</span></span><br><span class="line">                          timeoutResponse.setErrorMessage(future.getTimeoutMessage(<span class="keyword">true</span>));</span><br><span class="line">                          <span class="comment">// 响应结果，避免客户端等待</span></span><br><span class="line">                          DefaultFuture.received(future.getChannel(), timeoutResponse);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 休眠30 ms</span></span><br><span class="line">                  Thread.sleep(<span class="number">30</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                  logger.error(<span class="string">"Exception when scan the timeout invocation of remoting."</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Dubbo 在 DefaultFuture 类加载时会开启一个守护线程，该线程用于轮询请求关联的 DefaultFuture 集合，及时对超时的请求进行异常结果的响应，尽可能减少客户端的等待时间。</p><h3 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">+--- DefaultFuture</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Request request;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invoke id.  请求的编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送请求的 Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求-响应的超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前 DefaultFuture 创建的开始时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求发送的时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> sent;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Response response;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的选择器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition done = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回调，适用于异步请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.protocol.dubbo.filter.FutureFilter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ResponseCallback callback;</span><br></pre></td></tr></table></figure><p>对象属性中的 <strong>Request</strong>、<strong>Response</strong>、<strong>Lock</strong> 以及 <strong>Condition</strong> 是实现异步转同步的必要对象。Dubbo 的异步转同步本质上是利用<strong>等待通知机制</strong>，等到分析 HeaderExchangeHandler 时还会回过头来看这一块的。</p><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 DefaultFuture 时，会把创建的该实例放入 FUTURES 缓存中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel 发送请求的 Channel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request 请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 请求-响应的超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    <span class="keyword">this</span>.request = request;</span><br><span class="line">    <span class="comment">// 设置请求id，这个id是request和response映射的依据，非常重要</span></span><br><span class="line">    <span class="keyword">this</span>.id = request.getId();</span><br><span class="line">    <span class="comment">// 设置超时时间，如果传入的 timeout &gt; 0 就取传入的值，否则取 URL 中timeout的值，默认为 1000</span></span><br><span class="line">    <span class="keyword">this</span>.timeout = timeout &gt; <span class="number">0</span> ? timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">    <span class="comment">// Request 编号到 DefaultFuture 的映射，DefaultFuture 管理每个请求关联的DefaultFuture对象。</span></span><br><span class="line">    FUTURES.put(id, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// Request 编号到 Dubbo通道的映射</span></span><br><span class="line">    CHANNELS.put(id, channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 DefaultFuture 对象时会初始化对象属性，其中 <strong>sent</strong> 和 <strong>response</strong> 属性会在 HeaderExchangeHandler 处理方法中进行值的更新。</p><h3 id="Request-关联属性"><a href="#Request-关联属性" class="headerlink" title="Request 关联属性"></a>Request 关联属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+--- DefaultFuture</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 request 关联的 DefaultFuture 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 请求id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DefaultFuture <span class="title">getFuture</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FUTURES.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断通道是否有未响应的请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 发送请求的 Channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasFuture</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CHANNELS.containsValue(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送请求时更新 sent 属性。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HeaderExchangeHandler#sent(com.alibaba.dubbo.remoting.Channel, java.lang.Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sent</span><span class="params">(Channel channel, Request request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取请求关联的 DefaultFuture 对象</span></span><br><span class="line">        DefaultFuture future = FUTURES.get(request.getId());</span><br><span class="line">        <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">            future.doSent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新 sent 属性，记录请求发送时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sent = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断调用结果是否返回，即判断 response 字段是否为空</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="获取响应结果"><a href="#获取响应结果" class="headerlink" title="获取响应结果"></a>获取响应结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// 超时时间取 timeout 的值</span></span><br><span class="line">    <span class="keyword">return</span> get(timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 默认 1000</span></span><br><span class="line">        timeout = Constants.DEFAULT_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isDone()方法用来判断Response是否有值，即是否有返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">        <span class="comment">// 等待请求结果，计时开始</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 等待完成或超时</span></span><br><span class="line">            <span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待请求结果，释放锁</span></span><br><span class="line">                done.await(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果调用结果成功返回，或等待超时，则跳出while循环继续执行后面逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (isDone() || System.currentTimeMillis() - start &gt; timeout) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 未完成，抛出超时异常</span></span><br><span class="line">        <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(sent &gt; <span class="number">0</span>, channel, getTimeoutMessage(<span class="keyword">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回响应</span></span><br><span class="line">    <span class="keyword">return</span> returnFromResponse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回响应</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">returnFromResponse</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    Response res = response;</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"response cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 正常返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (res.getStatus() == Response.OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> res.getResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时，抛出超时异常</span></span><br><span class="line">    <span class="keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel, res.getErrorMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法用于在指定的超时时间内获取请求的响应结果，如果在超时时间内响应结果返回则本次请求完成，否则抛出超时异常。需要注意的是，在超时时间内返回的响应结果不一定是成功状态，因此在响应业务线程结果时，在 <strong>returnFromResponse()</strong> 方法中需要对响应的状态进行判断。</p><h3 id="响应结果"><a href="#响应结果" class="headerlink" title="响应结果"></a>响应结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 收到响应结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel  通道</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response 响应结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求与返回结果进行匹配，匹配成功则移除关联的DefaultFuture对象</span></span><br><span class="line">        DefaultFuture future = FUTURES.remove(response.getId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收结果,更新相关字段标识</span></span><br><span class="line">        <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">            future.doReceived(response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">"The timeout response finally returned at "</span></span><br><span class="line">                    + (<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>).format(<span class="keyword">new</span> Date()))</span><br><span class="line">                    + <span class="string">", response "</span> + response</span><br><span class="line">                    + (channel == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">", channel: "</span> + channel.getLocalAddress()</span><br><span class="line">                    + <span class="string">" -&gt; "</span> + channel.getRemoteAddress()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 收到结果后，移除关联的的 Channel，它的使命已完成</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        CHANNELS.remove(response.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置响应结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Response res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 设置结果</span></span><br><span class="line">        response = res;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  唤醒等待线程 &#123;<span class="doctag">@link</span> #get()&#125;，然后执行 returnFromResponse 方法返回结果</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (done != <span class="keyword">null</span>) &#123;</span><br><span class="line">            done.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有事件回调，就执行回调逻辑。</span></span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        invokeCallback(callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当请求的响应结果返回时，会找到响应关联的 DefaultFuture 对象（根据请求编号从缓存集合中查找）并调用 doReceived() 方法，进而设置响应结果 <strong>response 属性</strong>的值。</p><h3 id="连接断开异常"><a href="#连接断开异常" class="headerlink" title="连接断开异常"></a>连接断开异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当 Channel 断开连接时，应该对其关联的 request 进行异常结果响应，以结束阻塞等待的业务线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel channel to close</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeChannel</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> id : CHANNELS.keySet()) &#123;</span><br><span class="line">        <span class="comment">// 取出断开连接的Channel关联的Request对应的 DefaultFuture</span></span><br><span class="line">        <span class="keyword">if</span> (channel.equals(CHANNELS.get(id))) &#123;</span><br><span class="line">            DefaultFuture future = getFuture(id);</span><br><span class="line">            <span class="comment">// 如果请求结果还没有返回，则返回异常状态的结果</span></span><br><span class="line">            <span class="keyword">if</span> (future != <span class="keyword">null</span> &amp;&amp; !future.isDone()) &#123;</span><br><span class="line">                <span class="comment">// 构造响应 Response ，注意响应编号。</span></span><br><span class="line">                Response disconnectResponse = <span class="keyword">new</span> Response(future.getId());</span><br><span class="line">                disconnectResponse.setStatus(Response.CHANNEL_INACTIVE);</span><br><span class="line">                disconnectResponse.setErrorMessage(<span class="string">"Channel "</span> +</span><br><span class="line">                        channel +</span><br><span class="line">                        <span class="string">" is inactive. Directly return the unFinished request : "</span> +</span><br><span class="line">                        future.getRequest());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置响应结果 response</span></span><br><span class="line">                DefaultFuture.received(channel, disconnectResponse);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>closeChannel() 方法比较简单，用于处理连接断开无法正常响应结果给业务线程的情况。</p><h3 id="取消-DefaultFuture"><a href="#取消-DefaultFuture" class="headerlink" title="取消 DefaultFuture"></a>取消 DefaultFuture</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+---- DefaultFuture</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除当前请求关联的 Channel、DefaultFuture</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建响应结果对象</span></span><br><span class="line">        Response errorResult = <span class="keyword">new</span> Response(id);</span><br><span class="line">        errorResult.setErrorMessage(<span class="string">"request future has been canceled."</span>);</span><br><span class="line">        response = errorResult;</span><br><span class="line">        <span class="comment">// 移除请求关联的 DefaultFuture，Channel</span></span><br><span class="line">        FUTURES.remove(id);</span><br><span class="line">        CHANNELS.remove(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>用于发送请求失败的情况，由于发送请求之前进行了请求关联 DefaultFuture 和 Channel ，因此需要移除该请求关联的对象。此外，创建一个异常结果，防止有业务线程在等待请求结果。</p><h3 id="设置回调"><a href="#设置回调" class="headerlink" title="设置回调"></a>设置回调</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+--- DefaultFuture</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.protocol.dubbo.filter.FutureFilter#asyncCallback(com.alibaba.dubbo.rpc.Invoker, com.alibaba.dubbo.rpc.Invocation)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(ResponseCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果有响应则立即执行回调</span></span><br><span class="line">        <span class="keyword">if</span> (isDone()) &#123;</span><br><span class="line">            invokeCallback(callback);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isdone = <span class="keyword">false</span>;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没有响应，则先保存回调，收到结果再执行回调逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.callback = callback;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    isdone = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再尝试一次</span></span><br><span class="line">            <span class="keyword">if</span> (isdone) &#123;</span><br><span class="line">                invokeCallback(callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>设置回调是 FutureFilter 处理异步调用时调用的，目的是在返回调用结果时执行事件回调。</p><h3 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行回调逻辑</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeCallback</span><span class="params">(ResponseCallback c)</span> </span>&#123;</span><br><span class="line">      ResponseCallback callbackCopy = c;</span><br><span class="line">      <span class="keyword">if</span> (callbackCopy == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"callback cannot be null."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Response res = response;</span><br><span class="line">      <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"response cannot be null. url:"</span> + channel.getUrl());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 正常响应</span></span><br><span class="line">      <span class="keyword">if</span> (res.getStatus() == Response.OK) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 执行回调 - 处理执行结果</span></span><br><span class="line">              callbackCopy.done(res.getResult());</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              logger.error(<span class="string">"callback invoke error .reasult:"</span> + res.getResult() + <span class="string">",url:"</span> + channel.getUrl(), e);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 超时处理 TimeoutException 异常</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              TimeoutException te = <span class="keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage());</span><br><span class="line">              <span class="comment">// 执行回调 - 处理 TimeoutException 异常</span></span><br><span class="line">              callbackCopy.caught(te);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              logger.error(<span class="string">"callback invoke error ,url:"</span> + channel.getUrl(), e);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 处理其他异常</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              RuntimeException re = <span class="keyword">new</span> RuntimeException(res.getErrorMessage());</span><br><span class="line">              <span class="comment">// 执行回调 - 处理RuntimeException</span></span><br><span class="line">              callbackCopy.caught(re);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              logger.error(<span class="string">"callback invoke error ,url:"</span> + channel.getUrl(), e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在设置响应结果后，如果设置了事件回调则执行回调逻辑。</p><h1 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h1><p>Exchange 层通道处理器继承关系如下图所示：</p><p><img src="/posts/26722deb/dubbo-remoting-exchange-handler-hierarchy.jpg" alt></p><p>在 Transport 层已经介绍了大量 ChannelHandler，特别是 ChannelHandlerDelegate 类型的 ChannelHandler ，它们属于处理器装饰者接口，在 Exchange 层新定义了两个该类型的处理器 HeartbeatHandler 和 HeaderExchangeHandler。此外，Exchange 层还定义了一个<strong>供上层使用的 ExchangeHandler 接口及其抽象实现类 ExchangeHandlerAdapter</strong>。无论是发送请求还是处理响应都会涉及到 ChannelHandler。</p><h2 id="HeartbeatHandler"><a href="#HeartbeatHandler" class="headerlink" title="HeartbeatHandler"></a>HeartbeatHandler</h2><p>专门处理心跳消息的 ChannelHandler 实现，同样是在原有的 ChannelHandler 的基础上添加一些功能。</p><h3 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatHandler</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HeartbeatHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置Channel的读时间戳 的 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String KEY_READ_TIMESTAMP = <span class="string">"READ_TIMESTAMP"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置Channel的写时间戳 的 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String KEY_WRITE_TIMESTAMP = <span class="string">"WRITE_TIMESTAMP"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装饰 ChannelHandler</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeartbeatHandler</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 设置 Channel 读时间戳</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setReadTimestamp</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">     channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 设置 Channel 写时间戳</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setWriteTimestamp</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">     channel.setAttribute(KEY_WRITE_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 清理 Channel 中读时间戳</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearReadTimestamp</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">     channel.removeAttribute(KEY_READ_TIMESTAMP);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 清理 Channel 中写时间戳</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearWriteTimestamp</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">     channel.removeAttribute(KEY_WRITE_TIMESTAMP);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是否是心跳请求</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isHeartbeatRequest</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> message <span class="keyword">instanceof</span> Request &amp;&amp; ((Request) message).isHeartbeat();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是否是心跳响应</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isHeartbeatResponse</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> message <span class="keyword">instanceof</span> Response &amp;&amp; ((Response) message).isHeartbeat();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接完成时，设置通道的最后读写时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    setReadTimestamp(channel);</span><br><span class="line">    setWriteTimestamp(channel);</span><br><span class="line">    <span class="comment">// 设置最后读写时间后，传递给底层的 ChannelHandler 对象进行处理</span></span><br><span class="line">    handler.connected(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HeartbeatHandler 处理连接建立只是记录了通道的最后读写时间。</p><h3 id="连接断开"><a href="#连接断开" class="headerlink" title="连接断开"></a>连接断开</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接断开时，清空通道的最后读写时间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    clearReadTimestamp(channel);</span><br><span class="line">    clearWriteTimestamp(channel);</span><br><span class="line">    <span class="comment">// 清理读写时间后，传递给底层的 ChannelHandler 对象进行处理</span></span><br><span class="line">    handler.disconnected(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HeartbeatHandler 处理连接断开只是清理了最后读写时间。</p><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 发送消息后，设置最后写的时间</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sent</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">       setWriteTimestamp(channel);</span><br><span class="line">       <span class="comment">// 记录最后写时间后，传递给底层的 ChannelHandler 对象进行处理</span></span><br><span class="line">       handler.sent(channel, message);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>HeartbeatHandler 处理发送消息只是记录了最后的写时间，然后传递给底层的 ChannelHandler 对象继续处理。</p><h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 收到消息，设置最后读时间</span></span><br><span class="line"><span class="comment">   * 1. 收到心跳请求的时候，会生成相应的心跳响应并返回；</span></span><br><span class="line"><span class="comment">   * 2. 收到心跳响应的时候，会打印相应的日志；</span></span><br><span class="line"><span class="comment">   * 3. 在收到其他类型的消息时，会传递给底层的 ChannelHandler 对象进行处理</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1 设置最后读时间</span></span><br><span class="line">      setReadTimestamp(channel);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2 收到心跳请求，则生成对应的心跳响应并返回</span></span><br><span class="line">      <span class="keyword">if</span> (isHeartbeatRequest(message)) &#123;</span><br><span class="line">          Request req = (Request) message;</span><br><span class="line">          <span class="comment">// 需要响应</span></span><br><span class="line">          <span class="keyword">if</span> (req.isTwoWay()) &#123;</span><br><span class="line">              <span class="comment">// 设置请求id，为了和请求一一对应</span></span><br><span class="line">              Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">              <span class="comment">// 心跳事件</span></span><br><span class="line">              res.setEvent(Response.HEARTBEAT_EVENT);</span><br><span class="line">              <span class="comment">// 心跳响应</span></span><br><span class="line">              channel.send(res);</span><br><span class="line">              <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                  <span class="keyword">int</span> heartbeat = channel.getUrl().getParameter(Constants.HEARTBEAT_KEY, <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                      logger.debug(<span class="string">"Received heartbeat from remote channel "</span> + channel.getRemoteAddress()</span><br><span class="line">                              + <span class="string">", cause: The channel has no data-transmission exceeds a heartbeat period"</span></span><br><span class="line">                              + (heartbeat &gt; <span class="number">0</span> ? <span class="string">": "</span> + heartbeat + <span class="string">"ms"</span> : <span class="string">""</span>));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3 收到心跳响应，则打印日志</span></span><br><span class="line">      <span class="keyword">if</span> (isHeartbeatResponse(message)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">              logger.debug(<span class="string">"Receive heartbeat response in thread "</span> + Thread.currentThread().getName());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4 其它类型消息，则传递给底层的 ChannelHandler 对象进行处理</span></span><br><span class="line">      handler.received(channel, message);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>HeartbeatHandler 在处理接收消息时有几个点需要注意：</p><ol><li>收到消息回记录最后读的时间。</li><li>如果收到的是心跳请求消息，则生成该请求的响应并返回给业务线程，不会再往下传递即HeartbeatHandler后面的ChannelHandler没有机会处理这个消息。</li><li>如果收到的是心跳响应消息，则打印日志即可，同样不会再往下传递即HeartbeatHandler后面的ChannelHandler没有机会处理这个消息。</li><li>如果不是 2、3 步的情况，则直接传递给底层的 ChannelHandler 对象进行处理。</li></ol><p>需要注意的是，HeartbeatHandler 定义在 Exchange 层，但是使用是在 transport 层，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无论是Client还是Server，在构造方法中都会将传入的ChannelHandler进行包装，为该 ChannelHandler 增加了 Dubbo 消息派发、心跳处理以及多消息处理的功能。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ChannelHandler <span class="title">wrapInternal</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MultiMessageHandler( <span class="comment">// 多消息处理</span></span><br><span class="line">                <span class="keyword">new</span> HeartbeatHandler( <span class="comment">// 心跳处理</span></span><br><span class="line">                        ExtensionLoader.getExtensionLoader(Dispatcher<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                                .<span class="title">getAdaptiveExtension</span>() </span></span><br><span class="line"><span class="class">                                .<span class="title">dispatch</span>(<span class="title">handler</span>, <span class="title">url</span>) // 返回的是一个 <span class="title">ChannelHandlerDelegate</span> 类型的对象，默认是 <span class="title">AllChannelHandler</span>，确定了具体的线程模型</span></span><br><span class="line"><span class="class">                )</span></span><br><span class="line"><span class="class">        )</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="HeaderExchangeHandler"><a href="#HeaderExchangeHandler" class="headerlink" title="HeaderExchangeHandler"></a>HeaderExchangeHandler</h2><p>HeaderExchangeHandler 是一个装饰者类型的 ChannelHandler，内部封装了 ExchangeHandler 对象，而 ExchangeHandler 是上层与 Exchange 层交互的重要接口，上层调用方可以实现该接口完成特定功能。经过 HeaderExchangeHandler 装饰的 ExchangeHandler 对象具备 Exchange 层处理请求和响应的能力，最后再经过 Transport 层的 ChannelHandler 装饰而具备 Transport 层处理消息的能力。装饰流程如下图所示：</p><p><img src="/posts/26722deb/dubbo-remoting-exchange-wrap.jpg" alt></p><p>HeaderExchangeHandler 作为一个装饰器，其 <strong>对 Channel 中的逻辑处理最终都会委托给被装饰的对象即上层提供的 ExchangeHandler 进行处理，HeaderExchangeHandler 本身关注点在于对 Request 和 Response 的处理逻辑</strong>。</p><p>下面分析 HeaderExchangeHandler 对 Channel 中的逻辑处理。</p><h3 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeHandler</span> <span class="keyword">implements</span> <span class="title">ChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HeaderExchangeHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置Channel的读时间戳 的 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String KEY_READ_TIMESTAMP = HeartbeatHandler.KEY_READ_TIMESTAMP;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置Channel的写时间戳 的 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String KEY_WRITE_TIMESTAMP = HeartbeatHandler.KEY_WRITE_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被装饰的 ChannelHandler,由上层传入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeHandler</span><span class="params">(ExchangeHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HeaderExchangeHandler 实现了 ChannelHandlerDelegate 接口，基于消息头部的信息交换处理器实现类。</p><h3 id="获取被装饰的-ChannelHandler"><a href="#获取被装饰的-ChannelHandler" class="headerlink" title="获取被装饰的 ChannelHandler"></a>获取被装饰的 ChannelHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取被装饰的 ChannelHandler</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果被装饰的 ChannelHandler 属于装饰者类型就获取其装饰的 handler</span></span><br><span class="line">     <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ChannelHandlerDelegate) &#123;</span><br><span class="line">         <span class="keyword">return</span> ((ChannelHandlerDelegate) handler).getHandler();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> handler;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="连接建立-1"><a href="#连接建立-1" class="headerlink" title="连接建立"></a>连接建立</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对连接建立的处理</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> channel 底层的 Dubbo Channel</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">      <span class="comment">// 1. 设置读写时间戳</span></span><br><span class="line">      channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line">      channel.setAttribute(KEY_WRITE_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 创建 channel 相应的 HeaderExchangeChannel 并将两者绑定.</span></span><br><span class="line">      ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 3. 通知上层 ExchangeHandler 处理 connect 事件</span></span><br><span class="line">          handler.connected(exchangeChannel);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 4. 若channel已经断开，则 解绑 channel 与 HeaderExchangeChannel 的联系</span></span><br><span class="line">          HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="连接断开-1"><a href="#连接断开-1" class="headerlink" title="连接断开"></a>连接断开</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对连接断开的处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel channel.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 设置读写时间戳</span></span><br><span class="line">    channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line">    channel.setAttribute(KEY_WRITE_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建 channel 相应的 HeaderExchangeChannel 并将两者绑定.</span></span><br><span class="line">    ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 通知上层 ExchangeHandler 处理 disconnect</span></span><br><span class="line">        handler.disconnected(exchangeChannel);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 调用 DefaultFuture.closeChannel 方法通知 DefaultFuture 连接断开了，避免连接断开了还在阻塞业务线程。</span></span><br><span class="line">        <span class="comment">// DefaultFuture 接到连接断开通知后会先获取连接对应的请求，再通过请求找到关联的 DefaultFuture，判断该请求是否响应，没有响应就创建一个状态码为 CHANNEL_INACTIVE 的 Response 并设置到结果属性。</span></span><br><span class="line">        DefaultFuture.closeChannel(channel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 解绑 channel 与 HeaderExchangeChannel 的联系</span></span><br><span class="line">        HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理发送的数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel 底层的 Dubbo Channel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> message 可能是请求/响应 消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sent</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 设置写时间</span></span><br><span class="line">        channel.setAttribute(KEY_WRITE_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line">        <span class="comment">// 2. 创建 channel 相应的 HeaderExchangeChannel 并将两者绑定.</span></span><br><span class="line">        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 通知上层 ExchangeHandler 实现的 sent() 方法</span></span><br><span class="line">            handler.sent(exchangeChannel, message);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 4.  若channel已经断开，则 解绑 channel 与 HeaderExchangeChannel 的联系</span></span><br><span class="line">            HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上层 ExchangeHandler 实现的 sent() 方法 执行异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        exception = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 如果是请求，则调用 DefaultFuture.sent() 方法更新请求的具体发送时间</span></span><br><span class="line">    <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">        Request request = (Request) message;</span><br><span class="line">        DefaultFuture.sent(channel, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 如果发送消息出现异常，则进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) exception;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> RemotingException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RemotingException) exception;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(channel.getLocalAddress(), channel.getRemoteAddress(),</span><br><span class="line">                    exception.getMessage(), exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 HeaderExchangeChannel.request() 方法中创建了 DefaultFuture 对象，然后将请求通过装饰的 Dubbo Channel 发送出去。请求会通过 Channel 进行传输，在传输的过程中会触发沿途的 ChannelHandler.sent() 等方法，HeaderExchangeHandler 的 sent() 处理逻辑包括调用 DefaultFuture.sent() 方法更新 DefaultFuture 中的 sent 的值即更新请求发送时间。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 捕获到异常</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> channel   底层的 Dubbo Channel</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> exception exception.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 1. 当发生 ExecutionException 异常（线程池处理任务异常）</span></span><br><span class="line">     <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ExecutionException) &#123;</span><br><span class="line">         ExecutionException e = (ExecutionException) exception;</span><br><span class="line">         Object msg = e.getRequest();</span><br><span class="line">         <span class="comment">// 1.1 消息是请求时</span></span><br><span class="line">         <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">             Request req = (Request) msg;</span><br><span class="line">             <span class="comment">// 1.2 需要响应时且非心跳请求</span></span><br><span class="line">             <span class="keyword">if</span> (req.isTwoWay() &amp;&amp; !req.isHeartbeat()) &#123;</span><br><span class="line">                 <span class="comment">// 发送状态码为 SERVER_ERROR 的响应</span></span><br><span class="line">                 Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">                 res.setStatus(Response.SERVER_ERROR);</span><br><span class="line">                 res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">                 channel.send(res);</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2. 创建 channel 相应的 HeaderExchangeChannel 并将两者绑定.</span></span><br><span class="line">     ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 3. 通知上层 ExchangeHandler 实现的 caught() 方法</span></span><br><span class="line">         handler.caught(exchangeChannel, exception);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 4. 若channel已经断开，则 解绑 channel 与 HeaderExchangeChannel 的联系</span></span><br><span class="line">         HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>HeaderExchangeHandler 属于 Dubbo 中 ChannelHandler 链的一部分，并且是 Transport 层的 ChannelHandler 装饰的对象，Transport 层实现了 Dubbo 的线程模型，但是线程池执行时可能会发生异常，而这个异常就是 ExecutionException 。</p><p>如果线程池执行任务发生异常就会抛出该异常，HeaderExchangeHandler 最后会捕获到该异常。异常具体位置如下图所示：</p><p><img src="/posts/26722deb/dubbo-remoting-transport-dispatcher-exception.jpg" alt></p><h3 id="接收消息-1"><a href="#接收消息-1" class="headerlink" title="接收消息"></a>接收消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 接收消息</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> channel 底层的 Dubbo Channel</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> message message 消息</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="comment">// 1. 设置最后的读时间</span></span><br><span class="line">     channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line">     <span class="comment">// 2. 创建 channel 相应的 HeaderExchangeChannel 并将两者绑定.</span></span><br><span class="line">     ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 3. 对收到的消息分类</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 3.1 处理请求消息</span></span><br><span class="line">         <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">             Request request = (Request) message;</span><br><span class="line">             <span class="comment">// 3.1.1 只读请求</span></span><br><span class="line">             <span class="keyword">if</span> (request.isEvent()) &#123;</span><br><span class="line">                 <span class="comment">// 在Channel上设置'channel.readonly' 标志，然后往下传即可。</span></span><br><span class="line">                 handlerEvent(channel, request);</span><br><span class="line">                 <span class="comment">// 处理普通请求</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 3.1.2 需要响应，要将响应写回请求方</span></span><br><span class="line">                 <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                     <span class="comment">// 处理请求</span></span><br><span class="line">                     Response response = handleRequest(exchangeChannel, request);</span><br><span class="line">                     <span class="comment">// 将调用结果返回给服务消费端</span></span><br><span class="line">                     channel.send(response);</span><br><span class="line">                     </span><br><span class="line">                     <span class="comment">// 3.1.3 不需要响应，直接交给上层实现的 ExchangeHandler 进行处理</span></span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     handler.received(exchangeChannel, request.getData());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 3.2 处理响应响应消息</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">             <span class="comment">// 将关联的 DefaultFuture 设置为完成状态（或是异常完成状态）</span></span><br><span class="line">             handleResponse(channel, (Response) message);</span><br><span class="line">             </span><br><span class="line">             <span class="comment">// 3.3 处理String类型的消息，根据当前服务的角色进行分类处理</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 3.3.1 客户端侧 不支持String</span></span><br><span class="line">             <span class="keyword">if</span> (isClientSide(channel)) &#123;</span><br><span class="line">                 Exception e = <span class="keyword">new</span> Exception(<span class="string">"Dubbo client can not supported string message: "</span> + message + <span class="string">" in channel: "</span> + channel + <span class="string">", url: "</span> + channel.getUrl());</span><br><span class="line">                 logger.error(e.getMessage(), e);</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 3.3.2 服务端侧，目前仅有 telnet 命令的情况</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 调用 handler 的 telnet方法，处理telnet命令，并将执行命令的结果发送可客户端。【注意：ExchangeHandler实现了TelnetHandler接口】</span></span><br><span class="line">                 String echo = handler.telnet(channel, (String) message);</span><br><span class="line">                 <span class="keyword">if</span> (echo != <span class="keyword">null</span> &amp;&amp; echo.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                     channel.send(echo);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 3.4 其他情况，直接交给上层实现的 ExchangeHandler 进行处理</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             handler.received(exchangeChannel, message);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// 4. 若channel已经断开，则 解绑 channel 与 HeaderExchangeChannel 的联系</span></span><br><span class="line">         HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>由于收到消息的类型可能有多种，不同类型处理逻辑也不相同，下面对消息分类处理进行说明。</p><h4 id="只读请求"><a href="#只读请求" class="headerlink" title="只读请求"></a>只读请求</h4><p>只读请求由 handlerEvent() 方法进行处理，它会在 Channel 上设置 <strong>channel.readonly</strong> 标识，客户端收到只读事件请求后，后续不再向对应的服务发送新的请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理只读事件请求</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> channel 底层 Dubbo 通道</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> req     请求</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handlerEvent</span><span class="params">(Channel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">      <span class="comment">// 如果是只读请求 'R' </span></span><br><span class="line">      <span class="keyword">if</span> (req.getData() != <span class="keyword">null</span> &amp;&amp; req.getData().equals(Request.READONLY_EVENT)) &#123;</span><br><span class="line">          <span class="comment">// 客户端收到 READONLY_EVENT 事件请求后记录到通道，后续不再向该服务器发送新的请求</span></span><br><span class="line">          channel.setAttribute(Constants.CHANNEL_ATTRIBUTE_READONLY_KEY, Boolean.TRUE);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="双向请求"><a href="#双向请求" class="headerlink" title="双向请求"></a>双向请求</h4><p>双向请求即需要响应的请求由 handleRequest() 方法进行处理，该方法会先判断请求是否解码失败，如果解码失败则返回异常响应，如果请求解码成功则会将正常解码的请求交给上层实现的 ExchangeHandler 进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理普通请求 - 需要响应</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> channel 底层 Dubbo 通道</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Response <span class="title">handleRequest</span><span class="params">(ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">      <span class="comment">// 创建响应对象</span></span><br><span class="line">      Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果是解码失败的请求，则返回状态为 BAD_REQUEST 的异常结果</span></span><br><span class="line">      <span class="keyword">if</span> (req.isBroken()) &#123;</span><br><span class="line">          <span class="comment">// 请求数据，转成 msg</span></span><br><span class="line">          Object data = req.getData();</span><br><span class="line">          String msg;</span><br><span class="line">          <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">              msg = <span class="keyword">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line">              msg = StringUtils.toString((Throwable) data);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              msg = data.toString();</span><br><span class="line">          &#125;</span><br><span class="line">          res.setErrorMessage(<span class="string">"Fail to decode request due to: "</span> + msg);</span><br><span class="line">          res.setStatus(Response.BAD_REQUEST);</span><br><span class="line">          <span class="comment">// 返回</span></span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取请求数据，这里一般是 RpcInvocation 对象</span></span><br><span class="line">      Object msg = req.getData();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 交给上层实现的 ExchangeHandler 进行处理</span></span><br><span class="line">          Object result = handler.reply(channel, msg);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 封装请求状态和结果</span></span><br><span class="line">          res.setStatus(Response.OK);</span><br><span class="line">          res.setResult(result);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 上层实现的 ExchangeHandler 处理异常</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 若调用过程出现异常，则设置 SERVICE_ERROR，表示服务端异常</span></span><br><span class="line">          res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">          res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 返回响应</span></span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，在 Dubbo 2.7 版本中已经支持服务端的异步处理，通过 Java 8 的 CompletableFuture 来实现。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="comment">// 创建响应对象</span></span><br><span class="line">    Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">    <span class="comment">// 请求解码失败</span></span><br><span class="line">    <span class="keyword">if</span> (req.isBroken()) &#123; </span><br><span class="line">        Object data = req.getData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置异常信息和响应码，将异常响应返回给对端</span></span><br><span class="line">        res.setErrorMessage(<span class="string">"Fail to decode request due to: "</span> + msg);</span><br><span class="line">        res.setStatus(Response.BAD_REQUEST); </span><br><span class="line">        channel.send(res); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object msg = req.getData();</span><br><span class="line">    <span class="comment">// 交给上层实现的ExchangeHandler进行处理</span></span><br><span class="line">    CompletionStage&lt;Object&gt; future = handler.reply(channel, msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求处理后的回调</span></span><br><span class="line">    future.whenComplete((appResult, t) -&gt; &#123; </span><br><span class="line">        <span class="comment">// 返回正常响应</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            res.setStatus(Response.OK);</span><br><span class="line">            res.setResult(appResult);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 处理过程发生异常，设置异常信息和错误码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">            res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送响应</span></span><br><span class="line">        channel.send(res); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单向请求"><a href="#单向请求" class="headerlink" title="单向请求"></a>单向请求</h4><p>单向请求即调用方不需要返回结果，直接交给上层 ExchangeHandler 实现的 received() 方法进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler.received(exchangeChannel, request.getData());</span><br></pre></td></tr></table></figure><h4 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h4><p>处理接收到的 Response 消息，也就是返回了结果，只需要 HeaderExchangeHandler 调用 handleResponse() 方法将关联的 DefaultFuture 设置为完成状态（或是异常完成状态），然后向下传递即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 处理响应 - 客户端收到服务端的响应</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> channel  底层 Dubbo 通道</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> response 响应</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(Channel channel, Response response)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">       <span class="comment">// 只处理非心跳事件响应，调用DefaultFuture#received(channel, response) 方法设置响应结果以及唤醒等待请求结果的线程。</span></span><br><span class="line">       <span class="keyword">if</span> (response != <span class="keyword">null</span> &amp;&amp; !response.isHeartbeat()) &#123;</span><br><span class="line">           DefaultFuture.received(channel, response);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在 HeaderExchangeChannel.request() 方法中完成 DefaultFuture 对象的创建后，会将请求通过装饰的 Dubbo Channel 发送出去，发送的过程会触发 Dubbo Channel 中 ChannelHandler 链，至于是 IO 线程处理请求还是通过线程池来处理请求，需要看具体的消息派发策略。服务端处理完请求后，会将结果发送到对端，消费端读取到完整响应后，同样会触发 Dubbo Channel 中 ChannelHandler 链，当响应传递到 HeaderExchangeHandler 时 received() 方法会触发，执行该方法的内部逻辑，也就是调用 handleResponse() 方法设置响应结果并唤醒等待请求结果的线程。</p><h4 id="处理String类型消息"><a href="#处理String类型消息" class="headerlink" title="处理String类型消息"></a>处理String类型消息</h4><p>对于 String 类型的消息，HeaderExchangeHandler 会根据当前服务的角色进行分类处理，目前仅支持 <strong>telnet</strong> 命令。</p><h4 id="兜底处理"><a href="#兜底处理" class="headerlink" title="兜底处理"></a>兜底处理</h4><p>如果接收的消息不是以上类型，则直接交给上层实现的 ExchangeHandler 进行处理。</p><h2 id="ExchangeHandler"><a href="#ExchangeHandler" class="headerlink" title="ExchangeHandler"></a>ExchangeHandler</h2><p>ExchangeHandler 是 Exchange 层定义的供上层使用的信息交换处理器接口，该接口继承了 ChannelHandler 和 TelnetHandler 接口，它同样是一个 ChannelHandler 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExchangeHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span>, <span class="title">TelnetHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> response  返回请求结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object request)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExchangeHandler 新定义了 <strong>reply()</strong> 方法，该方法主要用来处理请求并返回请求结果，上文中的 HeaderExchangeHandler.handleRequest() 方法处理双向请求的过程就是将 <strong>reply()</strong> 方法返回结果设置到 <strong>Response.mResult</strong> 属性中。</p><h2 id="ExchangeHandlerAdapter"><a href="#ExchangeHandlerAdapter" class="headerlink" title="ExchangeHandlerAdapter"></a>ExchangeHandlerAdapter</h2><p>信息交换处理器适配器抽象类，实现了 ExchangeHandler 接口并继承了 TelnetHandlerAdapter 类，空实现了 <strong>reply</strong> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangeHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">TelnetHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ExchangeHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object msg)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExchangeHandler 接口虽然属于 ChannelHandler 类型，但是该接口的定位是供 Exchange 层的上层使用，其实就是 Protocol 层。截止到目前，我们不难发现 ExchangeHandler 的实现就是整个 ChannelHandler 链的最尾的一个节点，这意味着上层逻辑的直接处理对象就是该实现。</p><p>由于 ExchangeHandlerAdapter 实现了 ExchangeHandler 接口，在 DubboProtocol、ThirftProtocol 中都会基于 ExchangeHandlerAdapter 实现自己的处理器，处理请求并返回结果，如 DubboProtocol 中的处理器实现，简化后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;</span><br><span class="line">       <span class="comment">// 用于处理服务消费者的同步调用和异步调用的请求</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Object <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Invocation) &#123;</span><br><span class="line">               <span class="comment">// 转成 Invocation</span></span><br><span class="line">               Invocation inv = (Invocation) message;</span><br><span class="line">               <span class="comment">// 根据调用信息获取 Invoker</span></span><br><span class="line">               Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">               <span class="comment">// 执行调用</span></span><br><span class="line">               <span class="keyword">return</span> invoker.invoke(inv);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">         <span class="comment">//... 省略代码</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">           <span class="comment">//... 省略代码</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">          <span class="comment">//... 省略代码</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="异步转同步"><a href="#异步转同步" class="headerlink" title="异步转同步"></a>异步转同步</h2><p>Dubbo 协议下使用的网络通信底层依赖的是 NIO 组件，而这些 NIO 组件是异步通讯机制。既然底层是异步处理请求，那么 Dubbo 是怎样实现同步调用的呢？其实 Dubbo 异步调用和同步调用差不多，区别在于获取调用结果的时机。在分析异步转同步前，我们先简单说明下 Dubbo 中的同步调用和异步调用。</p><h3 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h3><p>同步调用是一种阻塞式的调用方式，消费方发起调用后会处于阻塞等待状态，直到服务提供方返回结果（这里不考虑超时、异常等异常流）。过程如下：</p><ol><li>消费方业务线程调用远程服务接口，同时当前业务线程处于阻塞状态。</li><li>服务提供方收到消费方的请求后会对请求进行处理，处理完毕会将结果发送到对端。</li><li>消费方收到调用结果后，阻塞的业务线程继续往下执行。</li></ol><p>上述同步调用过程有 3 个点值得关注：</p><ol><li>业务线程是怎么进入阻塞状态的</li><li>如何定义消费方收到调用结果</li><li>业务线程是如何唤醒的</li></ol><p>要弄清楚上面的问题需要从源码中找线索，我们先下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboInvoker.doInvoke()</span><br><span class="line">    <span class="comment">// 异步无返回值</span></span><br><span class="line">    <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">       <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">       <span class="comment">// 发送请求</span></span><br><span class="line">       currentClient.send(inv, isSent);</span><br><span class="line">       <span class="comment">// 设置上下文中的 future 为 null</span></span><br><span class="line">       RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">// 返回一个空的 RpcResult</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">      &#125; </span><br><span class="line">                                                </span><br><span class="line">   <span class="comment">// 异步有返回值</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (isAsync) &#123;</span><br><span class="line">      <span class="comment">// 发送请求，获得 ResponseFuture 实例</span></span><br><span class="line">      ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class="line">      <span class="comment">// 设置 future 到上下文中</span></span><br><span class="line">      RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter&lt;Object&gt;(future));</span><br><span class="line">      <span class="comment">// 暂时返回一个空结果</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">      &#125; </span><br><span class="line">                                                </span><br><span class="line">   <span class="comment">// 同步调用</span></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">     RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">// 发送请求，得到一个 ResponseFuture 实例，并调用该实例的 get 方法进行等待</span></span><br><span class="line">     <span class="keyword">return</span> (Result) currentClient.request(inv, timeout).get();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看到上面的代码后，是不是已经有了结论。关键点在消费方调用后会得到一个 ResponseFuture 对象，该对象在前文已经详细介绍过了。同步调用时，业务线程直接执行 ResponseFuture.get() 方法阻塞等待结果返回，一般消费方会定义超时时间（没有定义则使用默认超时时间）。当服务提供方返回结果后，通过执行 received() 方法将结果设置到 ResponseFuture 中，并唤醒阻塞等待的业务线程。如果超过最大等待时间结果还未返回，则业务线程会抛出异常。</p><h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p>Dubbo 默认使用的是同步调用，如果要使用异步调用需要消费方自行配置。Dubbo 的异步调用和同步调用类似，区别在于业务线程获取调用结果的时机是可控的。业务线程发起调用后并没有立即获取调用结果，而是将 ResponseFuture 保存到了 Dubbo 的上线文中，然后继续向下执行其它逻辑，当需要调用结果时可以随时从上下文中取出 ResponseFuture 并执行 get() 方法来获取。</p><h3 id="转化流程图"><a href="#转化流程图" class="headerlink" title="转化流程图"></a>转化流程图</h3><p><img src="/posts/26722deb/dubbo-remoting-exchange-process-conversion.jpg" alt></p><p>上图简单描述了 Dubbo 异步转同步的过程，包括了同步调用和异步调用。</p><h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>Exchange 层服务继承关系如下图所示：</p><p><img src="/posts/26722deb/dubbo-remoting-exchange-server-hierarchy.jpg" alt></p><p>上图中的 Endpoint、Server 和 Resetable 这三个接口在前面的文章中已经详细介绍过了，这里不再重复。</p><h2 id="ExchangeServer-接口"><a href="#ExchangeServer-接口" class="headerlink" title="ExchangeServer 接口"></a>ExchangeServer 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExchangeServer</span> <span class="keyword">extends</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得信息交换通道集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channels</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Collection&lt;ExchangeChannel&gt; <span class="title">getExchangeChannels</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据地址获取信息交换通道</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remoteAddress</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ExchangeChannel <span class="title">getExchangeChannel</span><span class="params">(InetSocketAddress remoteAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExchangeServer 继承了 Server 接口，在其基础之上新增了两个和信息交换层相关的通道方法。</p><h2 id="HeaderExchangeServer"><a href="#HeaderExchangeServer" class="headerlink" title="HeaderExchangeServer"></a>HeaderExchangeServer</h2><p>HeaderExchangeServer 实现了 ExchangeServer 接口，基于消息头的信息交换服务器实现类，是 Transport 层 Server 的装饰器，实现自 Server 接口的方法（包括 Server 继承的接口）几乎都是委托给装饰的 Server 对象。HeaderExchangeServer 主要为其修饰的 Server 添加了定时发送心跳消息的实现，用以关闭长时间没有客户端连接的通道。</p><h3 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeServer</span> <span class="keyword">implements</span> <span class="title">ExchangeServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳检测 Schedule</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduled = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-remoting-server-heartbeat"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被装饰的 Transport 层的服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Server server;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳检测定时器 Future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture&lt;?&gt; heartbeatTimer;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳间隔时间，毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeat;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳超时时间，毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeatTimeout;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否关闭，默认关闭状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean closed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键属性 Server、heartbeat 以及 heartbeatTimeout 是在 HeaderExchangeServer 构造方法中完成初始化的。</p><h3 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 构造方法</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> server Transport 层的 Server 对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeServer</span><span class="params">(Server server)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"server == null"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">this</span>.server = server;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 在此之前 Constants.HEARTBEAT_KEY 默认已经有值了， 如果手动配置就使用配置的，如果没有配置默认是 60</span></span><br><span class="line">     <span class="keyword">this</span>.heartbeat = server.getUrl().getParameter(Constants.HEARTBEAT_KEY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// heartbeatTimeout：默认是 heartbeat * 3</span></span><br><span class="line">     <span class="keyword">this</span>.heartbeatTimeout = server.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * <span class="number">3</span>);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 检测心跳超时时间是否合法</span></span><br><span class="line">     <span class="keyword">if</span> (heartbeatTimeout &lt; heartbeat * <span class="number">2</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"heartbeatTimeout &lt; heartbeatInterval * 2"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 默认在 heartbeat（默认是60s）内如果没有收到消息，就会发送心跳消息，如果连着3次（默认180s）没有收到心跳响应，provider会关闭channel。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     startHeartbeatTimer();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>构造方法主要的工作如下：</strong></p><ol><li>封装 Transport 层的 Server 对象，此后 HeaderExchangeServer 的服务工作都会交给该对象。</li><li>读取心跳相关配置，注意心跳间隔和心跳超时时间的关系，以及各自的默认值</li><li>启动心跳检测 Schedule</li></ol><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>Exchange 层客户端继承关系如下图所示：</p><p><img src="/posts/26722deb/dubbo-remoting-exchange-client-hierarchy.jpg" alt></p><h1 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h1><p>Exchange 层编解码器继承关系如下图所示：</p><p><img src="/posts/26722deb/dubbo-remoting-exchange-codec-hierarchy.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面的几篇文章详细介绍了 Dubbo Remoting 中的 Transport 层，它是 Dubbo 中的端到端的统一网络传输实现。本篇文
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 线程池</title>
    <link href="https://gentryhuang.com/posts/f3cd85ef/"/>
    <id>https://gentryhuang.com/posts/f3cd85ef/</id>
    <published>2020-06-12T14:42:08.000Z</published>
    <updated>2020-11-28T15:40:52.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://gentryhuang.com/posts/53cd7ee7/#WrappedChannelHandler">网络传输层</a> 中我们介绍 <strong>WrappedChannelHandler</strong> 类的构造方法时，提到了线程池的创建的，本篇文章我们对线程池部分详细分析。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在 Dubbo 的线程模型中，Dubbo 提供了四种线程池的实现，具体如下：</p><ul><li>fixed 固定大小线程池，启动时建立线程，不关闭，一直持有。(缺省)</li><li>cached 缓存线程池，空闲一定时间自动删除，需要时重建。</li><li>limited 可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题。</li><li>eager 优先创建Worker线程池。在任务数量大于corePoolSize但是小于maximumPoolSize时，优先创建Worker来处理任务。当任务数量大于maximumPoolSize时，将任务放入阻塞队列中。阻塞队列充满时抛出RejectedExecutionException。(相比于cached:cached在任务数量超过maximumPoolSize时直接抛出异常而不是将任务放入阻塞队列)</li></ul><p>一般情况下，Dubbo 线程池和 Dubbo 消息派发策略组合使用，即配置 Dubbo 中的线程模型，以应对不同的场景。如下面的配置案例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">dispatcher</span>=<span class="string">"all"</span> <span class="attr">threadpool</span>=<span class="string">"fixed"</span> <span class="attr">threads</span>=<span class="string">"100"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-threadpool-model.jpg" alt></p><p>有关消息派发机制部分在 <a href="https://gentryhuang.com/posts/53cd7ee7/#WrappedChannelHandler">网络传输层</a> 中已经详细说明，这里不再介绍。线程池相关的接口和实现位于 <strong>dubbo-common</strong> 模块中，下面我们开始介绍 Dubbo 线程模型中的线程池部分。</p><h1 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"fixed"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池执行器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url URL contains thread parameter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> thread pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.THREADPOOL_KEY&#125;)</span><br><span class="line">    <span class="function">Executor <span class="title">getExecutor</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadPool 接口被 @SPI 注解修饰，是 Dubbo 的扩展点，默认扩展实现名为 <strong>fixed</strong> ，对应的扩展实现为 FixedThreadPool 。ThreadPool 接口中的 getExecutor() 方法被 @Adaptive 注解修饰，会动态生成自适应类即适配器类，该类会优先根据 <strong>url.threadpool</strong> 参数选择 ThreadPool 的扩展实现。线程池 SPI 配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fixed&#x3D;com.alibaba.dubbo.common.threadpool.support.fixed.FixedThreadPool</span><br><span class="line">cached&#x3D;com.alibaba.dubbo.common.threadpool.support.cached.CachedThreadPool</span><br><span class="line">limited&#x3D;com.alibaba.dubbo.common.threadpool.support.limited.LimitedThreadPool</span><br><span class="line">eager&#x3D;com.alibaba.dubbo.common.threadpool.support.eager.EagerThreadPool</span><br></pre></td></tr></table></figure><p>ThreadPool 继承关系 UML 如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-threadpool-uml.jpg" alt></p><p>不同的 ThreadPool 扩展实现会根据 URL 参数创建不同特性的线程池。</p><h1 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h1><p>固定大小线程池，启动时建立线程，不关闭，一直持有，是 Dubbo 默认的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPool</span> <span class="keyword">implements</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程名，获取 url.threadname 的值，默认为 Dubbo</span></span><br><span class="line">        String name = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);</span><br><span class="line">        <span class="comment">// 线程数，获取 url.threads 的值，默认为 200</span></span><br><span class="line">        <span class="keyword">int</span> threads = url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS);</span><br><span class="line">        <span class="comment">// 队列数，获取 url.queues 的值，默认为 0</span></span><br><span class="line">        <span class="keyword">int</span> queues = url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池执行器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="comment">/* 核心线程数*/</span></span><br><span class="line">                threads,</span><br><span class="line">                <span class="comment">/* 最大线程数 */</span></span><br><span class="line">                threads,</span><br><span class="line">                <span class="comment">/* 空闲线程存活时间 */</span></span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="comment">/* 空闲存活时间单位 */</span></span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="comment">/* 阻塞队列,根据配置的队列数，选择对应的队列</span></span><br><span class="line"><span class="comment">                 * 1 queues == 0    -  SynchronousQueue</span></span><br><span class="line"><span class="comment">                 * 2 queues &lt; 0     -  LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">                 * 3 queues &gt; 0     -  带队列数的LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                queues == <span class="number">0</span> ? <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;() : (queues &lt; <span class="number">0</span> ? <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;() : <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(queues)),</span><br><span class="line">                <span class="comment">/* 线程工厂 */</span></span><br><span class="line">                <span class="keyword">new</span> NamedInternalThreadFactory(name, <span class="keyword">true</span>),</span><br><span class="line">                <span class="comment">/* 拒绝策略 */</span></span><br><span class="line">                <span class="keyword">new</span> AbortPolicyWithReport(name, url)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 配置方式:使用 &lt;dubbo:parameter key="xxx" value="yyy" /&gt; 配置</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FixedThreadPool 的核心线程数和最大线程数一致，且不会被回收。</p><h1 id="CacheThreadPool"><a href="#CacheThreadPool" class="headerlink" title="CacheThreadPool"></a>CacheThreadPool</h1><p>缓存线程池，空闲一定时间自动删除，需要时重建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span> <span class="keyword">implements</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程名，获取 url.threadname 的值，默认为 Dubbo</span></span><br><span class="line">        String name = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);</span><br><span class="line">        <span class="comment">// 核心线程数，获取 url.corethreads 的值，默认为 0</span></span><br><span class="line">        <span class="keyword">int</span> cores = url.getParameter(Constants.CORE_THREADS_KEY, Constants.DEFAULT_CORE_THREADS);</span><br><span class="line">        <span class="comment">// 最大线程数，获取 url.threads 的值，默认为 Integer 的最大值</span></span><br><span class="line">        <span class="keyword">int</span> threads = url.getParameter(Constants.THREADS_KEY, Integer.MAX_VALUE);</span><br><span class="line">        <span class="comment">// 队列数，获取 url.queues 的值，默认为 0</span></span><br><span class="line">        <span class="keyword">int</span> queues = url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES);</span><br><span class="line">        <span class="comment">// 线程存活时长，获取 url.alive 的值，默认为 60 * 1000</span></span><br><span class="line">        <span class="keyword">int</span> alive = url.getParameter(Constants.ALIVE_KEY, Constants.DEFAULT_ALIVE);</span><br><span class="line">        <span class="comment">// 创建执行器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                cores,</span><br><span class="line">                threads,</span><br><span class="line">                alive,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="comment">/* 阻塞队列,根据配置的队列数，选择对应的队列</span></span><br><span class="line"><span class="comment">                 * 1 queues == 0    -  SynchronousQueue</span></span><br><span class="line"><span class="comment">                 * 2 queues &lt; 0     -  LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">                 * 3 queues &gt; 0     -  带队列数的LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                queues == <span class="number">0</span> ? <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;() : (queues &lt; <span class="number">0</span> ? <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;() : <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(queues)),</span><br><span class="line">                <span class="comment">/* 线程工厂 */</span></span><br><span class="line">                <span class="keyword">new</span> NamedInternalThreadFactory(name, <span class="keyword">true</span>),</span><br><span class="line">                <span class="comment">/* 拒绝策略 */</span></span><br><span class="line">                <span class="keyword">new</span> AbortPolicyWithReport(name, url)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 配置方式:使用 &lt;dubbo:parameter key="xxx" value="yyy" /&gt; 配置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CacheThreadPool 缓存线程池，可以指定核心线程数、最大线程数、缓冲队列长度空以及空闲时间，空闲一定时间非核心线程会被回收，需要时重建。</p><h1 id="LimitedThreadPool"><a href="#LimitedThreadPool" class="headerlink" title="LimitedThreadPool"></a>LimitedThreadPool</h1><p>可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitedThreadPool</span> <span class="keyword">implements</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程名，获取 url.threadname 的值，默认为 Dubbo</span></span><br><span class="line">        String name = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);</span><br><span class="line">        <span class="comment">// 核心线程数，获取 url.corethreads 的值，默认为 0</span></span><br><span class="line">        <span class="keyword">int</span> cores = url.getParameter(Constants.CORE_THREADS_KEY, Constants.DEFAULT_CORE_THREADS);</span><br><span class="line">        <span class="comment">// 最大线程数，获取 url.threads 的值，默认为 200</span></span><br><span class="line">        <span class="keyword">int</span> threads = url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS);</span><br><span class="line">        <span class="comment">// 队列数，获取 url.queues 的值，默认为 0</span></span><br><span class="line">        <span class="keyword">int</span> queues = url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建执行器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                cores,</span><br><span class="line">                threads,</span><br><span class="line">                <span class="comment">/** 空闲时间无限大，即不会自动删除 */</span></span><br><span class="line">                Long.MAX_VALUE,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="comment">/* 阻塞队列,根据配置的队列数，选择对应的队列</span></span><br><span class="line"><span class="comment">                 * 1 queues == 0    -  SynchronousQueue</span></span><br><span class="line"><span class="comment">                 * 2 queues &lt; 0     -  LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">                 * 3 queues &gt; 0     -  带队列数的LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                queues == <span class="number">0</span> ? <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;() :</span><br><span class="line">                        (queues &lt; <span class="number">0</span> ? <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()</span><br><span class="line">                                : <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(queues)),</span><br><span class="line">                <span class="comment">/* 线程工厂 */</span></span><br><span class="line">                <span class="keyword">new</span> NamedInternalThreadFactory(name, <span class="keyword">true</span>),</span><br><span class="line">                <span class="comment">/* 拒绝策略 */</span></span><br><span class="line">                <span class="keyword">new</span> AbortPolicyWithReport(name, url)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置方式: 使用 &lt;dubbo:parameter /&gt; 配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LimitedThreadPool 可伸缩线程池，可以指定核心线程数、最大线程数以及缓冲队列长度，LimitedThreadPool 创建的线程池的非核心线程不会被回收。</p><p>以上三种类型的线程池都是基于 JDK ThreadPoolExecutor 线程池，在核心线程全部被占用的时候会先把任务放到缓冲队列中，当缓冲队列满了之后，才会尝试创建新线程来处理任务。EagerThreadPool 则有很大差异，具体我们接着分析。</p><h1 id="EagerThreadPool"><a href="#EagerThreadPool" class="headerlink" title="EagerThreadPool"></a>EagerThreadPool</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerThreadPool</span> <span class="keyword">implements</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getExecutor</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程名，获取 url.threadname 的值，默认为 Dubbo</span></span><br><span class="line">        String name = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);</span><br><span class="line">        <span class="comment">// 核心线程数，获取 url.corethreads 的值，默认为 0</span></span><br><span class="line">        <span class="keyword">int</span> cores = url.getParameter(Constants.CORE_THREADS_KEY, Constants.DEFAULT_CORE_THREADS);</span><br><span class="line">        <span class="comment">// 最大线程数，获取 url.threads 的值，默认为 Integer 的最大值</span></span><br><span class="line">        <span class="keyword">int</span> threads = url.getParameter(Constants.THREADS_KEY, Integer.MAX_VALUE);</span><br><span class="line">        <span class="comment">// 队列数，获取 url.queues 的值，默认为 0</span></span><br><span class="line">        <span class="keyword">int</span> queues = url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES);</span><br><span class="line">        <span class="comment">// 线程存活时长，获取 url.alive 的值，默认为 60 * 1000</span></span><br><span class="line">        <span class="keyword">int</span> alive = url.getParameter(Constants.ALIVE_KEY, Constants.DEFAULT_ALIVE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建缓冲队列</span></span><br><span class="line">        TaskQueue&lt;Runnable&gt; taskQueue = <span class="keyword">new</span> TaskQueue&lt;Runnable&gt;(queues &lt;= <span class="number">0</span> ? <span class="number">1</span> : queues);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 EagerThreadPoolExecutor 对象</span></span><br><span class="line">        EagerThreadPoolExecutor executor = <span class="keyword">new</span> EagerThreadPoolExecutor(</span><br><span class="line">                cores,</span><br><span class="line">                threads,</span><br><span class="line">                alive,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="comment">/* TaskQueue 队列*/</span></span><br><span class="line">                taskQueue,</span><br><span class="line">                <span class="keyword">new</span> NamedInternalThreadFactory(name, <span class="keyword">true</span>),</span><br><span class="line">                <span class="keyword">new</span> AbortPolicyWithReport(name, url));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将创建的 eager 线程池对象设置到 taskQueue 中</span></span><br><span class="line">        taskQueue.setExecutor(executor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置方式：使用 &lt;dubbo:parameter /&gt; 配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EagerThreadPool 并没有直接使用 JDK ThreadPoolExecutor 线程池，而是使用了继承 ThreadPoolExecutor 的 EagerThreadPoolExecutor 线程池。而且使用的队列 TaskQueue ，继承了 LinkedBlockingQueue。EagerThreadPool 的不同就体现在这两个对象上。</p><h2 id="TaskQueue"><a href="#TaskQueue" class="headerlink" title="TaskQueue"></a>TaskQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LinkedBlockingQueue 内部由单链表实现的阻塞队列，只能从head取元素，从tail添加元素。</span></span><br><span class="line"><span class="comment"> * 1 take() 取数据，当队列为空时阻塞</span></span><br><span class="line"><span class="comment"> * 2 poll() 取数据，弹出队列头部元素，队列为空时返回空</span></span><br><span class="line"><span class="comment"> * 3 offer() 添加数据，当队列满时返回 false</span></span><br><span class="line"><span class="comment"> * 4 put() 添加数据，当队列满时阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span>&lt;<span class="title">R</span> <span class="keyword">extends</span> <span class="title">Runnable</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2635853580887179627L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * eager 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> EagerThreadPoolExecutor executor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExecutor</span><span class="params">(EagerThreadPoolExecutor exec)</span> </span>&#123;</span><br><span class="line">        executor = exec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 LinkedBlockingQueue 的 offer() 方法。</span></span><br><span class="line"><span class="comment">     * 主要实现：</span></span><br><span class="line"><span class="comment">     * 1 在任务数量大于corePoolSize但是小于maximumPoolSize时，优先创建Worker来处理任务</span></span><br><span class="line"><span class="comment">     * 2 当任务数量大于maximumPoolSize时，将任务放入阻塞队列中。阻塞队列充满时抛出RejectedExecutionException</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"The task queue does not have executor!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前线程池中的活跃线程数(注意非核心线程数可能被回收)</span></span><br><span class="line">        <span class="keyword">int</span> currentPoolThreadSize = executor.getPoolSize();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前有线程空闲，直接将任务提交到队列中，空闲线程会直接从中获取任务执行</span></span><br><span class="line">        <span class="keyword">if</span> (executor.getSubmittedTaskCount() &lt; currentPoolThreadSize) &#123;</span><br><span class="line">            <span class="comment">// 将任务入队</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.offer(runnable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return false to let executor create new worker.</span></span><br><span class="line">        <span class="comment">// 当前没有空闲线程，但活跃线程数小于最大线程数即还可以创建线程，则返回 false，让线程池创建新的线程来执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (currentPoolThreadSize &lt; executor.getMaximumPoolSize()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// currentPoolThreadSize &gt;= max</span></span><br><span class="line">        <span class="comment">// 当前活跃线程达到上线，则只能将任务放入缓冲队列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.offer(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 再次将任务加入队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> offer success or not</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if executor is terminated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retryOffer</span><span class="params">(Runnable o, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor.isShutdown()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Executor is shutdown!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.offer(o, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TaskQueue 继承了 LinkedBlockingQueue 阻塞队列，它复写了 LinkedBlockingQueue 的 offer() 方法，会判断线程池 EagerThreadPoolExecutor 的 submittedTaskCount 值是否已经达到最大线程数，如果没有超过则返回 false，线程池会创建新线程来执行任务。这点非常重要，eager 线程池优先创建线程执行任务的逻辑判断就这这里。</p><h2 id="EagerThreadPoolExecutor"><a href="#EagerThreadPoolExecutor" class="headerlink" title="EagerThreadPoolExecutor"></a>EagerThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录当前在线程池中的任务总数（正在线程中执行的任务数+队列中等待的任务数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger submittedTaskCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EagerThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   TaskQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前线程池的任务总数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> current tasks which are executed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSubmittedTaskCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> submittedTaskCount.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 复写 ThreadPoolExecutor 的 afterExecute() 方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 任务执行结束，递减 submittedTaskCount</span></span><br><span class="line">        submittedTaskCount.decrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 复写 ThreadPoolExecutor 的 execute() 方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务提交之前，递增submittedTaskCount</span></span><br><span class="line">        submittedTaskCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交任务 （ThreadPoolExecutor 底层会执行 TaskQueue 的 poll() 方法）</span></span><br><span class="line">            <span class="keyword">super</span>.execute(command);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交任务被拒绝</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class="line">            <span class="comment">// 获取缓存队列</span></span><br><span class="line">            <span class="keyword">final</span> TaskQueue queue = (TaskQueue) <span class="keyword">super</span>.getQueue();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 尝试将被拒绝的任务再次放入队列中，如果再次入队被拒绝，则队列已满，无法执行任务。递减 submittedTaskCount</span></span><br><span class="line">                <span class="keyword">if</span> (!queue.retryOffer(command, <span class="number">0</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                    submittedTaskCount.decrementAndGet();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Queue capacity is full."</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 中断异常，递减 submittedTaskCount</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">                submittedTaskCount.decrementAndGet();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(x);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交任务发生其它异常，递减 submittedTaskCount</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// decrease any way</span></span><br><span class="line">            submittedTaskCount.decrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当活跃线程数没有达到最大线程数时，EagerThreadPoolExecutor 会优先创建线程来执行任务，而不是放到缓冲队列中，当活跃线程数达到最大值时，EagerThreadPoolExecutor 会将任务放入缓冲队列中等待空闲线程执行，阻塞队列充满时抛出异常。</p><h1 id="AbortPolicyWithReport"><a href="#AbortPolicyWithReport" class="headerlink" title="AbortPolicyWithReport"></a>AbortPolicyWithReport</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拒绝策略实现类，继承了 ThreadPoolExecutor.AbortPolicy，这里打印JStack，分析线程状态</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Abort Policy.</span></span><br><span class="line"><span class="comment"> * Log warn info when abort.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicyWithReport</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span>.<span class="title">AbortPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbortPolicyWithReport<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String threadName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后打印时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastPrintTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信号量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore guard = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicyWithReport</span><span class="params">(String threadName, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadName = threadName;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 复写了 rejectedExecution 方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打印告警日志</span></span><br><span class="line">        String msg = String.format(<span class="string">"Thread pool is EXHAUSTED!"</span> +</span><br><span class="line">                        <span class="string">" Thread Name: %s, Pool Size: %d (active: %d, core: %d, max: %d, largest: %d), Task: %d (completed: %d),"</span> +</span><br><span class="line">                        <span class="string">" Executor status:(isShutdown:%s, isTerminated:%s, isTerminating:%s), in %s://%s:%d!"</span>,</span><br><span class="line">                threadName, e.getPoolSize(), e.getActiveCount(), e.getCorePoolSize(), e.getMaximumPoolSize(), e.getLargestPoolSize(),</span><br><span class="line">                e.getTaskCount(), e.getCompletedTaskCount(), e.isShutdown(), e.isTerminated(), e.isTerminating(),</span><br><span class="line">                url.getProtocol(), url.getIp(), url.getPort());</span><br><span class="line">        logger.warn(msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印JStack，分析线程状态</span></span><br><span class="line">        dumpJStack();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 抛出 RejectedExecutionException 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印JStack，用来分析线程状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dumpJStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//10分钟打印一次</span></span><br><span class="line">        <span class="keyword">if</span> (now - lastPrintTime &lt; <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得信号量 ,用以保证同一时间有且仅有一个线程执行打印</span></span><br><span class="line">        <span class="keyword">if</span> (!guard.tryAcquire()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程池，后台执行打印逻辑</span></span><br><span class="line">        Executors.newSingleThreadExecutor().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获得系统</span></span><br><span class="line">                String dumpPath = url.getParameter(Constants.DUMP_DIRECTORY, System.getProperty(<span class="string">"user.home"</span>));</span><br><span class="line"></span><br><span class="line">                SimpleDateFormat sdf;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获得路径</span></span><br><span class="line">                String OS = System.getProperty(<span class="string">"os.name"</span>).toLowerCase();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// window system don't support ":" in file name</span></span><br><span class="line">                <span class="keyword">if</span> (OS.contains(<span class="string">"win"</span>)) &#123;</span><br><span class="line">                    sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd_HH-mm-ss"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd_HH:mm:ss"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                String dateStr = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 输出流</span></span><br><span class="line">                FileOutputStream jstackStream = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    jstackStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(dumpPath, <span class="string">"Dubbo_JStack.log"</span> + <span class="string">"."</span> + dateStr));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 打印JStack 信息</span></span><br><span class="line">                    JVMUtil.jstack(jstackStream);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(<span class="string">"dump jstack error"</span>, t);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放信号量</span></span><br><span class="line">                    guard.release();</span><br><span class="line">                    <span class="keyword">if</span> (jstackStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            jstackStream.flush();</span><br><span class="line">                            jstackStream.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录最后打印时间</span></span><br><span class="line">                lastPrintTime = System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Dubbo 线程模型中的线程池部分进行了介绍，Dubbo 目前支持四种线程池，其中 eager 线程池比较特别，使用的缓冲队列 TaskQueue 重写了 LinkedBlockingQueue 的 offer() 方法，该方法的逻辑是判断线程池的中的任务（执行中的和队列中的）是否已经达到最大线程数，如果没有超过就使线程池创建新线程来执行任务。其它三个线程的是基于 JDK ThreadPoolExecutor 线程池，在核心线程全部被占用的时候会先把任务放到缓冲队列中，当缓冲队列满了之后，才会尝试创建新线程来处理任务。最后，介绍了这四个线程池使用的拒绝策略，用于打印JStack，分析线程状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/53cd7ee7/#WrappedChannelHandl
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - Mina网络通信</title>
    <link href="https://gentryhuang.com/posts/543ee8c5/"/>
    <id>https://gentryhuang.com/posts/543ee8c5/</id>
    <published>2020-06-06T16:00:00.000Z</published>
    <updated>2020-12-01T01:45:15.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://gentryhuang.com/posts/53cd7ee7/">网络传输层</a> 中对 Transport 通用层或者说是抽象层进行了详细分析。上一篇文章 <a href="https://gentryhuang.com/posts/4468445c/">Netty4网络通信</a> 中我们详细分析了 Dubbo 接入 Netty4 实现的网络通信，本篇文章将分析 Dubbo 如何接入 Mina 库。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 为了集成不同优秀开源的 NIO 库，专门实现了一个抽象层，对应的模块是 <strong>dubbo-remoting-api</strong>，在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中介绍了该模块核心的接口和类。针对每一个 NIO 框架的接入，Dubbo 都构建一个单独的模块，该模块只需实现抽象模块 <strong>dubbo-remoting-api</strong> 即可，结合 Dubbo SPI 机制可以灵活切换到不同的 NIO 库。下面我们开始介绍实现层 <strong>dubbo-remoting-mina</strong> 模块，UML 图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-mina-uml.jpg" alt> </p><p>通过上面的 UML 图可以很清晰看出各个类之间的关系，和 Netty4 实现通信几乎一致。下面我们依然根据 UML 图的依赖关系逐个分析。</p><h1 id="MinaTransporter"><a href="#MinaTransporter" class="headerlink" title="MinaTransporter"></a>MinaTransporter</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaTransporter</span> <span class="keyword">implements</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"mina"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定一个服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MinaServer(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接服务器，级创建一个客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MinaClient(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MinaTransporter 实现了 Transporter 扩展接口，关于 Transporter 扩展接口已经在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中进行了介绍，默认扩展实现是 netty 即 Netty3 实现。bind() 和 connect() 方法分别用于创建 MinaServer 和 MinaClient 对象。一般 Transport 扩展实现会由 Transport 的门面 Transports 统一向上层提供，这个上层就是 Exchange 信息交互层。下面我们继续分析 MinaTransporter 创建的服务器和客户端。</p><h1 id="MinaServer"><a href="#MinaServer" class="headerlink" title="MinaServer"></a>MinaServer</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaServer</span> <span class="keyword">extends</span> <span class="title">AbstractServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MinaServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于同客户端建立连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SocketAcceptor acceptor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinaServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MinaServer 继承了 AbstractServer 抽象服务类，是 Mina 服务实现类。MinaServer 通过层层继承拥有了很多类的职能，如 端点（Endpoint）、通道处理（ChannelHandler）、(服务端)Server ，其中间接关联了 ChannelHandler（AbstractPeer中的属性）和 Codec2（AbstractEndpoint中的）对象 。剩下的不再说明，和 Netty4 实现一致。</p><h2 id="启动服务方法-doOpen"><a href="#启动服务方法-doOpen" class="headerlink" title="启动服务方法 doOpen"></a>启动服务方法 doOpen</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     <span class="comment">// set thread pool.</span></span><br><span class="line">     acceptor = <span class="keyword">new</span> SocketAcceptor(getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),</span><br><span class="line">             Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"MinaServerWorker"</span>,</span><br><span class="line">                     <span class="keyword">true</span>)));</span><br><span class="line">     <span class="comment">// 配置项</span></span><br><span class="line">     SocketAcceptorConfig cfg = acceptor.getDefaultConfig();</span><br><span class="line">     cfg.setThreadModel(ThreadModel.MANUAL);</span><br><span class="line">     <span class="comment">//编写过滤器链，通过过滤器执行编解码器</span></span><br><span class="line">     acceptor.getFilterChain().addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> MinaCodecAdapter(getCodec(), getUrl(), <span class="keyword">this</span>)));</span><br><span class="line">     <span class="comment">// 绑定端口，并设置 handler</span></span><br><span class="line">     acceptor.bind(getBindAddress(), <span class="keyword">new</span> MinaHandler(getUrl(), <span class="keyword">this</span>));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>启动服务的方法是父类的一个模版方法，代码实现是 Mina 的标准化流程。简单概括下：</p><ol><li>创建 SocketAcceptor 对象，URL 对象从父类 AbstractPeer 中获取。</li><li>设置 Mina 服务的配置项。</li><li>设置 Mina 的过滤器，在 Mina 中编解码器是通过过滤器职能实现的，Mina 的过滤器对 Codec2 实现进行了封装。</li><li>设置处理，绑定端口，启动服务</li></ol><p>除了标准化流程不同外，其它方面都和 NettyServer 一致，都需要把 Codec2 编解码器和通道处理器 ChannelHandler 关联到服务上。</p><h2 id="关闭服务-doClose"><a href="#关闭服务-doClose" class="headerlink" title="关闭服务 doClose"></a>关闭服务 doClose</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (acceptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 解绑端口，关闭服务</span></span><br><span class="line">               acceptor.unbind(getBindAddress());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           logger.warn(e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>NettyServer 关闭时需要考虑到多个对象，如服务 Channel、客户端连接到服务的Channel、以及循环线程组。 MinaServer 只需要考虑关闭 SocketAcceptor 对象即可。</p><h2 id="获取客户端通道"><a href="#获取客户端通道" class="headerlink" title="获取客户端通道"></a>获取客户端通道</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取Mina 连接集合</span></span><br><span class="line">     Set&lt;IoSession&gt; sessions = acceptor.getManagedSessions(getBindAddress());</span><br><span class="line">     Collection&lt;Channel&gt; channels = <span class="keyword">new</span> HashSet&lt;Channel&gt;();</span><br><span class="line">     <span class="keyword">for</span> (IoSession session : sessions) &#123;</span><br><span class="line">         <span class="comment">// 连接处于连接状态</span></span><br><span class="line">         <span class="keyword">if</span> (session.isConnected()) &#123;</span><br><span class="line">             <span class="comment">// 获取Mina 连接对应的 Dubbo MinaChannel</span></span><br><span class="line">             channels.add(MinaChannel.getOrAddChannel(session, getUrl(), <span class="keyword">this</span>));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> channels;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>和 NettyServer 类似，都需要获取处于连接状态的通道，最终映射到 Dubbo 层面的通道 MinaChannel。</p><h2 id="是否启动成功"><a href="#是否启动成功" class="headerlink" title="是否启动成功"></a>是否启动成功</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 服务是否启动</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> acceptor.isManaged(getBindAddress());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>调用 Mina API 判断服务是否开启，和 NettyServer 类似。</p><h1 id="MinaChannel"><a href="#MinaChannel" class="headerlink" title="MinaChannel"></a>MinaChannel</h1><p>MinaChannel 继承了 AbstractChannel 抽象类，是对 org.apache.mina.common.IoSession 的装饰，使用了装饰者模式，与 IoSession 是一对一的关系，这一点和 NettyChannel 一致。</p><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaChannel</span> <span class="keyword">extends</span> <span class="title">AbstractChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MinaChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IoSession 存储数据的key，value 是 MinaChannel 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private static final String CHANNEL_KEY = MinaChannel.class.getName() + ".CHANNEL";</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对底层连接的封装（服务器与客户端的特定连接）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IoSession session;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MinaChannel</span><span class="params">(IoSession session, URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line">        <span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"mina session == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MinaChannel 和 NettyChannel 有所不同，MinaChannel 内部装饰的 Mina 的连接 IoSession 直接存储数据，将对应的 MinaChannel 存储到 IoSession 中，而 NettyChannel 采用单独使用集合处理的方式。同样的，获取 MinaChannel 只能通过内部方法创建。</p><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="创建-获取-MinaChannel"><a href="#创建-获取-MinaChannel" class="headerlink" title="创建/获取 MinaChannel"></a>创建/获取 MinaChannel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> MinaChannel <span class="title">getOrAddChannel</span><span class="params">(IoSession session, URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (session == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// IoSession 中取出对应的 MinaChannel 对象</span></span><br><span class="line">     MinaChannel ret = (MinaChannel) session.getAttribute(CHANNEL_KEY);</span><br><span class="line">     <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 创建 MinaChannel 对象</span></span><br><span class="line">         ret = <span class="keyword">new</span> MinaChannel(session, url, handler);</span><br><span class="line">         <span class="comment">// 判断连接是处于连接中</span></span><br><span class="line">         <span class="keyword">if</span> (session.isConnected()) &#123;</span><br><span class="line">             MinaChannel old = (MinaChannel) session.setAttribute(CHANNEL_KEY, ret);</span><br><span class="line">             <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 session.setAttribute(CHANNEL_KEY, old);</span><br><span class="line">                 ret = old;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ret;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>和 NettyChannel 类似，都是使用NIO的连接作为映射的标识，getOrAddChannel() 方法不仅创建了 MinaChannel，也设置了 AbstractPeer 类中的 ChannelHandler 和 URL 属性的值，这意味着 AbstractPeer 当前子类对象关联了这两个属性的值。</p><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>该方法是 Endpoint 接口中的方法，并非 Channel 接口中的方法，Channel接口没有发送消息的方法。它会通过装饰的 Mina 框架的 IoSession 将数据发送到对端，并且支持等待发送完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">     <span class="comment">// 检查连接是否可用</span></span><br><span class="line">     <span class="keyword">super</span>.send(message, sent);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">     <span class="keyword">int</span> timeout = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 通过 IoSession 发送消息到对端</span></span><br><span class="line">         WriteFuture future = session.write(message);</span><br><span class="line">         <span class="comment">// 支持等待消息发送成功或者超时</span></span><br><span class="line">         <span class="keyword">if</span> (sent) &#123;</span><br><span class="line">             timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">             success = future.join(timeout);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message "</span> + message + <span class="string">" to "</span> + getRemoteAddress() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message "</span> + message + <span class="string">" to "</span> + getRemoteAddress()</span><br><span class="line">                 + <span class="string">"in timeout("</span> + timeout + <span class="string">"ms) limit"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="操作附加属性"><a href="#操作附加属性" class="headerlink" title="操作附加属性"></a>操作附加属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAttribute</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> session.containsAttribute(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> session.getAttribute(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">      session.setAttribute(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">      session.removeAttribute(key);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>MinaChannel 使用了 IoSession 直接操作附加属性，而 NettyChannel 维护了一个集合来存放附加属性。</p><h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 标记连接关闭</span></span><br><span class="line">         <span class="keyword">super</span>.close();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         logger.warn(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 移除处于断开连接的连接对应的 MinaChanenl</span></span><br><span class="line">         removeChannelIfDisconnected(session);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         logger.warn(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">             logger.info(<span class="string">"CLose mina channel "</span> + session);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 关闭 Mina 连接</span></span><br><span class="line">         session.close();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         logger.warn(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>和 NettyChannel 逻辑一致。</p><h3 id="清理-MinaChannel"><a href="#清理-MinaChannel" class="headerlink" title="清理 MinaChannel"></a>清理 MinaChannel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeChannelIfDisconnected</span><span class="params">(IoSession session)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (session != <span class="keyword">null</span> &amp;&amp; !session.isConnected()) &#123;</span><br><span class="line">          <span class="comment">// 直接使用 Mina API 移除</span></span><br><span class="line">          session.removeAttribute(CHANNEL_KEY);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="获取地址"><a href="#获取地址" class="headerlink" title="获取地址"></a>获取地址</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">getLocalAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (InetSocketAddress) session.getLocalAddress();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">getRemoteAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (InetSocketAddress) session.getRemoteAddress();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>和 NettyChannel 类似，都是使用各自NIO库API 获取对应的地址。</p><h1 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h1><p>通过前文的 UML 关系图以及 MinaServer 启动服务方法，我们不难看出 MinaCodecAdapter 充当适配器角色，严格来说属于对象适配器模式，即 将 Dubbo 的 Codec2 编解码器适配成 Mina 层面的编码器和解码器，Mina 会把编解码工作委托给 Dubbo 的 Codec2 编解码器去处理。相关关系如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-mina-codec.jpg" alt></p><p>在 <a href="https://gentryhuang.com/posts/53cd7ee7/">网络传输层</a> 中已经详细介绍过了 AbstractEndpoint 抽象类，该抽象类中的 codec 属性正是 Codec2 类型，该属性在 AbstractEndpoint 构造方法中被初始化，而 MinaServer 间接继承了 AbstractEndpoint 抽象类，在创建 MinaServer 对象时该编解码属性也进行了初始化。</p><h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaCodecAdapter</span> <span class="keyword">implements</span> <span class="title">ProtocolCodecFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Mina 编码器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProtocolEncoder encoder = <span class="keyword">new</span> InternalEncoder();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Mina 解码器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProtocolDecoder decoder = <span class="keyword">new</span> InternalDecoder();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关联的 Dubbo Codec2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Codec2 codec;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关联的 ChannelHandler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> bufferSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinaCodecAdapter</span><span class="params">(Codec2 codec, URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.codec = codec;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">int</span> b = url.getPositiveParameter(Constants.BUFFER_KEY, Constants.DEFAULT_BUFFER_SIZE);</span><br><span class="line">        <span class="keyword">this</span>.bufferSize = b &gt;= Constants.MIN_BUFFER_SIZE &amp;&amp; b &lt;= Constants.MAX_BUFFER_SIZE ? b : Constants.DEFAULT_BUFFER_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProtocolEncoder <span class="title">getEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProtocolDecoder <span class="title">getDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decoder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MinaCodecAdapter 和 NettyCodecAdapter 有一点差别，因为各自NIO库实现不同，MinaCodecAdapter 需要实现 Mina 的接口 ProtocolCodecFactory 。</p><h2 id="编码器实现"><a href="#编码器实现" class="headerlink" title="编码器实现"></a>编码器实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实现Mina的编码器接口 ProtocolEncoder</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalEncoder</span> <span class="keyword">implements</span> <span class="title">ProtocolEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(IoSession session, Object msg, ProtocolEncoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           ChannelBuffer buffer = ChannelBuffers.dynamicBuffer(<span class="number">1024</span>);</span><br><span class="line">           MinaChannel channel = MinaChannel.getOrAddChannel(session, url, handler);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 编码委托给 Codec2 实现去完成</span></span><br><span class="line">               codec.encode(channel, buffer, msg);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               MinaChannel.removeChannelIfDisconnected(session);</span><br><span class="line">           &#125;</span><br><span class="line">           out.write(ByteBuffer.wrap(buffer.toByteBuffer()));</span><br><span class="line">           out.flush();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="解码器实现"><a href="#解码器实现" class="headerlink" title="解码器实现"></a>解码器实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 实现Mina的解码器接口 ProtocolDecoder</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalDecoder</span> <span class="keyword">implements</span> <span class="title">ProtocolDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> ChannelBuffer buffer = ChannelBuffers.EMPTY_BUFFER;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(IoSession session, ByteBuffer in, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> readable = in.limit();</span><br><span class="line">         <span class="keyword">if</span> (readable &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">         ChannelBuffer frame;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (buffer.readable()) &#123;</span><br><span class="line">             <span class="keyword">if</span> (buffer <span class="keyword">instanceof</span> DynamicChannelBuffer) &#123;</span><br><span class="line">                 buffer.writeBytes(in.buf());</span><br><span class="line">                 frame = buffer;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">int</span> size = buffer.readableBytes() + in.remaining();</span><br><span class="line">                 frame = ChannelBuffers.dynamicBuffer(size &gt; bufferSize ? size : bufferSize);</span><br><span class="line">                 frame.writeBytes(buffer, buffer.readableBytes());</span><br><span class="line">                 frame.writeBytes(in.buf());</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             frame = ChannelBuffers.wrappedBuffer(in.buf());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         Channel channel = MinaChannel.getOrAddChannel(session, url, handler);</span><br><span class="line">         Object msg;</span><br><span class="line">         <span class="keyword">int</span> savedReadIndex;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 savedReadIndex = frame.readerIndex();</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="comment">// 解码委托给 Codec2 实现</span></span><br><span class="line">                     msg = codec.decode(channel, frame);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                     buffer = ChannelBuffers.EMPTY_BUFFER;</span><br><span class="line">                     <span class="keyword">throw</span> e;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (msg == Codec2.DecodeResult.NEED_MORE_INPUT) &#123;</span><br><span class="line">                     frame.readerIndex(savedReadIndex);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (savedReadIndex == frame.readerIndex()) &#123;</span><br><span class="line">                         buffer = ChannelBuffers.EMPTY_BUFFER;</span><br><span class="line">                         <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Decode without read data."</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         out.write(msg);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">while</span> (frame.readable());</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (frame.readable()) &#123;</span><br><span class="line">                 frame.discardReadBytes();</span><br><span class="line">                 buffer = frame;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 buffer = ChannelBuffers.EMPTY_BUFFER;</span><br><span class="line">             &#125;</span><br><span class="line">             MinaChannel.removeChannelIfDisconnected(session);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishDecode</span><span class="params">(IoSession session, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="MinaHandler"><a href="#MinaHandler" class="headerlink" title="MinaHandler"></a>MinaHandler</h1><p>MinaHandler 继承了 org.apache.mina.common.IoHandlerAdapter ，这是 Mina 提供的处理请求或事件的处理类。</p><h2 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaHandler</span> <span class="keyword">extends</span> <span class="title">IoHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Dubbo ChannelHandler。MinaHandler 中几乎所有方法都会触发该对象。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinaHandler</span><span class="params">(URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="请求或事件处理方法"><a href="#请求或事件处理方法" class="headerlink" title="请求或事件处理方法"></a>请求或事件处理方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//--------- MinaHandler 中以下所有方法都会触发装饰的 ChannelHandler 对象 ------------/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 连接服务</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> session 客户端与服务器的通道</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      MinaChannel channel = MinaChannel.getOrAddChannel(session, url, handler);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          handler.connected(channel);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          MinaChannel.removeChannelIfDisconnected(session);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 断开连接</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> session 客户端与服务器的通道</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionClosed</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      MinaChannel channel = MinaChannel.getOrAddChannel(session, url, handler);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          handler.disconnected(channel);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          MinaChannel.removeChannelIfDisconnected(session);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 接收消息</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> session 客户端与服务器的通道</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      MinaChannel channel = MinaChannel.getOrAddChannel(session, url, handler);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          handler.received(channel, message);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          MinaChannel.removeChannelIfDisconnected(session);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 发送消息</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> session 客户端与服务器的通道</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageSent</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      MinaChannel channel = MinaChannel.getOrAddChannel(session, url, handler);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          handler.sent(channel, message);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          MinaChannel.removeChannelIfDisconnected(session);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 异常处理</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> session 客户端与服务器的通道</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(IoSession session, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      MinaChannel channel = MinaChannel.getOrAddChannel(session, url, handler);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          handler.caught(channel, cause);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          MinaChannel.removeChannelIfDisconnected(session);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="MinaServer-amp-MinaHandler"><a href="#MinaServer-amp-MinaHandler" class="headerlink" title="MinaServer &amp; MinaHandler"></a>MinaServer &amp; MinaHandler</h2><p>在 MinaServer 创建 MinaHandler 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定端口，并设置 handler</span></span><br><span class="line"><span class="comment">// MinaHandler 构造方法第二个参数是 MinaServer 本身</span></span><br><span class="line">acceptor.bind(getBindAddress(), <span class="keyword">new</span> MinaHandler(getUrl(), <span class="keyword">this</span>));</span><br></pre></td></tr></table></figure><p>第一个参数是调用间接父类 AbstractPeer#getUrl() 方法获取上层传入的 URL对象。第二个参数正是 MinaServer 对象本身，通过之前的介绍，我们知道 MinaServer 继承关系，它的父类 AbstractPeer 实现了 ChannelHandler 接口，并且将所有方法都委托给了其装饰的 ChannelHandler 对象。因此，MinaHandler 中的通道方法都是交给 MinaServer 关联的 ChannelHandler 对象本身。</p><h1 id="MinaClient"><a href="#MinaClient" class="headerlink" title="MinaClient"></a>MinaClient</h1><p>MinaClient 是基于 Mina 实现的客户端，下面我们对它的属性、构造方法以及基本方法进行详细说明。</p><h2 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinaClient</span> <span class="keyword">extends</span> <span class="title">AbstractClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MinaClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SocketConnector 缓存</span></span><br><span class="line"><span class="comment">     * key: URL 串</span></span><br><span class="line"><span class="comment">     * value: SocketConnector 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, SocketConnector&gt; connectors = <span class="keyword">new</span> ConcurrentHashMap&lt;String, SocketConnector&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String connectorKey;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于连接Mina服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SocketConnector connector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对底层连接的封装（服务器与客户端的特定连接）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> IoSession session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MinaClient</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">      <span class="comment">// wrapChannelHandler方法用于包装ChannelHandler，其中实现了 Dubbo 线程模型的功能。</span></span><br><span class="line">      <span class="keyword">super</span>(url, wrapChannelHandler(url, handler));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>和 NettyClient 本质一摸一样，不再说明。</p><h2 id="启动客户端-doOpen"><a href="#启动客户端-doOpen" class="headerlink" title="启动客户端 doOpen"></a>启动客户端 doOpen</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">       <span class="comment">// URL 串</span></span><br><span class="line">       connectorKey = getUrl().toFullString();</span><br><span class="line">       SocketConnector c = connectors.get(connectorKey);</span><br><span class="line">       <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">           connector = c;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// set thread pool.</span></span><br><span class="line">           connector = <span class="keyword">new</span> SocketConnector(Constants.DEFAULT_IO_THREADS,</span><br><span class="line">                   Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"MinaClientWorker"</span>, <span class="keyword">true</span>)));</span><br><span class="line">           <span class="comment">// config</span></span><br><span class="line">           SocketConnectorConfig cfg = (SocketConnectorConfig) connector.getDefaultConfig();</span><br><span class="line">           cfg.setThreadModel(ThreadModel.MANUAL);</span><br><span class="line">           cfg.getSessionConfig().setTcpNoDelay(<span class="keyword">true</span>);</span><br><span class="line">           cfg.getSessionConfig().setKeepAlive(<span class="keyword">true</span>);</span><br><span class="line">           <span class="keyword">int</span> timeout = getConnectTimeout();</span><br><span class="line">           cfg.setConnectTimeout(timeout &lt; <span class="number">1000</span> ? <span class="number">1</span> : timeout / <span class="number">1000</span>);</span><br><span class="line">           <span class="comment">// set codec. 编解码器支持</span></span><br><span class="line">           connector.getFilterChain().addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> MinaCodecAdapter(getCodec(), getUrl(), <span class="keyword">this</span>)));</span><br><span class="line">           connectors.put(connectorKey, connector);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="连接服务器-doConnect"><a href="#连接服务器-doConnect" class="headerlink" title="连接服务器 doConnect"></a>连接服务器 doConnect</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">     <span class="comment">// 根据服务地址连接服务</span></span><br><span class="line">     ConnectFuture future = connector.connect(getConnectAddress(), <span class="keyword">new</span> MinaHandler(getUrl(), <span class="keyword">this</span>));</span><br><span class="line">     <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">     <span class="keyword">final</span> AtomicReference&lt;Throwable&gt; exception = <span class="keyword">new</span> AtomicReference&lt;Throwable&gt;();</span><br><span class="line">     <span class="keyword">final</span> CountDownLatch finish = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>); <span class="comment">// resolve future.awaitUninterruptibly() dead lock</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 添加监听器</span></span><br><span class="line">     future.addListener(<span class="keyword">new</span> IoFutureListener() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(IoFuture future)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// 服务准备好了</span></span><br><span class="line">                 <span class="keyword">if</span> (future.isReady()) &#123;</span><br><span class="line">                     <span class="comment">// 获取连接通道</span></span><br><span class="line">                     IoSession newSession = future.getSession();</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="comment">// Close old channel 对旧的通道处理</span></span><br><span class="line">                         IoSession oldSession = MinaClient.<span class="keyword">this</span>.session; <span class="comment">// copy reference</span></span><br><span class="line">                         <span class="keyword">if</span> (oldSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">                             <span class="keyword">try</span> &#123;</span><br><span class="line">                                 <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                                     logger.info(<span class="string">"Close old mina channel "</span> + oldSession + <span class="string">" on create new mina channel "</span> + newSession);</span><br><span class="line">                                 &#125;</span><br><span class="line">                                 oldSession.close();</span><br><span class="line">                             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                 MinaChannel.removeChannelIfDisconnected(oldSession);</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                         <span class="comment">// 如果关闭</span></span><br><span class="line">                         <span class="keyword">if</span> (MinaClient.<span class="keyword">this</span>.isClosed()) &#123;</span><br><span class="line">                             <span class="keyword">try</span> &#123;</span><br><span class="line">                                 <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                                     logger.info(<span class="string">"Close new mina channel "</span> + newSession + <span class="string">", because the client closed."</span>);</span><br><span class="line">                                 &#125;</span><br><span class="line">                                 newSession.close();</span><br><span class="line">                             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                 MinaClient.<span class="keyword">this</span>.session = <span class="keyword">null</span>;</span><br><span class="line">                                 MinaChannel.removeChannelIfDisconnected(newSession);</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                             MinaClient.<span class="keyword">this</span>.session = newSession;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 exception.set(e);</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 finish.countDown();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         finish.await(getConnectTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"client(url: "</span> + getUrl() + <span class="string">") failed to connect to server "</span> + getRemoteAddress() + <span class="string">" client-side timeout "</span></span><br><span class="line">                 + getConnectTimeout() + <span class="string">"ms (elapsed: "</span> + (System.currentTimeMillis() - start)</span><br><span class="line">                 + <span class="string">"ms) from netty client "</span> + NetUtils.getLocalHost() + <span class="string">" using dubbo version "</span></span><br><span class="line">                 + Version.getVersion() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line">     Throwable e = exception.get();</span><br><span class="line">     <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> e;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>连接服务流程和 NettyClient 一致。</p><h2 id="断开连接-doDisConnect"><a href="#断开连接-doDisConnect" class="headerlink" title="断开连接 doDisConnect"></a>断开连接 doDisConnect</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDisConnect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 直接使用 Mina API 移除关闭的通道</span></span><br><span class="line">          MinaChannel.removeChannelIfDisconnected(session);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          logger.warn(t.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>断开连接仅仅是在客户端连接服务的通道处于关闭状态时，把对应的通道缓存清除。</p><h2 id="获取连接到服务的通道-getChannel"><a href="#获取连接到服务的通道-getChannel" class="headerlink" title="获取连接到服务的通道 getChannel"></a>获取连接到服务的通道 getChannel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Channel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      IoSession s = session;</span><br><span class="line">      <span class="keyword">if</span> (s == <span class="keyword">null</span> || !s.isConnected()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> MinaChannel.getOrAddChannel(s, getUrl(), <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>获取连接到服务的通道是父类的模版方法，用于返回具体NIO的通道对应的 Dubbo 通道，这里是返回Mina的通道对应的Dubbo 层面的MinaChanel 。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>无论是 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> ，还是 <a href="https://gentryhuang.com/posts/53cd7ee7/">网络传输层</a> 都是为具体实现服务的，具体实现依赖上层抽象，在 Mina 这个 NIO 框架的实现角度来看依赖的上层（dubbo-remoting-api）是透明的即通用的逻辑模版。整个 Transport 层相关的核心继承关系如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-netty4-server-hierarchy.jpg" alt></p><p>至此，Dubbo 接入 Mina 实现网络通信就介绍完了，其实这篇文章是对 <a href="https://gentryhuang.com/posts/4468445c/">Netty4网络通信</a> <strong>的删剪版</strong>，为什么接入Netty库和接入Mina库实现起来的差异如此之小，我们可以发现两者的流程基本一致，如果非要说区别那就是两者的 API 和实现机制不同。这得益于 Dubbo 的优秀设计，它把 NIO库的共性全都进行了抽象，进而屏蔽不同 NIO 库之间的差异，扩展性大大增强。包括没有介绍到的 <strong>dubbo-remoting-grizzly</strong> 模块，实现模式也是一样的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/53cd7ee7/&quot;&gt;网络传输层&lt;/a&gt; 中对 Trans
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Mina" scheme="https://gentryhuang.com/tags/Mina/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - Netty4网络通信</title>
    <link href="https://gentryhuang.com/posts/4468445c/"/>
    <id>https://gentryhuang.com/posts/4468445c/</id>
    <published>2020-05-29T16:00:00.000Z</published>
    <updated>2020-12-01T01:45:15.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://gentryhuang.com/posts/53cd7ee7/">网络传输层</a> 中对 Transport 通用层或者说是抽象层进行了详细分析。接下来会继续分析 Transport 层的 NIO库实现，本篇文章将分析 Dubbo 如何将 Neety4 接入实现。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在 NIO 库的选型上，有很多优秀的开源框架，如 Netty、Mina、Grizzy 等，Dubbo 的选择是分别对这些框架进行集成。对上层进行抽象以屏蔽不同 NIO 库的差异，抽象对应的模块是 <strong>dubbo-remoting-api</strong>，在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中介绍了核心的接口和类。针对每一个 NIO 框架的接入，Dubbo 都构建一个单独的模块，该模块只需实现抽象模块 <strong>dubbo-remoting-api</strong> 即可，结合 Dubbo SPI 机制可以灵活切换到不同的 NIO 库。下面我们开始介绍实现层 <strong>dubbo-remoting-netty4</strong> 模块，代码结构如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-netty4-outline.jpg" alt></p><p>上面的代码结构诠释了 “麻雀虽小五脏俱全”，作为一个通信框架该有的基本元素都具备了。注意，在当前分析的 Dubbo 版本中默认使用的是 Netty3 实现，考虑到现在主流 Netty4 而且 Dubbo 最新版本已经默认切换成了 Netty4 实现，另一方面 Netty3 接入和 Netty4 基本一致，因此就不再分析 Netty3 实现。</p><p>通过下面的 UML 图会更加清晰看到 Netty4 实现中各个功能类之间的关联关系。下面我们就根据 UML 图的依赖关系逐个分析。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-netty4-uml.jpg" alt></p><h1 id="NettyTransporter"><a href="#NettyTransporter" class="headerlink" title="NettyTransporter"></a>NettyTransporter</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTransporter</span> <span class="keyword">implements</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拓展名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"netty4"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定一个服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 通道处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> server 返回服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NettyServer(url, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接一个服务器，即创建一个客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 通道处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> client 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NettyClient(url, listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NettyTransporter 实现了 Transporter 扩展接口，关于 Transporter 扩展接口已经在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中进行了介绍，默认扩展实现是 <strong>netty</strong> 即 Netty3 实现。bind() 和 connect() 方法分别用于创建 <strong>NettyServer</strong> 和 <strong>NettyClient</strong> 对象。一般 Transport 扩展实现会由 Transport 的门面 Transports 统一向上层提供，这个上层就是 Exchange 信息交互层。下面我们继续分析 NettyTransporter 创建的服务和客户端。</p><h1 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h1><p>NettyServer 是基于 Netty4 实现的服务，下面我们对它的属性、构造方法以及基本方法进行详细说明。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractServer</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道集合,这里是连接到服务器的客户端通道集合</span></span><br><span class="line"><span class="comment">     * key: ip:port</span></span><br><span class="line"><span class="comment">     * value: Dubbo 的 Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Channel&gt; channels;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Netty 服务端的引导类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ServerBootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Netty 的 Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> io.netty.channel.Channel channel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * boss 线程组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup bossGroup;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * worker 线程组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup workerGroup;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NettyServer 继承了 AbstractServer，并实现了 Server 接口，是 Netty 服务实现类。NettyServer 通过层层继承拥有了很多类的职能，如 <strong>端点（Endpoint）、通道处理（ChannelHandler）、(服务端)Server ，其中间接关联了 ChannelHandler（AbstractPeer中的属性）和 Codec2（AbstractEndpoint中的）对象</strong> 。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractServer</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 NettyServer 时，会对传入的 ChannelHandler 进行层层包装。</span></span><br><span class="line"><span class="comment">     * 其中在包装过程中， Dispatcher创建的ChanglHandler的过程都要创建一个线程池，然后保存到Datasource 中。 todo 2.7.7 对次做了优化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// ChannelHandlers.wrap方法，用来包装 ChannelHandler，实现Dubbo 线程模型的功能。 SERVER_THREAD_POOL_NAME -&gt; 'DubboServerHandler'</span></span><br><span class="line">        <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NettyServer 的构造方法主要两个工作，但这两个工作信息量非常大。对上层传入的 ChannelHandler 进行包装，调用父类 AbstractServer 的构造方法。包装 ChannelHandler 的方法在 <a href="https://gentryhuang.com/posts/53cd7ee7/#ChannelHandlers">网络传输层</a> 中已经详细说明，会自动为传入的 ChannelHandler 外面包裹三层 ChannelHandler，即 <strong>MultiMessageHandler(HeartbeatHandler(线程模型Handler(传入的ChannelHandler)))</strong> ，其中线程模型Handler默认为 AllChannelHandler，<strong>线程模型Handler进行创建的时候会初始化线程池并存放到 DataSource 中（是父类 WrappedChannelHandler 的职能）</strong> 。下面对这两件事整体概括：</p><ol><li>对传入的 ChannelHandler 进行包装，最终得到一个增强的 ChannelHandler。注意，它不再是传入进来的 ChannelHandler 。</li><li>执行 super(URL,ChannelHandler) ，调用父类 AbstractServer 的构造方法。</li><li>将增强后的 ChannelHandler 和 上层传入的 URL 通过父类构造方法层层向下传递，直到 AbstractPeer 抽象类，该类将 ChannelHandler 和 URL 保存起来。</li><li>第 3 步向上调用父类构造方法时，执行到 AbstractEndpoint 抽象类时，会通过传递的 URL 获取 Codec2 的扩展实现类以及超时时间和连接超时时间。</li><li>执行到 AbstractServer 构造方法时，分别获取服务地址、绑定地址、最大可接受连接数、空闲超时时间以及从 DataSource 中获取当前服务端口对应的线程池。</li><li>第 5 步还有最重要的一个过程，调用模版方法启动服务，而这个模版方法每个子类服务都会进行实现，这里就是 NettyServer 的 doOpen 方法。</li></ol><p>NettyServer 构造方法中 ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME) 方法用于设置线程名到 URL 参数中，该个线程名包含 URL 的地址信息，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--- ExecutorUtil</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> URL <span class="title">setThreadName</span><span class="params">(URL url, String defaultName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从URL中获取 threadname 的值作为线程名，没有就使用defaultName</span></span><br><span class="line">        String name = url.getParameter(Constants.THREAD_NAME_KEY, defaultName);</span><br><span class="line">        name = name + <span class="string">"-"</span> + url.getAddress();</span><br><span class="line">        url = url.addParameter(Constants.THREAD_NAME_KEY, name);</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="启动服务方法-doOpen"><a href="#启动服务方法-doOpen" class="headerlink" title="启动服务方法 doOpen"></a>启动服务方法 doOpen</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">--- NettyServer</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 创建引导类</span></span><br><span class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别创建Boss线程组和Worker线程组</span></span><br><span class="line">        bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>, <span class="keyword">new</span> DefaultThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));</span><br><span class="line">        workerGroup = <span class="keyword">new</span> NioEventLoopGroup(getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),</span><br><span class="line">                <span class="keyword">new</span> DefaultThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建NettyServerHandler对象，注意传入的第二个参数是 NettyServer 对象本身，因为NettyServer是ChannelHander的子类。</span></span><br><span class="line">        <span class="comment">// 由于 NettyServerHandler 继承了 ChannelDuplexHandler，因此它是 Netty 层面的 ChannelHanlder。</span></span><br><span class="line">        <span class="keyword">final</span> NettyServerHandler nettyServerHandler = <span class="keyword">new</span> NettyServerHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取当前NettyServer创建的所有Channel</span></span><br><span class="line">        channels = nettyServerHandler.getChannels();</span><br><span class="line"></span><br><span class="line">        bootstrap</span><br><span class="line">                <span class="comment">// 设置线程组</span></span><br><span class="line">                .group(bossGroup, workerGroup)</span><br><span class="line">                <span class="comment">// 服务端使用NioServerSocketChannel 作为传输通道</span></span><br><span class="line">                .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                // 配置可选项，<span class="title">Netty</span> 优化相关</span></span><br><span class="line"><span class="class">                .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">TCP_NODELAY</span>, <span class="title">Boolean</span>.<span class="title">TRUE</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">SO_REUSEADDR</span>, <span class="title">Boolean</span>.<span class="title">TRUE</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">childOption</span>(<span class="title">ChannelOption</span>.<span class="title">ALLOCATOR</span>, <span class="title">PooledByteBufAllocator</span>.<span class="title">DEFAULT</span>)</span></span><br><span class="line"><span class="class">                // 设置出入站通道处理器链</span></span><br><span class="line"><span class="class">                .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">NioSocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 创建编解码适配器,NettyCodecAdapter中会创建Decoder和Encoder</span></span><br><span class="line">                        NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">                        <span class="comment">// ChannelPipeline</span></span><br><span class="line">                        ch.pipeline()</span><br><span class="line">                                <span class="comment">//.addLast("logging",new LoggingHandler(LogLevel.INFO)) // 打印日志，方便debug</span></span><br><span class="line">                                <span class="comment">// 注册解码器</span></span><br><span class="line">                                .addLast(<span class="string">"decoder"</span>, adapter.getDecoder())</span><br><span class="line">                                <span class="comment">// 注册编码器</span></span><br><span class="line">                                .addLast(<span class="string">"encoder"</span>, adapter.getEncoder())</span><br><span class="line">                                <span class="comment">// 注册NettyServerHandler</span></span><br><span class="line">                                .addLast(<span class="string">"handler"</span>, nettyServerHandler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务器绑定指定地址和端口 ，启动 Netty</span></span><br><span class="line">        ChannelFuture channelFuture = bootstrap.bind(getBindAddress());</span><br><span class="line">        <span class="comment">// 等待绑定完成</span></span><br><span class="line">        channelFuture.syncUninterruptibly();</span><br><span class="line">        <span class="comment">// 获取服务通道，即用来接收客户端连接的 Channel</span></span><br><span class="line">        channel = channelFuture.channel();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>启动服务的方法是父类的一个模版方法，该方法的信息量很大，从 Netty 角度看就是使用的标准化流程并没有什么特别的地方，但是从 Dubbo 的角度看涉及很多核心组件。下面对主要的过程进行概括：</p><ol><li>初始化 ServerBootstrap 、创建 Boss 线程组和 Worker 线程组。</li><li>创建 Dubbo 层面的 NettyServerHandler 对象，因其继承了 ChannelDuplexHandler 类，因此它又属于 Netty 层面的 ChannelHandler，这给出了一个非常重要的信息，那就是该对象有处理 Netty 通道消息或事件的能力。</li><li>获取 NettyServerHandler 中维护的 channels 缓存集合，该集合是 io.netty.channel.Channel.remoteAddress 到 Dubbo层面的 NettyChannel 的映射，而 NettyChannel 内部封装了 Netty的Channel，NettyChannel 和 Netty的Channel 是一一对应的关系。从代码中不难看出 NettyServer 和 NettyServerHandler 共用一个 channels 缓存集合。当有连接创建时，先是创建该Netty连接对应的Dubbo层面的NettyChannel（不存在的情况下），然后 channels 就会把该NettyChannel缓存起来。当有连接断开时，就根据当前Netty连接的 remoteAddress 从 channels 中移除对应的NettyChannel。</li><li>设置服务侧 Channel 类型为 NioServerSocketChannel，并设置一些可选项用来优化Netty。</li><li>创建 ChannelInitializer 并指定如何初始化 Channel 上的 ChannelHandler 等一系列 Netty 使用的标准化流程，其中注册了编解码器和 NettyServerHandler 对象。</li><li>在第 5 步中，会分别创建Netty的编码器和解码器，NettyCodecAdapter 只是一个适配对象，其两个内部类才是真正的 Netty 的编解码器。</li></ol><p>下文会对该过程涉及的接口及实现类分别说明，接下来我们继续分析 NettyServer 中的方法，此后我们要时刻牢记 NettyServer 通过层层继承拥有了很多类的职能。</p><h2 id="关闭服务方法-doClose"><a href="#关闭服务方法-doClose" class="headerlink" title="关闭服务方法 doClose"></a>关闭服务方法 doClose</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">--- NettyServer</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 关闭服务器通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.warn(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接到服务器的客户端通道</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Collection&lt;com.alibaba.dubbo.remoting.Channel&gt; channels = getChannels();</span><br><span class="line">            <span class="keyword">if</span> (channels != <span class="keyword">null</span> &amp;&amp; channels.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 依次遍历连接到服务器的客户端通道，然后进行关闭操作</span></span><br><span class="line">                <span class="keyword">for</span> (com.alibaba.dubbo.remoting.Channel channel : channels) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        channel.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        logger.warn(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.warn(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优雅关闭线程组</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bootstrap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bossGroup.shutdownGracefully();</span><br><span class="line">                workerGroup.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.warn(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空连接到服务器的客户端通道</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channels != <span class="keyword">null</span>) &#123;</span><br><span class="line">                channels.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.warn(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>关闭服务主要工作如下：</strong></p><ol><li>关闭服务通道 channel</li><li>关闭连接到服务的客户端通道集合们</li><li>关闭线程组</li><li>清空连接到服务的客户端通道缓存</li></ol><h2 id="获得客户端通道集合"><a href="#获得客户端通道集合" class="headerlink" title="获得客户端通道集合"></a>获得客户端通道集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--- NettyServer</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;Channel&gt; chs = <span class="keyword">new</span> HashSet&lt;Channel&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Channel channel : <span class="keyword">this</span>.channels.values()) &#123;</span><br><span class="line">            <span class="comment">// 已连接，则加入结果集</span></span><br><span class="line">            <span class="keyword">if</span> (channel.isConnected()) &#123;</span><br><span class="line">                chs.add(channel);</span><br><span class="line">                <span class="comment">// 未连接，移除</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channels.remove(NetUtils.toAddressString(channel.getRemoteAddress()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chs;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上代码用于获取连接到服务的客户端通道集合，注意只会筛选目前连接到服务的通道。</p><h2 id="是否启动成功"><a href="#是否启动成功" class="headerlink" title="是否启动成功"></a>是否启动成功</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> channel.isActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 Netty API 判断服务通道是否开启。</p><h1 id="NettyChannel"><a href="#NettyChannel" class="headerlink" title="NettyChannel"></a>NettyChannel</h1><p>NettyChannel 继承了 AbstractChannel，是对 io.netty.channel.Channel 的装饰，使用了装饰者模式，与 io.netty.channel.Channel 是一对一的关系。</p><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChannel</span> <span class="keyword">extends</span> <span class="title">AbstractChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Netty的Channel 到 Dubbo的Channel 映射集合</span></span><br><span class="line"><span class="comment">     * key: Netty 的 Channel</span></span><br><span class="line"><span class="comment">     * value: NettyChannel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Channel, NettyChannel&gt; channelMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Channel, NettyChannel&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Netty的Channel，和当前的 Dubbo Channel对象一一对应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前Channel 中附加属性集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attributes = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装饰 Netty的Channel</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel Netty的Channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NettyChannel</span><span class="params">(Channel channel, URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"netty channel == null;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NettyChannel 中的属性已经详细标注，其中它的构造方法是私有的，调用入口只有一个，是该类内部方法 – getOrAddChannel() 。</p><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="创建-NettyChannel"><a href="#创建-NettyChannel" class="headerlink" title="创建 NettyChannel"></a>创建 NettyChannel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--- NettyChannel</span><br><span class="line"> <span class="function"><span class="keyword">static</span> NettyChannel <span class="title">getOrAddChannel</span><span class="params">(Channel ch, URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        NettyChannel ret = channelMap.get(ch);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建 NettyChannel，封装 Netty的 Channel</span></span><br><span class="line">            NettyChannel nettyChannel = <span class="keyword">new</span> NettyChannel(ch, url, handler);</span><br><span class="line">            <span class="comment">// 处于连接中</span></span><br><span class="line">            <span class="keyword">if</span> (ch.isActive()) &#123;</span><br><span class="line">                <span class="comment">// 添加到 通道集合缓存中</span></span><br><span class="line">                ret = channelMap.putIfAbsent(ch, nettyChannel);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">                ret = nettyChannel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>优先从缓存中找，找不到则创建 NettyChannel 对象，NettyChannel 对象封装了 io.netty.channel.Channel 对象、传入的 ChannelHandler 和 URL，如果封装的 Netty 通道是连接状态，则加入缓存。需要特别说明的是，NettyChannel 继承了 AbstractChannel，而 AbstractChannel 又继承了 AbstractPeer 抽象类，在 <a href="https://gentryhuang.com/posts/53cd7ee7/#AbstractPeer-%E6%8A%BD%E8%B1%A1%E7%B1%BB">网络传输层</a> 中已经详细介绍过了AbstractPeer 抽象类，它是整个 Remoting 层链路最底层，上层传入的 ChannelHandler 会最终保存在该类中。因此，getOrAddChannel() 方法不仅创建了 NettyChannel，也设置了 AbstractPeer 类中的 ChannelHandler 和 URL 属性的值，这意味着 AbstractPeer 当前子类对象关联了这两个属性的值。</p><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>该方法是 Endpoint 接口中的方法，并非 Channel 接口中的方法，Channel接口没有发送消息的方法。它会通过装饰的 Netty 框架 Channel 将数据发送到对端，并且支持等待发送完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">--- NettyChannel</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 检查连接是否可用</span></span><br><span class="line">        <span class="keyword">super</span>.send(message, sent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否执行成功。 如果不需要等待发送成功（sent = false），默认就是成功状态</span></span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> timeout = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用Netty 的 Channel 发送消息</span></span><br><span class="line">            ChannelFuture future = channel.writeAndFlush(message);</span><br><span class="line">            <span class="comment">// 为true的话，会等待消息发送成功或者超时</span></span><br><span class="line">            <span class="keyword">if</span> (sent) &#123;</span><br><span class="line">                timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">                success = future.await(timeout);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发生异常就抛出</span></span><br><span class="line">            Throwable cause = future.cause();</span><br><span class="line">            <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> cause;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message "</span> + message + <span class="string">" to "</span> + getRemoteAddress() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送失败，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message "</span> + message + <span class="string">" to "</span> + getRemoteAddress()</span><br><span class="line">                    + <span class="string">"in timeout("</span> + timeout + <span class="string">"ms) limit"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="操作通道附加属性"><a href="#操作通道附加属性" class="headerlink" title="操作通道附加属性"></a>操作通道附加属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">--- NettyChannel</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAttribute</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> attributes.containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getAttribute</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> attributes.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// The null value unallowed in the ConcurrentHashMap.</span></span><br><span class="line">            attributes.remove(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            attributes.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        attributes.remove(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--- NettyChannel</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 标记关闭 ，设置 com.alibaba.dubbo.remoting.transport.AbstractPeer.closed 的值为 true</span></span><br><span class="line">            <span class="keyword">super</span>.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 移除断开连接的Channel对应的Dubbo NettyChannel</span></span><br><span class="line">            removeChannelIfDisconnected(channel);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 清空属性 attributes</span></span><br><span class="line">            attributes.clear();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Close netty channel "</span> + channel);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭Netty 的 Channel，注意在关闭前对一些其它资源进行清理工作。</span></span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="清理-NettyChannel-缓存"><a href="#清理-NettyChannel-缓存" class="headerlink" title="清理 NettyChannel 缓存"></a>清理 NettyChannel 缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeChannelIfDisconnected</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Netty的Channel 未连接</span></span><br><span class="line">     <span class="keyword">if</span> (ch != <span class="keyword">null</span> &amp;&amp; !ch.isActive()) &#123;</span><br><span class="line">         channelMap.remove(ch);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="获取地址"><a href="#获取地址" class="headerlink" title="获取地址"></a>获取地址</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取本机地址 - Endpoint 接口中的方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">getLocalAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (InetSocketAddress) channel.localAddress();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取远程地址 - Channel 接口中的方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> InetSocketAddress <span class="title">getRemoteAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (InetSocketAddress) channel.remoteAddress();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h1><p>通过前文的 UML 关系图以及 NettyServer 启动服务方法，我们不难看出 NettyCodecAdapter 充当适配器角色，严格来说属于对象适配器模式，即 将 Dubbo 的 Codec2 编解码器适配成 Netty 层面的编码器和解码器，Netty 会把编解码工作委托给 Dubbo 的 Codec2 编解码器去处理。相关关系如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-netty4-codec.jpg" alt></p><p>在 <a href="https://gentryhuang.com/posts/53cd7ee7/#AbstractEndpoint-%E6%8A%BD%E8%B1%A1%E7%B1%BB">网络传输层</a> 中已经详细介绍过了 AbstractEndpoint 抽象类，该抽象类中的 <strong>codec</strong> 属性正是 Codec2 类型，该属性在 AbstractEndpoint 构造方法中被初始化，而 NettyServer 间接继承了 AbstractEndpoint 抽象类，在创建 NettyServer 对象时该编解码属性也进行了初始化。</p><h2 id="属性及方法"><a href="#属性及方法" class="headerlink" title="属性及方法"></a>属性及方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyCodecAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Netty 的 编码器。内部封装的Codec2 ，是在 &#123;<span class="doctag">@link</span> com.alibaba.dubbo.remoting.transport.AbstractEndpoint&#125; 中创建的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler encoder = <span class="keyword">new</span> InternalEncoder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Netty 的 解码器。内部封装的Codec2 ，是在 &#123;<span class="doctag">@link</span> com.alibaba.dubbo.remoting.transport.AbstractEndpoint&#125; 中创建的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler decoder = <span class="keyword">new</span> InternalDecoder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo 的 编解码器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Codec2 codec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo 的 ChannelHandler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> com.alibaba.dubbo.remoting.ChannelHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyCodecAdapter</span><span class="params">(Codec2 codec, URL url, com.alibaba.dubbo.remoting.ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.codec = codec;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取编码器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">getEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取解码器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">getDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编码器实现"><a href="#编码器实现" class="headerlink" title="编码器实现"></a>编码器实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">--- NettyCodecAdapter</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码器  - MessageToByteEncoder：编码器抽象类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> ctx ChannelHandler 的上下文</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> msg msg</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> out 缓冲区</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 创建 NettyBackedChannelBuffer</span></span><br><span class="line">            com.alibaba.dubbo.remoting.buffer.ChannelBuffer buffer = <span class="keyword">new</span> NettyBackedChannelBuffer(out);</span><br><span class="line">            <span class="comment">// 从当前ChannelHandlerContext中获取对应的 Channel 对象 </span></span><br><span class="line">            <span class="comment">// Channel : pipeline : ChannelHandler : ChannelHandlerContext = 1:1:n:n</span></span><br><span class="line">            Channel ch = ctx.channel();</span><br><span class="line">            <span class="comment">// 获取 Netty 通道对应的 Dubbo Channel</span></span><br><span class="line">            NettyChannel channel = NettyChannel.getOrAddChannel(ch, url, handler);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 编码，将解码任务委托给 Codec2 实现去完成</span></span><br><span class="line">                codec.encode(channel, buffer, msg);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 移除 Netty的Channel关联的缓存</span></span><br><span class="line">                NettyChannel.removeChannelIfDisconnected(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="解码器实现"><a href="#解码器实现" class="headerlink" title="解码器实现"></a>解码器实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">--- NettyCodecAdapter</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码器 - ByteToMessageDecoder： 解码器抽象类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf input, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建Dubbo 对 Netty 的缓存区封装的 NettyBackedChannelBuffer 对象</span></span><br><span class="line">            ChannelBuffer message = <span class="keyword">new</span> NettyBackedChannelBuffer(input);</span><br><span class="line">            <span class="comment">// 获取 Netty 通道对应的 Dubbo Channel</span></span><br><span class="line">            NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line"></span><br><span class="line">            Object msg;</span><br><span class="line">            <span class="keyword">int</span> saveReaderIndex;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 循环解析数据，直到结束</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 记录当前读进度</span></span><br><span class="line">                    saveReaderIndex = message.readerIndex();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 将解码任务委托给 Codec2 完成</span></span><br><span class="line">                        msg = codec.decode(channel, message);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 需要更多的输入，即消息不完整，标记回原有读进度，并结束</span></span><br><span class="line">                    <span class="keyword">if</span> (msg == Codec2.DecodeResult.NEED_MORE_INPUT) &#123;</span><br><span class="line">                        message.readerIndex(saveReaderIndex);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 解码到消息，添加到 out集合中，即 将读取到的消息传递给后面的Handler处理</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//is it possible to go here ? todo </span></span><br><span class="line">                        <span class="keyword">if</span> (saveReaderIndex == message.readerIndex()) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Decode without read data."</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            out.add(msg);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">while</span> (message.readable());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 移除 Netty的Channel 关联的缓存</span></span><br><span class="line">                NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NettyServerHandler"><a href="#NettyServerHandler" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h1><p>NettyServerHandler 继承了 io.netty.channel.ChannelDuplexHandler ，这是 Netty 提供的一个<strong>同时处理入站数据和出站数据</strong>的 ChannelHandler ，作为 Netty4 的通道处理器。</p><h2 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@io</span>.netty.channel.ChannelHandler.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo Channel 集合,即连接到当前服务的Dubbo Channel集合</span></span><br><span class="line"><span class="comment">     * key: Netty 通道的 remoteAddress</span></span><br><span class="line"><span class="comment">     * value: Dubbo 的 Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Channel&gt; channels = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Channel&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo ChannelHandler。NettyServerHandler 中几乎所有方法都会触发该对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServerHandler</span><span class="params">(URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 NettyServerHandler 中有 channels、handler 以及 url 属性。下面分别说明对应属性：</p><ol><li>channels 属性：保存当前 Server 创建的所有 Dubbo Channel，连接创建、连接断开都会操作 channels 集合进行相应的增删。其中 ServerHandler 也会使用该属性值。</li><li>url 属性： 通过构造方法传入。</li><li>handler属性：通道处理器，是 NettyServer 对象。NettyServerHandler 中几乎所有方法都会触发该 ChannelHandler 对象。</li></ol><h2 id="通道处理方法"><a href="#通道处理方法" class="headerlink" title="通道处理方法"></a>通道处理方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">--- NettyServerHandler</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------- NettyServerHandler 中以下所有方法都会触发装饰的 ChannelHandler 对象 ------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接创建触发该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交给下一个节点处理</span></span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Dubbo 的NettyChannel 对象</span></span><br><span class="line">        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加入到 连接到服务的 Dubbo Channel集合 中</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                channels.put(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()), channel);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交给 handler 处理，处理连接事件</span></span><br><span class="line">            handler.connected(channel);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/** 如果已经断开，就移除NettyChannel对象  &#123;<span class="doctag">@link</span> com.alibaba.dubbo.remoting.transport.netty4.NettyChannel.channelMap &#125;*/</span></span><br><span class="line">            NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接断开触发该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从缓存中移除 Netty Channel 对应的 Dubbo Channel</span></span><br><span class="line">            channels.remove(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()));</span><br><span class="line">            <span class="comment">// 将断开连接事件交给 handler处理</span></span><br><span class="line">            handler.disconnected(channel);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise future)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler.received(channel, msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> promise</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将发送的数据继续向下传递</span></span><br><span class="line">        <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler.sent(channel, msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            handler.caught(channel, cause);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="NettyServer-amp-NettyServerHandler"><a href="#NettyServer-amp-NettyServerHandler" class="headerlink" title="NettyServer &amp; NettyServerHandler"></a>NettyServer &amp; NettyServerHandler</h2><p>在 NettyServer 创建 NettyServerHandler 时，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建NettyServerHandler对象，注意传入的第二个参数是 NettyServer 对象本身，因为NettyServer是ChannelHandler的子类。</span></span><br><span class="line"><span class="comment">// 由于 NettyServerHandler 继承了 ChannelDuplexHandler，因此它是 Netty 层面的 ChannelHandler。</span></span><br><span class="line"><span class="keyword">final</span> NettyServerHandler nettyServerHandler = <span class="keyword">new</span> NettyServerHandler(getUrl(), <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>第一个参数是调用间接父类 AbstractPeer#getUrl() 方法获取上层传入的 URL对象。第二个参数正是 NettyServer 对象本身，通过之前的介绍，我们知道 NettyServer 继承关系，它的父类 AbstractPeer 实现了 ChannelHandler 接口，并且将所有方法都委托给了其装饰的 ChannelHandler 对象。因此，NettyServerHandler 中的通道方法都是交给 NettyServer 关联的 ChannelHandler 对象本身。</p><p>NettyServer 结构如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-netty4-frame-server.jpg" alt></p><p>由上图可知，Dubbo 接入 Netty4 这个 NIO 框架服务器部分具体实现还是很直观的，图中有四个元素：端点（NettyServer）、通道（NettyChannel）、编码器（InternalEncoder）和解码器（InternalDecoder）、通道处理器（NettyServerHandler）。从 Transporter 层来看，功能的不同其实就是注册在 Channel 上的 ChannelHandler 不同，对于 Netty 来说编解码器也属于通道处理器，而端点和通道这两个元素是必须存在的。</p><p>至此，我们可以看到 Dubbo 通过装饰者模式层层包装 ChannelHandler，从而不需要将每个 ChannelHandler 都挂载到 Pipeline 中，在 NettyServer 以及下面介绍的 NettyClient 中最多有 3 个 ChannelHandler，分别是编码器、解码器以及 NettyServerHandler(或 NettyClientHandler)。不仅是 Netty 实现的网络通信是这样的，Mina 等实现也是一样的，这在一定程度上避免了低效和浪费资源。</p><h1 id="服务小结"><a href="#服务小结" class="headerlink" title="服务小结"></a>服务小结</h1><p>无论是 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> ，还是 <a href="https://gentryhuang.com/posts/53cd7ee7/">网络传输层</a> 都是为具体实现服务的，具体实现依赖上层抽象，在 Netty4 这个 NIO 框架的实现角度来看依赖的上层（dubbo-remoting-api）是透明的即通用的逻辑模版。整个 Transport 层和服务相关的核心继承关系如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-netty4-server-hierarchy.jpg" alt></p><p>至此，Dubbo 接入 Netty4 的服务部分就介绍完了。从 AbstractPeer 开始一路继承下来，NettyServer 拥有了多个核心类的职能，关联了两个核心的对象，分别是 ChannelHandler 对象以及 Codec2 对象，这两个对象非常重要，到达服务底层的所有任务 NettyServer 最终都是委托给这两个对象进行处理的。等等，好像漏了通道这个核心对象，尽管它很重要，但是它毕竟是两个端点之间的TCP连接的抽象，对于上层来说一般是非可控的，Dubbo 层面的 Channel 最终是通对 Netty Channel 的装饰来完成工作的。通过前面的介绍，我们知道 NettyServer 关联的 ChannelHandler 是上层传入并经过包装后的对象，包装过程中的功能性对象可由上层通过配置进行管控的，如线程模型中的派发策略和线程池都是可指定的。NettyServer 关联的 Codec2 对象是根据上层传入的 URL 通过 Dubbo SPI 机制初始化的，而 URL 是 Dubbo 中的配置载体，同样是上层可控的。最后的结论是，上层只需要根据业务场景需要，实现 ChannelHandler 和 Codec2 这两个扩展接口即可。</p><p>下面我们开始分析 Dubbo 接入 Netty4 的客户端部分。这部分涉及的很多接口和类都是服务部分介绍过的，在下面介绍的客户端部分就不再重复说明。</p><h1 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h1><p>NettyClient 是基于 Netty4 实现的客户端，下面我们对它的属性、构造方法以及基本方法进行详细说明。</p><h2 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">extends</span> <span class="title">AbstractClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NioEventLoopGroup nioEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(Constants.DEFAULT_IO_THREADS, <span class="keyword">new</span> DefaultThreadFactory(<span class="string">"NettyClientWorker"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引导类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Bootstrap bootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Netty 的通道。使用volatitle 修饰符。因为客户端可能会和服务端断开连接，需要保证多线程的可见性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Channel channel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NettyClient 继承了 AbstractClient 抽象类，是 Dubbo 的 Netty 客户端实现类。Channel 属性只有一个，是因为作为客户端同一时间只会连接一个服务。其它两个属性是 Netty 层相关类。</p><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">      <span class="comment">// wrapChannelHandler方法用于包装ChannelHandler，其中实现了 Dubbo 线程模型的功能。 </span></span><br><span class="line">      <span class="keyword">super</span>(url, wrapChannelHandler(url, handler));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>NettyClient 构造方法流程和 NettyServer 构造方法流程大体一致，区别在 NettyServer 初始化服务器并启动，NettyClient 初始化客户端并连接服务器，其它流程一摸一样，无论是服务端还是客户端，都需要通道处理器，都需要编解码器。下面对构造方法流程简单总结：</p><ol><li>对传入的 ChannelHandler 进行包装，最终得到一个增强的 ChannelHandler。对传入的 URL 进行线程池类型和线程名配置赋值。</li><li>调用父类 AbstractClient 构造方法及上层父类方法，初始化编解码器 Codec2。</li><li>第 2 步执行 AbstractClient 构造方法时，根据 URL 参数配置依次初始化：<ul><li>发送消息时连接断开是否重连 url.send.reconnect（默认false）</li><li>关闭超时时间 url.shutdown.timeout（默认15min）</li><li>重连告警间隔时间即重连n次告警一次 url.reconnect.waring.period（默认1800）</li></ul></li><li>调用父类模版方法 doOpen() 启动客户端，启动过程出现异常则调用父类的 close() 方法并抛出异常。</li><li>连接服务器，先启动<strong>断线重连机制</strong>再调用父类模版方法 doConnect() 方法进行连接服务器，其中断线重连机制是父类方法。同样的，连接服务器失败则调用父类的 close() 方法并抛出异常。</li><li>从 DataSource 中获取当前客户端对应的线程池。</li></ol><p>NettyClient 构造方法中 wrapChannelHandler(url,handler) 方法用于设置线程名并设置线程池类型，相比 NettyServer 构造方法多了设置线程池类型步骤，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractClient</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> ChannelHandler <span class="title">wrapChannelHandler</span><span class="params">(URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置线程名，即 URL.threadname 配置参数值，默认为 'DubboClientHandler'</span></span><br><span class="line">        url = ExecutorUtil.setThreadName(url, CLIENT_THREAD_POOL_NAME);</span><br><span class="line">        <span class="comment">// 设置使用的线程池类型，即 URL.threadpool 配置参数值，默认值为 'cached'</span></span><br><span class="line">        url = url.addParameterIfAbsent(Constants.THREADPOOL_KEY, Constants.DEFAULT_CLIENT_THREADPOOL);</span><br><span class="line">        <span class="comment">// 包装通道处理器</span></span><br><span class="line">        <span class="keyword">return</span> ChannelHandlers.wrap(handler, url);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="启动客户端-doOpen"><a href="#启动客户端-doOpen" class="headerlink" title="启动客户端 doOpen"></a>启动客户端 doOpen</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 NettyClientHandler 对象，第二个参数是 NettyClient 对象本身，因为 NettyClient 是 ChannelHander的实现类。</span></span><br><span class="line">    <span class="keyword">final</span> NettyClientHandler nettyClientHandler = <span class="keyword">new</span> NettyClientHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 创建 Netty 客户端引导对象</span></span><br><span class="line">    bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    bootstrap</span><br><span class="line">            <span class="comment">// 设置它的线程组</span></span><br><span class="line">            .group(nioEventLoopGroup)</span><br><span class="line">            <span class="comment">// 设置可选项</span></span><br><span class="line">            .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">            .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">            .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class="line">            <span class="comment">//.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout())</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置 客户端对应的Channel类型</span></span><br><span class="line">            .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置连接超时时间，这里使用到 AbstractEndpoint 中的 connectTimeout 字段</span></span><br><span class="line">    <span class="keyword">if</span> (getConnectTimeout() &lt; <span class="number">3000</span>) &#123;</span><br><span class="line">        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getConnectTimeout());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置处理器执行链</span></span><br><span class="line">    bootstrap.handler(<span class="keyword">new</span> ChannelInitializer() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 创建 NettyCoderAdapter 对象</span></span><br><span class="line">            NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 获取Pipeline</span></span><br><span class="line">            ch.pipeline()</span><br><span class="line">                    <span class="comment">//.addLast("logging",new LoggingHandler(LogLevel.INFO)) // 设置日志，方便调试</span></span><br><span class="line">                    <span class="comment">// 注册解码器</span></span><br><span class="line">                    .addLast(<span class="string">"decoder"</span>, adapter.getDecoder())</span><br><span class="line">                    <span class="comment">// 注册编码器</span></span><br><span class="line">                    .addLast(<span class="string">"encoder"</span>, adapter.getEncoder())</span><br><span class="line">                    <span class="comment">// 注册处理器</span></span><br><span class="line">                    .addLast(<span class="string">"handler"</span>, nettyClientHandler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NettyClient 的启动客户端方法是父类的一个模版方法，和 NettyServer 的启动服务方法类似，下面简单概括：</p><ol><li>创建 Dubbo 层面的 NettyClientHandler 对象，因其继承了 Netty 中的 ChannelDuplexHandler 类，因此它又属于 Netty 层面的 ChannelHandler，直接参与 Netty 通道消息或事件的处理。</li><li>初始化客户端引导对象，设置参数项。其中不需要boss线程组，通道类型是 NioSocketChannel，<strong>连接超时时间是从父类 AbstractEndpoint 中获取</strong> 。</li><li>创建 ChannelInitializer 初始化器，指定如何初始化 Channel 上的 ChannelHandler 等系列 Netty 使用的标准化流程，这里就是注册通道处理器（包括编解码器）。</li></ol><p>客户端初始化完毕后，进入连接服务的流程。</p><h2 id="连接服务器-doConnect"><a href="#连接服务器-doConnect" class="headerlink" title="连接服务器 doConnect"></a>连接服务器 doConnect</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 记录连接开始时间</span></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 连接指定地址的服务，地址从 URL 配置总线中获取 （URL从AbstractPeer中取）</span></span><br><span class="line">    ChannelFuture future = bootstrap.connect(getConnectAddress());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 等待连接成功或者超时</span></span><br><span class="line">        <span class="keyword">boolean</span> ret = future.awaitUninterruptibly(getConnectTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接成功</span></span><br><span class="line">        <span class="keyword">if</span> (ret &amp;&amp; future.isSuccess()) &#123;</span><br><span class="line">            <span class="comment">// 取出连接服务的通道</span></span><br><span class="line">            Channel newChannel = future.channel();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果已经存在连接服务的通道了，就把老的关闭，使用新的</span></span><br><span class="line">                Channel oldChannel = NettyClient.<span class="keyword">this</span>.channel;</span><br><span class="line">                <span class="keyword">if</span> (oldChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(<span class="string">"Close old netty channel "</span> + oldChannel + <span class="string">" on create new netty channel "</span> + newChannel);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 关闭老的通道</span></span><br><span class="line">                        oldChannel.close();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 移除老的通道对应的缓存（即对应的 Dubbo 的通道 NettyChannel）</span></span><br><span class="line">                        NettyChannel.removeChannelIfDisconnected(oldChannel);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 若客户端关闭了，则关闭新的连接</span></span><br><span class="line">                <span class="keyword">if</span> (NettyClient.<span class="keyword">this</span>.isClosed()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(<span class="string">"Close new netty channel "</span> + newChannel + <span class="string">", because the client closed."</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        newChannel.close();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        NettyClient.<span class="keyword">this</span>.channel = <span class="keyword">null</span>;</span><br><span class="line">                        NettyChannel.removeChannelIfDisconnected(newChannel);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 更新连接服务的通道</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    NettyClient.<span class="keyword">this</span>.channel = newChannel;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 连接服务发生异常，则抛出</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (future.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"client(url: "</span> + getUrl() + <span class="string">") failed to connect to server "</span></span><br><span class="line">                    + getRemoteAddress() + <span class="string">", error message is:"</span> + future.cause().getMessage(), future.cause());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 连接超时，抛出RemotingException异常</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"client(url: "</span> + getUrl() + <span class="string">") failed to connect to server "</span></span><br><span class="line">                    + getRemoteAddress() + <span class="string">" client-side timeout "</span></span><br><span class="line">                    + getConnectTimeout() + <span class="string">"ms (elapsed: "</span> + (System.currentTimeMillis() - start) + <span class="string">"ms) from netty client "</span></span><br><span class="line">                    + NetUtils.getLocalHost() + <span class="string">" using dubbo version "</span> + Version.getVersion());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 没有连接</span></span><br><span class="line">        <span class="keyword">if</span> (!isConnected()) &#123;</span><br><span class="line">            <span class="comment">//future.cancel(true); </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端连接服务主要做了以下工作：</p><ol><li>调用 Netty 的 Bootstrap#connect(remoteAddress) 方法连接服务器，返回连接结果对象 ChannelFuture 。</li><li>调用 Netty 的 ChannelFuture#awaitUninterruptibly(getConnectTimeout(), TimeUnit.MILLISECONDS) 方法，等待连接成功或超时。</li><li>如果连接服务成功，先判断是否存在旧的连接通道，有则关闭旧的通道并删除对应的通道缓存，再判断当前客户端是否关闭（通道、线程池等资源），关闭则新的连接作废并删除对应的通道缓存。前置检测完成后，最后更新连接服务的通道。</li><li>连接失败，可能是连接服务异常，也可能是连接超时异常。</li><li>finally 块中的逻辑，当没有连接时什么也不做，可以看到官方把取消连接任务方法调用注释了，这里应该是前面判断失败的分支逻辑已经处理过了，没有连接无非就是连接失败或超时。</li></ol><h2 id="断开连接-doDisConnect"><a href="#断开连接-doDisConnect" class="headerlink" title="断开连接 doDisConnect"></a>断开连接 doDisConnect</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDisConnect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        NettyChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断开连接仅仅是在客户端连接服务的通道关闭时，把对应的通道缓存清除。</p><h2 id="获取连接到服务的通道-getChannel"><a href="#获取连接到服务的通道-getChannel" class="headerlink" title="获取连接到服务的通道 getChannel"></a>获取连接到服务的通道 getChannel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">protected</span> com.alibaba.dubbo.remoting.<span class="function">Channel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Channel c = channel;</span><br><span class="line">     <span class="keyword">if</span> (c == <span class="keyword">null</span> || !c.isActive()) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> NettyChannel.getOrAddChannel(c, getUrl(), <span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>获取连接到服务的通道是父类的模版方法，用于返回具体NIO的通道对应的 Dubbo 通道，这里是返回Netty的Channel对应的Dubbo 层面的NettyChanel 。</p><h1 id="NettyClientHandler"><a href="#NettyClientHandler" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h1><p>NettyClientHandler 的实现和 NettyServerHandler 类似，同样实现了 Netty 的 ChannelDuplexHandler。NettyClientHandler 会将所有方法委托给 NettyClient 关联的 ChannelHandler 对象进行处理。</p><h2 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@io</span>.netty.channel.ChannelHandler.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ChannelHandler，NettyClient 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler NettyClient</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClientHandler</span><span class="params">(URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 NettyClientHandler 中有两个属性，url 和 handler 。属性说明如下：</p><ol><li>url 属性：通过构造方法传入。</li><li>handler 属性：通道处理器，是 NettyClient 对象。NettyClientHandler 中几乎所有方法都会委托给该对象处理。</li></ol><h2 id="通道处理方法-1"><a href="#通道处理方法-1" class="headerlink" title="通道处理方法"></a>通道处理方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 处理连接事件</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;</span></span><br><span class="line"><span class="comment">  * 说明：不同于NettyServerHandler的该方法会提交给handler处理，客户端不会被连接，因此无需做连接处理。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     ctx.fireChannelActive();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 处理断开连接事件</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;</span></span><br><span class="line"><span class="comment">  * 说明： 不同于NettyServerHandler的该方法会提交给handler处理，客户端无需处理断开连接事件，因此无需做连接处理。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     ctx.fireChannelInactive();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//--------- 以下断开连接、读取数据、写数据以及异常处理，都是直接委托给ClientHandler装饰的ChannelHandler进行处理，所需的通道是 Netty通道对应Dubbo通道 --------------/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 断开连接</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> future</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(ChannelHandlerContext ctx, ChannelPromise future)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         handler.disconnected(channel);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 读取消息</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         handler.received(channel, msg);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 写数据</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> promise</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">     NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         handler.sent(channel, msg);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 异常处理</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         handler.caught(channel, cause);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>NettyClientHandler 对 io.netty.channel.ChannelDuplexHandler 重写的方法，在需要处理的时候都是委托给 NettyClient 关联的 ChannelHandler 对象，所需通道是 Netty通道对应的 Dubbo 通道，在前面的 NettyChannel 类中已经说明，它是对 Netty 通道的装饰，实际操作还是由 Netty 通道处理。</p><h2 id="NettyClient-amp-NettyClientHandler"><a href="#NettyClient-amp-NettyClientHandler" class="headerlink" title="NettyClient &amp; NettyClientHandler"></a>NettyClient &amp; NettyClientHandler</h2><p>NettyClient 创建 NettyClientHandler 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Dubbo NettyClientHandler 对象。注意传入的第二个参数是 NettyClient 对象本身，因为 NettyClient 是ChannelHander的实现类。</span></span><br><span class="line"><span class="keyword">final</span> NettyClientHandler nettyClientHandler = <span class="keyword">new</span> NettyClientHandler(getUrl(), <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>由于继承关系，NettyClient 继承了 AbstractPeer 抽象类，该类是将数据全部直接委托给装饰的 ChannelHandler 对象，因此 NettyClient 同样是将数据委托给其关联的 ChannelHandler 对象。</p><p>NettyClient 结构如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-netty4-frame-client.jpg" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇文章重点介绍了 Dubbo Transporter 层中基于 Netty4 实现的 Server 和 Client 实现以及相关的核心类，如 NettyTransporter 、 NettyChannel 通道、NettyServerHandler 和 NettyClientHandler 通道处理器、NettyCodecAdapter 编解码器，它们都是最低层的实现。前面文章也提到，<strong>dubbo-remoting-api</strong> 模块对于 <strong>dubbo-remoting-netty4</strong> 模块来说是透明的即通用的逻辑模版，其中 NettyServer 和 NettyClient 通过继承及实现，拥有了 Endpoint、ChannelHandler等多个接口的职能，关联了 ChannelHandler 对象和 Codec2 对象，并最终将数据委托给这两个对象去处理。上层只需要根据业务场景需要，配置功能参数到配置总线 URL 并实现 ChannelHandler 和 Codec2 这两个扩展接口即可，Codec2 的实现是在 AbstractEndpoint 抽象类的构造方法中根据 Dubbo SPI 获取的。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-netty4-frame.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/53cd7ee7/&quot;&gt;网络传输层&lt;/a&gt; 中对 Trans
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Netty" scheme="https://gentryhuang.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 网络传输层</title>
    <link href="https://gentryhuang.com/posts/53cd7ee7/"/>
    <id>https://gentryhuang.com/posts/53cd7ee7/</id>
    <published>2020-05-22T16:00:00.000Z</published>
    <updated>2020-12-11T06:05:32.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中对 Remoting 层进行了总体说明，下面我们开始详细介绍 Remoting 层的 Transport 网络传输层。本文会从 Transporter 层的 Server、Client、Channel、ChannelHandler、Dispatcher 以及 Codec2 等核心接口出发，分别介绍这些核心接口的实现。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>有很多网络库可以实现网络传输的功能，如 Netty、Mina、Grizzly等。但这些 NIO 库对外接口和使用方式不一样，如果使用方直接使用 Netty 或其它通信组件，那么就依赖了具体的NIO库实现，而不是依赖一个有传输能力的抽象，后续要切换其它NIO库实现的话就需要修改依赖和接入的相关代码，这既容易出错也不符合设计模式中的开放-封闭原则。因此，Dubbo Transporter 层就被抽象出来了，它屏蔽了不同的通信框架的异同，封装了统一的对外接口。有了 Transporter 层之后，我们可以通过 Dubbo SPI 动态切换具体的 Transporter 扩展实现，从而切换到不同的 Client 和 Server 实现，达到底层 NIO 库切换的目的。需要注意的是，Dubbo Transporter 层不等于 Transport 扩展接口及其实现，它是对网络传输层的抽象即在NIO库之上的抽象，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec, ChannelHandler, Dispatcher 等。</p><p>Transport 抽象层代码结构如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-outline.jpg" alt></p><p>注意， Dubbo 接入具体 NIO 库的代码散落在 dubbo-remoting-* 实现模块中，会在后面的文章中介绍。</p><h1 id="Transporter-扩展接口"><a href="#Transporter-扩展接口" class="headerlink" title="Transporter 扩展接口"></a>Transporter 扩展接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"netty"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个服务器，监听来自客户端的请求。根据 'server'，'transporter' 确定 Server 扩展实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> server 返回服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.remoting.Transporters#bind(URL, ChannelHandler...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    <span class="function">Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接服务器，即创建一个客户端。根据 'client','transporter' 确定 Client 扩展实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> client 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.remoting.Transporters#connect(URL, ChannelHandler...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    <span class="function">Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transporter 是在 Client 和 Server 之上封装的统一的对外接口，针对每个支持的NIO库，都有一个 Transporter 接口实现，它们是 Dubbo 接入具体NIO库的实现入口，在各个 dubbo-remoting-* 实现模块中。如，Dubbo 接入 Mina 网络通信库，就会有对应的 <strong>dubbo-remoting-mina</strong> 模块对抽象api模块的实现，该模块提供了 <strong>Transporter</strong>、<strong>Server</strong>、<strong>Client</strong>、<strong>Channel</strong>、<strong>ChannelHandler</strong> 等核心接口的实现。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-api.jpg" alt></p><p>这些 Transporter 接口实现返回的 Client 和 Server 具体实现如下图所示，它们是Dubbo 接入的NIO库对应的 Server和Client实现。</p><h2 id="具体NIO库Server的实现"><a href="#具体NIO库Server的实现" class="headerlink" title="具体NIO库Server的实现"></a>具体NIO库Server的实现</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-server.jpg" alt></p><h2 id="具体NIO库Client的实现"><a href="#具体NIO库Client的实现" class="headerlink" title="具体NIO库Client的实现"></a>具体NIO库Client的实现</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-client.jpg" alt></p><p>在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中已经介绍过 Transporter 接口以及该接口的门面类 Transporters ，这里不再重复介绍。关于通信具体实现模块会在后面的文章中介绍，它们也是 Transporter 层的一部分，本篇文章着重分析 Transport 层公用组件及抽象概念。</p><h1 id="AbstractPeer-抽象类"><a href="#AbstractPeer-抽象类" class="headerlink" title="AbstractPeer 抽象类"></a>AbstractPeer 抽象类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPeer</span> <span class="keyword">implements</span> <span class="title">Endpoint</span>, <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道处理器,AbstractPeer 对 ChannelHandler 接口的所有实现，都是委托给了这个 ChannelHandler 对象来处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 端点自身的 URL 类型的字段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正在关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closing;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * handler 属性，通道处理器，通过构造方法传入。使用 '装饰者模式'</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractPeer</span><span class="params">(URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractPeer 这个抽象类，它同时实现了 Endpoint 接口和 ChannelHandler 接口，AbstractPeer 对 ChannelHandler 接口的所有实现都是委托给维护的 ChannelHandler 属性来处理。对 Endpoint 接口的实现，包括和Channel有关的，如关闭Channel、开始关闭Channel(做标记关闭)、检查Channel是否关闭，这些都是对其维护的 <strong>closing</strong> 和 <strong>closed</strong> 属性进行操作；发送消息 send 方法的实现交给其子类去完成；获取端点自身的 URL；获取 ChannelHandler。<strong>需要特别说明的是，上层的 ChannelHandler 在链路的最底层保存的位置就是在 AbstractPeer 这个抽象类中</strong>。</p><p>AbstractPeer 也是 AbstractChannel、AbstractEndpoint 抽象类的父类，继承关系如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-abstractpeer-hierarchy.jpg" alt></p><p>红框中的实现类是 Dubbo 接入的具体NIO库实现相关的 Server、Client 和 Channel 实现类，通过继承关系以及前面的描述，我们可以知道 <strong>AbstractChannel、AbstractServer、AbstractClient 都会关联一个 ChannelHandler 对象</strong>，这个对象很重要，后面会慢慢揭开它的面纱。</p><h1 id="AbstractEndpoint-抽象类"><a href="#AbstractEndpoint-抽象类" class="headerlink" title="AbstractEndpoint 抽象类"></a>AbstractEndpoint 抽象类</h1><p>上文也提到了，AbstractEndpoint 继承了 AbstractPeer 这个抽象类，因为继承关系因此也会关联一个 ChannelHandler。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEndpoint</span> <span class="keyword">extends</span> <span class="title">AbstractPeer</span> <span class="keyword">implements</span> <span class="title">Resetable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractEndpoint<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编解码器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Codec2 codec;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接超时时间 (用于具体子类客户端连接超时时间)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> connectTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractEndpoint</span><span class="params">(URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类 AbstractPeer 的构造方法</span></span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line">        <span class="comment">// 根据URL中的 codec 参数值 获取Codec2的实现类</span></span><br><span class="line">        <span class="keyword">this</span>.codec = getChannelCodec(url);</span><br><span class="line">        <span class="comment">// 根据 URL 中的 timeout 参数确定 timeout 字段的值，默认 1000</span></span><br><span class="line">        <span class="keyword">this</span>.timeout = url.getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">        <span class="comment">// 根据URL中的connect.timeout 参数确定connectTimeout 字段值，默认 3000</span></span><br><span class="line">        <span class="keyword">this</span>.connectTimeout = url.getPositiveParameter(Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于Dubbo SPI机制，加载对应的Codec实现对象，如：在DubboProtocol中会获得DubboCodec对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Codec2 <span class="title">getChannelCodec</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        String codecName = url.getParameter(Constants.CODEC_KEY, <span class="string">"telnet"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(Codec2<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">codecName</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Codec2<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">codecName</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 注意： Codec接口已经废弃了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CodecAdapter(ExtensionLoader.getExtensionLoader(Codec<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">codecName</span>))</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码可以看到，<strong>AbstractEndpoint 中维护了一个编解码对象 Codec2 ，该对象是在 AbstractEndpoint 构造方法中根据传入的URL完成初始化</strong>，这个非常重要。除了维护 Codec2 编解码对象外，还维护了超时时间（timeout）和连接超时时间（connectTimeout），它们也是在构造方法中根据传入的URL进行初始化的。</p><p>此外，AbstractEndpoint 还实现了 Resetable 接口用来支持重置 AbstractEndpoint 中维护的三个属性，代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractEndpoint</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重置属性, 即使用新的 url 重置 codec、timeout、connectTimeout 属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isClosed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to reset parameters "</span></span><br><span class="line">                    + url + <span class="string">", cause: Channel closed. channel: "</span> + getLocalAddress());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (url.hasParameter(Constants.TIMEOUT_KEY)) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = url.getParameter(Constants.TIMEOUT_KEY, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.timeout = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (url.hasParameter(Constants.CONNECT_TIMEOUT_KEY)) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = url.getParameter(Constants.CONNECT_TIMEOUT_KEY, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.connectTimeout = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (url.hasParameter(Constants.CODEC_KEY)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.codec = getChannelCodec(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="抽象的服务端和客户端"><a href="#抽象的服务端和客户端" class="headerlink" title="抽象的服务端和客户端"></a>抽象的服务端和客户端</h1><p>由上面的继承关系图可知，AbstractServer 和 AbstractClient 都继承自 AbstractEndpoint 抽象类，下面我们先来分析 AbstractServer 这个抽象服务的实现。</p><h2 id="AbstractServer"><a href="#AbstractServer" class="headerlink" title="AbstractServer"></a>AbstractServer</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractServer</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_THREAD_POOL_NAME = <span class="string">"DubboServerHandler"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前Server关联的线程池，是从 DataStore 中取的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ExecutorService executor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前Server本地地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> InetSocketAddress localAddress;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定地址  （默认值与 localAddress 一致）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> InetSocketAddress bindAddress;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器最大可接受连接数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> accepts;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空闲超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idleTimeout = <span class="number">600</span>; <span class="comment">//600 seconds</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractServer 在继承 AbstractEndpoint 的同时，还实现了 Server 接口，是服务抽象类，<strong>重点实现了服务的公用逻辑</strong>，Server 接口在 在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中已经介绍，其中的属性已经在代码中详细标注。下面我们接着看它的构造方法，上述的属性字段都是在构造方法中进行初始化的。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractServer</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">AbstractServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类构造方法</span></span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line">        <span class="comment">// 服务地址: 本机地址  如：-&gt; /192.168.0.100:20880</span></span><br><span class="line">        localAddress = getUrl().toInetSocketAddress();</span><br><span class="line">        <span class="comment">// 获取ip和端口</span></span><br><span class="line">        String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());</span><br><span class="line">        <span class="keyword">int</span> bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());</span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(Constants.ANYHOST_KEY, <span class="keyword">false</span>) || NetUtils.isInvalidLocalHost(bindIp)) &#123;</span><br><span class="line">            <span class="comment">// 设置ip 为 0.0.0.0</span></span><br><span class="line">            bindIp = NetUtils.ANYHOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 绑定地址  如： /0.0.0.0:20880</span></span><br><span class="line">        bindAddress = <span class="keyword">new</span> InetSocketAddress(bindIp, bindPort);</span><br><span class="line">        <span class="comment">// 获取最大可接受连接数</span></span><br><span class="line">        <span class="keyword">this</span>.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);</span><br><span class="line">        <span class="comment">// 空闲超时时间</span></span><br><span class="line">        <span class="keyword">this</span>.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用模版方法 doOpen 启动服务</span></span><br><span class="line">            doOpen();</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Start "</span> + getClass().getSimpleName() + <span class="string">" bind "</span> + getBindAddress() + <span class="string">", export "</span> + getLocalAddress());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(url.toInetSocketAddress(), <span class="keyword">null</span>, <span class="string">"Failed to bind "</span> + getClass().getSimpleName()</span><br><span class="line">                    + <span class="string">" on "</span> + getLocalAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 从DataStore中获得线程池 ,来源 &#123;<span class="doctag">@link</span> com.alibaba.dubbo.remoting.transport.dispatcher.WrappedChannelHandler.WrappedChannelHandler&#125;*/</span></span><br><span class="line">        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>()</span>;</span><br><span class="line">        executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>构造方法会根据传入的URL初始化 AbstractServer 中的属性，这也是为了其子类的初始化做准备，其中在构造方法中调用了一个<strong>模版方法 doOpen，这个方法就是初始化其子类的关键入口，即启动具体的NIO服务</strong>，下篇文章分析具体NIO库是如何接入的就会清晰了。当前Server关联的线程池 executor 是从 DataStore 中取的，下文会对 DataStore 进行介绍并说明线程池的来源。</p><h3 id="模版方法"><a href="#模版方法" class="headerlink" title="模版方法"></a>模版方法</h3><p>用于子类实现，完成服务的开启和关闭工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br></pre></td></tr></table></figure><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>发送消息方法是对 Endpoint 接口的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractServer</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sent    true: 会等待消息发出，消息发送失败会抛出异常；  false: 不等待消息发出，将消息放入IO队列，即可返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取连接上服务器的通道列表 【客户端列表】</span></span><br><span class="line">        Collection&lt;Channel&gt; channels = getChannels();</span><br><span class="line">        <span class="comment">// 群发消息</span></span><br><span class="line">        <span class="keyword">for</span> (Channel channel : channels) &#123;</span><br><span class="line">            <span class="comment">// 如果是已经连接的就发送</span></span><br><span class="line">            <span class="keyword">if</span> (channel.isConnected()) &#123;</span><br><span class="line">                channel.send(message, sent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="客户端请求连接"><a href="#客户端请求连接" class="headerlink" title="客户端请求连接"></a>客户端请求连接</h3><p>用于客户端连接当前服务，是对父类 AbstractPeer 方法的重写，对 ChannelHandler 的实现，AbstractPeer 中的实现很简单，只是判断服务是否关闭，关闭就不会处理客户端连接请求，没有关闭则会把连接请求交给维护的 ChannelHandler 处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractServer</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// If the server has entered the shutdown process, reject any new connection</span></span><br><span class="line">        <span class="comment">// 调用父类AbstractPeer 中的方法，判读当前这个 Server 端是否正在关闭或关闭了。如果不是启动状态则直接关闭新建的 Client 连接。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isClosing() || <span class="keyword">this</span>.isClosed()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Close new channel "</span> + ch + <span class="string">", cause: server is closing or has been closed. For example, receive a new connect request while in shutdown process."</span>);</span><br><span class="line">            ch.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1 超过上限，关闭新的连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.1 获取连接上服务器的通道列表 【客户端列表】</span></span><br><span class="line">        Collection&lt;Channel&gt; channels = getChannels();</span><br><span class="line">        <span class="comment">//1.2 判断服务器上连接数是否超过上限</span></span><br><span class="line">        <span class="keyword">if</span> (accepts &gt; <span class="number">0</span> &amp;&amp; channels.size() &gt; accepts) &#123;</span><br><span class="line">            logger.error(<span class="string">"Close channel "</span> + ch + <span class="string">", cause: The server "</span> + ch.getLocalAddress() + <span class="string">" connections greater than max config "</span> + accepts);</span><br><span class="line">            <span class="comment">// 服务器上的连接数超过上上限的话，就关闭新的连接</span></span><br><span class="line">            ch.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理连接事件，AbstractPeer 中的方法，本质还是委托内部装饰的 ChannelHandler 来处理</span></span><br><span class="line">        <span class="keyword">super</span>.connected(ch);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="客户端断开连接"><a href="#客户端断开连接" class="headerlink" title="客户端断开连接"></a>客户端断开连接</h3><p>用于客户端断开连接当前服务，是对父类 AbstractPeer 方法的重写，对 ChannelHandler 的实现，AbstractPeer 中的实现很简单，直接把断开连接请求交给装饰的 ChannelHandler 处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractServer</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        Collection&lt;Channel&gt; channels = getChannels();</span><br><span class="line">        <span class="keyword">if</span> (channels.isEmpty()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"All clients has discontected from "</span> + ch.getLocalAddress() + <span class="string">". You can graceful shutdown now."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理断开连接请求</span></span><br><span class="line">        <span class="keyword">super</span>.disconnected(ch);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="服务关闭"><a href="#服务关闭" class="headerlink" title="服务关闭"></a>服务关闭</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">         logger.info(<span class="string">"Close "</span> + getClass().getSimpleName() + <span class="string">" bind "</span> + getBindAddress() + <span class="string">", export "</span> + getLocalAddress());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 关闭关联的线程池</span></span><br><span class="line">     ExecutorUtil.shutdownNow(executor, <span class="number">100</span>);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 标记关闭</span></span><br><span class="line">         <span class="keyword">super</span>.close();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         logger.warn(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 子类关闭动作</span></span><br><span class="line">         doClose();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">         logger.warn(e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>还有一些不是很重要的其它方法就不分析了，下面继续分析抽象客户端实现。</p><h2 id="AbstractClient"><a href="#AbstractClient" class="headerlink" title="AbstractClient"></a>AbstractClient</h2><p>AbstractClient 同样继承了 AbstractEndpoint 抽象类，并且实现了 Client 接口，是客户端的抽象类，实现了公用的逻辑。Client 接口在 在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中已经介绍过，就不再重复说明。</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClient</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span> <span class="keyword">implements</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接线程池名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLIENT_THREAD_POOL_NAME = <span class="string">"DubboClientHandler"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接线程池id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger CLIENT_THREAD_POOL_ID = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重连定时任务执行器，在客户端连接服务端时，会创建后台任务，定时检查连接，若断开会进行重新连</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledThreadPoolExecutor reconnectExecutorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">2</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboClientReconnectTimer"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接锁，用于实现发起连接和断开连接互斥，避免并发。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock connectLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息时，若断开，是否重连</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> send_reconnect;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重连次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger reconnect_count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重连时，是否已经打印过错误日志。默认没有打印过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean reconnect_error_log_flag = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重连warning的间隔，warning多少次之后warning一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> reconnect_warning_period;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> shutdown_timeout;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前客户端对应的线程池</span></span><br><span class="line"><span class="comment">     * 在调用 &#123;<span class="doctag">@link</span> #wrapChannelHandler(URL, ChannelHandler)&#125; 时，会调用 &#123;<span class="doctag">@link</span> com.alibaba.dubbo.remoting.transport.dispatcher.WrappedChannelHandler&#125; 创建</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> ExecutorService executor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重连执行任务 Future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ScheduledFuture&lt;?&gt; reconnectExecutorFuture = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最后成功连接时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastConnectedTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractClient 中的相关属性已经详细标注，因为是客户端，会涉及到重连服务的情况，属性相对比服务端要多些，但是这些属性都是很有用的 。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractClient</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AbstractClient</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从URL中，获得重连相关配置，即 send.reconnect 配置属性</span></span><br><span class="line">        send_reconnect = url.getParameter(Constants.SEND_RECONNECT_KEY, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从URL中获得关闭超时时间 即 shutdown.timeout 配置属性</span></span><br><span class="line">        shutdown_timeout = url.getParameter(Constants.SHUTDOWN_TIMEOUT_KEY, Constants.DEFAULT_SHUTDOWN_TIMEOUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The default reconnection interval is 2s, 1800 means warning interval is 1 hour.</span></span><br><span class="line">        reconnect_warning_period = url.getParameter(<span class="string">"reconnect.waring.period"</span>, <span class="number">1800</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化客户端</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doOpen();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 初始化失败，则关闭，并抛出异常</span></span><br><span class="line">            close();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(url.toInetSocketAddress(), <span class="keyword">null</span>,</span><br><span class="line">                    <span class="string">"Failed to start "</span> + getClass().getSimpleName() + <span class="string">" "</span> + NetUtils.getLocalAddress()</span><br><span class="line">                            + <span class="string">" connect to the server "</span> + getRemoteAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接服务器</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connect();</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Start "</span> + getClass().getSimpleName() + <span class="string">" "</span> + NetUtils.getLocalAddress() + <span class="string">" connect to the server "</span> + getRemoteAddress());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException t) &#123;</span><br><span class="line">            <span class="comment">// 如果连接失败，并且配置了启动检查，则进行对应的逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                <span class="comment">// 关闭连接</span></span><br><span class="line">                close();</span><br><span class="line">                <span class="keyword">throw</span> t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"Failed to start "</span> + getClass().getSimpleName() + <span class="string">" "</span> + NetUtils.getLocalAddress()</span><br><span class="line">                        + <span class="string">" connect to the server "</span> + getRemoteAddress() + <span class="string">" (check == false, ignore and retry later!), cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            close();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(url.toInetSocketAddress(), <span class="keyword">null</span>,</span><br><span class="line">                    <span class="string">"Failed to start "</span> + getClass().getSimpleName() + <span class="string">" "</span> + NetUtils.getLocalAddress()</span><br><span class="line">                            + <span class="string">" connect to the server "</span> + getRemoteAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从DataStore中获得线程池，这里的线程池就是线程模型中的涉及的线程池</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> WrappedChannelHandler#WrappedChannelHandler(com.alibaba.dubbo.remoting.ChannelHandler, com.alibaba.dubbo.common.URL)&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        executor = (ExecutorService) ExtensionLoader.getExtensionLoader(DataStore<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>().<span class="title">get</span>(<span class="title">Constants</span>.<span class="title">CONSUMER_SIDE</span>, <span class="title">Integer</span>.<span class="title">toString</span>(<span class="title">url</span>.<span class="title">getPort</span>()))</span>;</span><br><span class="line">        ExtensionLoader.getExtensionLoader(DataStore<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>().<span class="title">remove</span>(<span class="title">Constants</span>.<span class="title">CONSUMER_SIDE</span>, <span class="title">Integer</span>.<span class="title">toString</span>(<span class="title">url</span>.<span class="title">getPort</span>()))</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>构造方法中不仅初始化了属性，还调用了模版方法，用于完成子类的初始化工作，即完成客户端的初始化并连接上服务。具体的客户端实现同样在后面的文章中说明。</p><h3 id="模版方法-1"><a href="#模版方法-1" class="headerlink" title="模版方法"></a>模版方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractClient</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Open client.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Close client.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Connect to server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * disConnect to server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doDisConnect</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the connected channel.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Channel <span class="title">getChannel</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>与 AbstractServer 类似，AbstractClient 定义了 doOpen()、doClose()、doConnect()、 doDisConnect() 和 getChannel() 抽象方法给子类实现以完成特定的功能。其中 doClose() 方法在 Netty 实现中是个空方法。</p><h3 id="连接服务的通用逻辑"><a href="#连接服务的通用逻辑" class="headerlink" title="连接服务的通用逻辑"></a>连接服务的通用逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractClient</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 获得锁 </span></span><br><span class="line">        connectLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断连接状态，若已经连接就不重复连接。</span></span><br><span class="line">            <span class="keyword">if</span> (isConnected()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化重连线程 【断线重连机制】</span></span><br><span class="line">            initConnectStatusCheckCommand();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行连接</span></span><br><span class="line">            doConnect();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否已经连接，如过连接失败则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (!isConnected()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed connect to server "</span> + getRemoteAddress() + <span class="string">" from "</span> + getClass().getSimpleName() + <span class="string">" "</span></span><br><span class="line">                        + NetUtils.getLocalHost() + <span class="string">" using dubbo version "</span> + Version.getVersion()</span><br><span class="line">                        + <span class="string">", cause: Connect wait timeout: "</span> + getConnectTimeout() + <span class="string">"ms."</span>);</span><br><span class="line">                <span class="comment">// 连接成功，打印日志</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Successed connect to server "</span> + getRemoteAddress() + <span class="string">" from "</span> + getClass().getSimpleName() + <span class="string">" "</span></span><br><span class="line">                            + NetUtils.getLocalHost() + <span class="string">" using dubbo version "</span> + Version.getVersion()</span><br><span class="line">                            + <span class="string">", channel is "</span> + <span class="keyword">this</span>.getChannel());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置重连次数归零</span></span><br><span class="line">            reconnect_count.set(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置未打印过重连错误日志</span></span><br><span class="line">            reconnect_error_log_flag.set(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed connect to server "</span> + getRemoteAddress() + <span class="string">" from "</span> + getClass().getSimpleName() + <span class="string">" "</span></span><br><span class="line">                    + NetUtils.getLocalHost() + <span class="string">" using dubbo version "</span> + Version.getVersion()</span><br><span class="line">                    + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            connectLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>连接服务通用逻辑主要做了以下工作：</p><ol><li>获得锁，用于实现在连接和断开连接同时操作时，通过加锁以防止并发问题。</li><li>判断是否连接，如果连接了就无需再连接，是否连接逻辑是对Channel接口方法的实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractClient</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo的Channel 接口中的方法。方法内部调用的是Channel对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Channel channel = getChannel();</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channel.isConnected();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>开启断线重连机制，即初始化重连线程，定时检查连接状态。</li><li>调用具体客户端实现的连接服务的方法去连接对应的服务。</li><li>连接失败抛出异常，连接成功则打印日志并归零重连次数。</li></ol><h3 id="断线重连机制"><a href="#断线重连机制" class="headerlink" title="断线重连机制"></a>断线重连机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractClient</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化重连线程 【以一定频率尝试重连任务】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initConnectStatusCheckCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得重连频率  【注意：默认是开启的，2000毫秒】</span></span><br><span class="line">        <span class="keyword">int</span> reconnect = getReconnectParam(getUrl());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若开启重连功能，创建重连线程 </span></span><br><span class="line">        <span class="keyword">if</span> (reconnect &gt; <span class="number">0</span> &amp;&amp; (reconnectExecutorFuture == <span class="keyword">null</span> || reconnectExecutorFuture.isCancelled())) &#123;</span><br><span class="line">            <span class="comment">// 创建重连任务体</span></span><br><span class="line">            Runnable connectStatusCheckCommand = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 判断是否连接，未连接就重连</span></span><br><span class="line">                        <span class="keyword">if</span> (!isConnected()) &#123;</span><br><span class="line">                            connect();</span><br><span class="line">                            <span class="comment">// 已连接则记录最后连接时间（确保是连接状态的时间）</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            lastConnectedTime = System.currentTimeMillis();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 符合条件时，打印错误或告警日志。 如果不加节制打印日志，很容易打出满屏日志，严重的可能造成JVM崩溃</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 超过一定时间未连接上，才打印异常日志。并且，仅打印一次。默认15分钟</span></span><br><span class="line">                        String errorMsg = <span class="string">"client reconnect to "</span> + getUrl().getAddress() + <span class="string">" find error . url: "</span> + getUrl();</span><br><span class="line">                        <span class="comment">// wait registry sync provider list</span></span><br><span class="line">                        <span class="keyword">if</span> (System.currentTimeMillis() - lastConnectedTime &gt; shutdown_timeout) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!reconnect_error_log_flag.get()) &#123;</span><br><span class="line">                                reconnect_error_log_flag.set(<span class="keyword">true</span>);</span><br><span class="line">                                logger.error(errorMsg, t);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 按照一定的重连次数，打印告警日志</span></span><br><span class="line">                        <span class="keyword">if</span> (reconnect_count.getAndIncrement() % reconnect_warning_period == <span class="number">0</span>) &#123;</span><br><span class="line">                            logger.warn(errorMsg, t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 发起重连定时任务，定时检查是否需要重连 [默认两秒检查一次]</span></span><br><span class="line">            reconnectExecutorFuture = reconnectExecutorService.scheduleWithFixedDelay(connectStatusCheckCommand, reconnect, reconnect, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>断线重连机制就是在客户端连接服务端时，会创建后台任务，定时检查连接，若断开会进行重连。</p><h3 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractClient</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sent    true: 会等待消息发出，消息发送失败会抛出异常；  false: 不等待消息发出，将消息放入IO队列，即可返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 未连接时，并且开启了发送消息断开重连功能，则先发起连接</span></span><br><span class="line">        <span class="keyword">if</span> (send_reconnect &amp;&amp; !isConnected()) &#123;</span><br><span class="line">            connect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取通道，如 NettyChannel 实例，该实例内部channel实例就是 NioClientSocketChannel。</span></span><br><span class="line">        Channel channel = getChannel();</span><br><span class="line">        <span class="comment">//TODO Can the value returned by getChannel() be null? need improvement.</span></span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span> || !channel.isConnected()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"message can not send, because channel is closed . url:"</span> + getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        channel.send(message, sent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>客户端连接服务时只会有对应的一个 Channel 通道，客户端发送消息时使用的是 Dubbo 接入具体NIO库的 Channel 实例，如 NettyChannel 实例，它内部封装的 Channel 实例是 Netty 的通道实例 NioClientSocketChannel 。这个在后面的文章中详细说明。</p><h3 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h3><p>该方法目前用在 reconnect() 重连方法和 close() 关闭方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 加锁</span></span><br><span class="line">     connectLock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 1 关闭断线重连任务</span></span><br><span class="line">         destroyConnectStatusCheckCommand();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 2 关闭连接服务的通道</span></span><br><span class="line">             Channel channel = getChannel();</span><br><span class="line">             <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 channel.close();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">             logger.warn(e.getMessage(), e);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 3 清除通道缓存(Dubbo 层面的 Channel，该Channel 内部封装了NIO库的Channel，它们是一对一关系)</span></span><br><span class="line">             doDisConnect();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">             logger.warn(e.getMessage(), e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         connectLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="重连"><a href="#重连" class="headerlink" title="重连"></a>重连</h3><p>先断开连接，在进行连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reconnect</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">// 1 先断开连接</span></span><br><span class="line">    disconnect();</span><br><span class="line">    <span class="comment">// 2 连接</span></span><br><span class="line">    connect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 1 关闭线程池</span></span><br><span class="line">          <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">              ExecutorUtil.shutdownNow(executor, <span class="number">100</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          logger.warn(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 2 标记通道关闭完成</span></span><br><span class="line">          <span class="keyword">super</span>.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          logger.warn(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 3 断开连接</span></span><br><span class="line">          disconnect();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          logger.warn(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//4 执行关闭</span></span><br><span class="line">          doClose();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          logger.warn(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="超时关闭"><a href="#超时关闭" class="headerlink" title="超时关闭"></a>超时关闭</h3><p>对线程池超时关闭</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">       ExecutorUtil.gracefulShutdown(executor, timeout);</span><br><span class="line">       close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="抽象通道-AbstractChannel"><a href="#抽象通道-AbstractChannel" class="headerlink" title="抽象通道 AbstractChannel"></a>抽象通道 AbstractChannel</h1><p>AbstractChannel 同样继承了 AbstractPeer 这个抽象类，同时还实现了 Channel 接口。AbstractChannel 实现非常简单，只是在 send() 方法中检测了底层连接的状态，没有实现具体的发送消息的逻辑。注意，一般情况下 <strong>Dubbo 层面的 Channel 和 具体NIO库的通道是一对一的关系，前者会对后者进行装饰，前者的功能本质上是后者的职能</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannel</span> <span class="keyword">extends</span> <span class="title">AbstractPeer</span> <span class="keyword">implements</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关联了 ChannelHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractChannel</span><span class="params">(URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息，在这里只做底层连接状态检查，没有实现具体的发送消息的逻辑，具体的发送逻辑由子类实现</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sent    true: 会等待消息发出，消息发送失败会抛出异常；  false: 不等待消息发出，将消息放入IO队列，即可返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isClosed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message "</span> + (message == <span class="keyword">null</span> ? <span class="string">""</span> : message.getClass().getName()) + <span class="string">":"</span> + message + <span class="string">", cause: Channel closed. channel: "</span> + getLocalAddress() + <span class="string">" -&gt; "</span> + getRemoteAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承关系图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-abstractchannel-hierarchy.jpg" alt></p><p>各子类实现会对 send 方法进行重写。</p><h1 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h1><p>前文介绍的 AbstractEndpoint、AbstractChannel 都是通过对 AbstractPeer 继承间接实现了 ChannelHandler 接口并关联了 ChannelHandler 对象，仅仅是对 ChannelHandler 的装饰，方法都是委托给底层关联的这个 ChannelHandler 对象。下面我们对 Transporter 层相关的 ChannelHandler 进行详细分析。继承关系如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-channelhandler.jpg" alt></p><h2 id="ChannelHandlerAdapter"><a href="#ChannelHandlerAdapter" class="headerlink" title="ChannelHandlerAdapter"></a>ChannelHandlerAdapter</h2><p>ChannelHandlerAdapter 是 ChannelHandler 的一个空实现，TelnetHandlerAdapter 继承了它并实现了 TelnetHandler 接口，用于支持 Dubbo 命令行的服务治理。关于 Telnet 的实现，会在后面单独进行介绍，这里就不展开说明了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ChannelHandlerAdapter.  实现ChannelHandler接口，通道处理器适配器，每个方法都是空实现。子类可根据具体场景选择性实现所需方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sent</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ChannelHandlerDispatcher"><a href="#ChannelHandlerDispatcher" class="headerlink" title="ChannelHandlerDispatcher"></a>ChannelHandlerDispatcher</h2><p>在前面的文章中有提到过 ChannelHandlerDispatcher，它维护了一个 CopyOnWriteArraySet 集合，负责将多个 ChannelHandler 对象聚合成一个 ChannelHandler 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelHandlerDispatcher</span> <span class="keyword">implements</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChannelHandlerDispatcher<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道处理器集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;ChannelHandler&gt; channelHandlers = <span class="keyword">new</span> CopyOnWriteArraySet&lt;ChannelHandler&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelHandlerDispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelHandlerDispatcher</span><span class="params">(ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(handlers == <span class="keyword">null</span> ? <span class="keyword">null</span> : Arrays.asList(handlers));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelHandlerDispatcher</span><span class="params">(Collection&lt;ChannelHandler&gt; handlers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlers != <span class="keyword">null</span> &amp;&amp; !handlers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.channelHandlers.addAll(handlers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略对 ChannelHandler 接口方法的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChannelHandlerDispatcher 实现了 ChannelHandler 接口中的所有方法，每个方法都是循环通道集合调用相应的方法。</p><h2 id="ChannelHandlerDelegate"><a href="#ChannelHandlerDelegate" class="headerlink" title="ChannelHandlerDelegate"></a>ChannelHandlerDelegate</h2><p>实现 ChannelHandler 接口，通道处理器装饰者接口，即<strong>是对其它 ChannelHandler 进行装饰的接口，这个接口非常重要</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandlerDelegate</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取装饰的ChannelHandler</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ChannelHandler <span class="title">getHandler</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChannelHandlerDelegate 有三个直接的实现类，分别是 <strong>AbstractChannelHandlerDelegate</strong>、<strong>WrappedChannelHandler</strong> 和 <strong>HeaderExchangeHandler</strong> ，它们就是对其它 ChannelHandler 的装饰。其中 <strong>HeaderExchangeHandler</strong> 是 Exchange 层涉及的对象，我们先不讨论。我们先来分析 AbstractChannelHandlerDelegate 继承体系。</p><h3 id="AbstractChannelHandlerDelegate"><a href="#AbstractChannelHandlerDelegate" class="headerlink" title="AbstractChannelHandlerDelegate"></a>AbstractChannelHandlerDelegate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannelHandlerDelegate</span> <span class="keyword">implements</span> <span class="title">ChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 装饰的 ChannelHandler</span></span><br><span class="line">    <span class="keyword">protected</span> ChannelHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannelHandlerDelegate</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(handler, <span class="string">"handler == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> ChannelHandlerDelegate) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((ChannelHandlerDelegate) handler).getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        handler.connected(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        handler.disconnected(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sent</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        handler.sent(channel, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        handler.received(channel, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        handler.caught(channel, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 ChannelHandlerDelegate 接口，在每个实现的方法里都是直接调用被装饰的 ChannelHandler 对象对应的方法，没有其它逻辑。它的三个子类都是在被装饰的 ChannelHandler 的基础上添加了一些增强的功能，使用的是装饰者模式。因为 <strong>HeartbeatHandler</strong> 属于 Exchange 层的 ChannelHandler ，在分析  Exchange 层时再进行分析，这里不再展开说明。</p><h4 id="DecodeHandler"><a href="#DecodeHandler" class="headerlink" title="DecodeHandler"></a>DecodeHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeHandler</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(DecodeHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecodeHandler</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆写了 received(channel,message)方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message RpcInvocation 或 RpcResult</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec#decodeBody(com.alibaba.dubbo.remoting.Channel, java.io.InputStream, byte[])</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 当消息是 Decodeable 类型时 进行解码</span></span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Decodeable) &#123;</span><br><span class="line">            decode(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当消息是Request类型时，对 data 字段进行解码</span></span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">            decode(((Request) message).getData());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当消息是Response类型时，对 result 字段进行解码</span></span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">            decode(((Response) message).getResult());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解码后，调用ChannelHandler#received(channel,message)方法，将消息交给委托的handler继续处理</span></span><br><span class="line">        handler.received(channel, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Decodeable 接口目前有两个实现类：</span></span><br><span class="line"><span class="comment">         * 1 DecodeableRpcInvocation</span></span><br><span class="line"><span class="comment">         * 2 DecodeableRpcResult</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (message != <span class="keyword">null</span> &amp;&amp; message <span class="keyword">instanceof</span> Decodeable) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 解析消息</span></span><br><span class="line">                ((Decodeable) message).decode();</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(<span class="string">"Decode decodeable message "</span> + message.getClass().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Call Decodeable.decode failed: "</span> + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// ~ end of catch</span></span><br><span class="line">        &#125; <span class="comment">// ~ end of if</span></span><br><span class="line">    &#125; <span class="comment">// ~ end of method decode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DecodeHandler 是一个解码处理器，<strong>专门用于处理 Decodeable 类型消息的 ChannelHandler实现类</strong>，因此该实现类只重写了 received() 接收消息的方法，它的作用和含义如下：</p><ol><li>请求解码可在IO线程上执行，也可在线程池中执行，取决于配置。DecodeHandler 存在的意义就是保证请求体或响应体可在线程池中被解码。</li></ol><blockquote><p>在Codec2解码器实现中，如果请求体和响应结果需要在线程池中进行解码，那么就不进行直接解码，而是把解码任务最终交给线程池来处理，最后由 DecodeHandler来处理，因为 DecodeHandler 也参与了对上层 ChannelHandler 的包装。</p></blockquote><ol start="2"><li>实现了 Decodeable 接口的类都会提供了一个 decode() 方法实现对自身的解码，DecodeHandler.received() 方法就是通过该方法得到解码后的消息，然后传递给底层的 ChannelHandler 对象继续处理。</li></ol><h4 id="MultiMessageHandler"><a href="#MultiMessageHandler" class="headerlink" title="MultiMessageHandler"></a>MultiMessageHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiMessageHandler</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiMessageHandler</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆写了 received方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 消息类型是MultiMessage，即多消息</span></span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> MultiMessage) &#123;</span><br><span class="line">            MultiMessage list = (MultiMessage) message;</span><br><span class="line">            <span class="comment">// 循环提交给handler处理</span></span><br><span class="line">            <span class="keyword">for</span> (Object obj : list) &#123;</span><br><span class="line">                handler.received(channel, obj);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是单消息时，直接提交给handler处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handler.received(channel, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MultiMessageHandler 是<strong>专门处理 MultiMessage 类型消息</strong>的 ChannelHandler 实现类。MultiMessage 是 Exchange 层的一种消息类型，它其中封装了多个消息。在 MultiMessageHandler 收到 MultiMessage 消息的时候，received() 方法会遍历其中的所有消息，并交给底层的 ChannelHandler 对象进行处理。</p><p>至此，Transport 层的 AbstractChannelHandlerDelegate 继承体系分析完毕。下面我们继续看 ChannelHandlerDelegate 的另一条继承体系分支。</p><h3 id="WrappedChannelHandler"><a href="#WrappedChannelHandler" class="headerlink" title="WrappedChannelHandler"></a>WrappedChannelHandler</h3><p>WrappedChannelHandler 也实现了 ChannelHandlerDelegate 接口，也是对其它 ChannelHandler 装饰的类。WrappedChannelHandler 在 ChannelHandler 接口方法实现上和 AbstractChannelHandlerDelegate 基本一致，那为什么又要搞一个新的继承体系而不是直接继承 AbstractChannelHandlerDelegate 呢？因为 <strong>WrappedChannelHandler 继承体系不仅是对其它 ChannelHandler 的装饰而且还决定了 Dubbo 的线程模型</strong>，有关 Dubbo 中的线程池会单独分析，这里先不展开说明。WrappedChannelHandler 关联体系如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-channelhandler-dispatcher.jpg" alt></p><p>从上图可知，每个 WrappedChannelHandler 的子类都有一个对应的 Dispatcher 实现类，这些实现类就是用来创建 WrappedChannelHandler 的子类们。 Dispatcher 接口已经在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中已经介绍过，它主要支持了 Dubbo 的线程模型，通过它的实现类可以创建不同的 ChannelHandler 来决定消息是交给线程池处理还是IO线程处理。</p><p>WrappedChannelHandler 实现了 ChannelHandlerDelegate 接口，其子类实现了消息派发功能，即决定了 Dubbo 以哪种线程模型处理收到的事件和消息。每个子类都由对应的Dispatcher 实现类创建。</p><p><strong>属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrappedChannelHandler</span> <span class="keyword">implements</span> <span class="title">ChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WrappedChannelHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 共享线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService SHARED_EXECUTOR = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboSharedHandler"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前端点关联的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被装饰的通道处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WrappedChannelHandler 中有四个核心的属性，因为是对 ChannelHandler 的装饰，因此 ChannelHandler 是必须的。需要说明的是共享线程池和当前端点关联的线程池，共享线程池对每个子类公用，当前端点关联的线程池属于每个子类对象独有，它是在构造方法中初始化的。</p><p><strong>构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">--- WrappedChannelHandler</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrappedChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于SPI机制创建线程池</span></span><br><span class="line">        executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>().<span class="title">getExecutor</span>(<span class="title">url</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认是 ExecutorService 的名称</span></span><br><span class="line">        String componentKey = Constants.EXECUTOR_SERVICE_COMPONENT_KEY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是消费端，则 componentKey 为 'consumer'</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(Constants.SIDE_KEY))) &#123;</span><br><span class="line">            componentKey = Constants.CONSUMER_SIDE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于SPI机制创建线程池存储对象</span></span><br><span class="line">        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加线程池到 DataStore中</span></span><br><span class="line">        dataStore.put(componentKey, Integer.toString(url.getPort()), executor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过 WrappedChannelHandler 的构造方法可知，每个子类对象都会创建一个线程池并添加到 DataStore 缓存起来，我们上面介绍的 AbstractClient 和 AbstractServer 是从 DataStore 获得线程池的，而数据来源正是这里。关于线程池的介绍，会在后面的文章中详细分析，这里先不展开说明。</p><p>DataSource 核心就是一个 Map 结构缓存，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleDataStore 是 DataStore 唯一扩展实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDataStore</span> <span class="keyword">implements</span> <span class="title">DataStore</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key1: ExecutorService 的名称 或 'consumer'</span></span><br><span class="line"><span class="comment">     * key2: port</span></span><br><span class="line"><span class="comment">     * value: ExecutorService</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt; data = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">get</span><span class="params">(String componentName)</span> </span>&#123;</span><br><span class="line">        ConcurrentMap&lt;String, Object&gt; value = data.get(componentName);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;String, Object&gt;(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String componentName, String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.containsKey(componentName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.get(componentName).get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String componentName, String key, Object value)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; componentData = data.get(componentName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == componentData) &#123;</span><br><span class="line">            data.putIfAbsent(componentName, <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;());</span><br><span class="line">            componentData = data.get(componentName);</span><br><span class="line">        &#125;</span><br><span class="line">        componentData.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String componentName, String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!data.containsKey(componentName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data.get(componentName).remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取线程池</strong></p><p>获取线程池，供子类使用调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--- WrappedChannelHandler</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前端点关联的公共线程池，部分子类会使用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getExecutorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = executor;</span><br><span class="line">        <span class="comment">// 当前端点关联的线程池为空或关闭就使用共享的</span></span><br><span class="line">        <span class="keyword">if</span> (cexecutor == <span class="keyword">null</span> || cexecutor.isShutdown()) &#123;</span><br><span class="line">            cexecutor = SHARED_EXECUTOR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cexecutor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>WrappedChannelHandler 实现 ChannelHandler 接口的方法都是直接调用装饰的 ChannelHandler 对应的方法，就不再进行分析。</p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>如果事件处理的逻辑能迅速完成，并且不会发起新的 IO 请求，比如只是在内存中记个标识，则直接在 IO 线程上处理更快，因为减少了线程池调度。但如果事件处理逻辑较慢，或者需要发起新的 IO 请求，比如需要查询数据库，则必须派发到线程池，否则 IO 线程阻塞，将导致不能接收其它请求。因此，需要通过不同的派发策略和不同的线程池配置的组合来应对不同的场景:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">dispatcher</span>=<span class="string">"all"</span> <span class="attr">threadpool</span>=<span class="string">"fixed"</span> <span class="attr">threads</span>=<span class="string">"100"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-threadpool-model.jpg" alt></p><p>Dubbo 的线程模型需要具有线程派发能力的 ChannelHandler 和 定制化的线程池来支撑。Dispatcher 的职责就是用来创建具有线程派发能力的 ChannelHandler，其本身并不具备线程派发能力。关于 Dispatcher 在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中已经介绍，这里不再重复说明。</p><p>Dispatcher 派发策略：</p><ul><li><strong>all:</strong> 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。</li><li><strong>direct:</strong> 所有消息都不派发到线程池，全部在 IO 线程上直接执行。</li><li><strong>message:</strong> 只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在 IO 线程上执行。</li><li><strong>execution:</strong> 只有请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在 IO 线程上执行。</li><li><strong>connection:</strong> 在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。</li></ul><p>关于线程池部分在后面的文章中详细说明，先不在这里展开介绍。</p><p>Dispatcher 实现类用来创建 WrappedChannelHandler 的子类对象，每个子类对象代表不同的派发策略，同时子类对象在创建的时候会初始化一个线程池。下面我们来分析 Dispatcher 扩展实现和对应的 WrappedChannelHandler 的子类。</p><h4 id="AllDispatcher-amp-AllChannelHandler"><a href="#AllDispatcher-amp-AllChannelHandler" class="headerlink" title="AllDispatcher &amp; AllChannelHandler"></a>AllDispatcher &amp; AllChannelHandler</h4><p>AllDispatcher 用来创建 AllChannelHandler 对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllDispatcher</span> <span class="keyword">implements</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"all"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 AllChannelHandler 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">dispatch</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AllChannelHandler(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AllChannelHandler 实现 WrappedChannelHandler 抽象类，所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllChannelHandler</span> <span class="keyword">extends</span> <span class="title">WrappedChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法调用父类方法，创建独享的线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AllChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理连接事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取线程池</span></span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将CONNECTED 事件的处理封装成ChannelEventRunnable提交到线程池中执行</span></span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(<span class="string">"connect event"</span>, channel, getClass() + <span class="string">" error when process connected event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理断开连接事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取线程池</span></span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建ChannelEventRunnable对象，用于将断开连接事件任务派发到线程池执行</span></span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(<span class="string">"disconnect event"</span>, channel, getClass() + <span class="string">" error when process disconnected event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收到的所有消息都派发到线程池。注意这里的message 可能是 Request也可能是 Response。</span></span><br><span class="line"><span class="comment">     * 流程大概是：消息先由IO线程（Netty 中的EventLoopGroup ）从二进制流中解码出来，然后执行到该方法会把请求提交给线程池处理，处理完后调用send 方法用于向对端写回结果。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将请求/响应消息派发到线程池中处理，ChannelEventRunnable对象作为任务体</span></span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 如果是请求消息，并且出现了线程池满了的异常</span></span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request &amp;&amp; t <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</span><br><span class="line">                Request request = (Request) message;</span><br><span class="line">                <span class="comment">// 如果通信方式为双向通信，将错误信息封装到Response 中，并返回给服务消费方。防止消费端等待超时</span></span><br><span class="line">                <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                    String msg = <span class="string">"Server side("</span> + url.getIp() + <span class="string">","</span> + url.getPort() + <span class="string">") threadpool is exhausted ,detail msg:"</span> + t.getMessage();</span><br><span class="line">                    Response response = <span class="keyword">new</span> Response(request.getId(), request.getVersion());</span><br><span class="line">                    response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);</span><br><span class="line">                    response.setErrorMessage(msg);</span><br><span class="line">                    <span class="comment">// 返回包含错误信息的 Response 对象</span></span><br><span class="line">                    channel.send(response);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(message, channel, getClass() + <span class="string">" error when process received event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(<span class="string">"caught event"</span>, channel, getClass() + <span class="string">" error when process caught event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AllChannelHandler 重写了 WrappedChannelHandler 中除了 sent() 方法之外的其它方法，执行底层的 ChannelHandler 的逻辑都交给线程池处理，但是发送消息 AllChannelHandler 会直接在 IO 线程中进行处理。</p><h4 id="ExecutionDispatcher-amp-AllChannelHandler"><a href="#ExecutionDispatcher-amp-AllChannelHandler" class="headerlink" title="ExecutionDispatcher &amp; AllChannelHandler"></a>ExecutionDispatcher &amp; AllChannelHandler</h4><p>ExecutionDispatcher 用来创建 ExecutionChannelHandler 对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutionDispatcher</span> <span class="keyword">implements</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"execution"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 ExecutionChannelHandler 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">dispatch</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutionChannelHandler(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExecutionChannelHandler 实现 WrappedChannelHandler 抽象类，只会将请求消息派发到线程池进行处理。对于响应消息以及其他网络事件（例如，连接建立事件、连接断开事件、心跳消息等），ExecutionChannelHandler 会直接在 IO 线程中进行处理，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutionChannelHandler</span> <span class="keyword">extends</span> <span class="title">WrappedChannelHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法调用父类方法，创建独享的线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutionChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="comment">// 请求消息</span></span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</span><br><span class="line">                    Request request = (Request) message;</span><br><span class="line">                    <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                        String msg = <span class="string">"Server side("</span> + url.getIp() + <span class="string">","</span> + url.getPort()</span><br><span class="line">                                + <span class="string">") thread pool is exhausted, detail msg:"</span> + t.getMessage();</span><br><span class="line">                        Response response = <span class="keyword">new</span> Response(request.getId(), request.getVersion());</span><br><span class="line">                        response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);</span><br><span class="line">                        response.setErrorMessage(msg);</span><br><span class="line">                        channel.send(response);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(message, channel, getClass() + <span class="string">" error when process received event."</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 直接交给装饰的 ChannelHandler 处理</span></span><br><span class="line">            handler.received(channel, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面代码可知，ExecutionChannelHandler 只重写了 received() 方法并且只处理请求消息，其它方法的调用直接调用父类的，是直接在 IO 线程中进行处理。</p><h4 id="DirectDispatcher-amp-DirectChannelHandler"><a href="#DirectDispatcher-amp-DirectChannelHandler" class="headerlink" title="DirectDispatcher &amp; DirectChannelHandler"></a>DirectDispatcher &amp; DirectChannelHandler</h4><p>direct 类型，所有消息都不派发到线程池，全部在 IO 线程上直接执行，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectDispatcher</span> <span class="keyword">implements</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"direct"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">dispatch</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MessageOnlyDispatcher-amp-MessageOnlyChannelHandler"><a href="#MessageOnlyDispatcher-amp-MessageOnlyChannelHandler" class="headerlink" title="MessageOnlyDispatcher &amp; MessageOnlyChannelHandler"></a>MessageOnlyDispatcher &amp; MessageOnlyChannelHandler</h4><p>MessageOnlyDispatcher 用来创建 MessageOnlyChannelHandler 对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageOnlyDispatcher</span> <span class="keyword">implements</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"message"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 MessageOnlyChannelHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">dispatch</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageOnlyChannelHandler(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageOnlyChannelHandler 实现 WrappedChannelHandler 抽象类，会将所有收到的消息（请求/响应）提交到线程池处理，其他网络事件（连接断开事件，心跳等消息）则是由 IO 线程直接处理，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageOnlyChannelHandler</span> <span class="keyword">extends</span> <span class="title">WrappedChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法调用父类方法，创建独享的线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageOnlyChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理读取到的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message request/response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(message, channel, getClass() + <span class="string">" error when process received event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面代码可知，ExecutionChannelHandler 只重写了 received() 方法，其它方法的调用是直接调用父类的方法，直接在 IO 线程中进行处理。</p><h4 id="ConnectionOrderedDispatcher-amp-ConnectionOrderedChannelHandler"><a href="#ConnectionOrderedDispatcher-amp-ConnectionOrderedChannelHandler" class="headerlink" title="ConnectionOrderedDispatcher &amp; ConnectionOrderedChannelHandler"></a>ConnectionOrderedDispatcher &amp; ConnectionOrderedChannelHandler</h4><p>ConnectionOrderedDispatcher 用来创建 ConnectionOrderedChannelHandler 对象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionOrderedDispatcher</span> <span class="keyword">implements</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"connection"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 ConnectionOrderedChannelHandler 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">dispatch</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConnectionOrderedChannelHandler(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConnectionOrderedChannelHandler 实现 WrappedChannelHandler 抽象类，会将收到的消息交给线程池进行处理，对于连接建立以及断开事件是通过 IO 线程将连接、断开事件交给 connectionExecutor 线程池排队处理的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionOrderedChannelHandler</span> <span class="keyword">extends</span> <span class="title">WrappedChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理连接建立和断开事件的线程池，线程池线程数只有一个，因此任务多的情况会先堆积到阻塞队列进行排队，有序执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ThreadPoolExecutor connectionExecutor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池阻塞队列告警阈值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> queuewarninglimit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionOrderedChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类构造方法，创建独享的线程池</span></span><br><span class="line">        <span class="keyword">super</span>(handler, url);</span><br><span class="line">        <span class="comment">// 从 'threadname' 配置项获取线程池名，默认为 Dubbo</span></span><br><span class="line">        String threadName = url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);</span><br><span class="line">        <span class="comment">// 该线程池只有一个线程，并且阻塞队列的长度也是固定的，由配置参数决定</span></span><br><span class="line">        connectionExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(url.getPositiveParameter(Constants.CONNECT_QUEUE_CAPACITY, Integer.MAX_VALUE)),</span><br><span class="line">                <span class="keyword">new</span> NamedThreadFactory(threadName, <span class="keyword">true</span>),</span><br><span class="line">                <span class="keyword">new</span> AbortPolicyWithReport(threadName, url)</span><br><span class="line">        ); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 'connect.queue.warning.size' 配置项获取线程池阻塞队列告警阈值，默认大小为 1000</span></span><br><span class="line">        queuewarninglimit = url.getParameter(Constants.CONNECT_QUEUE_WARNING_SIZE, Constants.DEFAULT_CONNECT_QUEUE_WARNING_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkQueueLength();</span><br><span class="line">            connectionExecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(<span class="string">"connect event"</span>, channel, getClass() + <span class="string">" error when process connected event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkQueueLength();</span><br><span class="line">            connectionExecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(<span class="string">"disconnected event"</span>, channel, getClass() + <span class="string">" error when process disconnected event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">//fix, reject exception can not be sent to consumer because thread pool is full, resulting in consumers waiting till timeout.</span></span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request &amp;&amp; t <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</span><br><span class="line">                Request request = (Request) message;</span><br><span class="line">                <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                    String msg = <span class="string">"Server side("</span> + url.getIp() + <span class="string">","</span> + url.getPort() + <span class="string">") threadpool is exhausted ,detail msg:"</span> + t.getMessage();</span><br><span class="line">                    Response response = <span class="keyword">new</span> Response(request.getId(), request.getVersion());</span><br><span class="line">                    response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);</span><br><span class="line">                    response.setErrorMessage(msg);</span><br><span class="line">                    channel.send(response);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(message, channel, getClass() + <span class="string">" error when process received event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        ExecutorService cexecutor = getExecutorService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cexecutor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(<span class="string">"caught event"</span>, channel, getClass() + <span class="string">" error when process caught event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查阈值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkQueueLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 排队任务超过阈值打印告警日志</span></span><br><span class="line">        <span class="keyword">if</span> (connectionExecutor.getQueue().size() &gt; queuewarninglimit) &#123;</span><br><span class="line">            logger.warn(<span class="keyword">new</span> IllegalThreadStateException(<span class="string">"connectionordered channel handler `queue size: "</span> + connectionExecutor.getQueue().size() + <span class="string">" exceed the warning limit number :"</span> + queuewarninglimit));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 AllChannelHandler 一样，发送消息由 ConnectionOrderedChannelHandler 直接在 IO 线程中进行处理，区别在于后者的连接建立、断开事件不是通过父类中创建的线程池处理，而是创建了一个排队线程池。之所以叫它排队线程池，是该线程池只有一个线程，并且使用的阻塞队列是有序的。</p><h4 id="ChannelEventRunnable-线程派发任务体"><a href="#ChannelEventRunnable-线程派发任务体" class="headerlink" title="ChannelEventRunnable 线程派发任务体"></a>ChannelEventRunnable 线程派发任务体</h4><p>实现Runnable接口，该任务体被不同的线程派发机制使用。</p><h5 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelEventRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ChannelEventRunnable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装饰的通道处理器，会在线程池中处理消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelState state;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息（可能为空，如连接断开事件）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常时，捕获的异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Throwable exception;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ChannelEventRunnable</span><span class="params">(Channel channel, ChannelHandler handler, ChannelState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(channel, handler, state, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelEventRunnable</span><span class="params">(Channel channel, ChannelHandler handler, ChannelState state, Object message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(channel, handler, state, message, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelEventRunnable</span><span class="params">(Channel channel, ChannelHandler handler, ChannelState state, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(channel, handler, state, <span class="keyword">null</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelEventRunnable</span><span class="params">(Channel channel, ChannelHandler handler, ChannelState state, Object message, Throwable exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.exception = exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChannelEventRunnable 中的属性都是由线程派发相关的 ChannelHandler 传入的，不同的派发策略传入的属性不同，通过不同的构造方法也可以看出。</p><h5 id="任务体"><a href="#任务体" class="headerlink" title="任务体"></a>任务体</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelEventRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测通道状态，如果是请求或响应消息， 那么state = RECEIVED</span></span><br><span class="line">        <span class="keyword">if</span> (state == ChannelState.RECEIVED) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将 channel 和 message 传递给 ChannelHandler 对象用于后续的调用。</span></span><br><span class="line">                handler.received(channel, message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"ChannelEventRunnable handle "</span> + state + <span class="string">" operation error, channel is "</span> + channel</span><br><span class="line">                        + <span class="string">", message is "</span> + message, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 其它通道状态</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                <span class="comment">// 连接事件</span></span><br><span class="line">                <span class="keyword">case</span> CONNECTED:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        handler.connected(channel);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"ChannelEventRunnable handle "</span> + state + <span class="string">" operation error, channel is "</span> + channel, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 断开连接事件</span></span><br><span class="line">                <span class="keyword">case</span> DISCONNECTED:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        handler.disconnected(channel);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"ChannelEventRunnable handle "</span> + state + <span class="string">" operation error, channel is "</span> + channel, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 发送消息</span></span><br><span class="line">                <span class="keyword">case</span> SENT:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        handler.sent(channel, message);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"ChannelEventRunnable handle "</span> + state + <span class="string">" operation error, channel is "</span> + channel</span><br><span class="line">                                + <span class="string">", message is "</span> + message, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 异常处理</span></span><br><span class="line">                <span class="keyword">case</span> CAUGHT:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        handler.caught(channel, exception);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"ChannelEventRunnable handle "</span> + state + <span class="string">" operation error, channel is "</span> + channel</span><br><span class="line">                                + <span class="string">", message is: "</span> + message + <span class="string">", exception is "</span> + exception, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    logger.warn(<span class="string">"unknown state: "</span> + state + <span class="string">", message is "</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> ChannelState &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * CONNECTED  - 连接</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CONNECTED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * DISCONNECTED - 断开连接</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        DISCONNECTED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * SENT - 发送消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SENT,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * RECEIVED - 接收请求/响应消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RECEIVED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * CAUGHT - 异常</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CAUGHT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该任务体功能和作用如下：</p><blockquote><p>1 请求和响应消息出现频率比其他类型消息高，因此这里对消息类型进行了针对性判断，便于提前处理。<br>2 ChannelEventRunnable 仅是一个中转站，它的 run 方法中并不包含具体的调用逻辑，只是判断对应的通道状态，然后将参数传给装饰的 ChannelHandler 对象进行针对性处理。</p></blockquote><p>至此，ChannelHandlerDelegate 的另一条继承体系分析完毕，Transport 层的主要 ChannelHandler 分析到此结束。     </p><h1 id="ChannelHandlers"><a href="#ChannelHandlers" class="headerlink" title="ChannelHandlers"></a>ChannelHandlers</h1><p>ChannelHandler 的工具类，主要是对传入的 ChannelHandler 进行层层包装，具体怎么包装的我们看下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelHandlers</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelHandlers INSTANCE = <span class="keyword">new</span> ChannelHandlers();</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ChannelHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包装</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelHandler <span class="title">wrap</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ChannelHandlers.getInstance().wrapInternal(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> ChannelHandlers <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无论是Client还是Server，在构造方法中都会将传入的ChannelHandler进行包装，为该 ChannelHandler 增加了 Dubbo 消息派发、心跳处理以及多消息处理的功能。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ChannelHandler <span class="title">wrapInternal</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MultiMessageHandler( <span class="comment">// 多消息处理</span></span><br><span class="line">                <span class="keyword">new</span> HeartbeatHandler( <span class="comment">// 心跳处理</span></span><br><span class="line">                        ExtensionLoader.getExtensionLoader(Dispatcher<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                                .<span class="title">getAdaptiveExtension</span>() </span></span><br><span class="line"><span class="class">                                .<span class="title">dispatch</span>(<span class="title">handler</span>, <span class="title">url</span>) // 返回的是一个 <span class="title">ChannelHandlerDelegate</span> 类型的对象，默认是 <span class="title">AllChannelHandler</span>，确定了具体的线程模型</span></span><br><span class="line"><span class="class">                )</span></span><br><span class="line"><span class="class">        )</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易发现，包装器其实就是前文介绍的 ChannelHandlerDelegate 类型的 ChannelHandler。<strong>该包装逻辑无论在 Client 端还是 Server 端都会使用</strong>，也就意味着上层传入的 ChannelHandler 会增加很多的逻辑，即支持多消息处理、心跳处理以及支持 Dubbo 线程模型机制。我们在下一篇文章中还会再次介绍，这里先以 netty4 实现的网络通信简单说明。</p><ul><li>NettyServer<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractServer</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// ChannelHandlers.wrap方法，用来包装 ChannelHandler，实现Dubbo 线程模型等功能</span></span><br><span class="line">        <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>NettyClient<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">extends</span> <span class="title">AbstractClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// wrapChannelHandler方法，用来包装 ChannelHandler，实现Dubbo 线程模型等功能</span></span><br><span class="line">        <span class="keyword">super</span>(url, wrapChannelHandler(url, handler));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="编解码"><a href="#编解码" class="headerlink" title="编解码"></a>编解码</h1><p>关于 Codec2 扩展接口已经在 <a href="https://gentryhuang.com/posts/95ab077/">远程通信模块总览</a> 中进行了介绍，下面介绍在 Transport 层相关的实现和扩展。</p><h2 id="编解码工具类-CodecSupport"><a href="#编解码工具类-CodecSupport" class="headerlink" title="编解码工具类 CodecSupport"></a>编解码工具类 CodecSupport</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodecSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(CodecSupport<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化对象集合</span></span><br><span class="line"><span class="comment">     * key: 序列化类型编号  &#123;<span class="doctag">@link</span> Serialization#getContentTypeId()&#125;</span></span><br><span class="line"><span class="comment">     * value: 序列化对象，如： Hessian2Serialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, Serialization&gt; ID_SERIALIZATION_MAP = <span class="keyword">new</span> HashMap&lt;Byte, Serialization&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化名集合</span></span><br><span class="line"><span class="comment">     * key: 序列化类型编号 &#123;<span class="doctag">@link</span> Serialization#getContentTypeId()&#125;</span></span><br><span class="line"><span class="comment">     * value: 序列化拓展名，如：hessian2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; ID_SERIALIZATIONNAME_MAP = <span class="keyword">new</span> HashMap&lt;Byte, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 基于 Dubbo SPI，获取 Serialization 的扩展名列表</span></span><br><span class="line">        Set&lt;String&gt; supportedExtensions = ExtensionLoader.getExtensionLoader(Serialization<span class="class">.<span class="keyword">class</span>).<span class="title">getSupportedExtensions</span>()</span>;</span><br><span class="line">        <span class="keyword">for</span> (String name : supportedExtensions) &#123;</span><br><span class="line">            <span class="comment">// 根据扩展名获取对应的扩展实现</span></span><br><span class="line">            Serialization serialization = ExtensionLoader.getExtensionLoader(Serialization<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">name</span>)</span>;</span><br><span class="line">            <span class="comment">// 内容类型编号</span></span><br><span class="line">            <span class="keyword">byte</span> idByte = serialization.getContentTypeId();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ID_SERIALIZATION_MAP.containsKey(idByte)) &#123;</span><br><span class="line">                logger.error(<span class="string">"Serialization extension "</span> + serialization.getClass().getName()</span><br><span class="line">                        + <span class="string">" has duplicate id to Serialization extension "</span></span><br><span class="line">                        + ID_SERIALIZATION_MAP.get(idByte).getClass().getName()</span><br><span class="line">                        + <span class="string">", ignore this Serialization extension"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以内容编号作为 key,分别缓存序列化扩展实现和扩展实现名</span></span><br><span class="line">            ID_SERIALIZATION_MAP.put(idByte, serialization);</span><br><span class="line">            ID_SERIALIZATIONNAME_MAP.put(idByte, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CodecSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从缓存中，根据序列化号查找Serialization对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Serialization <span class="title">getSerializationById</span><span class="params">(Byte id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ID_SERIALIZATION_MAP.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过URL根据SPI机制查找Serialization对象，默认使用 hessian2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Serialization <span class="title">getSerialization</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Serialization<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">url</span>.<span class="title">getParameter</span>(<span class="title">Constants</span>.<span class="title">SERIALIZATION_KEY</span>, <span class="title">Constants</span>.<span class="title">DEFAULT_REMOTING_SERIALIZATION</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找Serialization对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Serialization <span class="title">getSerialization</span><span class="params">(URL url, Byte id)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Serialization serialization = getSerializationById(id);</span><br><span class="line">        <span class="comment">// 序列化扩展名</span></span><br><span class="line">        String serializationName = url.getParameter(Constants.SERIALIZATION_KEY, Constants.DEFAULT_REMOTING_SERIALIZATION);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出于安全的目的，针对 JDK 类型的序列化方式，检查连接到服务器的 URL 和实际传输的数据协议是否一致。</span></span><br><span class="line">        <span class="keyword">if</span> (serialization == <span class="keyword">null</span></span><br><span class="line">                || ((id == <span class="number">3</span> || id == <span class="number">7</span> || id == <span class="number">4</span>) &amp;&amp; !(serializationName.equals(ID_SERIALIZATIONNAME_MAP.get(id))))) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected serialization id:"</span> + id + <span class="string">" received from network, please check if the peer send the right id."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serialization;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取反序列化对应的 ObjectInput</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> is</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proto</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObjectInput <span class="title">deserialize</span><span class="params">(URL url, InputStream is, <span class="keyword">byte</span> proto)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Serialization s = getSerialization(url, proto);</span><br><span class="line">        <span class="keyword">return</span> s.deserialize(url, is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码已经详细注释，整个逻辑分为两点，Dubbo 应用启动时缓存序列化并提供获取序列化的方法。 关于序列化在之前的文章中已经详细介绍过，这里就不再重复说明。</p><h2 id="编解码适配器"><a href="#编解码适配器" class="headerlink" title="编解码适配器"></a>编解码适配器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CodecAdapter</span> <span class="keyword">implements</span> <span class="title">Codec2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被适配的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Codec codec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过构造方法设置被适配的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> codec</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CodecAdapter</span><span class="params">(Codec codec)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(codec, <span class="string">"codec == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.codec = codec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(Channel channel, ChannelBuffer buffer, Object message)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        UnsafeByteArrayOutputStream os = <span class="keyword">new</span> UnsafeByteArrayOutputStream(<span class="number">1024</span>);</span><br><span class="line">        codec.encode(channel, os, message);</span><br><span class="line">        buffer.writeBytes(os.toByteArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.readableBytes()];</span><br><span class="line">        <span class="keyword">int</span> savedReaderIndex = buffer.readerIndex();</span><br><span class="line">        buffer.readBytes(bytes);</span><br><span class="line">        UnsafeByteArrayInputStream is = <span class="keyword">new</span> UnsafeByteArrayInputStream(bytes);</span><br><span class="line">        Object result = codec.decode(channel, is);</span><br><span class="line">        buffer.readerIndex(savedReaderIndex + is.position());</span><br><span class="line">        <span class="keyword">return</span> result == Codec.NEED_MORE_INPUT ? DecodeResult.NEED_MORE_INPUT : result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Codec <span class="title">getCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> codec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CodecAdapter 使用<strong>对象适配模式</strong>完成对 Codec 类型的适配工作，即将 Codec 适配成 Codec2 。关于适配器模式可以参考 <a href="https://gentryhuang.com/posts/f5c535ea/">适配器模式</a> 。</p><h2 id="编解码继承关系"><a href="#编解码继承关系" class="headerlink" title="编解码继承关系"></a>编解码继承关系</h2><p>编解码 Codec2 的继承关系如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-transport-codec-hierarchy.jpg" alt></p><p>继承关系中包含了各层的编解码实现，本篇文章只介绍 Transport 层相关的实现，其它层相关的实现会在对应的层进行介绍。需要注意的是，Exchange 层的编解码实现依赖了 Transport 层的编解码实现，Protocol 层又依赖了 Exchange 层的编解码实现。可以发现，编解码器的实现通过继承的方式以获得更多的功能，每个编码器实现类编解码消息的逻辑都不一样。</p><h3 id="AbstractCodec"><a href="#AbstractCodec" class="headerlink" title="AbstractCodec"></a>AbstractCodec</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCodec</span> <span class="keyword">implements</span> <span class="title">Codec2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractCodec<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法，校验消息长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkPayload</span><span class="params">(Channel channel, <span class="keyword">long</span> size)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//  8M</span></span><br><span class="line">        <span class="keyword">int</span> payload = Constants.DEFAULT_PAYLOAD;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.getUrl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取配置允许最大的消息大小，默认 为 8 * 1024 * 1024;  8M</span></span><br><span class="line">            payload = channel.getUrl().getParameter(Constants.PAYLOAD_KEY, Constants.DEFAULT_PAYLOAD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 超过允许最大的消息大小，则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (payload &gt; <span class="number">0</span> &amp;&amp; size &gt; payload) &#123;</span><br><span class="line">            ExceedPayloadLimitException e = <span class="keyword">new</span> ExceedPayloadLimitException(<span class="string">"Data length too large: "</span> + size + <span class="string">", max payload: "</span> + payload + <span class="string">", channel: "</span> + channel);</span><br><span class="line">            logger.error(e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得Serialization对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Serialization <span class="title">getSerialization</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CodecSupport.getSerialization(channel.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为客户端的通道</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isClientSide</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        String side = (String) channel.getAttribute(Constants.SIDE_KEY);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"client"</span>.equals(side)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"server"</span>.equals(side)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            InetSocketAddress address = channel.getRemoteAddress();</span><br><span class="line">            URL url = channel.getUrl();</span><br><span class="line">            <span class="keyword">boolean</span> client = url.getPort() == address.getPort()</span><br><span class="line">                    &amp;&amp; NetUtils.filterLocalHost(url.getIp()).equals(</span><br><span class="line">                    NetUtils.filterLocalHost(address.getAddress()</span><br><span class="line">                            .getHostAddress()));</span><br><span class="line">            channel.setAttribute(Constants.SIDE_KEY, client ? <span class="string">"client"</span></span><br><span class="line">                    : <span class="string">"server"</span>);</span><br><span class="line">            <span class="keyword">return</span> client;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为服务端的通道</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isServerSide</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !isClientSide(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是 Codec2 的抽象实现，提供了公用的一些方法，如校验消息长度是否超过阈值，根据URL获取 Serialization 扩展实现，判断当前通道属于客户端侧还是服务端侧。</p><h3 id="TransportCodec"><a href="#TransportCodec" class="headerlink" title="TransportCodec"></a>TransportCodec</h3><p>TransportCodec 的逻辑简单、粗暴，使用 Serialize 对所有消息直接序列化或者反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransportCodec</span> <span class="keyword">extends</span> <span class="title">AbstractCodec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(Channel channel, ChannelBuffer buffer, Object message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 对 ChannelBuffer 进行装饰获得 Dubbo 输出流</span></span><br><span class="line">        OutputStream output = <span class="keyword">new</span> ChannelBufferOutputStream(buffer);</span><br><span class="line">        <span class="comment">// 获得用于序列化的ObjectOutput对象</span></span><br><span class="line">        ObjectOutput objectOutput = getSerialization(channel).serialize(channel.getUrl(), output);</span><br><span class="line">        <span class="comment">// 将消息写入 ObjectOutput</span></span><br><span class="line">        encodeData(channel, objectOutput, message);</span><br><span class="line">        objectOutput.flushBuffer();</span><br><span class="line">        <span class="comment">// 释放，kryo 的 KryoObjectInput 和 KryoObjectOutput 实现了 Cleanable 接口，需要释放资源。</span></span><br><span class="line">        <span class="keyword">if</span> (objectOutput <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) objectOutput).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//  对 ChannelBuffer 进行装饰获得 Dubbo 输入流</span></span><br><span class="line">        InputStream input = <span class="keyword">new</span> ChannelBufferInputStream(buffer);</span><br><span class="line">        <span class="comment">// 获得用于反序列的 ObjectInput 对象</span></span><br><span class="line">        ObjectInput objectInput = getSerialization(channel).deserialize(channel.getUrl(), input);</span><br><span class="line">        <span class="comment">// 从 ObjectInput 读取消息并反序列化为 对象</span></span><br><span class="line">        Object object = decodeData(channel, objectInput);</span><br><span class="line">        <span class="keyword">if</span> (objectInput <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) objectInput).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeData</span><span class="params">(Channel channel, ObjectOutput output, Object message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        encodeData(output, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decodeData</span><span class="params">(Channel channel, ObjectInput input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decodeData(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeData</span><span class="params">(ObjectOutput output, Object message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeObject(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decodeData</span><span class="params">(ObjectInput input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> input.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"ClassNotFoundException: "</span> + StringUtils.toString(e));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章简单介绍了 Transport 层及其必要性，然后从端点抽象类 AbstractPeer、AbstractEndpoint，语意端点抽象类 AbstractServer、AbstractServer，抽象通道 AbstractChannel 以及 通道关联的 ChannelHandler 多方面介绍了 Transport 层的实现，最后介绍了编解码的继承体系。不难发现，作为底层的 Transport，支持了消息/事件发送、处理、响应以及编解码，涉及的接口和类在功能层面上已经是一个闭环了。后面两篇文章会对本篇文章的抽象进行具体化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/95ab077/&quot;&gt;远程通信模块总览&lt;/a&gt; 中对 Rem
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - Buffer缓冲区</title>
    <link href="https://gentryhuang.com/posts/e79185fb/"/>
    <id>https://gentryhuang.com/posts/e79185fb/</id>
    <published>2020-05-17T16:00:00.000Z</published>
    <updated>2020-11-21T08:23:29.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章继续说明 <strong>Remoting 层中的 buffer 包</strong>相关抽象及实现。在序列化层中虽然不会直接和 Buffer 缓冲区交互，但是序列化和反序列化方法所需的参数底层一般都是 Buffer 缓冲区。 </p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>缓冲区在NIO框架中是一个必要的角色，在各个 NIO 框架中都有自己的缓冲区实现。如，Java NIO 的 ByteBuffer、Mina 的 IoBuffer 以及 Netty4 的 ByteBuf等。Dubbo 抽象出了 ChannelBuffer 接口用于对底层 NIO 框架的缓冲区进行统一。相关的 UML 图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-remote-buffer.jpg" alt></p><p>Dubbo 不仅抽象出了 ChannelBuffer 接口，还抽象出了对应的工厂 ChannelBufferFactory。</p><h2 id="ChannelBuffer-接口"><a href="#ChannelBuffer-接口" class="headerlink" title="ChannelBuffer 接口"></a>ChannelBuffer 接口</h2><p>ChannelBuffer 接口的设计与 Netty 的 ByteBuf 设计基本一致，也定义了 <strong>readerIndex</strong> 和 <strong>writeIndex</strong> 指针。 下面对方法大致归类说明：</p><ul><li>getBytes()、setBytes() 方法：读/写当前 ChannelBuffer，但是不会修改 readerIndex 和 writerIndex 指针的位置。</li><li>readBytes() 、writeBytes() 方法：读/写当前 ChannelBuffer，readBytes() 方法会从 readerIndex 指针开始读取数据，并移动 readerIndex 指针；writeBytes() 方法会从 writerIndex 指针位置开始写入数据，并移动 writerIndex 指针。</li><li>markReaderIndex()、markWriterIndex() 方法：分别记录当前 readerIndex 指针和 writerIndex 指针的位置，一般会和 resetReaderIndex()、resetWriterIndex() 方法配合使用，resetReaderIndex() 方法用于将 readerIndex 指针重置到被 markedReaderIndex() 方法标记时的位置，resetwriterIndex() 方法同理。</li><li>capacity()、clear()、copy() 等辅助方法用来获取 ChannelBuffer 容量以及实现清理、拷贝数据的功能。</li><li>factory() 方法：是 Dubbo 独有的方法，该方法返回创建 ChannelBuffer 的工厂对象。</li></ul><h2 id="AbstractChannelBuffer"><a href="#AbstractChannelBuffer" class="headerlink" title="AbstractChannelBuffer"></a>AbstractChannelBuffer</h2><p>实现了 ChannelBuffer 接口的大部分方法，但是在 AbstractChannelBuffer 实现的方法都是重载的方法，具体功能的方法需要子类实现。</p><p>AbstractChannelBuffer 主要维护了四个核心属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractChannelBuffer</span> <span class="keyword">implements</span> <span class="title">ChannelBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> readerIndex;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writerIndex;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标记的读取位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> markedReaderIndex;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标记的写入位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> markedWriterIndex;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>readerIndex：通过 readBytes() 方法及其重载读取数据时，会后移该指针。</li><li>writerIndex：通过 writeBytes() 方法及其重载写入数据的时候，会后移该指针。</li><li>markedReaderIndex：实现记录 readerIndex 指针以及用于回滚 readerIndex 指针的功能。</li><li>markedWriterIndex：实现记录 writerIndex 指针以及用于回滚 writerIndex 指针的功能。</li></ul><p>其中，AbstractChannelBuffer 中还定义了用于动态扩容的 ensureWritableBytes 方法，目前只有 DynamicChannelBuffer 、NettyBackedChannelBuffer（Dubbo 的 Netty3 和 Netty4 ChannelBuffer实现）实现。</p><p>需要注意，AbstractChannelBuffer 中 readBytes() 和 writeBytes() 方法的各个重载最终会通过 getBytes() 方法和 setBytes() 方法实现数据的读写，这些方法需要在 AbstractChannelBuffer 的子类中实现。下面以读写一个 byte 数组为例进行说明，其它都类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractChannelBuffer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 buffer 中读取长度为 length 的字节放到 dst字节数组中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readBytes</span><span class="params">(<span class="keyword">byte</span>[] dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检测读取字节长度是否超过可读长度，超过则抛出异常</span></span><br><span class="line">        checkReadableBytes(length);</span><br><span class="line">        <span class="comment">// 将readerIndex之后的length个字节数读取到dst数组中，从 dst数组的 dstIndex 位置开始，长度为 length</span></span><br><span class="line">        getBytes(readerIndex, dst, dstIndex, length);</span><br><span class="line">        <span class="comment">// 将readerIndex后移length个字节</span></span><br><span class="line">        readerIndex += length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 src 字节数组中 [scrIndex-scrIndex+leng] 范围数据写入到 buffer 中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        setBytes(writerIndex, src, srcIndex, length);</span><br><span class="line">        <span class="comment">// 将writerIndex 后移 length个字节 </span></span><br><span class="line">        writerIndex += length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面简单使用图示说明 ChannelBuffer 中的四个核心属性和容量，<a href="https://blog.csdn.net/zhxdick/article/details/51187362" target="_blank" rel="noopener">图片来源</a></p><ul><li><p><strong>初始状态</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-remote-buffer-detail1.png" alt></p></li><li><p><strong>写入 5 个字节后</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-remote-buffer-detail2.png" alt></p></li><li><p><strong>读取 3 个字节后</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-remote-buffer-detail3.png" alt></p></li></ul><h2 id="ChannelBufferFactory"><a href="#ChannelBufferFactory" class="headerlink" title="ChannelBufferFactory"></a>ChannelBufferFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelBufferFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定容量的 ChannelBuffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ChannelBuffer <span class="title">getBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定偏移量的数据的 ChannelBuffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offset</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ChannelBuffer <span class="title">getBuffer</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 java.nio.ByteBuffer 数据获取ChannelBuffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nioBuffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ChannelBuffer <span class="title">getBuffer</span><span class="params">(ByteBuffer nioBuffer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChannelBuffer 工厂</p><h3 id="DirectChannelBufferFactory"><a href="#DirectChannelBufferFactory" class="headerlink" title="DirectChannelBufferFactory"></a>DirectChannelBufferFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectChannelBufferFactory</span> <span class="keyword">implements</span> <span class="title">ChannelBufferFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DirectChannelBufferFactory INSTANCE = <span class="keyword">new</span> DirectChannelBufferFactory();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectChannelBufferFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelBufferFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelBuffer <span class="title">getBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"capacity: "</span> + capacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ChannelBuffers.EMPTY_BUFFER;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用 ChannelBuffers 工具类创建 ByteBufferBackedChannelBuffer</span></span><br><span class="line">        <span class="keyword">return</span> ChannelBuffers.directBuffer(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelBuffer <span class="title">getBuffer</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"array"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"offset: "</span> + offset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ChannelBuffers.EMPTY_BUFFER;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset + length &gt; array.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"length: "</span> + length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用 getBuffer 方法，使用 ChannelBuffers 工具类创建 ByteBufferBackedChannelBuffer</span></span><br><span class="line">        ChannelBuffer buf = getBuffer(length);</span><br><span class="line">        <span class="comment">// 向 buf 中写入数据</span></span><br><span class="line">        buf.writeBytes(array, offset, length);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelBuffer <span class="title">getBuffer</span><span class="params">(ByteBuffer nioBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!nioBuffer.isReadOnly() &amp;&amp; nioBuffer.isDirect()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ChannelBuffers.wrappedBuffer(nioBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 getBuffer 方法，使用 ChannelBuffers 工具类创建 ByteBufferBackedChannelBuffer</span></span><br><span class="line">        ChannelBuffer buf = getBuffer(nioBuffer.remaining());</span><br><span class="line">        <span class="keyword">int</span> pos = nioBuffer.position();</span><br><span class="line">        <span class="comment">// 向buf中写入数据</span></span><br><span class="line">        buf.writeBytes(nioBuffer);</span><br><span class="line">        nioBuffer.position(pos);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 ChannelBufferFactory 接口，创建 ByteBufferBackedChannelBuffer 的工厂类。</p><h3 id="HeapChannelBufferFactory"><a href="#HeapChannelBufferFactory" class="headerlink" title="HeapChannelBufferFactory"></a>HeapChannelBufferFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapChannelBufferFactory</span> <span class="keyword">implements</span> <span class="title">ChannelBufferFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HeapChannelBufferFactory INSTANCE = <span class="keyword">new</span> HeapChannelBufferFactory();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapChannelBufferFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelBufferFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------- 通过 ChannelBuffers 工具类创建 HeapChannelBuffer 对象 ------/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelBuffer <span class="title">getBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ChannelBuffers.buffer(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelBuffer <span class="title">getBuffer</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ChannelBuffers.wrappedBuffer(array, offset, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelBuffer <span class="title">getBuffer</span><span class="params">(ByteBuffer nioBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nioBuffer.hasArray()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ChannelBuffers.wrappedBuffer(nioBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChannelBuffer buf = getBuffer(nioBuffer.remaining());</span><br><span class="line">        <span class="keyword">int</span> pos = nioBuffer.position();</span><br><span class="line">        buf.writeBytes(nioBuffer);</span><br><span class="line">        nioBuffer.position(pos);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 ChannelBufferFactory 接口，创建 HeapChannelBufferFactory 的工厂。</p><h3 id="NettyBackedChannelBufferFactory"><a href="#NettyBackedChannelBufferFactory" class="headerlink" title="NettyBackedChannelBufferFactory"></a>NettyBackedChannelBufferFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyBackedChannelBufferFactory</span> <span class="keyword">implements</span> <span class="title">ChannelBufferFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NettyBackedChannelBufferFactory INSTANCE = <span class="keyword">new</span> NettyBackedChannelBufferFactory();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelBufferFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelBuffer <span class="title">getBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 Netty 的 ChannelBuffers 方法创建 org.jboss.netty.buffer.ChannelBuffer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NettyBackedChannelBuffer(ChannelBuffers.dynamicBuffer(capacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelBuffer <span class="title">getBuffer</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Netty3 ChannelBuffer 对象</span></span><br><span class="line">        org.jboss.netty.buffer.ChannelBuffer buffer = ChannelBuffers.dynamicBuffer(length);</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        buffer.writeBytes(array, offset, length);</span><br><span class="line">        <span class="comment">// 创建 NettyBackedChannelBuffer 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NettyBackedChannelBuffer(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelBuffer <span class="title">getBuffer</span><span class="params">(ByteBuffer nioBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 使用 Netty 的 ChannelBuffers 方法创建 org.jboss.netty.buffer.ChannelBuffer</span></span><br><span class="line">        <span class="comment">// 2 创建 NettyBackedChannelBuffer</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NettyBackedChannelBuffer(ChannelBuffers.wrappedBuffer(nioBuffer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 ChannelBufferFactory 接口，创建 NettyBackedChannelBuffer 的工厂。目前 Dubbo 框架中，Netty3 通信框架在使用这个工厂，Netty4 不再使用工厂。</p><h2 id="ChannelBuffers"><a href="#ChannelBuffers" class="headerlink" title="ChannelBuffers"></a>ChannelBuffers</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Buffer 工具类，提供创建，比较 ChannelBuffer 等公用方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelBuffers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ChannelBuffer EMPTY_BUFFER = <span class="keyword">new</span> HeapChannelBuffer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ChannelBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------ 创建 DynamicChannelBuffer 对象 -------------------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelBuffer <span class="title">dynamicBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 默认大小为 256</span></span><br><span class="line">        <span class="keyword">return</span> dynamicBuffer(<span class="number">256</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelBuffer <span class="title">dynamicBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicChannelBuffer(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelBuffer <span class="title">dynamicBuffer</span><span class="params">(<span class="keyword">int</span> capacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              ChannelBufferFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicChannelBuffer(capacity, factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------- 创建 HeapChannelBuffer 对象  -----------------------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelBuffer <span class="title">buffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"capacity can not be negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_BUFFER;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapChannelBuffer(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelBuffer <span class="title">wrappedBuffer</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"array == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] dest = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        System.arraycopy(array, offset, dest, <span class="number">0</span>, length);</span><br><span class="line">        <span class="keyword">return</span> wrappedBuffer(dest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelBuffer <span class="title">wrappedBuffer</span><span class="params">(<span class="keyword">byte</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"array == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_BUFFER;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeapChannelBuffer(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelBuffer <span class="title">wrappedBuffer</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!buffer.hasRemaining()) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_BUFFER;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ByteBuffer 中的字节数组是否可访问，可访问就创建 HeapChannelBuffer</span></span><br><span class="line">        <span class="keyword">if</span> (buffer.hasArray()) &#123;</span><br><span class="line">            <span class="keyword">return</span> wrappedBuffer(buffer.array(), buffer.arrayOffset() + buffer.position(), buffer.remaining());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不可访问就 创建 ByteBufferBackedChannelBuffer</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ByteBufferBackedChannelBuffer(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------------------- 创建 ByteBufferBackedChannelBuffer 对象 ------------------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelBuffer <span class="title">directBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_BUFFER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChannelBuffer buffer = <span class="keyword">new</span> ByteBufferBackedChannelBuffer(ByteBuffer.allocateDirect(capacity));</span><br><span class="line">        buffer.clear();</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于比较两个 ChannelBuffer 是否相同。</span></span><br><span class="line"><span class="comment">     * 注意该方法不能完全确定两个 ChannelBuffer 是否相等，但是可以快速确定两个 ChannelBuffer 不相同。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bufferA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bufferB</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(ChannelBuffer bufferA, ChannelBuffer bufferB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 比较两个ChannelBuffer的可读字节数</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> aLen = bufferA.readableBytes();</span><br><span class="line">        <span class="keyword">if</span> (aLen != bufferB.readableBytes()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// aLen &amp; 0111，最大为 7</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> byteCount = aLen &amp; <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取读取索引</span></span><br><span class="line">        <span class="keyword">int</span> aIndex = bufferA.readerIndex();</span><br><span class="line">        <span class="keyword">int</span> bIndex = bufferB.readerIndex();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最多比较前 7 个字节</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = byteCount; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bufferA.getByte(aIndex) != bufferB.getByte(bIndex)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            aIndex++;</span><br><span class="line">            bIndex++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于比较两个 ChannelBuffer 的大小，方法中会逐个比较两个 ChannelBuffer 中的全部可读字节</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bufferA</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bufferB</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ChannelBuffer bufferA, ChannelBuffer bufferB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> aLen = bufferA.readableBytes();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bLen = bufferB.readableBytes();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> minLength = Math.min(aLen, bLen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> aIndex = bufferA.readerIndex();</span><br><span class="line">        <span class="keyword">int</span> bIndex = bufferB.readerIndex();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = minLength; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">byte</span> va = bufferA.getByte(aIndex);</span><br><span class="line">            <span class="keyword">byte</span> vb = bufferB.getByte(bIndex);</span><br><span class="line">            <span class="keyword">if</span> (va &gt; vb) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (va &lt; vb) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            aIndex++;</span><br><span class="line">            bIndex++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> aLen - bLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChannelBuffers 用来创建 ChannelBuffer 和 比较 ChannelBuffer 。创建的 ChannelBuffer 包括 DynamicChannelBuffer、HeapChannelBuffer、ByteBufferBackedChannelBuffer，不包括 NettyBackedChannelBuffer，Netty 3 的 NettyBackedChannelBuffer 可由工厂创建，Netty 4 的 NettyBackedChannelBuffer 没有工厂，在 Dubbo 中直接使用构造方法创建。</p><h2 id="Buffer-实现类"><a href="#Buffer-实现类" class="headerlink" title="Buffer 实现类"></a>Buffer 实现类</h2><p>前面介绍了 ChannelBuffer 接口以及对应的工厂，并对 ChannelBuffers 工具类进行了介绍，下面我们来分析 ChannelBuffer 的具体实现类。</p><h3 id="ByteBufferBackedChannelBuffer"><a href="#ByteBufferBackedChannelBuffer" class="headerlink" title="ByteBufferBackedChannelBuffer"></a>ByteBufferBackedChannelBuffer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferBackedChannelBuffer</span> <span class="keyword">extends</span> <span class="title">AbstractChannelBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于 nio 的 Buffer 实现类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer buffer;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ByteBufferBackedChannelBuffer</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"buffer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer.slice();</span><br><span class="line">        <span class="comment">// 设置容量</span></span><br><span class="line">        capacity = buffer.remaining();</span><br><span class="line">        <span class="comment">// 设置 writerIndex</span></span><br><span class="line">        writerIndex(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ByteBufferBackedChannelBuffer</span><span class="params">(ByteBufferBackedChannelBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer.buffer;</span><br><span class="line">        <span class="comment">// 设置容量</span></span><br><span class="line">        capacity = buffer.capacity;</span><br><span class="line">        <span class="comment">// 设置 writerIndex,readerIndex</span></span><br><span class="line">        setIndex(buffer.readerIndex(), buffer.writerIndex());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 ChannelBuf 工厂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelBufferFactory <span class="title">factory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.isDirect()) &#123;</span><br><span class="line">            <span class="keyword">return</span> DirectChannelBufferFactory.getInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> HeapChannelBufferFactory.getInstance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ByteBufferBackedChannelBuffer 继承了 AbstractChannelBuffer， 是基于 Java NIO 中 ByteBuffer 的 ChannelBuffer 实现类。其中的方法基本都是基于 Java NIO 的 ByteBuffer 的 API 实现的。以 getBytes() 方法和 setBytes() 方法的一个重载为例，进行说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--- ByteBufferBackedChannelBuffer</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span>[] dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ByteBuffer 的 API</span></span><br><span class="line">        ByteBuffer data = buffer.duplicate();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.limit(index + length).position(index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        data.get(dst, dstIndex, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ByteBuffer 的 API</span></span><br><span class="line">        ByteBuffer data = buffer.duplicate();</span><br><span class="line">        data.limit(index + length).position(index);</span><br><span class="line">        data.put(src, srcIndex, length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ByteBufferBackedChannelBuffer 对应的 ChannelBufferFactory 实现有两个，DirectChannelBufferFactory 和 HeapChannelBufferFactory 。DirectChannelBufferFactory 主要用来创建 ByteBufferBackedChannelBuffer 对象的，兜底时才会创建 HeapChannelBuffer；HeapChannelBufferFactory 兜底时会创建 ByteBufferBackedChannelBuffer 对象。</p><h3 id="HeapChannelBuffer"><a href="#HeapChannelBuffer" class="headerlink" title="HeapChannelBuffer"></a>HeapChannelBuffer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapChannelBuffer</span> <span class="keyword">extends</span> <span class="title">AbstractChannelBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * The underlying heap byte array that this buffer is wrapping.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new heap buffer with a newly allocated byte array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length the length of the new byte array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapChannelBuffer</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> <span class="keyword">byte</span>[length], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new heap buffer with an existing byte array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array the byte array to wrap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapChannelBuffer</span><span class="params">(<span class="keyword">byte</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(array, <span class="number">0</span>, array.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new heap buffer with an existing byte array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array       the byte array to wrap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> readerIndex the initial reader index of this buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> writerIndex the initial writer index of this buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">HeapChannelBuffer</span><span class="params">(<span class="keyword">byte</span>[] array, <span class="keyword">int</span> readerIndex, <span class="keyword">int</span> writerIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"array"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.array = array;</span><br><span class="line">        <span class="comment">// 设置 readerIndex 和 writerIndex</span></span><br><span class="line">        setIndex(readerIndex, writerIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 HeapChannelBufferFactory 工厂</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelBufferFactory <span class="title">factory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HeapChannelBufferFactory.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它方法&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HeapChannelBuffer 是基于字节数组的 ChannelBuffer 实现类，数据的存储都是放在 <strong>array</strong> 字节数组中。读取和写入都是调用 System.arraycopy() 方法完成操作的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--- HeapChannelBuffer</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span>[] src, <span class="keyword">int</span> srcIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(src, srcIndex, array, index, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span>[] dst, <span class="keyword">int</span> dstIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(array, index, dst, dstIndex, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HeapChannelBuffer 对应的 ChannelBufferFactory 实现是 HeapChannelBufferFactory，前面已经介绍过，内部是使用 ChannelBuffers 工具类来完成创建任务。</p><h3 id="DynamicChannelBuffer"><a href="#DynamicChannelBuffer" class="headerlink" title="DynamicChannelBuffer"></a>DynamicChannelBuffer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicChannelBuffer</span> <span class="keyword">extends</span> <span class="title">AbstractChannelBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ChannelBuffer 工厂，用于创建 ChannelBuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelBufferFactory factory;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被修饰的 ChannelBuffer，默认为 HeapChannelBuffer。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ChannelBuffer buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认 HeapChannelBufferFactory</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> estimatedLength</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicChannelBuffer</span><span class="params">(<span class="keyword">int</span> estimatedLength)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(estimatedLength, HeapChannelBufferFactory.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的 factory 创建 ChannelBuffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> estimatedLength</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> factory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicChannelBuffer</span><span class="params">(<span class="keyword">int</span> estimatedLength, ChannelBufferFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (estimatedLength &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"estimatedLength: "</span> + estimatedLength);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"factory"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 factory</span></span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">        <span class="comment">// 创建 buffer</span></span><br><span class="line">        buffer = factory.getBuffer(estimatedLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelBufferFactory <span class="title">factory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DynamicChannelBuffer 是其他 ChannelBuffer 的装饰器，并且可以为其他 ChannelBuffer 动态扩展容量。扩容时机是，在每次写入数据之前，都需要调用该方法确定当前可用空间是否足够，我们可以看到在 DynamicChannelBuffer 中调用的位置：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-remote-dynamic-buffer.jpg" alt></p><p>DynamicChannelBuffer 的 ensureWritableBytes 方法会检查底层 ChannelBuffer 对象的空间是否需要扩容，如果空间不足则创建一个新的 ChannelBuffer（空间扩大为原来的两倍），然后将原来 ChannelBuffer 中的数据拷贝到新 ChannelBuffer 中，最后将 buffer 字段指向新 ChannelBuffer 对象以完成整个扩容操作。方法具体逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">--- DynamicChannelBuffer</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureWritableBytes</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 剩余空间充足</span></span><br><span class="line">        <span class="keyword">if</span> (minWritableBytes &lt;= writableBytes()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> newCapacity;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前 ChannelBuffer 容量大小是否为 0</span></span><br><span class="line">        <span class="keyword">if</span> (capacity() == <span class="number">0</span>) &#123;</span><br><span class="line">            newCapacity = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 ChannelBuffer 容量大小</span></span><br><span class="line">            newCapacity = capacity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算预计容量大小</span></span><br><span class="line">        <span class="keyword">int</span> minNewCapacity = writerIndex() + minWritableBytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果预计容量大于当前 ChannelBuffer 的容量大小，则进行 2 倍容量扩容</span></span><br><span class="line">        <span class="keyword">while</span> (newCapacity &lt; minNewCapacity) &#123;</span><br><span class="line">            newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过工厂创建容量大小为 newCapacity 的 ChannelBuffer</span></span><br><span class="line">        ChannelBuffer newBuffer = factory().getBuffer(newCapacity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原来ChannelBuffer 中的数据拷贝到新的 ChannelBuffer 中</span></span><br><span class="line">        newBuffer.writeBytes(buffer, <span class="number">0</span>, writerIndex());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 buffer 字段指向新 ChannelBuffer 对象</span></span><br><span class="line">        buffer = newBuffer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="NettyBackedChannelBuffer"><a href="#NettyBackedChannelBuffer" class="headerlink" title="NettyBackedChannelBuffer"></a>NettyBackedChannelBuffer</h3><p>NettyBackedChannelBuffer 是基于 Netty 中 ByteBuf 的 ChannelBuffer 实现类，因为 Netty 中的 ByteBuf 内部维护了 readerIndex 、writerIndex 、 markedReaderIndex 、markedWriterIndex 指针，因此该实现类没有继承 AbstractChannelBuffer 抽象类，而是直接实现了 ChannelBuffer 接口。NettyBackedChannelBuffer 操作缓存区的任务都是委托给 Netty 的 ByteBuf 来完成。</p><p>下面是 Dubbo 的 Netty 4 模块缓冲区构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyBackedChannelBuffer</span> <span class="keyword">implements</span> <span class="title">ChannelBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Netty 的 ByteBuf  - 字节数容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuf buffer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyBackedChannelBuffer</span><span class="params">(ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(buffer, <span class="string">"buffer == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelBufferFactory <span class="title">factory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------------------------- 该类的实现方法都是直接调用 Netty 的 ByteBuf 对应的方法 -----------------------/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它方法&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，该实现类无需工厂创建，因此 factory() 方法返回为 null 。对于 Netty 3 模块，是有对应的工厂的。</p><h2 id="JDK-Stream-和-ChannelBuffer"><a href="#JDK-Stream-和-ChannelBuffer" class="headerlink" title="JDK Stream 和 ChannelBuffer"></a>JDK Stream 和 ChannelBuffer</h2><p>Dubbo 框架的序列化和反序列化是基于 JDK 的  InputStream 和 OutputStream 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">--- Serialization</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create serializer</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 创建ObjectOutput对象，实现序列化功能，序列化输出到 OutputStream</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url    URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> output 输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> serializer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    <span class="function">ObjectOutput <span class="title">serialize</span><span class="params">(URL url, OutputStream output)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create deserializer</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 创建 ObjectInput 对象，实现反序列化，从 InputStream 反序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url   URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input 输入流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> deserializer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    <span class="function">ObjectInput <span class="title">deserialize</span><span class="params">(URL url, InputStream input)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>直接使用 JDK Stream 虽然可行，但是效率上有待提升。因此，在 ChannelBuffer 基础上，Dubbo 提供了一套输入输出流，对 ChannelBufer 进行装饰，如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-remote-stream-buffer.jpg" alt></p><h3 id="ChannelBufferInputStream"><a href="#ChannelBufferInputStream" class="headerlink" title="ChannelBufferInputStream"></a>ChannelBufferInputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 InputStream 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelBufferInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelBuffer buffer;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> startIndex;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> endIndex;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelBufferInputStream</span><span class="params">(ChannelBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(buffer, buffer.readableBytes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelBufferInputStream</span><span class="params">(ChannelBuffer buffer, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"buffer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"length: "</span> + length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; buffer.readableBytes()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 ChannelBuffer </span></span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">        <span class="comment">// 设置 开始位置 为 ChannelBuffer 的读取索引位置</span></span><br><span class="line">        startIndex = buffer.readerIndex();</span><br><span class="line">        <span class="comment">// 设置 结束位置</span></span><br><span class="line">        endIndex = startIndex + length;</span><br><span class="line">        <span class="comment">// 标记 读取索引位置</span></span><br><span class="line">        buffer.markReaderIndex();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChannelBufferInputStream 底层装饰了一个 ChannelBuffer，其实现 InputStream 接口的 readXxx() 方法都是从装饰的 ChannelBuffer 中读取数据。ChannelBufferInputStream 中还维护了一个 startIndex 和一个 endIndex 属性，用来记录读取数据的起止位置。</p><h3 id="ChannelBufferOutputStream"><a href="#ChannelBufferOutputStream" class="headerlink" title="ChannelBufferOutputStream"></a>ChannelBufferOutputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelBufferOutputStream</span> <span class="keyword">extends</span> <span class="title">OutputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被装饰的 ChannelBuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelBuffer buffer;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> startIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelBufferOutputStream</span><span class="params">(ChannelBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"buffer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 ChannelBuffer</span></span><br><span class="line">        <span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">        <span class="comment">// 设置 开始位置 为 ChannelBuffer 的写入索引位置</span></span><br><span class="line">        startIndex = buffer.writerIndex();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取装饰的 ChannelBuffer</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelBuffer <span class="title">buffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取写入字节数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writtenBytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.writerIndex() - startIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------ 写入数据都是委托给被装饰的 ChannelBuffer -------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.writeBytes(b, off, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        buffer.writeBytes(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        buffer.writeByte((<span class="keyword">byte</span>) b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChannelBufferOutputStream 底层装饰了一个 ChannelBuffer，其实现 OutputStream 接口的 writeXxx() 方法都向被装饰的 ChannelBuffer 中写入数据。ChannelBufferInputStream 中还维护了一个 startIndex 属性，用来记录最初的写入数据的位置。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章介绍了 <strong>Remoting 层中的 buffer 包</strong>相关抽象及实现。先是介绍 ChannelBuffer 这一缓冲区抽象接口，并说明了其核心方法和属性以及工作原理。接着介绍了其工厂和实现类，并说明了每个实现类的特点。最后分析了 ChannelBuffer 和 JDK 的 InputStream/OutputStream 的联系，结合 Dubbo 中的序列化层进行了说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇文章继续说明 &lt;strong&gt;Remoting 层中的 buffer 包&lt;/strong&gt;相关抽象及实现。在序列化层中虽然不会直接和 B
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 远程通信模块总览</title>
    <link href="https://gentryhuang.com/posts/95ab077/"/>
    <id>https://gentryhuang.com/posts/95ab077/</id>
    <published>2020-05-09T16:00:00.000Z</published>
    <updated>2020-12-11T02:15:51.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面的几篇文章对 Dubbo 的 <strong>Serialize</strong> 层进行了介绍，它属于 Remoting 层的一部分，相比较同属于 Remoting 层的 <strong>Transport</strong> 层 和 <strong>Exchange</strong> 层，<strong>Serialize</strong> 层在单独的一个模块中，<strong>Transport</strong> 层 和 <strong>Exchange</strong> 层在 dubbo-remoting 模块中， 接下来我们对该模块进行总体说明。需要说明的是，整个 Remoting 层实现是 Dubbo 协议的实现，如果选择 RMI 协议，那整个 Remoting 层都不会用上。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>dubbo-remoting 模块提供了多种客户端和服务端通信的功能，该模块内部可以再划分为  Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty 等网络传输组件的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-remote.png" alt></p><p>dubbo-remoting 模块结构如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-source-remoting.jpg" alt></p><p>Dubbo 框架并没有自己实现一套完整的网络库，而是使用第三方开源网络库。dubbo-remoting-api 子模块中定义了远程通信的抽象概念，具体通信功能需要 dubbo-remoting-* 模块来实现，它们依赖第三方 NIO 库实现 dubbo-remoting-api 模块。如 dubbo-remoting-netty 模块依赖 Netty 3 实现 Dubbo 的远程通信。需要说明的是，dubbo-remoting-zookeeper 模块是实现注册中心功能的模块。</p><h2 id="远程通信的抽象"><a href="#远程通信的抽象" class="headerlink" title="远程通信的抽象"></a>远程通信的抽象</h2><p>dubbo-remoting-api 模块是对远程通信的抽象，结构如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-remote-api.jpg" alt></p><p>下面对各个包进行简单说明：</p><ul><li>buffer 包<br>定义了缓冲区相关的接口、抽象类以及实现。缓存区对于通信框架是一个不可或缺的功能，几乎每个通信框架都有自己的缓存区实现。Dubbo 中的该包是对各个通信框架的缓存区进行了统一的抽象，同时实现了一些基础能力。</li><li>exchange 包<br>建立Request-Response模型，封装请求响应模式，以 Request, Response 为中心。</li><li>telnet 包<br>Dubbo 支持通过 telnet 命令进行服务治理。</li><li>transport 包<br>将网络传输抽象为统一接口，屏蔽了不同网络库的差异，只负责抽象单向消息的传输，以 Message 为中心。即请求消息由 Client 端发出，Server 端接收；响应消息由 Server 端发出，Client端接收。</li><li>其它接口<br>顶层接口放到了 remoting 包下，这些接口是 Dubbo Remoting 的核心接口。</li></ul><p>远程通信抽象相关UML图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-remote-api-uml.jpg" alt></p><h3 id="端点-Endpoint"><a href="#端点-Endpoint" class="headerlink" title="端点 Endpoint"></a>端点 Endpoint</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Endpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关联的 URL 信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 底层 Channel 关联的 ChannelHandler</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ChannelHandler <span class="title">getChannelHandler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取本地地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> local address.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">getLocalAddress</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sent    true: 会等待消息发出，消息发送失败会抛出异常；  false: 不等待消息发出，将消息放入IO队列，即可返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭底层Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优雅关闭底层Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测底层Channel是否已经关闭</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> closed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo 中抽象了端点（Endpoint)的概念，通过 <strong>ip + port</strong> 能够唯一确定一个端点，两个端点之间可以建立 TCP 连接，用于双向传输数据。Dubbo 将 Endpoint 之间的 TCP 连接抽象为通道（Channel），将发起请求的 Endpoint 抽象为客户端（Client），将接收请求的 Endpoint 抽象为服务端（Server）。本质上 Client 和 Server 都是一个端点。</p><h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道 Channel"></a>通道 Channel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> <span class="keyword">extends</span> <span class="title">Endpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取远程地址 (注意，父类中是获取本地地址)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> remote address.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">getRemoteAddress</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经链接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> connected</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------- Channel 中属性相关接口，可以对Channel 中属性进行操作 -----------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * has attribute.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> has or has not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasAttribute</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get attribute.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getAttribute</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set attribute.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   key.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * remove attribute.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Channel 是对两个 Endpoint 连接的抽象，消息发送端会往 Channel 写入消息，而接收端会从 Channel 读取消息。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-remote-channel.jpg" alt></p><p>Channel 接口继承了 Endpoint 接口，也具备开关 Channel 以及发送数据的能力。此外，Channel 支持附加键值对属性。Dubbo 的 Channel 和 Netty 中的 Channel 一致，是通信的载体，<strong>Dubbo 的 Channel 的工作最终是要委托给底层 NIO 连接完成，如 Netty 的 Channel 来完成的</strong> 。</p><h3 id="通道处理器-ChannelHandler"><a href="#通道处理器-ChannelHandler" class="headerlink" title="通道处理器 ChannelHandler"></a>通道处理器 ChannelHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 Channel 的连接建立事件 - Channel 已经被创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel channel.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 Channel 的连接断开事件 - Channel 已经被断开</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel channel.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理发送的数据 - 消息被发送</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel channel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sent</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理读取到的数据 - 消息被接收</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel channel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理捕获到的异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel   channel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception exception.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChannelHandler 是注册在 Channel 上的消息处理器，和 Netty 的 ChannelHandler 一致，负责 Channel 中的逻辑处理。需要说明的是，ChannelHandler 被 @SPI注解标注，表示是一个 Dubbo 扩展点。ChannelHandler 中定义了 5 个方法，对应着它的 5 种状态：</p><ul><li>connected        Channel 已经被创建</li><li>disconnected     Channel 已经被断开</li><li>sent             消息被发送</li><li>received         消息被接收</li><li>caught           捕获到异常</li></ul><p>Dubbo 中提供了大量的 ChannelHandler 去承载特性和扩展，<strong>这些 Handler 最终会和底层通信框架进行关联</strong>，如 Netty、Mina 等。一次完整的 RPC 调用贯穿了一系列的 ChannelHandler，如果直接挂载到 Netty 这样的底层通信框架，因为整个调用链路比较长，需要触发大量链式查找和事件，不仅效率低而且消耗资源。因此，Dubbo 框架内部使用了大量的 ChannelHandler 组成链式结构（类似过滤器Filter链），根据 ChannelHandler 的特性依次处理具体的逻辑，Dubbo 这种将多个 ChannelHandler 聚合成一个 ChannelHandler 使用的是装饰者模式，在后面的具体实现中可以看到大量装饰者模式的使用。</p><h3 id="语义端点"><a href="#语义端点" class="headerlink" title="语义端点"></a>语义端点</h3><p>Dubbo 中抽象了端点 Endpoint 的概念，将发起请求的 Endpoint 抽象为客户端（Client），将接收请求的 Endpoint 抽象为服务端（Server），Client 和 Server 本身都是 Endpoint，只不过在语义上区分了请求和响应的职责，两者都具备发送消息的能力，所以都继承了 Endpoint 接口。UML 图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-endpoint-uml.jpg" alt></p><h4 id="客户端-Client"><a href="#客户端-Client" class="headerlink" title="客户端 Client"></a>客户端 Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">Endpoint</span>, <span class="title">Channel</span>, <span class="title">Resetable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重连</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reconnect</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameters</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(com.alibaba.dubbo.common.Parameters parameters)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务端-Server"><a href="#服务端-Server" class="headerlink" title="服务端 Server"></a>服务端 Server</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">Endpoint</span>, <span class="title">Resetable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  是否绑定本地端口，即是否启动成功，可连接、接收消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bound</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBound</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接上服务的通道列表。 多个Client 可以连接同一个Server</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channels</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据地址获取连接上服务的通道</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remoteAddress</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Channel <span class="title">getChannel</span><span class="params">(InetSocketAddress remoteAddress)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重置，已废弃</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameters</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(com.alibaba.dubbo.common.Parameters parameters)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client 和 Server 的主要区别是 Client 只能关联一个 Channel，而 Server 可以接收多个 Client 发起的 Channel 连接。</p><h3 id="网络传输-Transporter"><a href="#网络传输-Transporter" class="headerlink" title="网络传输 Transporter"></a>网络传输 Transporter</h3><p>由远程通信抽象相关UML图可知，网络传输 Transporter 是在 Client 和 Server 之上封装的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"netty"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个服务器。根据 'server'，'transporter' 确定 Server 扩展实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> server 返回服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.remoting.Transporters#bind(URL, ChannelHandler...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    <span class="function">Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接服务器，即创建一个客户端。根据 'client','transporter' 确定 Client 扩展实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> client 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.remoting.Transporters#connect(URL, ChannelHandler...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    <span class="function">Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transporter 接口上标注 @SPI 注解，表示它是一个扩展点，默认扩展名为 <em>netty</em> ，<strong>bind 方法</strong> 和 <strong>connect 方法</strong> 都使用 @Adaptive 注解标注，表示会生成自适应扩展实现。</p><h3 id="网络传输门面-Transporters"><a href="#网络传输门面-Transporters" class="headerlink" title="网络传输门面 Transporters"></a>网络传输门面 Transporters</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transporters</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// check duplicate jar package</span></span><br><span class="line">        Version.checkDuplicate(Transporters<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Version.checkDuplicate(RemotingException<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Transporters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法，创建一个服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title">bind</span><span class="params">(String url, ChannelHandler... handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bind(URL.valueOf(url), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handlers == <span class="keyword">null</span> || handlers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handlers == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建handler</span></span><br><span class="line">        ChannelHandler handler;</span><br><span class="line">        <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">            handler = handlers[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果handlers 元素数量大于1，则创建分发器 ChannelHandlerDispatcher【分发器会循环调用handlers】</span></span><br><span class="line">            handler = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取自适应 Transporter 实例，由具体的Transporter 来创建Server 。默认是NettyTransporter创建NettyServer</span></span><br><span class="line">        <span class="keyword">return</span> getTransporter().bind(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法，连接服务器，即创建一个客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Client <span class="title">connect</span><span class="params">(String url, ChannelHandler... handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connect(URL.valueOf(url), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ChannelHandler handler;</span><br><span class="line">        <span class="comment">// 没有传入通道处理器 ChannelHandler，则会创建ChannelHandlerAdapter 作为通道处理器</span></span><br><span class="line">        <span class="keyword">if</span> (handlers == <span class="keyword">null</span> || handlers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            handler = <span class="keyword">new</span> ChannelHandlerAdapter();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">            handler = handlers[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 传入多个 ChanenlHandler，则会创建分发器 ChannelHandlerDispatcher【分发器会循环调用handlers】</span></span><br><span class="line">            handler = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取自适应 Transporter 实例，由具体的Transporter 来创建 Client 。默认是NettyTransporter创建 NettyClient</span></span><br><span class="line">        <span class="keyword">return</span> getTransporter().connect(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取自适应 Transporter 实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transporter <span class="title">getTransporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Transporter<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transporters 是一个门面类，其中封装了通过 Dubbo SPI 获取 Transporter 对象、ChannelHandler 的处理、服务器 Sever 的创建以及客户端 Client 的创建。属于外观模式。</p><h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>Codec2相比较Codec的变化是，将OutputStream和InputStream，替换成了ChannelBuffer，更好的以 ChannelBuffer 为核心，与其他框架整合。</p><h4 id="Codec2"><a href="#Codec2" class="headerlink" title="Codec2"></a>Codec2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Codec2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer  Buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CODEC_KEY&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(Channel channel, ChannelBuffer buffer, Object message)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer  Buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CODEC_KEY&#125;)</span><br><span class="line">    <span class="function">Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码过程中，需要解决TCP拆包，粘包的场景。解码结果如下：</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> DecodeResult &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 需要更多输入</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEED_MORE_INPUT,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 忽略一些输入</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SKIP_SOME_INPUT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Codec"><a href="#Codec" class="headerlink" title="Codec"></a>Codec</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Need more input poison.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #decode(Channel, InputStream)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object NEED_MORE_INPUT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Encode message.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel channel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> output  output stream.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CODEC_KEY&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(Channel channel, OutputStream output, Object message)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Decode message.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel channel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input   input stream.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message or &lt;code&gt;NEED_MORE_INPUT&lt;/code&gt; poison.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #NEED_MORE_INPUT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CODEC_KEY&#125;)</span><br><span class="line">    <span class="function">Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Codec 是老的编解码器接口，目前已经被Codec2取代，可以通过CodecAdapter将Codec适配成Codec2。</p><h3 id="可解码接口-Decodeable"><a href="#可解码接口-Decodeable" class="headerlink" title="可解码接口 Decodeable"></a>可解码接口 Decodeable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Decodeable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口在消息解码的过程中扮演重要角色，是对 Dubbo 协议下的请求和响应<strong>消息体</strong>解码的支持。在后面的文章中会详细说明其作用。</p><h3 id="派发器-Dispatcher"><a href="#派发器-Dispatcher" class="headerlink" title="派发器 Dispatcher"></a>派发器 Dispatcher</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ChannelHandlerWrapper (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * &lt;span&gt;说明：&lt;/span&gt;</span></span><br><span class="line"><span class="comment"> * 1 调度器接口，被 <span class="doctag">@SPI</span>(AllDispatcher.NAME)注解标注，是Dubbo 的拓展点，默认扩展名为 'all'</span></span><br><span class="line"><span class="comment"> * 2 如果事件处理的逻辑能迅速完成，并且不会发起新的 IO 请求，比如只是在内存中记个标识，则直接在 IO 线程上处理更快，因为减少了线程池调度。</span></span><br><span class="line"><span class="comment"> *   如果事件处理逻辑较慢，或者需要发起新的 IO 请求，比如需要查询数据库，则必须派发到线程池，否则 IO 线程阻塞，将导致不能接收其它请求。</span></span><br><span class="line"><span class="comment"> * 3 通过不同的派发策略和不同的线程池配置的组合来应对不同的场景。注意，派发策略和线程池的联系</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;span&gt;在dubbo 中，有多种Dispatcher的实现&lt;/span&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;all: 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;direct: 所有消息都不派发到线程池，全部在IO线程上直接执行&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;message: 只有请求/响应消息派发到线程池，其他的消息直接在IO线程上执行&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;execution: 只有请求消息派发到线程池，其他的消息直接在IO线程上执行&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;connection: 在IO线程上，将连接/断开事件放入队列，有序逐个执行。其他消息派发到线程池&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * 注意：每个Dispatcher实现类，都对应一个ChannelHandler实现类。默认情况下，使用AllDispatcher调度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span>(AllDispatcher.NAME)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 派发消息到线程池处理还是IO线程直接处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.DISPATCHER_KEY, <span class="string">"dispather"</span>, <span class="string">"channel.handler"</span>&#125;)</span><br><span class="line">    <span class="function">ChannelHandler <span class="title">dispatch</span><span class="params">(ChannelHandler handler, URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dispatcher 主要支持了 Dubbo 的线程模型，可以创建不同的 ChannelHandler 来决定消息是交给线程池处理还是IO线程处理，因此我们可以在不同的场景中选择不同的派发策略实现消息或者事件的处理。</p><h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-exception-uml.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章主要介绍了 dubbo-remoting-api 中核心接口以及类，重点介绍了 <strong>端点 Endpoint</strong>、<strong>通道 Channel</strong>、<strong>通道处理器 ChannelHandler</strong> 、以及<strong>编解码器</strong> 。在语义上将端点 Endpoint 区分为 <strong>Client</strong> 和 <strong>Server</strong>。接着又介绍了 Server 和 Client 之上的 <strong>网络传输层Transporter</strong> 以及其<strong>门面类 Transporters</strong> 。</p><p>总结起来，上层使用方通过 Transporters 门面获取具体的 Transporter 实现，然后通过该 Transporter 创建相应的 Server 和 Client 实现，接着 Client 和 Server 之间建立连接即通道 Channel，并使用 ChannelHandler 处理 Channel相关事件和消息，这个过程还会涉及到编解码的处理，Codec2 正是用来解决编解码问题的。需要注意的是，这里上层指的其实就是信息交互层 Exchange ，我们会在之后的文章中介绍。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-remote-simple-relation.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面的几篇文章对 Dubbo 的 &lt;strong&gt;Serialize&lt;/strong&gt; 层进行了介绍，它属于 Remoting 层的一部分，
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - FST序列化</title>
    <link href="https://gentryhuang.com/posts/cfaae53/"/>
    <id>https://gentryhuang.com/posts/cfaae53/</id>
    <published>2020-05-04T16:00:00.000Z</published>
    <updated>2020-11-07T16:20:28.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 <a href="https://gentryhuang.com/posts/16132b67/">序列化总览</a> 中介绍了 Dubbo 序列化抽象API相关接口，本篇文章将介绍 Dubbo 的 FST 序列化实现。</p><p>相关的代码结构如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-serialize-fst.jpg" alt></p><h2 id="FST-工厂"><a href="#FST-工厂" class="headerlink" title="FST 工厂"></a>FST 工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FstFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FstFactory factory = <span class="keyword">new</span> FstFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FST 配置对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法，获取FST默认工厂</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FstFactory <span class="title">getDefaultFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FstFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将要序列化优化的类 注册到 FSTConfiguration 配置对象中</span></span><br><span class="line">        <span class="keyword">for</span> (Class clazz : SerializableClassRegistry.getRegisteredClasses()) &#123;</span><br><span class="line">            conf.registerClass(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得 FSTObjectOutput 对象，被 FstObjectOutput 调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FSTObjectOutput <span class="title">getObjectOutput</span><span class="params">(OutputStream outputStream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> conf.getObjectOutput(outputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得 FSTObjectInput 对象，被 FstObjectInput 调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FSTObjectInput <span class="title">getObjectInput</span><span class="params">(InputStream inputStream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> conf.getObjectInput(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，FST 工厂的构造方法中会将 SerializableClassRegistry 注册表中的待序列化优化类，注册到 FSTConfiguration 中。</p><h2 id="FstSerialization"><a href="#FstSerialization" class="headerlink" title="FstSerialization"></a>FstSerialization</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FstSerialization</span> <span class="keyword">implements</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getContentTypeId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内容类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x-application/fst"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectOutput <span class="title">serialize</span><span class="params">(URL url, OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FstObjectOutput(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectInput <span class="title">deserialize</span><span class="params">(URL url, InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FstObjectInput(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 Serialization 接口，FST 序列化实现类，将序列化任务交给 FstObjectOutput 对象完成，将反序列化任务交给 FstObjectInput 对象完成。</p><h2 id="FstObjectOutput"><a href="#FstObjectOutput" class="headerlink" title="FstObjectOutput"></a>FstObjectOutput</h2><p>FstObjectOutput 实现序列化抽象API模块的 ObjectOutput 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FstObjectOutput</span> <span class="keyword">implements</span> <span class="title">ObjectOutput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FSTObjectOutput output;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FstObjectOutput</span><span class="params">(OutputStream outputStream)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过工厂创建 FSTObjectOutput 对象</span></span><br><span class="line">        output = FstFactory.getDefaultFactory().getObjectOutput(outputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------------- 序列化方法直接委托给 FSTObjectOutput 对应的方法 ---------- /</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeBoolean(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeByte(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeShort</span><span class="params">(<span class="keyword">short</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeShort(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeInt(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLong</span><span class="params">(<span class="keyword">long</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeLong(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFloat</span><span class="params">(<span class="keyword">float</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeFloat(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeDouble(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            output.writeInt(-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writeBytes(v, <span class="number">0</span>, v.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] v, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            output.writeInt(-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            output.writeInt(len);</span><br><span class="line">            output.write(v, off, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeUTF(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeObject(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FstObjectOutput 中的序列化方法直接委托给 FSTObjectOutput 中对应的方法。</p><h2 id="FstObjectInput"><a href="#FstObjectInput" class="headerlink" title="FstObjectInput"></a>FstObjectInput</h2><p>FstObjectInput 实现序列化抽象API模块的 ObjectInput 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FstObjectInput</span> <span class="keyword">implements</span> <span class="title">ObjectInput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FSTObjectInput input;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FstObjectInput</span><span class="params">(InputStream inputStream)</span> </span>&#123;</span><br><span class="line">        input = FstFactory.getDefaultFactory().getObjectInput(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----------  所有的实现方法委托给 FSTObjectInput 对应的方法 ---------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readBoolean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readByte();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readShort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readFloat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readDouble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readUTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) input.readObject(clazz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; clazz, Type type)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) input.readObject(clazz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readBytes() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">int</span> len = input.readInt();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            input.readFully(b);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个实现方法，直接委托给 FSTObjectInput 对应的方法。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Dubbo 的 FST 序列化方式特殊点在于可以指定要序列化优化的类，然注册到 FSTConfiguration 配置对象中，用以发挥出 FST 的高性能。其中 Kryo 序列化方式和 FST 类似。其它没有分析到的序列化方式套路都是一样的。Dubbo 的序列化到此结束。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/16132b67/&quot;&gt;序列化总览&lt;/a&gt; 中介绍了 Dub
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - Hessian序列化</title>
    <link href="https://gentryhuang.com/posts/4fd38523/"/>
    <id>https://gentryhuang.com/posts/4fd38523/</id>
    <published>2020-05-03T16:00:00.000Z</published>
    <updated>2020-11-07T16:00:54.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 <a href="https://gentryhuang.com/posts/16132b67/">序列化总览</a> 中介绍了 Dubbo 序列化抽象API相关接口，本篇文章将介绍 Dubbo 的 Hessian 序列化实现，它是 Dubbo 的默认序列化实现。</p><p>相关的代码结构如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-serialize-hessian.jpg" alt></p><p>Hessian 有自己的序列化实现，Dubbo 对 Hessian2 进行了改进，形成了一套自己的序列化方式。</p><h2 id="Hessian2Serialization"><a href="#Hessian2Serialization" class="headerlink" title="Hessian2Serialization"></a>Hessian2Serialization</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hessian2Serialization</span> <span class="keyword">implements</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> ID = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getContentTypeId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x-application/hessian2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectOutput <span class="title">serialize</span><span class="params">(URL url, OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hessian2ObjectOutput(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectInput <span class="title">deserialize</span><span class="params">(URL url, InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hessian2ObjectInput(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hessian2Serialization 实现并没有什么不同，同样是使用 <code>serialize</code> 方法创建 ObjectOutput 对象，该对象类型为 Hessian2ObjectOutput，负责序列化工作。使用 <code>deserialize</code> 方法创建 ObjectInput 对象，该对象类型为 Hessian2ObjectInput，负责反序列化工作。</p><h2 id="Hessian2ObjectOutput"><a href="#Hessian2ObjectOutput" class="headerlink" title="Hessian2ObjectOutput"></a>Hessian2ObjectOutput</h2><p>Hessian2ObjectOutput 实现了抽象API模块中的 ObjectOutput 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hessian2ObjectOutput</span> <span class="keyword">implements</span> <span class="title">ObjectOutput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Hessian2Output mH2o;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hessian2ObjectOutput</span><span class="params">(OutputStream os)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Hessian2Output 对象</span></span><br><span class="line">        mH2o = <span class="keyword">new</span> Hessian2Output(os);</span><br><span class="line">        <span class="comment">// 设置对应的工厂</span></span><br><span class="line">        mH2o.setSerializerFactory(Hessian2SerializerFactory.SERIALIZER_FACTORY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------- 最终序列化任务都委托给 Hessian2Output 对象来完成 ------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeBoolean(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeInt(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeShort</span><span class="params">(<span class="keyword">short</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeInt(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeInt(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLong</span><span class="params">(<span class="keyword">long</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeLong(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFloat</span><span class="params">(<span class="keyword">float</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeDouble(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeDouble(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeBytes(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeBytes(b, off, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeString(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.flushBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hessian2ObjectOutput 中封装一个 Hessian2Output 对象，由上面代码可知，Hessian2Output 对 java.io.OutputStream 进行了封装，并且序列化各类数据的方法都会委托给 Hessian2Output 对象的相应方法完成。需要注意的是，对于基本类型数据的序列化，Hessian2Output 使用字节数组来处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hessian2Output</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractHessianOutput</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Hessian2Constants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SIZE = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">// 字节数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] _buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[SIZE];</span><br><span class="line">    <span class="comment">// the output stream/</span></span><br><span class="line">    <span class="keyword">protected</span> OutputStream _os;</span><br><span class="line">    <span class="comment">// map of references</span></span><br><span class="line">    <span class="keyword">private</span> IdentityIntMap _refs = <span class="keyword">new</span> IdentityIntMap();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> _isCloseStreamOnClose;</span><br><span class="line">    <span class="comment">// map of classes</span></span><br><span class="line">    <span class="keyword">private</span> HashMap _classRefs;</span><br><span class="line">    <span class="comment">// map of types</span></span><br><span class="line">    <span class="keyword">private</span> HashMap _typeRefs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> _offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> _isStreaming;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new Hessian output stream, initialized with an</span></span><br><span class="line"><span class="comment">     * underlying output stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> os the underlying output stream.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hessian2Output</span><span class="params">(OutputStream os)</span> </span>&#123;</span><br><span class="line">        _os = os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ... 省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hessian2ObjectInput"><a href="#Hessian2ObjectInput" class="headerlink" title="Hessian2ObjectInput"></a>Hessian2ObjectInput</h2><p>Hessian2ObjectInput 实现了抽象API模块中的 ObjectInput 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hessian2ObjectInput</span> <span class="keyword">implements</span> <span class="title">ObjectInput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Hessian2Input mH2i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hessian2ObjectInput</span><span class="params">(InputStream is)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Hessian2Input 对象</span></span><br><span class="line">        mH2i = <span class="keyword">new</span> Hessian2Input(is);</span><br><span class="line">        <span class="comment">// 设置序列化工厂</span></span><br><span class="line">        mH2i.setSerializerFactory(Hessian2SerializerFactory.SERIALIZER_FACTORY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mH2i.readBoolean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>) mH2i.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">short</span>) mH2i.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mH2i.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mH2i.readLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>) mH2i.readDouble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mH2i.readDouble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readBytes() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> mH2i.readBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mH2i.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mH2i.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">            ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) mH2i.readObject(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls, Type type)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readObject(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hessian2ObjectInput 中封装一个 Hessian2Input 对象，由上面代码可知，Hessian2Input 对 java.io.InputStream 进行了封装，并且将所有反序列化的实现都委托给 Hessian2Input 对象。同样的，Hessian2Input 对基本数据类型的数据进行反序列化是读取字节数组内容。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Dubbo 的 Hessian 序列化也是同样的套路，Hessian2Serialization 要进行序列化操作就把任务交给创建的 Hessian2ObjectOutput 对象去完成，要进行反序列化操作就把任务交给 Hessian2ObjectInput 对象去完成。只不过，Hessian2ObjectOutput 和 Hessian2ObjectInput 又会把任务委托给 Hessian类的Hessian2Output对象和Hessian2Input对象去完成。下一篇文章中分析 Dubbo 的 FST 序列化实现，它代表了一种类型，支持将那些需要被序列化的类注册到dubbo系统中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/16132b67/&quot;&gt;序列化总览&lt;/a&gt; 中介绍了 Dub
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - JDK序列化</title>
    <link href="https://gentryhuang.com/posts/5898e8ff/"/>
    <id>https://gentryhuang.com/posts/5898e8ff/</id>
    <published>2020-05-02T16:00:00.000Z</published>
    <updated>2020-11-07T10:49:32.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 <a href="https://gentryhuang.com/posts/16132b67/">序列化总览</a> 中介绍了 Dubbo 序列化抽象API相关接口，本篇文章将介绍JDK的序列化实现。</p><p>相关的代码结构如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-serialize-jdk.jpg" alt></p><p>JDK 序列化是基于Java原生的序列化实现，从不同的方面考虑，具体有三种实现方式：</p><blockquote><p>java=com.alibaba.dubbo.common.serialize.java.JavaSerialization<br>compactedjava=com.alibaba.dubbo.common.serialize.java.CompactedJavaSerialization<br>nativejava=com.alibaba.dubbo.common.serialize.nativejava.NativeJavaSerialization</p></blockquote><p>NativeJavaSerialization 是原生的 Java 序列化的实现方式。CompactedJavaSerialization 是在原生的 Java 序列化的基础上做了压缩，实现了自定义的类描述符的写入和读取，在序列化时只需写入类名而不是完整的类信息，可以有效压缩体积。JavaSerialization 是对原生 Java 序列化和压缩的组合实现，并且支持对空字符串及空对象的处理。三者的UML图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-serialize-jdk-outline.jpg" alt></p><h3 id="Java-原生序列化"><a href="#Java-原生序列化" class="headerlink" title="Java 原生序列化"></a>Java 原生序列化</h3><h3 id="NativeJavaSerialization"><a href="#NativeJavaSerialization" class="headerlink" title="NativeJavaSerialization"></a>NativeJavaSerialization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeJavaSerialization</span> <span class="keyword">implements</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"nativejava"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getContentTypeId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x-application/nativejava"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectOutput <span class="title">serialize</span><span class="params">(URL url, OutputStream output)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NativeJavaObjectOutput(output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectInput <span class="title">deserialize</span><span class="params">(URL url, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NativeJavaObjectInput(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于原生的Java序列化实现，即使用 java.io.ObjectOutputSteam 进行序列化，使用 java.io.ObjectInputStream 进行反序列化。在 NativeJavaObjectOutput 和 NativeJavaObjectInput 会分别对传入的流进行包装。</p><h3 id="NativeJavaObjectOutput"><a href="#NativeJavaObjectOutput" class="headerlink" title="NativeJavaObjectOutput"></a>NativeJavaObjectOutput</h3><p>NativeJavaObjectOutput 实现了抽象API模块中的 ObjectOutput 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeJavaObjectOutput</span> <span class="keyword">implements</span> <span class="title">ObjectOutput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * java原生的 输出流对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectOutputStream outputStream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NativeJavaObjectOutput</span><span class="params">(OutputStream os)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> ObjectOutputStream(os));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">NativeJavaObjectOutput</span><span class="params">(ObjectOutputStream out)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(out, <span class="string">"output == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.outputStream = out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ObjectOutputStream <span class="title">getObjectOutputStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeBoolean(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeByte(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeShort</span><span class="params">(<span class="keyword">short</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeShort(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeInt(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLong</span><span class="params">(<span class="keyword">long</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeLong(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFloat</span><span class="params">(<span class="keyword">float</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeFloat(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeDouble(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeUTF(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            outputStream.writeInt(-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writeBytes(v, <span class="number">0</span>, v.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] v, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            outputStream.writeInt(-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outputStream.writeInt(len);</span><br><span class="line">            outputStream.write(v, off, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 原生的序列化，无论是基本数据类型还是引用数据类型，进行序列化时都直接使用 java.io.ObjectOutputStream API来完成。</p><h3 id="NativeJavaObjectInput"><a href="#NativeJavaObjectInput" class="headerlink" title="NativeJavaObjectInput"></a>NativeJavaObjectInput</h3><p>NativeJavaObjectInput 实现了抽象API模块中的 ObjectInput接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeJavaObjectInput</span> <span class="keyword">implements</span> <span class="title">ObjectInput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java原生的 ObjectInputStream 输入流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectInputStream inputStream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NativeJavaObjectInput</span><span class="params">(InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> ObjectInputStream(is));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">NativeJavaObjectInput</span><span class="params">(ObjectInputStream is)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(is, <span class="string">"input == null"</span>);</span><br><span class="line">        inputStream = is;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ObjectInputStream <span class="title">getObjectInputStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls, Type type)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readBoolean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readByte();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readShort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readFloat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readDouble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readUTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readBytes() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">int</span> len = inputStream.readInt();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            inputStream.readFully(result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 原生的反序列化，无论是基本数据类型还是引用数据类型，进行反序列化时都直接使用 java.io.ObjectInputStream API来完成。</p><h2 id="压缩能力的序列化"><a href="#压缩能力的序列化" class="headerlink" title="压缩能力的序列化"></a>压缩能力的序列化</h2><h3 id="CompactedJava"><a href="#CompactedJava" class="headerlink" title="CompactedJava"></a>CompactedJava</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompactedJavaSerialization</span> <span class="keyword">implements</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getContentTypeId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x-application/compactedjava"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在创建 JavaObjectOutput 时，根据 compact = true 时，使用 CompactedObjectOutputStream 输出流</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectOutput <span class="title">serialize</span><span class="params">(URL url, OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JavaObjectOutput(out, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectInput <span class="title">deserialize</span><span class="params">(URL url, InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JavaObjectInput(is, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原生的 Java 序列化的基础上做了压缩，实现了自定义的类描述符的写入和读取，在序列化时只需写入类名而不是完整的类信息，可以有效压缩体积。功能由 CompactedObjectOutputStream 和 CompactedObjectInputStream 实现。</p><h3 id="CompactedObjectOutputStream"><a href="#CompactedObjectOutputStream" class="headerlink" title="CompactedObjectOutputStream"></a>CompactedObjectOutputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompactedObjectOutputStream</span> <span class="keyword">extends</span> <span class="title">ObjectOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompactedObjectOutputStream</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeClassDescriptor</span><span class="params">(ObjectStreamClass desc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = desc.forClass();</span><br><span class="line">        <span class="keyword">if</span> (clazz.isPrimitive() || clazz.isArray()) &#123;</span><br><span class="line">            write(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">super</span>.writeClassDescriptor(desc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            write(<span class="number">1</span>);</span><br><span class="line">            writeUTF(desc.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承了 ObjectOutputStream 类，重写了 writeClassDescriptor 方法，实现了对 ClassDescriptor 的写入。</p><h3 id="CompactedObjectInputStream"><a href="#CompactedObjectInputStream" class="headerlink" title="CompactedObjectInputStream"></a>CompactedObjectInputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompactedObjectInputStream</span> <span class="keyword">extends</span> <span class="title">ObjectInputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader mClassLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompactedObjectInputStream</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(in, Thread.currentThread().getContextClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompactedObjectInputStream</span><span class="params">(InputStream in, ClassLoader cl)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">        mClassLoader = cl == <span class="keyword">null</span> ? ClassHelper.getClassLoader() : cl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ObjectStreamClass <span class="title">readClassDescriptor</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> type = read();</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.readClassDescriptor();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                Class&lt;?&gt; clazz = loadClass(readUTF());</span><br><span class="line">                <span class="keyword">return</span> ObjectStreamClass.lookup(clazz);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(<span class="string">"Unexpected class descriptor type: "</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; loadClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> mClassLoader.loadClass(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承了 ObjectInputStream 类，重写了 readClassDescriptor 方法，实现了对 ClassDescriptor 读取。</p><h2 id="组合原生和压缩序列化"><a href="#组合原生和压缩序列化" class="headerlink" title="组合原生和压缩序列化"></a>组合原生和压缩序列化</h2><h3 id="JavaSerialization"><a href="#JavaSerialization" class="headerlink" title="JavaSerialization"></a>JavaSerialization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaSerialization</span> <span class="keyword">implements</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getContentTypeId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x-application/java"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectOutput <span class="title">serialize</span><span class="params">(URL url, OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JavaObjectOutput(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectInput <span class="title">deserialize</span><span class="params">(URL url, InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JavaObjectInput(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JavaObjectOutput"><a href="#JavaObjectOutput" class="headerlink" title="JavaObjectOutput"></a>JavaObjectOutput</h3><p>JavaObjectOutput 继承了 Java 原生序列化的 NativeJavaObjectOutput 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaObjectOutput</span> <span class="keyword">extends</span> <span class="title">NativeJavaObjectOutput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaObjectOutput</span><span class="params">(OutputStream os)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> ObjectOutputStream(os));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意 compact 为true的情况  &#123;<span class="doctag">@link</span> CompactedJavaSerialization#serialize(URL, OutputStream)&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> os</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> compact</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaObjectOutput</span><span class="params">(OutputStream os, <span class="keyword">boolean</span> compact)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(compact ? <span class="keyword">new</span> CompactedObjectOutputStream(os) : <span class="keyword">new</span> ObjectOutputStream(os));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对空字符串的处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            getObjectOutputStream().writeInt(-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getObjectOutputStream().writeInt(v.length());</span><br><span class="line">            getObjectOutputStream().writeUTF(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对空对象的处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            getObjectOutputStream().writeByte(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getObjectOutputStream().writeByte(<span class="number">1</span>);</span><br><span class="line">            getObjectOutputStream().writeObject(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        getObjectOutputStream().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaObjectOutput 构造方法可以根据 <strong>compact</strong> 参数创建不同的实现序列化功能对象。</p><h3 id="JavaObjectInput"><a href="#JavaObjectInput" class="headerlink" title="JavaObjectInput"></a>JavaObjectInput</h3><p>JavaObjectInput 继承了 Java 原生序列化的 NativeJavaObjectInput 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaObjectInput</span> <span class="keyword">extends</span> <span class="title">NativeJavaObjectInput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_BYTE_ARRAY_LENGTH = <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaObjectInput</span><span class="params">(InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> ObjectInputStream(is));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaObjectInput</span><span class="params">(InputStream is, <span class="keyword">boolean</span> compacted)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(compacted ? <span class="keyword">new</span> CompactedObjectInputStream(is) : <span class="keyword">new</span> ObjectInputStream(is));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readBytes() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">int</span> len = getObjectInputStream().readInt();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (len &gt; MAX_BYTE_ARRAY_LENGTH)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Byte array length too large. "</span> + len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        getObjectInputStream().readFully(b);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = getObjectInputStream().readInt();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getObjectInputStream().readUTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> b = getObjectInputStream().readByte();</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getObjectInputStream().readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">            ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls, Type type)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaObjectOutput 构造方法可以根据 <strong>compact</strong> 参数创建不同的实现反序列化功能对象。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本篇文章加单介绍了 Dubbo 原生的 Java 序列化实现方式，即直接使用 java.io.ObjectOutputSteam 进行序列化，使用 java.io.ObjectInputStream 进行反序列化，并没有进行过多的其它处理，不依赖其它组件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/16132b67/&quot;&gt;序列化总览&lt;/a&gt; 中介绍了 Dub
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="JDK" scheme="https://gentryhuang.com/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 序列化总览</title>
    <link href="https://gentryhuang.com/posts/16132b67/"/>
    <id>https://gentryhuang.com/posts/16132b67/</id>
    <published>2020-05-02T16:00:00.000Z</published>
    <updated>2020-11-24T04:54:38.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Dubbo 的服务暴露、服务引用以及服务调用除了需要之前介绍的配置、代理、注册中心，还需要协议、网络通信、集群容错、序列化等。因此，从本文开始会由底向上分析 Dubbo 架构中的模块。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RPC框架需要网络通信实现信息的发送和接收，既然是网络通信就一定会使用到序列化和反序列化技术。Dubbo 对序列化的定义是，将对象（基本数据类型和引用类型）转成字节流用于<strong>网络传输</strong>；以及将字节流转为对象（基本数据类型和引用类型），用于在收到字节流数据后进行还原。</p><p>提起序列化就不得不提到<strong>协议</strong>这个概念，两者是不同的东西，它们之间属于组合关系，协议需要用到序列化技术，而序列化技术可以服务于不同的协议。序列化层在 Dubbo 的架构图中的位置如下，它处于最低层，属于 Remoting 层的一部分。在 Dubbo 中还有一个和序列化相关的扩展接口 Codec2，是基于序列化之上封装的组件，主要用于实现对数据的编码和解码，即解决粘包和拆包等问题，序列化和反序列化功能是使用序列化层来完成的。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-serialize.jpg" alt></p><p>Dubbo 为了支持多种序列化算法，单独抽象了 Serialize 层，对应的模块结构如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-source-serialization.jpg" alt></p><h2 id="Dubbo-序列化抽象-API"><a href="#Dubbo-序列化抽象-API" class="headerlink" title="Dubbo 序列化抽象 API"></a>Dubbo 序列化抽象 API</h2><p>dubbo-serialization-api 模块中定义了 Dubbo 序列化层的核心接口以及类，关系如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-serialize-api.jpg" alt></p><h3 id="Serialization-接口"><a href="#Serialization-接口" class="headerlink" title="Serialization 接口"></a>Serialization 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"hessian2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化类型编号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> content type id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">byte</span> <span class="title">getContentTypeId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得序列化对应的类型，每一种序列化算法都对应一个类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> content type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getContentType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create serializer</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 创建ObjectOutput对象，实现序列化功能，序列化输出到 OutputStream</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url    URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> output 输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> serializer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    <span class="function">ObjectOutput <span class="title">serialize</span><span class="params">(URL url, OutputStream output)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create deserializer</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 创建 ObjectInput 对象，实现反序列化，从 InputStream 反序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url   URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input 输入流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> deserializer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    <span class="function">ObjectInput <span class="title">deserialize</span><span class="params">(URL url, InputStream input)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Serialization 接口是一个扩展点，默认扩展实现是 Hessian2Serialization 。它是序列化最核心的接口，<strong>serialize</strong>方法用来创建实现序列化功能的 ObjectOutput 对象，<strong>deserialize</strong>方法用来创建实现反序列化功能的 ObjectInput。不同的 Serialization 扩展实现对应不同的 ObjectOutput 和 ObjectInput 对象，但是本质上都是对 JDK的 OutputStream 和 InputStream 类的封装或改造，Dubbo 中一般使用对 ChannelBuffer 装饰的流对象。不同的 Serialization 扩展实现会有所差异，除了效率外还体现在API上，对于引用类型的序列化一般最底层都是使用JDK的OutputStream 和 InputStream的API，上层因不同特性的 Serialization 会有不同，对于基本类型数据的序列化有的 Serialization 会使用自身维护的字节数组来实现，有的直接使用传入的 Stream 流实现。</p><p>Serialization 的序列化（serialize）和反序列化（deserialize）方法的 Stream 参数，在使用的时候一般都是 Dubbo 自定义的 Stream 对象，该对象是对 Dubbo 中的 ChannelBuffer 的封装，用以提高效率和性能。关于 Dubbo 的 ChannelBuffer 我们会在后面的文章中进行说明，下面是 Dubbo 相关 Stream :</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-remote-stream-buffer.jpg" alt></p><p>Dubbo 提供了多个 Serialization 实现 ，如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-serialize-hierarchy.jpg" alt></p><h3 id="DataOutput-接口"><a href="#DataOutput-接口" class="headerlink" title="DataOutput 接口"></a>DataOutput 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataOutput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write boolean.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write byte.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write short.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeShort</span><span class="params">(<span class="keyword">short</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write integer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write long.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeLong</span><span class="params">(<span class="keyword">long</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write float.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeFloat</span><span class="params">(<span class="keyword">float</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write double.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write string.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write byte array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write byte array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v   value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> off offset.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len length.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] v, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flush buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DataOutput 接口中定义了用于序列化 Java 中各种基本数据类型的方法。</p><h3 id="ObjectOutput-接口"><a href="#ObjectOutput-接口" class="headerlink" title="ObjectOutput 接口"></a>ObjectOutput 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectOutput</span> <span class="keyword">extends</span> <span class="title">DataOutput</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * write object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承 DataOutput 接口，在DataOutput 的基础上增加序列化对象的能力。</p><h3 id="InputStream-接口"><a href="#InputStream-接口" class="headerlink" title="InputStream 接口"></a>InputStream 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataInput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read boolean.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read byte.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read short integer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> short.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read integer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> integer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read long.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read float.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> float.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read double.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> double.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read UTF-8 string.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read byte array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte array.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">byte</span>[] readBytes() <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputStream 接口中定义了反序列化 Java 中各种化基本类型的数据。</p><h3 id="ObjectInput-接口"><a href="#ObjectInput-接口" class="headerlink" title="ObjectInput 接口"></a>ObjectInput 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectInput</span> <span class="keyword">extends</span> <span class="title">DataInput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * read object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * read object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cls object type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * read object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cls object type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls, Type type)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承 DataInput 接口，在DataInput 的基础上增加了反序列化对象的能力。</p><h3 id="Cleanable"><a href="#Cleanable" class="headerlink" title="Cleanable"></a>Cleanable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cleanable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成序列化或反序列化需要做清理工作，通过实现该接口释放资源，目前 Kryo 实现。</p><h3 id="序列化优化器"><a href="#序列化优化器" class="headerlink" title="序列化优化器"></a>序列化优化器</h3><h4 id="SerializationOptimizer-接口"><a href="#SerializationOptimizer-接口" class="headerlink" title="SerializationOptimizer 接口"></a>SerializationOptimizer 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用文件也是一个选择，这个类可以替换为配置文件中的内容，但是类的方式更容易编写</span></span><br><span class="line"><span class="comment"> * This class can be replaced with the contents in config file, but for now I think the class is easier to write</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SerializationOptimizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回需要使用优化的类的集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Collection&lt;Class&gt; <span class="title">getSerializableClasses</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Kryo、FST 序列化实现中，支持配置需要优化的类。可以实现自定义的SerializationOptimizer实现，配置需要优化的类，让Kryo和FST完全发挥出高性能。序列化优化器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationOptimizerImpl</span> <span class="keyword">implements</span> <span class="title">SerializationOptimizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Class&gt; <span class="title">getSerializableClasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Class&gt; classes = <span class="keyword">new</span> LinkedList&lt;Class&gt;();</span><br><span class="line">        classes.add(BidRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        classes.add(BidResponse<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        classes.add(Device<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        classes.add(Geo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        classes.add(Impression<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        classes.add(SeatBid<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo 已经自动将 JDK 中常用的类进行了注册，不要重复注册，即使重复注册也没又任何影响。由于注册被序列化的类仅仅是出于性能优化的目的，所以即使忘记注册某些类也没有关系。事实上，即使不注册任何类，Kryo和FST的性能依然普遍优于hessian和dubbo序列化。</p><h4 id="序列化类的注册表"><a href="#序列化类的注册表" class="headerlink" title="序列化类的注册表"></a>序列化类的注册表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableClassRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要序列化优化的类的注册表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Class&gt; registrations = <span class="keyword">new</span> LinkedHashSet&lt;Class&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * only supposed to be called at startup time</span></span><br><span class="line"><span class="comment">     * 在 &#123;<span class="doctag">@link</span> SerializationOptimizer#getSerializableClasses()&#125; 方法获得的类集合，会注册到这里。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerClass</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        registrations.add(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得序列化优化类集合。在 Kryo,FST中调用该方法会获得需要优化的类的集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&gt; <span class="title">getRegisteredClasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registrations;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要序列化优化的类都会注册到该类中进行缓存。</p><h4 id="序列化优化器的使用"><a href="#序列化优化器的使用" class="headerlink" title="序列化优化器的使用"></a>序列化优化器的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">--- DubboProtocol</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">optimizeSerialization</span><span class="params">(URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 获得 optimizer 序列化优化器 配置项</span></span><br><span class="line">        String className = url.getParameter(Constants.OPTIMIZER_KEY, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果系统中没有序列化优化器就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(className) || optimizers.contains(className)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"Optimizing the serialization process for Kryo, FST, etc..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据 序列化优化器名 加载 SerializationOptimizer 实现类</span></span><br><span class="line">            Class clazz = Thread.currentThread().getContextClassLoader().loadClass(className);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否是SerializationOptimizer的子</span></span><br><span class="line">            <span class="keyword">if</span> (!SerializationOptimizer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"The serialization optimizer "</span> + className + <span class="string">" isn't an instance of "</span> + SerializationOptimizer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反射创建 SerializationOptimizer 对象</span></span><br><span class="line">            SerializationOptimizer optimizer = (SerializationOptimizer) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有要优化的类直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (optimizer.getSerializableClasses() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将要优化的类注册到 SerializableClassRegistry 注册表中</span></span><br><span class="line">            <span class="keyword">for</span> (Class c : optimizer.getSerializableClasses()) &#123;</span><br><span class="line">                SerializableClassRegistry.registerClass(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 序列化优化器实现类名 加入到缓存中</span></span><br><span class="line">            optimizers.add(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Cannot find the serialization optimizer class: "</span> + className, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Cannot instantiate the serialization optimizer class: "</span> + className, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Cannot instantiate the serialization optimizer class: "</span> + className, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章主要介绍了序列化层的抽象API，序列化实现具体的职能是由其 serialize 方法创建的<strong>ObjectOutput</strong>和 deserialize 方法创建的<strong>ObjectInput</strong>来完成的，而这两个对象又是对 OutputStream 和 InputStream 的封装。还介绍了序列化优化器，它是用来支持序列化实现对指定的序列化类进行序列化优化处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Dubbo 的服务暴露、服务引用以及服务调用除了需要之前介绍的配置、代理、注册中心，还需要协议、网络通信、集群容错、序列化等。因此，从本文开
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 动态代理本地存根</title>
    <link href="https://gentryhuang.com/posts/1663a5dc/"/>
    <id>https://gentryhuang.com/posts/1663a5dc/</id>
    <published>2020-05-01T16:00:00.000Z</published>
    <updated>2020-10-01T15:06:29.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="http://localhost:4000/posts/1d1e42a8/" target="_blank" rel="noopener">动态代理总览</a> 中已经介绍了抽象层及使用方式，本篇文章介绍动态代理Wrapper StubProxyFactoryWrapper 。</p><h2 id="Wrapper-类"><a href="#Wrapper-类" class="headerlink" title="Wrapper 类"></a>Wrapper 类</h2><p>在 <a href="https://gentryhuang.com/posts/5d81f464/">Dubbo SPI</a> 中已经详细介绍了什么是 Wrapper 类以及 Wrapper 类的作用和用法。StubProxyFactoryWrapper 会在 ProxyFactory 实现执行前先执行。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StubProxyFactoryWrapper</span> <span class="keyword">implements</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(StubProxyFactoryWrapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ProxyFactory$Adaptive 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProxyFactory proxyFactory;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Protocol$Adaptive 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * StubProxyFactoryWrapper 基于 Dubbo SPI Wrapper 机制，根据URL配置，使用具体的实现【JavassistProxyFactory/JdkProxyFactory】</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxyFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StubProxyFactoryWrapper</span><span class="params">(ProxyFactory proxyFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxyFactory = proxyFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StubProxyFactoryWrapper 是 ProxyFactory 的 Wrapper 类，同时它又是实现 Dubbo 动态代理本地存根的类，我们继续往下看。</p><h2 id="动态代理本地存根"><a href="#动态代理本地存根" class="headerlink" title="动态代理本地存根"></a>动态代理本地存根</h2><h3 id="获取代理"><a href="#获取代理" class="headerlink" title="获取代理"></a>获取代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StubProxyFactoryWrapper</span> <span class="keyword">implements</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取代理对象【使用JavassistProxyFactory/JdkProxyFactory】</span></span><br><span class="line">        T proxy = proxyFactory.getProxy(invoker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非泛化 【泛化不支持使用本地存根】</span></span><br><span class="line">        <span class="keyword">if</span> (GenericService<span class="class">.<span class="keyword">class</span> !</span>= invoker.getInterface()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得 `stub` 配置项 ，注意，local 配置项，和 stub 配置项是等价的，目前使用 stub 而不使用 local 。</span></span><br><span class="line">            String stub = invoker.getUrl().getParameter(Constants.STUB_KEY, invoker.getUrl().getParameter(Constants.LOCAL_KEY));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 服务引用有配置本地存根</span></span><br><span class="line">            <span class="keyword">if</span> (ConfigUtils.isNotEmpty(stub)) &#123;</span><br><span class="line">                Class&lt;?&gt; serviceType = invoker.getInterface();</span><br><span class="line">                <span class="comment">// `stub = true` 的时，使用 接口 + `Stub` 作为存根类的类名</span></span><br><span class="line">                <span class="keyword">if</span> (ConfigUtils.isDefault(stub)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (invoker.getUrl().hasParameter(Constants.STUB_KEY)) &#123;</span><br><span class="line">                        stub = serviceType.getName() + <span class="string">"Stub"</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        stub = serviceType.getName() + <span class="string">"Local"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 反射获取本地存根类</span></span><br><span class="line">                    Class&lt;?&gt; stubClass = ReflectUtils.forName(stub);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 本地存根类必须是实现服务接口</span></span><br><span class="line">                    <span class="keyword">if</span> (!serviceType.isAssignableFrom(stubClass)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The stub implementation class "</span> + stubClass.getName() + <span class="string">" not implement interface "</span> + serviceType.getName());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 反射获取 Stub 的有参构造方法，参数类型是服务类型</span></span><br><span class="line">                        Constructor&lt;?&gt; constructor = ReflectUtils.findConstructor(stubClass, serviceType);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 反射创建本地对象，构造参数需要是服务接口类型对象</span></span><br><span class="line">                        proxy = (T) constructor.newInstance(<span class="keyword">new</span> Object[]&#123;proxy&#125;);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//设置了 Stub 参数回调就需要暴露 Stub 服务 </span></span><br><span class="line">                        URL url = invoker.getUrl();</span><br><span class="line">                        <span class="keyword">if</span> (url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT)) &#123;</span><br><span class="line">                            url = url.addParameter(Constants.STUB_EVENT_METHODS_KEY, StringUtils.join(Wrapper.getWrapper(proxy.getClass()).getDeclaredMethodNames(), <span class="string">","</span>));</span><br><span class="line">                            url = url.addParameter(Constants.IS_SERVER_KEY, Boolean.FALSE.toString());</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 暴露 Stub 服务</span></span><br><span class="line">                                export(proxy, (Class) invoker.getInterface(), url);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                LOGGER.error(<span class="string">"export a stub service error."</span>, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such constructor \"public "</span> + stubClass.getSimpleName() + <span class="string">"("</span> + serviceType.getName() + <span class="string">")\" in stub implementation class "</span> + stubClass.getName(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    LOGGER.error(<span class="string">"Failed to create stub implementation class "</span> + stub + <span class="string">" in consumer "</span> + NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">                    <span class="comment">// ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取-Invoker"><a href="#获取-Invoker" class="headerlink" title="获取 Invoker"></a>获取 Invoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StubProxyFactoryWrapper</span> <span class="keyword">implements</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 服务对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 服务接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getInvoker(proxy, type, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，服务提供方不支持 Stub 本地存根，即使 &lt;dubbo:service /&gt; 有 stub 配置项，实际是不起作用的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>StubProxyFactoryWrapper 功能比较简单，基本流程如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-proxy-wrapper.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;http://localhost:4000/posts/1d1e42a8/&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - JDK动态代理</title>
    <link href="https://gentryhuang.com/posts/faa2b4a3/"/>
    <id>https://gentryhuang.com/posts/faa2b4a3/</id>
    <published>2020-04-30T16:00:00.000Z</published>
    <updated>2020-10-01T15:09:02.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="http://localhost:4000/posts/1d1e42a8/" target="_blank" rel="noopener">动态代理总览</a> 中已经介绍了抽象层，本篇文章介绍 JdkProxyFactory 。</p><h2 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">proxy</span>=<span class="string">"jdk"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">proxy</span>=<span class="string">"jdk"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JDK-代理工厂"><a href="#JDK-代理工厂" class="headerlink" title="JDK 代理工厂"></a>JDK 代理工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker    invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces 服务实现的接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                interfaces,</span><br><span class="line">                <span class="keyword">new</span> InvokerInvocationHandler(invoker)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 服务对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type  服务接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url   URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 调用 Class#getMethod(String name, Class&lt;?&gt;... parameterTypes) 方法，反射获得方法。</span></span><br><span class="line">                Method method = proxy.getClass().getMethod(methodName, parameterTypes);</span><br><span class="line">                <span class="comment">// 调用 Method#invoke(proxy, arguments) 方法，执行方法</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(proxy, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取代理对象"><a href="#获取代理对象" class="headerlink" title="获取代理对象"></a>获取代理对象</h3><p>JDK 获取代理的方式很简单，不依赖三方依赖，直接使用 JDK 的动态代理为服务接口创建一个代理对象，其中 InvokerInvocationHandler 同 JavassistProxyFactory 。</p><h3 id="获取-Invoker"><a href="#获取-Invoker" class="headerlink" title="获取 Invoker"></a>获取 Invoker</h3><p>JDK 获取 Invoker 同样是创建 AbstractProxyInvoker 的匿名对象，不过在 doInvoke 方法中是直接通过反射拿到实现类的Method对象，然后执行对应的方法，非常清爽。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Dubbo 使用 JDK 实现动态非常简单，并且不需要依赖三个依赖，直接一个反射就解决了所有问题，就是性能上有所不足。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;http://localhost:4000/posts/1d1e42a8/&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="JDK" scheme="https://gentryhuang.com/tags/JDK/"/>
    
  </entry>
  
</feed>
