<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gentryhuang‘s blog</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gentryhuang.com/"/>
  <updated>2021-08-30T12:56:09.525Z</updated>
  <id>https://gentryhuang.com/</id>
  
  <author>
    <name>gentryhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发 - ThreadLocal</title>
    <link href="https://gentryhuang.com/posts/151f44ae/"/>
    <id>https://gentryhuang.com/posts/151f44ae/</id>
    <published>2021-08-21T04:30:12.000Z</published>
    <updated>2021-08-30T12:56:09.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ThreadLocal 提供了线程局部变量，它是将线程需要访问的数据存储在线程对象自身中，从而避免多线程的数据竞争问题。ThreadLocal 实现原理如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-struct.png" alt></p><p>理解 ThreadLocal 原理，其实就是理解 <strong>Thread</strong>、<strong>ThreadLocal</strong> 以及 <strong>ThreadLocalMap</strong> 三者之间的关系。线程类 Thread 内部持有 ThreadLocalMap 的成员变量，而 ThreadLocalMap 是 ThreadLocal 的内部类，ThreadLocal 对外暴露操作数据的 API 都是操作 ThreadLocalMap 中的数据。总得来说，线程 Thread 在向 ThreadLocal 中设置值时，其实都是向自己所持有的 ThreadLocalMap 中设置数据；读的时候同理，先是从线程自己中取出持有的 ThreadLocalMap ，然后再根据 ThreadLocal 引用作为 key 取出对应的元素进而取出 value 。因此 ThreadLocal 可以轻松实现变量的线程隔离，毕竟变量都是从各个线程中取的，自然没有竞争。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 与此线程相关的 ThreadLocal 值，这个映射由 ThreadLocal 类维护 */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 与此线程相关的 InheritableThreadLocal 值。这个映射由 InheritableThreadLocal 类维护。*/</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread 中维护了两个 ThreadLocalMap 类型的变量，<code>threadLocals</code> 用于存储当前线程使用的 ThreadLocal 相关信息；<code>inheritableThreadLocals</code> 用于存储当前线程使用的 InheritableThreadLocal 相关信息。使用 InheritableThreadLocal 可以实现多个线程访问 ThreadLocal 的值，即父线程中创建一个 InheritableThreadLocal 的实例，然后在子线程中就可以得到这个 InheritableThreadLocal 中设置的值。关于共享线程的 ThreadLocal 数据将在下面的内容中分析。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal 相关的 UML 类图如下所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-uml.jpg" alt></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1 作为 ThreadLocal 实例的变量，私有、不可变。每当创建 ThreadLocal 时这个值都会累加 HASH_INCREMENT</span></span><br><span class="line"><span class="comment">    * 2 主要为了多个 ThreadLocal 实例的情况下，让哈希码能均匀的分布在2的N次方的数组里, 即 Entry[] table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二进制：-10011110001101110111100110111001</span></span><br><span class="line"><span class="comment">    * 十进制：-2654435769</span></span><br><span class="line"><span class="comment">    * 说明：</span></span><br><span class="line"><span class="comment">    * 1 Entry[] table 的大小必须是 2^N，那 len-1 的二进制表示就是低位连续的N个1，</span></span><br><span class="line"><span class="comment">    * 2 key.threadLocalHashCode &amp; (len-1) 的值就是 threadLocalHashCode 的低 N 位</span></span><br><span class="line"><span class="comment">    * 3 因此要求 threadLocalHashCode 的值要均匀</span></span><br><span class="line"><span class="comment">    * 原因：</span></span><br><span class="line"><span class="comment">    * 取该值与fibonacci hashing(斐波那契散列法)以及黄金分割有关，目的就是为了让哈希码能均匀的分布在2的n次方的数组里, 也就是Entry[] table中。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 作为 ThreadLocal 类变量</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * 基于当前 ThreadLocal ，下一个要给出的哈希码，自动更新，从 0 开始计数。</span></span><br><span class="line"><span class="comment">    * 每次获取当前值并加上固定的 HASH_INCREMENT</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回下一个 ThreadLocal 的 hash</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal 主要属性如上，分为两类。一类是 ThreadLocal 实例变量，另一类是 ThreadLocal 类变量。其中类变量在 ThreadLocal 类加载过程就进行初始化，也就是 <code>nextHashCode</code> 的初始化，后续实例变量 <code>threadLocalHashCode</code> 随着对象的创建而调用 <code>nextHashCode</code> 方法进行赋值，可以看出每次递增为 <strong>HASH_INCREMENT</strong> ，至于为什么选择这个值，是和斐波那契散列法以及黄金分割有关，目的就是为了让哈希码能均匀的分布在 2^n 次方的数组里，这个和 HashMap 中 hash 实现目的是一致的。</p><h3 id="Set-方法"><a href="#Set-方法" class="headerlink" title="Set 方法"></a>Set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置当前线程变量的值 value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 根据当前线程获取其成员变量 threadLocals 所指向的 ThreadLocalMap 对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 判断当前线程的 ThreadLocalMap 是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 3.1 如果不为空，说明当前线程内部已经有ThreadLocalMap对象了</span></span><br><span class="line">            <span class="comment">// 那么直接将当前对应的 ThreadLocal 对象的引用作为键，存入的 value 作为值存储到 ThreadLocalMap 中</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 3.2 创建一个 ThreadLocalMap 对象并将值存入到该对象中，并赋值给当前线程的threadLocals成员变量</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>ThreadLocal 中的增、删、查方法主要有三个步骤，下面对 Set 方法进行小结:</strong></p><ul><li>获取当前线程</li><li>根据当前线程获取其持有的 ThreadLocalMap 映射表</li><li>操作映射表 ThreadLocalMap ，如果映射表存在就调用映射表的 set 方法放入数据，映射表不存在则先创建映射表再放入数据</li></ul><h3 id="Get-方法"><a href="#Get-方法" class="headerlink" title="Get 方法"></a>Get 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程的线程副本变量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 根据当前线程获取其 ThreadLocalMap 实例</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 如果当前线程的 ThreadLocalMap 不为空</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T) e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 如果当前线程的 ThreadLocalMap 为空或 ThreadLocalMap 中没有当前 ThreadLocal 对应的元素，则调用 initialValue() 方法初始化值</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>下面对 Set 方法进行小结:</strong></p><ul><li>获取当前线程</li><li>根据当前线程获取其持有的 ThreadLocalMap 映射表</li><li>操作映射表 ThreadLocalMap ，如果映射表存在就调用映射表的 getEntry 方法查询数据；映射表不存在或从映射表中没有找到当前 ThreadLocal 对应的元素，则调用 setInitialValue 方法完成映射表的创建或初始值的获取</li></ul><p><strong>其中 setInitialValue 方法如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置初始化值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 调用 initialValue() 方法获取指定的初始化值，默认为 null</span></span><br><span class="line">        T value = initialValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取当前线程的 ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 如果 ThreadLocalMap 不为空，则直接将初始值设置到 ThreadLocalMap 中</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 如果 ThreadLocalMap 为空，则创建 ThreadLocalMap 对象，并设置初始值</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化值，子类覆盖</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="createMap-方法"><a href="#createMap-方法" class="headerlink" title="createMap 方法"></a>createMap 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为线程 t 初始化 ThreadLocalMap 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t          当前线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>线程中的 ThreadLocalMap 使用的是延迟初始化，第一次调用 get() 或者 set() 方法的时候才会进行初始化，即调用上述方法完成初始化。</p><h3 id="getMap-方法"><a href="#getMap-方法" class="headerlink" title="getMap 方法"></a>getMap 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">// 返回线程 t 的 threadLocals</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述方法用于获取每个线程持有自己的 ThreadLocalMap 实例，因此它们是不存在并发竞争的，这也就是我们说的每个线程有自己的变量副本。</p><h3 id="Remove-方法"><a href="#Remove-方法" class="headerlink" title="Remove 方法"></a>Remove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程持有的 ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 删除 ThreadLocalMap 中当前 ThreadLocal 相关的信息</span></span><br><span class="line">        <span class="comment">// 包括清理对应的引用和值</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">            m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>下面对 Remove 方法进行小结:</strong></p><ul><li>获取当前线程</li><li>根据当前线程获取其持有的 ThreadLocalMap 映射表</li><li>操作映射表 ThreadLocalMap ，如果映射表存在就调用映射表的 remove 方法根据当前 ThreadLocal 清理对应 Entry </li></ul><p>至此，ThreadLocal 暴露的相关方法已经分析完毕，但是这只是 ThreadLocal 源码分析的开始。ThreadLocal 中并没有对于 ThreadLocalMap 的引用，该引用是在 Thread 类中。此外，ThreadLocal 暴露的 API 操作都是基于 ThreadLocalMap 的。因此，我们理解了 ThreadLocalMap 才算是掌握了 ThreadLocal 。下面我们重点对 ThreadLocalMap 进行分析。</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，本质上是一个 Map ，和 HashMap 类似，依然是 key-value 的形式，具体由 Entry 结构封装。</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储数据的 Entry 数组，长度是 2 的幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中元素的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组扩容阈值，默认为0，创建了 ThreadLocalMap 对象后会被重新设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置调整大小阈值，以保持在最坏 2/3 的负载因子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ThreadLocalMap使用 开放地址法-线性探测法 来解决哈希冲突 */</span></span><br><span class="line"><span class="comment">// 向后一个位置找，注意从头开始的情况</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向前一个位置找，注意跳到尾部的情况</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体属性类似 HashMap ，各个值的含义已经详细注释就不再说明。需要注意的是，由于 ThreadLocalMap 使用的是线性探测法解决 hash 冲突，因此定义向前和向后探测的方法以便于寻找合适的位置及定位元素。</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 与这个ThreadLocal关联的值，也就是线程局部变量缓存值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Entry的 key 是对 ThreadLocal 的弱引用，当抛弃掉 ThreadLocal 对象时，垃圾收集器会忽略这个 key 的引用而清理掉 ThreadLocal 对象，放置内存泄漏。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一个线程可以使用不同的 ThreadLocal 将不同的值存储在当前线程的 ThreadLocalMap 中。熟悉 HashMap 存储结构的可以发现，ThreadLocalMap 中的存储结构有两大不同点：</p><ul><li>没有链表相关的指针，更没有树节点的左右链接</li><li>元素节点结构 Entry 继承了 <code>WeakReference</code> 类，以实现弱引用功能</li></ul><p>作为一个映射表，必然会有元素冲突的可能，因为没有 HashMap 中链表和树形结构，那么 ThreadLocalMap 是怎么解决 hash 冲突的呢？答案是<strong>线性探测法</strong>。Entry 继承 <code>WeakReference</code> 的原因我们在后面的文章中进行分析。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 懒加载构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstKey   ThreadLocal 引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue 设置的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="comment">// 1 初始化 Entry 数组，大小为 16</span></span><br><span class="line">        table = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry[INITIAL_CAPACITY];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取 ThreadLocal 的 hash 值(该值是累加的)</span></span><br><span class="line">        <span class="comment">// 计算当前 key 对应的数组下标位置， 和 HashMap 的位运算代替取模原理一样</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 将 Entry 对象存入到数组指定的位置</span></span><br><span class="line">        table[i] = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(firstKey, firstValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 记录数组元素个数</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 初始化扩容阈值</span></span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当线程 Thread 持有的 ThreadLocalMap 还没有初始化时，在使用 ThreadLocal 存储或获取数据时都会先创建一个 ThreadLocalMap 对象然后挂载到当前线程 Thread 上，后续不管该线程 Thread 使用了多少个 ThreadLocal ，都会使用创建的 ThreadLocalMap 进行储存相应值。</p><p>了解了 ThreadLocalMap 的底层数据结构后，下面我们依然从它的核心操作方法出发分析底层实现。</p><h3 id="getEntry-方法"><a href="#getEntry-方法" class="headerlink" title="getEntry 方法"></a>getEntry 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取与 key 关联的 Entry</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 根据 key 计算下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 根据下标获取 Entry</span></span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 通过下标直接得到的 Entry 不是要找的，那么就线性探测找</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>获取线程局部变量值的 getEntry 方法是 ThreadLocal 暴露的 get() 方法的底层实现，它的主要流程如下：</p><ul><li>根据 ThreadLocal 引用计算对应的数组下标，这个和 HashMap 类似</li><li>根据计算得到的下标尝试直接获取对应的 Entry，如果当前 Entry 为空或对应的 key 不是当前传入的 key ，那么进行线性探测获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * getEntry方法的版本，用于在键未在其直接散列槽中找到时使用。</span></span><br><span class="line"><span class="comment">         * 注意，该方法会清理无效 Entry</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i   the table index for key's hash code</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e   the entry at table[i]</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 线性探测</span></span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取 Entry 的 key</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.1 命中，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (k == key)</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="comment">// 2.2 无效 Entry，执行连续段删除</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.3 获取下个位置</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3 遍历完也没查到，返回 null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>之所以要进行线性探测获取和链表查询一样，可能目标元素由于 hash 冲突放到了后续位置。<strong>注意：查询流程也就是 get() 方法也会及时清理无效的元素，防止了内存泄漏</strong>。关于连续段清理无效元素逻辑暂略过。</p><h3 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置与 key 关联的值</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * ThreadLocal 的 set 方法，就是为了将指定的值存入到指定线程的 ThreadLocalMap 对象中，具体还是通过 ThreadLocalMap 的 set 方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key   the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 获取数组信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 计算当前 ThreadLocal 对象引用作为键在数组中的下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 根据获取到的下标进行线性探测，寻找空的位置。</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1 获取当前 Entry 中的 key ，即 ThreadLocal 的引用，注意是弱引用。</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 判断和当前的 ThreadLocal 对象是否是同一个对象，如果是，那么直接进行值替换，并结束方法，</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.3 判断当前 Entry 的 key 是否失效，即是否被回收（弱引用）。</span></span><br><span class="line">                <span class="comment">// 如果失效，说明当前位置可以重新使用，就使用新的 key-value 将其替换</span></span><br><span class="line">                <span class="comment">// 该过程还会删除其它无效的 entry</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 找到某个空位置，直接将键值对设置到这个位置上。</span></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 尝试清理无效 entry ，如果没有可清理的 entry 且数组元素大小 &gt;= 扩容阈值，则进行 rehash</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>设置线程局部变量值的 set 方法稍微复杂点，下面对其主要流程进行说明：</strong></p><ol><li>根据传入的 key 计算数组下标位置</li><li>根据计算得到的下标进行线性探测，寻找空的位置以存放元素<ul><li>检测到存在相同 key 的元素，进行值覆盖，然后结束流程即可</li><li>检测到无效的元素，则重用无效元素位置，并尝试清理无效的元素</li><li>在某个空位置存放数据</li></ul></li><li>如果不是值覆盖或重用无效元素位置的情况，那么需要判断是否需要 rehash  </li></ol><p>下面我们对上述核心方法进行拆解分析。</p><h4 id="重用无效元素位置"><a href="#重用无效元素位置" class="headerlink" title="重用无效元素位置"></a>重用无效元素位置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 替换无效 Entry ，并尝试删除其它无效的 Entry。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> staleSlot 无效 entry 的位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取数组信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            Entry e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标志 Table 中是否存在无效 Entry。slotToExpunge != staleSlot 说明 table 中存在无效 Entry 需要进行清理，否则说明没有。</span></span><br><span class="line">            <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 根据传入的无效 Entry 的位置 staleSlot 向前扫描一段连续非空的 Entry ，并记录最后一个无效的 Entry 的位置。或者扫描完也没有找到。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; i = prevIndex(i, len))</span><br><span class="line">                <span class="comment">// 2.1 如果是无效 Entry ，则更新删除标记 slotToExpunge</span></span><br><span class="line">                <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 根据传入的无效 Entry 向后扫描一段连续的 Entry ,以寻找是否有相同 key 的 Entry，以及在需要时更新删除标记位 slotToExpunge</span></span><br><span class="line">            <span class="comment">// 找到运行的关键字或末尾的空槽，以最先出现的为准</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1 获取当前 Entry 的 key</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 如果找到了具有相同的 key ，则更新其值。也就是更新其值并将其与传入的无效 Entry 替换，即与 table[staleSlot] 进行替换</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    <span class="comment">// 3.2.1 更新为传入的 value</span></span><br><span class="line">                    e.value = value;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.2.2 使用相同 key 的 Entry 重用失效位置以避免新创建一个 Entry，以维持散列表的顺序。</span></span><br><span class="line">                    tab[i] = tab[staleSlot];</span><br><span class="line">                    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.2.3 如果向前查找没有找到无效的 Entry，则更新删除标记位 slotToExpunge 为当前位置 i，此时 i 位置对应的是无效 Entry</span></span><br><span class="line">                    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                        slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.3.4 将新过时的槽或在其上面遇到的任何其他过时槽发送到expungeStaleEntry，以删除或重新散列运行中的所有其他条目。</span></span><br><span class="line">                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果向前查找没有找到无效 entry，并且当前向后扫描的entry无效，则更新 slotToExpunge 为当前值 i</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 执行到这里，说明 table 中不存在相同 key 的 Entry，此时只需直接重用无效位置即可</span></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 slotToExpunge != staleSlot 说明 table 中存在无效 Entry 需要进行清理</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>重用无效 Entry 位置有两种可能：</strong></p><ul><li>如果扫描的 Table 中存在和要插入的 key 相同的 Entry，那么就使用更新 value 后的该 Entry 替换无效 Entry 以避免新创建 Entry，同时该 Entry 成为了无效 Entry，只需等待后续删除即可。</li><li>如果扫描的 Table 中不存在和要插入的 key 相同的 Entry ，那么直接创建 Entry 替换无效 Entry 即可。</li></ul><p>此外，上述方法还会对无效 Entry 进行清理，触发条件就是检测到其它无效 Entry 的存在。</p><h4 id="rehash-操作"><a href="#rehash-操作" class="headerlink" title="rehash 操作"></a>rehash 操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * rehash 操作</span></span><br><span class="line"><span class="comment">         * 1 扫描整个 Table ，删除无效的 Entry</span></span><br><span class="line"><span class="comment">         * 2 执行清理后，如果还需要扩容，则将表扩大一倍</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 清理所有无效 Entry</span></span><br><span class="line">            expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  2 threshold - threshold / 4 = 1en / 2，降低扩容阈值是因为上面做了一次全清理所以 size 可能会减小</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Table 容量扩大为原来 2 倍</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] oldTab = table;</span><br><span class="line">            <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 容量扩大为原来 2 倍</span></span><br><span class="line">            <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">            Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 重新映射旧数组中的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">                Entry e = oldTab[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 清理无效 Entry</span></span><br><span class="line">                    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 线性探测重新设置值</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, newLen);</span><br><span class="line">                        newTab[h] = e;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 设置新的阈值</span></span><br><span class="line">            setThreshold(newLen);</span><br><span class="line">            size = count;</span><br><span class="line">            table = newTab;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>新增数据后，如果达到阈值就会触发 rehash 流程，进行数组扩容和数据重新映射，这个没什么可说的。</p><h3 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 计算 key 对应的下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 进行线性探测，查找正确的 Entry</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 找到对应的 Entry</span></span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    <span class="comment">// 调用 WeakReference.clear() 方法清除对应的引用</span></span><br><span class="line">                    e.clear();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 连续段删除 Entry</span></span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上述方法是 ThreadLocal 暴露的 remove() 方法的底层实现，用来清理当前 ThreadLocal 关联的信息。具体清理信息如下：</p><ul><li>清除对当前 ThreadLocal 的弱引用</li><li>清除当前 ThreadLcoal 对应的 Entry 中的 value </li><li>清除当前 ThreadLocal 对应的 Entry </li></ul><h3 id="expungeStaleEntry-方法"><a href="#expungeStaleEntry-方法" class="headerlink" title="expungeStaleEntry 方法"></a>expungeStaleEntry 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除过期的元素，是连续段删除</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 清理 staleSlot 位置的无效 Entry ，并递减元素个数</span></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">            Entry e;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 从 stateSlot 开始向后扫描一段连续的非空的 Entry</span></span><br><span class="line">            <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1 获取当前 Entry 的 k</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 如果遇到key为null,表示无效entry，进行清理.</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    e.value = <span class="keyword">null</span>;</span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                    size--;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.3 如果 key 不为 null ，则对可能存在 hash 冲突的 Entry 进行 rehash</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 计算 key 对应的下标，如果与现在所在位置不一致，认为存在 hash 冲突，置空当前 table[i] ，</span></span><br><span class="line">                    <span class="comment">// 并从 h 开始向后线性探测到第一个空的 slot，把当前的 entry 移动过去。</span></span><br><span class="line">                    <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                        tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                        <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                        <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        tab[h] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下一个为空的下标</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上述方法用于删除过期的元素，具体删除策略如下：</p><ul><li>根据传入的 stateSlot 清理对应的无效 Entry</li><li>根据传入的 stateSlot 向后扫描一段连续非空的 Entry ，对可能存在 hash 冲突的 Entry 进行 rehash ，并且清理遇到的无效 Entry</li></ul><h3 id="expungeStaleEntries-方法"><a href="#expungeStaleEntries-方法" class="headerlink" title="expungeStaleEntries 方法"></a>expungeStaleEntries 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扫描整个 Table ，删除无效的 Entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="comment">// 无效 Entry ，则调用 expungeStaleEntry 方法删除对应位置及连坐删除 Entry</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是在 expungeStaleEntry 方法的基础上，对整个 Table 中无效元素进行清理。</p><h3 id="cleanSomeSlots-方法"><a href="#cleanSomeSlots-方法" class="headerlink" title="cleanSomeSlots 方法"></a>cleanSomeSlots 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 启发式的扫描清除，扫描次数由传入的参数n决定</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i 从i向后开始扫描（不包括i，因为索引为i的Slot肯定为null）</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> n  控制扫描次数，正常情况下为 log2(n) ，如果找到了无效 Entry ，会将 n 重置为 table 的长度 len 进行阶段删除</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> true if any stale entries have been removed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 删除标志</span></span><br><span class="line">            <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 数组信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 i 位置向后遍历，删除无效的 Entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">                Entry e = tab[i];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果当前 Entry 无效，则进行清理并进行连坐</span></span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    n = len;</span><br><span class="line">                    removed = <span class="keyword">true</span>;</span><br><span class="line">                    i = expungeStaleEntry(i);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 无符号的右移动，可以用于控制扫描次数在log2(n)</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> removed;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>启发式扫描删除具有随机性，启发式思想也用在其他代码中，如 Redis 中的定期删除逻辑。</p><p>自此，ThreadLocalMap 的源码实现分析完毕。</p><h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><p>共享线程的 ThreadLocal 数据可以使用 <strong>InheritableThreadLocal</strong> 来实现。可以通过在父线程中创建一个 <strong>InheritableThreadLocal</strong> 的实例，然后在子线程中就可以获取该实例中设置的值。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 创建 InheritableThreadLocal 对象</span></span><br><span class="line">    ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 创建的 ThreadLocalMap 挂载到当前 Thread 的 inheritableThreadLocals 属性</span></span><br><span class="line">    threadLocal.set(<span class="string">"小芒果!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 创建并启动子线程</span></span><br><span class="line">    Runnable runnable = () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 打印子线程 ThreadLocal 的线程变量值</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt; "</span> + threadLocal.get());</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印父线程（这里是主线程） ThreadLocal 的线程变量值</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt; "</span> + threadLocal.get());</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main-&gt; 小芒果!</span><br><span class="line">Thread-0-&gt; 小芒果!</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>线程变量传递逻辑很简单，它隐藏在 Thread 的 init 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- Thread</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">        init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 获取初始化当前线程的线程</span></span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果 parent 线程使用了 InheritableThreadLocal ，那么就把 parent 的 inheritableThreadLocals 给当前线程的 inheritableThreadLocals 。</span></span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 设置到当前线程的 inheritableThreadLocals 属性中</span></span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">        <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set thread ID */</span></span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从线程初始化逻辑中可以看出，如果父线程 ThreadLocalMap 类型的变量 <code>inheritableThreadLocals</code> 不为空，那么就把父线程的该属性设置给当前线程的 <code>inheritableThreadLocals</code> 属性。具体设置逻辑在 ThreadLocal 的 createInheritedMap 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">// 继承式创建 ThreadLocal</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅由 createInheritedMap 方法调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocal.ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取 parentMap 的 Table 信息</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">        setThreshold(len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建新的 Table</span></span><br><span class="line">        table = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 将 parentMap 中的数据依次映射到新创建的 Table 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">// 3.1 获取当前 Entry</span></span><br><span class="line">            ThreadLocal.ThreadLocalMap.Entry e = parentTable[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 获取 Entry 中的 key</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.3 Entry 有效的话就进行映射</span></span><br><span class="line">                <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 用于获取父线程变量值的转换，默认就是父线程 Entry.value 值</span></span><br><span class="line">                    Object value = key.childValue(e.value);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 线性探测存储元素</span></span><br><span class="line">                    ThreadLocal.ThreadLocalMap.Entry c = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(key, value);</span><br><span class="line">                    <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line"></span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过以上逻辑可以发现，如果要使用线程变量共享需要使用到 <strong>InheritableThreadLocal</strong> 类，线程 Thread 的映射属性使用 <code>inheritableThreadLocals</code> 而非 <code>threadLocals</code> 。</p><h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认是 Entry 的 value 值，使用方可继承 InheritableThreadLocal 覆盖该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentValue the parent thread's value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the child thread's initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程 t 的 ThreadLocalMap ，注意取的是 inheritableThreadLocals 属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建当前线程 t 的 ThreadLocalMap ，注意设置的是 inheritableThreadLocals 属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InheritableThreadLocal 继承了 ThreadLocal ，重写了以上三个方法，主要是将映射表挂在到 Thread 的 <code>inheritableThreadLocals</code> 上，用以实现线程变量的共享。注意，线程变量独享使用的是 Thread 中的 <code>threadLocals</code> 属性。InheritableThreadLocal 对比 ThreadLocal 唯一不同是子线程会继承父线程变量，并支持自定义赋值函数。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>ThreadLocalMap 使用 ThreadLocal 的弱引用做为元素的 key ,如果一个 ThreadLocal 没有外部强引用来引用它，那么系统 GC 时这个 ThreadLocal 会被回收。此时，ThreadLocalMap 中就会出现 key == null 的 Entry ，这样就没有办法访问这些 key == null 的 Entry，这些 Entry 理论上属于无效的，应该被 GC 回收。但是，如果存在持有这些 Entry 的线程迟迟不结束（如使用线程池），那么这些 key 为 null 的 Entry.value 就会一直存在一条强引用链 <strong>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</strong>，导致无法回收，造成内存泄漏。</p><p>ThreadLocal 为了尽可能避免内存泄漏问题，在 <code>get()</code>、<code>set()</code> 以及 <code>remove()</code> 方法中都有清除线程中 ThreadLocalMap 里所有 key == null 的 value 逻辑，只有在线性探测流程中才会尝试清理无效 Entry 。<strong>注意，其中 get()、set() 两个方法都不能完全防止内存泄漏，存在无效 Entry 无法扫描到的情况。最好的方式是每次使用完 ThreadLocal 都手动 remove 一下</strong>。</p><p>此外，以下措施并不能保证不会内存泄漏：</p><ul><li>使用 static 的 ThreadLocal ，这种方式延长了 ThreadLocal 的生命周期</li><li>分配使用了 ThreadLocal ，而不再调用其 <code>get()</code>、<code>set()</code> 以及 <code>remove()</code> 方法</li></ul><h2 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h2><ul><li><strong>key 使用强引用：</strong>ThreadLocal 对象没有外部引用，但是 ThreadLocalMap 持有 ThreadLocal 的强引用，如果没有手动删除，ThreadLocal 不会被回收，这会导致 Entry 内存泄漏。</li><li><strong>key 使用弱引用：</strong>ThreadLocal 对象没有外部引用，由于 ThreadLocalMap 持有 ThreadLocal 的弱引用，即使没有手动删除，ThreadLcoal 也可以被回收。value 在下一次执行方法时被清除。 </li></ul><p>Entry 继承 WeakReference，并且使用 ThreadLocal 的弱引用作为 key，这样可以将 ThreadLocal 对象的生命周期和线程生命周期解绑。持有弱引用可以使得 ThreadLocal 在没有其他强引用的时候被回收掉，这样可以避免因为线程得不到销毁导致 ThreadLocal 对象无法被回收。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>每次使用完 ThreadLocal 都应该调用它的 remove() 方法，进行数据清理，防止内存泄漏。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>多线程之间需要拥有同一个信息，那么通常可以采用 <code>initialValue()</code> 方法进行初始化，直接将需要拥有的变量副本存储到 ThreadLocal 中。</li><li>多个线程中存储不同的信息，那么需要使用 set() 方法设置变量副本到 ThreadLocal 中。</li></ul><p>上述描述<strong>存储到 ThreadLocal 中</strong>是不对的，需要注意，数据其实是存储到线程持有的 ThreadLocalMap 对象中，该对象是一个散列表。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 ThreadLocal 进行了深入的分析，它能保证数据安全是因为每个线程都有自己的线程变量，不会发生多个线程共享变量的情况。首先对 ThreadLocal 的关系进行了介绍，从总体上认识 ThreadLocal 。接着对 ThreadLocal 进行了分析，从其属性到暴露的 API 。然后对 ThreadLocal 底层的支持类 ThreadLocalMap 进行了分析，同样从属性到支撑上层的方法的分析。最后对父子线程就 ThreadLocal 如何共享线程变量进行了分析。在文章的最后，对内存泄漏问题进行了介绍。</p><p><strong>参考资料</strong><br><a href="https://www.cnblogs.com/lqlqlq/p/13302901.html" target="_blank" rel="noopener">https://www.cnblogs.com/lqlqlq/p/13302901.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;ThreadLocal 提供了线程局部变量，它是将线程需要访问的数据存储在线程对象自身中，从而避免多线程的数据竞争问题。ThreadLoca
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="Thread" scheme="https://gentryhuang.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Java基础 - Reference</title>
    <link href="https://gentryhuang.com/posts/55ae5a2b/"/>
    <id>https://gentryhuang.com/posts/55ae5a2b/</id>
    <published>2021-08-14T02:30:12.000Z</published>
    <updated>2021-08-30T13:00:54.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在 Java 中有 4 种引用类型，主要是在垃圾回收时 JVM 会根据不同的引用类型采取不同的措施。下面分别对这四种类型进行说明，特别是弱引用，将会结合示例进行分析。</p><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>Java 中的四种引用类型如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/reference/java-reference-uml.jpg" alt></p><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>强引用是 Java 默认的引用类型。如果一个对象具有强引用，当内存空间不足时，JVM 宁可抛出 <strong>OutOfMemoryError</strong> 错误使程序异常终止，也不会回收具有强引用的对象来解决内存不足问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，在一个方法中有一个强引用 <code>object</code> ，该引用保存在栈中，而真正的引用内容 <code>Object</code> 对象保存在堆中。当上述方法运行完成后退出方法栈，强引用 <code>object</code> 就不存在了，引用的 <code>Object</code> 对象就会被回收。 注意，如果 <code>Object object = new Object();</code> 是全局的，那么在不使用该对象时需要设置 <code>object = null</code> 以帮助垃圾收集器回收该对象。</p><p>也就是说，一个对象从根路径能找到强引用指向它，JVM 就不会回收。</p><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>如果一个对象只具有软引用，在内存空间足够的情况下 JVM 就不会回收它；如果内存空间不足就会回收这些对象。更准确地来说，进行 Young GC 不会触发软引用所指向对象的回收；但如果触发Full GC，则软引用所指向的对象将被回收。前提是除了软引用之外没有其他强引用引用的情况下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">String str = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="comment">// 软引用</span></span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(str);       </span><br><span class="line"><span class="comment">// 内存不足</span></span><br><span class="line"><span class="keyword">if</span>(isNotFullMemeory())&#123;</span><br><span class="line">     str = <span class="keyword">null</span>;</span><br><span class="line">     System.gc();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如上所示，在内存不足时会回收软引用。软引用可用来实现高速缓存。</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>如果一个对象只有弱引用指向它，当进行年轻代垃圾回收时，一旦发现该引用指向的对象就会立刻回收，不管当前内存空间是否足够。注意，由于垃圾回收器是一个优先级很低的线程，因此不一定及时发现那些具有弱引用的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">String str = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="comment">// 弱引用</span></span><br><span class="line">WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(str);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 垃圾回收</span></span><br><span class="line">str = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure><p>如上所示，在进行垃圾回收时发现弱引用立即回收。如果想使用一个对象且不想介入这个对象的生命周期，这时就可以使用弱引用。注意，下面的代码可以转为强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String  str = weakReference.get();</span><br></pre></td></tr></table></figure><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line">String str = <span class="string">"hello world!"</span>;</span><br><span class="line"><span class="comment">// 虚引用</span></span><br><span class="line">PhantomReference phantomReference = <span class="keyword">new</span> PhantomReference(str,<span class="keyword">new</span> ReferenceQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">str = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 随时可能会输</span></span><br></pre></td></tr></table></figure><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中，该队列就是前文类图中的 <code>ReferenceQueue</code> 。</p><h1 id="再谈弱引用"><a href="#再谈弱引用" class="headerlink" title="再谈弱引用"></a>再谈弱引用</h1><p>由于在看 <strong>ThreadLocal</strong> 源码时考虑到涉及 <strong>弱引用</strong> ，因此单独拿出来说明下。下面对 <strong>WeakReference</strong> 类进行分析。</p><h2 id="WeakReference"><a href="#WeakReference" class="headerlink" title="WeakReference"></a>WeakReference</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个指向给定对象的弱引用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referent 给定对象的引用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referent 给定对象的引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q 对象被回收后会把弱引用对象，也就是WeakReference对象或者其子类的对象，放入队列ReferenceQueue中，注意不是被弱引用的对象，被弱引用的对象已经被回收了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过上述代码强调两个概念：</strong></p><blockquote><p>1 弱引用对象是指 WeakReference 实例或其子类实例。<br>2 被弱引用的对象是指需要通过 WeakReference 封装的对象，<strong>形如：</strong><code>WeakReference&lt;Xxx&gt; appleWeakReference = new WeakReference&lt;&gt;(xxx)</code>。这个时候我们说，持有了 <code>xxx</code> 指向对象的弱引用，也就是说当 <code>xxx</code> 也不再引用（可能不止 xxx 引用）时，就剩下弱引用，此时垃圾回收时是可以把对应的对象回收掉。</p></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><strong>Fruit 类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fruit</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        log.info(name + <span class="string">"finalize !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Fruit&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强引用</span></span><br><span class="line">        Fruit fruit = <span class="keyword">new</span> Fruit(<span class="string">"小芒果"</span>);</span><br><span class="line">        <span class="comment">// 创建弱引用对象</span></span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal(fruit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 WeakReference.get() 方法获取对应的对象</span></span><br><span class="line">        log.info(<span class="string">"Fruit: "</span> + animal.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消除强引用，确保只有弱引用（不消除强引用，不会回收）</span></span><br><span class="line">        fruit = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证 GC 的发生</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小芒果被回收 - 因此只有弱引用</span></span><br><span class="line">        log.info(animal.get() == <span class="keyword">null</span> ? <span class="string">" Fruit is Cleared"</span> : animal.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 WeakReference ，持有 Fruit 的弱引用。</span></span><br><span class="line"><span class="comment">     * 当垃圾回收时，回收的是弱引用 referent 指向的对象，而非 Animal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(Fruit referent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(referent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[main] INFO com.code.concurrent.Client - Fruit: Fruit&#123;name&#x3D;&#39;小芒果&#39;&#125;</span><br><span class="line">[Finalizer] INFO com.code.concurrent.Fruit - 小芒果finalize !</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 5242K-&gt;752K(76288K)] 5242K-&gt;760K(251392K), 0.0008122 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 752K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;534K(175104K)] 760K-&gt;534K(251392K), [Metaspace: 3371K-&gt;3371K(1056768K)], 0.0042356 secs] [Times: user&#x3D;0.03 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[main] INFO com.code.concurrent.Client -  Fruit is Cleared</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 7209K [0x000000076ab00000, 0x0000000770000000, 0x00000007c0000000)</span><br><span class="line">  eden space 65536K, 11% used [0x000000076ab00000,0x000000076b20a738,0x000000076eb00000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076eb00000,0x000000076eb00000,0x000000076f580000)</span><br><span class="line">  to   space 10752K, 0% used [0x000000076f580000,0x000000076f580000,0x0000000770000000)</span><br><span class="line"> ParOldGen       total 175104K, used 534K [0x00000006c0000000, 0x00000006cab00000, 0x000000076ab00000)</span><br><span class="line">  object space 175104K, 0% used [0x00000006c0000000,0x00000006c0085bf8,0x00000006cab00000)</span><br><span class="line"> Metaspace       used 3857K, capacity 4704K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 428K, capacity 464K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 强引用</span></span><br><span class="line">        Fruit fruit = <span class="keyword">new</span> Fruit(<span class="string">"小芒果"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建弱引用对象及引用队列</span></span><br><span class="line">        ReferenceQueue&lt;Fruit&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal(fruit, referenceQueue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 WeakReference.get() 方法获取对应的对象</span></span><br><span class="line">        log.info(<span class="string">"Fruit 对象信息: "</span> + animal.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC 前</span></span><br><span class="line">        log.info(<span class="string">"GC 前"</span>);</span><br><span class="line">        <span class="keyword">if</span> (referenceQueue.poll() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"没有回收被弱引用的对象，不会加入队列中"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录弱引用对象地址，用于回收前后对比</span></span><br><span class="line">        log.info(<span class="string">"弱引用对象地址："</span>+ animal.toString());</span><br><span class="line">        <span class="comment">// 消除强引用，确保只有弱引用（不消除强引用，不会回收）</span></span><br><span class="line">        fruit = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发垃圾回收</span></span><br><span class="line">        log.info(<span class="string">"GC 中"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 保证 GC 的发生</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GC 后</span></span><br><span class="line">        log.info(<span class="string">"GC 后"</span>);</span><br><span class="line">        <span class="comment">// 小芒果被回收 - 因此只有弱引用</span></span><br><span class="line">        log.info(animal.get() == <span class="keyword">null</span> ? <span class="string">" Fruit is Cleared"</span> : animal.get().toString());</span><br><span class="line"></span><br><span class="line">        Reference reference = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((reference = referenceQueue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"回收被弱引用的对象，弱引用对象加入队列中，地址为："</span> + reference.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 WeakReference ，持有 Fruit 的弱引用。</span></span><br><span class="line"><span class="comment">     * 当垃圾回收时，回收的是弱引用 referent 指向的对象，而非 Animal</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(Fruit referent, ReferenceQueue referenceQueue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(referent, referenceQueue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[main] INFO com.code.concurrent.Client - Fruit 对象信息: Fruit&#123;name&#x3D;&#39;小芒果&#39;&#125;</span><br><span class="line">[main] INFO com.code.concurrent.Client - GC 前</span><br><span class="line">[main] INFO com.code.concurrent.Client - 没有回收被弱引用的对象，不会加入队列中</span><br><span class="line">[main] INFO com.code.concurrent.Client - 弱引用对象地址：com.code.concurrent.Client$Animal@a09ee92</span><br><span class="line">[main] INFO com.code.concurrent.Client - GC 中</span><br><span class="line">[Finalizer] INFO com.code.concurrent.Fruit - 小芒果finalize !</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 5242K-&gt;736K(76288K)] 5242K-&gt;744K(251392K), 0.0006983 secs] [Times: user&#x3D;0.00 sys&#x3D;0.01, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 736K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;535K(175104K)] 744K-&gt;535K(251392K), [Metaspace: 3380K-&gt;3380K(1056768K)], 0.0035821 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[main] INFO com.code.concurrent.Client - GC 后</span><br><span class="line">[main] INFO com.code.concurrent.Client -  Fruit is Cleared</span><br><span class="line">[main] INFO com.code.concurrent.Client - 回收被弱引用的对象，弱引用对象加入队列中，地址为：com.code.concurrent.Client$Animal@a09ee92</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 7209K [0x000000076ab00000, 0x0000000770000000, 0x00000007c0000000)</span><br><span class="line">  eden space 65536K, 11% used [0x000000076ab00000,0x000000076b20a738,0x000000076eb00000)</span><br><span class="line">  from space 10752K, 0% used [0x000000076eb00000,0x000000076eb00000,0x000000076f580000)</span><br><span class="line">  to   space 10752K, 0% used [0x000000076f580000,0x000000076f580000,0x0000000770000000)</span><br><span class="line"> ParOldGen       total 175104K, used 535K [0x00000006c0000000, 0x00000006cab00000, 0x000000076ab00000)</span><br><span class="line">  object space 175104K, 0% used [0x00000006c0000000,0x00000006c0085e60,0x00000006cab00000)</span><br><span class="line"> Metaspace       used 3856K, capacity 4704K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 428K, capacity 464K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Java 中的 4 种引用进行了介绍，重点对弱引用进行了详细分析，理解了弱引用再去看 <code>ThreadLocal</code> 就能更好地理解其内存泄漏问题。下一篇文章将对 <code>ThreadLocal</code> 进行分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在 Java 中有 4 种引用类型，主要是在垃圾回收时 JVM 会根据不同的引用类型采取不同的措施。下面分别对这四种类型进行说明，特别是弱引
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
  </entry>
  
  <entry>
    <title>时间轮算法 - HashedWheelTimer</title>
    <link href="https://gentryhuang.com/posts/1d01ceec/"/>
    <id>https://gentryhuang.com/posts/1d01ceec/</id>
    <published>2021-07-24T02:06:24.000Z</published>
    <updated>2021-08-03T07:56:47.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>时间轮是一种高效利用线程资源来进行批量化调度的一种调度模型。将大批量的调度任务全部都绑定到同一个调度器上，使用这一调度器来进行所有任务的管理、触发以及执行。本篇文章将对 HashedWheelTimer 进行分析。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p><strong>编码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.util.HashedWheelTimer;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.Timeout;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.Timer;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimerClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 创建一个 HashedWheelTimer，内部参数全部使用默认值</span></span><br><span class="line">        Timer timer = <span class="keyword">new</span> HashedWheelTimer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 编写 TimeTask 任务</span></span><br><span class="line">        TimerTask timerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"is working !"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 提交任务</span></span><br><span class="line">        <span class="comment">// 创建 HashedWheelTimeout 对象，并将该对象放入任务队列中，等待被加入到 Hash 轮中被调用。</span></span><br><span class="line">        Timeout timeout = timer.newTimeout(timerTask, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调度结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1is working !</span><br></pre></td></tr></table></figure><h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>时间轮调度模型如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/hashedwheeltimer/hash-wheel-timer-model.jpeg" alt></p><p><strong>HashedWheelTimer</strong> 时间轮算法可以通过上图来描述。假设时间轮大小为 8 即 8 个格子，1s 转一格，每格都对应一个链表，链表每个节点都保存着待执行的任务。某一时刻，时间轮走到编号为 2 的格子，此时添加了一个 3s 后执行的任务，对应 3 个格子，则 2 + 3 = 5，在编号为 5 的格子对应链表中添加一个任务节点即可，轮次 round 为 0 ；如果添加一个 10s 后执行的任务，同理得 (2 + 10) % 8 = 4，在编号为 4 的格子对应的链表中添加一个任务节点，并标识轮次 round 为 1，当时间轮第二次经过编号为 4 的格子时就会执行该任务。注意，时间轮只会执行 round = 0 的任务，并会把该格子上的其他任务的 round 减 1 。</p><p>时间轮算法的原理还是非常容易理解的，下面我们从源码层面进行分析。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>HashedWheelTimer 相关的核心类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/hashedwheeltimer/hash-wheel-timer-uml.jpg" alt></p><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>HashedWheelTimer 是接口 io.netty.util.Timer 的实现，Timer 是任务调度器，负责对延时任务进行管理、触发和调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调度指定的 TimerTask ，在指定的延迟后执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 与指定任务相关联的句柄</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException      if this timer has been &#123;<span class="doctag">@linkplain</span> #stop() stopped&#125; already</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the pending timeouts are too many and creating new timeout</span></span><br><span class="line"><span class="comment">     *                                    can cause instability in the system.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Timeout <span class="title">newTimeout</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止所有的还没被执行的定时任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 与被此方法取消的任务相关联的句柄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Set&lt;Timeout&gt; <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TimerTask"><a href="#TimerTask" class="headerlink" title="TimerTask"></a>TimerTask</h2><p>延时任务，由业务方自行实现。Timer 会在触发时间对延时任务进行调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Timer 调度的任务，由业务方实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executed after the delay specified with</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Timer#newTimeout(TimerTask, long, TimeUnit)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 任务执行的时候会将该任务对应的 Timeout 传进来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h2><p>Timeout 是一个非常重要的接口，它的唯一实现类是 HashedWheelTimer 内部类 HashedWheelTimeout ，该内部类聚合了时间轮主要的核心对象，关于该内部类下文会详细分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与&#123;<span class="doctag">@link</span> TimerTask&#125;关联的句柄，由&#123;<span class="doctag">@link</span> Timer&#125;返回。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Timeout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回创建此句柄的&#123;<span class="doctag">@link</span> Timer&#125;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Timer <span class="title">timer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TimerTask <span class="title">task</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当且仅当与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;已过期时返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当且仅当与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;已被取消时返回 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试取消与此句柄关联的&#123;<span class="doctag">@link</span> TimerTask&#125;。如果任务已经被执行或取消，它将返回而没有副作用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果取消成功，则为 true，否则为 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashedWheelTimer"><a href="#HashedWheelTimer" class="headerlink" title="HashedWheelTimer"></a>HashedWheelTimer</h2><p>HashedWheelTimer 是对 Timer 的实现，也就是我们说的时间轮。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimer</span> <span class="keyword">implements</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimer 实例统计原子变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger INSTANCE_COUNTER = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过多 HashedWheelTimer 阈值开关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicBoolean WARNED_TOO_MANY_INSTANCES = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimer 数量的阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTANCE_COUNT_LIMIT = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小延时时间，默认是 1 毫秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MILLISECOND_NANOS = TimeUnit.MILLISECONDS.toNanos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ResourceLeakDetector&lt;HashedWheelTimer&gt; leakDetector = ResourceLeakDetectorFactory.instance()</span><br><span class="line">            .newResourceLeakDetector(HashedWheelTimer<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间轮状态，可以控制工作线程执行任务的状态。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimer&gt; WORKER_STATE_UPDATER =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimer.class, "workerState");</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResourceLeakTracker&lt;HashedWheelTimer&gt; leak;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread workerThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态  0 - init, 1 - started, 2 - shut down</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_INIT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_STARTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_STATE_SHUTDOWN = <span class="number">2</span>;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unused"</span>, <span class="string">"FieldMayBeFinal"</span>&#125;)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> workerState; <span class="comment">// 0 - init, 1 - started, 2 - shut down</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走一个 bucket 需要花费的纳秒时长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> tickDuration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bucket 数组，用于存储任务，即 HashedWheelTimeout 实例们</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelBucket[] wheel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 掩码，用于 与运算 ，计算属于 wheel 哪个下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 newTimeout 方法线程等待工作线程 workerThread 开启执行任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startTimeInitialized = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimeout 任务队列。MPSC 队列，适用于这里的多生产线程，单消费线程的场景</span></span><br><span class="line">    <span class="comment">// 提交的任务会先进入到该队列中，每次 tick 才会将队列中的任务（一次最多 10 万个）加入到 bucket 中的链表里</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;HashedWheelTimeout&gt; timeouts = PlatformDependent.newMpscQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashedWheelTimeout 任务取消队列</span></span><br><span class="line">    <span class="comment">// 取消的任务会加入到该队列中，此次 tick 会将该队列中的任务从 bucket 中移除</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;HashedWheelTimeout&gt; cancelledTimeouts = PlatformDependent.newMpscQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间轮中处于等待执行的任务数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong pendingTimeouts = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许最大的等待任务数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxPendingTimeouts;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作线程启动时间，作为时间轮的基准时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> startTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*----------------- 系列构造方法 -------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Executors.defaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(<span class="keyword">long</span> tickDuration, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Executors.defaultThreadFactory(), tickDuration, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(<span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Executors.defaultThreadFactory(), tickDuration, unit, ticksPerWheel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory, <span class="keyword">long</span> tickDuration, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, tickDuration, unit, <span class="number">512</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, tickDuration, unit, ticksPerWheel, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel, <span class="keyword">boolean</span> leakDetection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(threadFactory, tickDuration, unit, ticksPerWheel, leakDetection, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 HashedWheelTimer 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory      线程工厂，用于创建执行 TimerTask 任务的工作线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tickDuration       tick 之间的持续时间，即一次 tick 的时间长度。默认是 100</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit               tickDuration 的时间单位。默认是 毫秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ticksPerWheel      定义一圈有多少个 bucket 。 默认是 512</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leakDetection      用于追踪内存泄漏</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxPendingTimeouts 最大允许等待的任务数，也就是 Timeout 实例数（调用 newTimeout 方法产生），可以根据该参数控制不允许太多的任务等待。</span></span><br><span class="line"><span class="comment">     *                           如果未执行任务数达到阈值，那么再次提交任务会抛出 RejectedExecutionException 异常。如果该值为 0 或 负数，则不限制。</span></span><br><span class="line"><span class="comment">     *                           默认不限制。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel, <span class="keyword">boolean</span> leakDetection,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> maxPendingTimeouts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 参数校验</span></span><br><span class="line">        ObjectUtil.checkNotNull(threadFactory, <span class="string">"threadFactory"</span>);</span><br><span class="line">        ObjectUtil.checkNotNull(unit, <span class="string">"unit"</span>);</span><br><span class="line">        ObjectUtil.checkPositive(tickDuration, <span class="string">"tickDuration"</span>);</span><br><span class="line">        ObjectUtil.checkPositive(ticksPerWheel, <span class="string">"ticksPerWheel"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建时间轮 bucket 结构，这里做向上取整，保证 bucket 数组长度是 2 的 n 次方</span></span><br><span class="line">        <span class="comment">// wheel 就是一个个 bucket。时间轮会以循环的方式走这个 wheel 数组</span></span><br><span class="line">        wheel = createWheel(ticksPerWheel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 掩码，bucket - 1，用来做取模，计算任务应该放到哪个 bucket 中</span></span><br><span class="line">        <span class="comment">// 给定一个 deadline 的任务，其应该放置的格子: deadline%wheel.length 但是 % 操作是个相对耗时的操作，所以使用位运算代替：因为一圈的长度为 2^n 次方，mask = 2^n-1 后低位将全部是1，</span></span><br><span class="line">        <span class="comment">// 因此 deadline&amp;mast == deadline%wheel.length 。 HashMap 在进行 hash 之后，进行index的hash寻址寻址的算法也是和这个一样的</span></span><br><span class="line">        mask = wheel.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 将延迟时间统一转为纳秒</span></span><br><span class="line">        <span class="keyword">long</span> duration = unit.toNanos(tickDuration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 防止延迟时间溢出</span></span><br><span class="line">        <span class="keyword">if</span> (duration &gt;= Long.MAX_VALUE / wheel.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(</span><br><span class="line">                    <span class="string">"tickDuration: %d (expected: 0 &lt; tickDuration in nanos &lt; %d"</span>,</span><br><span class="line">                    tickDuration, Long.MAX_VALUE / wheel.length));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 延迟时间不能小于 1 毫秒</span></span><br><span class="line">        <span class="keyword">if</span> (duration &lt; MILLISECOND_NANOS) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Configured tickDuration &#123;&#125; smaller then &#123;&#125;, using 1ms."</span>,</span><br><span class="line">                    tickDuration, MILLISECOND_NANOS);</span><br><span class="line">            <span class="keyword">this</span>.tickDuration = MILLISECOND_NANOS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.tickDuration = duration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7 根据线程工厂创建线程。注意，这里并没有立即启动线程，启动线程是在第一次提交延迟任务的时候。</span></span><br><span class="line">        workerThread = threadFactory.newThread(worker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追踪内存泄露的，略</span></span><br><span class="line">        leak = leakDetection || !workerThread.isDaemon() ? leakDetector.track(<span class="keyword">this</span>) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8 最大允许等待的 Timeout 实例数</span></span><br><span class="line">        <span class="keyword">this</span>.maxPendingTimeouts = maxPendingTimeouts;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 9  如果超过 64 个 HashedWheelTimer 实例，它会打印错误日志提醒你</span></span><br><span class="line">        <span class="comment">// 因为时间轮是一个非常耗费资源的结构，所以一个 jvm 中的实例数目不能太高</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE_COUNTER.incrementAndGet() &gt; INSTANCE_COUNT_LIMIT &amp;&amp;</span><br><span class="line">                WARNED_TOO_MANY_INSTANCES.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="comment">// 打印错误日志</span></span><br><span class="line">            reportTooManyInstances();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过以上构造方法可以初始化一个时间轮对象，默认情况下，时间轮大小是 512，也就是一圈有 512 个 bucket，走一个 bucket 需要时间为 100ms 。</p><h3 id="初始化-bucket"><a href="#初始化-bucket" class="headerlink" title="初始化 bucket"></a>初始化 bucket</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时间轮 bucket 数组，用来存储任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ticksPerWheel 一圈有多少个 bucket ，默认是 512</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashedWheelBucket[] createWheel(<span class="keyword">int</span> ticksPerWheel) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"ticksPerWheel must be greater than 0: "</span> + ticksPerWheel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间轮 tick 不能多大</span></span><br><span class="line">        <span class="keyword">if</span> (ticksPerWheel &gt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"ticksPerWheel may not be greater than 2^30: "</span> + ticksPerWheel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  标准化时间轮大小</span></span><br><span class="line">        ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 HashedWheelBucket 数组</span></span><br><span class="line">        HashedWheelBucket[] wheel = <span class="keyword">new</span> HashedWheelBucket[ticksPerWheel];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wheel.length; i++) &#123;</span><br><span class="line">            wheel[i] = <span class="keyword">new</span> HashedWheelBucket();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wheel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 标准化时间轮大小，原则：向上取整，达到 2 的 n 次方</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ticksPerWheel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">normalizeTicksPerWheel</span><span class="params">(<span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> normalizedTicksPerWheel = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取第一个大于 ticksPerWheel 的 2 的 n 次方的值</span></span><br><span class="line">        <span class="keyword">while</span> (normalizedTicksPerWheel &lt; ticksPerWheel) &#123;</span><br><span class="line">            <span class="comment">// 左移一位，即 扩大 2 倍</span></span><br><span class="line">            normalizedTicksPerWheel &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> normalizedTicksPerWheel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>初始化 bucket 的过程就是初始化时间轮的格子，每个格子用于管理落在当前位置的延时任务们，这些任务由链表组织起来，且任务具有轮次的语义，只有任务的轮次为 0 时才能被时间轮执行。注意，时间轮中的每个 bucket 和延时时间是通过 tick 来间接关联的，通过延时任务的时间可以计算出它对应 N 个 tick ，而 tick 通过对 bucket 数组长度取模运算就能确定具体的 bucket。延时任务完成 Bucket 分配后，时间轮不断进行 tick 的过程就可以通过计算找到 tick 对应的 Bucket ，进而处理延时任务。</p><h2 id="HashedWheelTimeout"><a href="#HashedWheelTimeout" class="headerlink" title="HashedWheelTimeout"></a>HashedWheelTimeout</h2><p>延时任务的包装类，该类聚合了时间轮所有的核心对象及属性，也就是说通过该对象可以拿到所有核心的对象和属性，并且该类包含了延时任务执行的方法<strong>expire()</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimeout</span> <span class="keyword">implements</span> <span class="title">Timeout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_INIT = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 取消</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_CANCELLED = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 到期</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_EXPIRED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来CAS方式更新任务状态</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimeout&gt; STATE_UPDATER =</span><br><span class="line">                AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimeout.class, "state");</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Timer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelTimer timer;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * TimerTask</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TimerTask task;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 任务触发时间</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> deadline;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unused"</span>, <span class="string">"FieldMayBeFinal"</span>, <span class="string">"RedundantFieldInitialization"</span>&#125;)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = ST_INIT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 离任务执行的轮数，0 表示当前轮次执行。当任务从队列加入 bucket 时会计算这个值。</span></span><br><span class="line">        <span class="comment">// 对与轮次非 0 的任务，那么时间轮执行到对应的 bucket 时会将该任务的该属性值 -1 </span></span><br><span class="line">        <span class="keyword">long</span> remainingRounds;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这将用于通过双向链表在 hashhedwheeltimerbucket 中链接超时 的前后指针</span></span><br><span class="line">        HashedWheelTimeout next;</span><br><span class="line">        HashedWheelTimeout prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前 HashedWheelTimeout 所在的 bucket</span></span><br><span class="line">        HashedWheelBucket bucket;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashedWheelTimeout 用于封装 HashedWheelTimer、TimerTask 以及 deadLine 触发时间</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> timer</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> deadline</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        HashedWheelTimeout(HashedWheelTimer timer, TimerTask task, <span class="keyword">long</span> deadline) &#123;</span><br><span class="line">            <span class="keyword">this</span>.timer = timer;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.deadline = deadline;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+---HashedWheelTimeout</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 到期并执行任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_EXPIRED)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行 TimerTask.run 方法</span></span><br><span class="line">                task.run(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"An exception was thrown by "</span> + TimerTask<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>() + '.', <span class="title">t</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行任务本质上是调用 HashedWheelTimeout 对象中封装的 TimerTask 对象的方法。</p><h3 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+---HashedWheelTimeout</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 取消任务</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里只是修改状态为取消，实际会在下次tick的时候移除</span></span><br><span class="line">     <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_CANCELLED)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">           </span><br><span class="line">     <span class="comment">// 加入到时间轮的待取消队列，并在每次tick的时候，从相应格子中移除。 </span></span><br><span class="line">      timer.cancelledTimeouts.add(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>取消任务只是将待执行的 HashedWheelTimeout 对象加入到全局取消队列中，在后续的 tick 过程才会从对应的 bucket 中删除。</p><h3 id="移除任务"><a href="#移除任务" class="headerlink" title="移除任务"></a>移除任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimeout</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前 Timeout 从对应的 bucket 链表中移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   HashedWheelBucket bucket = <span class="keyword">this</span>.bucket;</span><br><span class="line">     <span class="keyword">if</span> (bucket != <span class="keyword">null</span>) &#123;</span><br><span class="line">          bucket.remove(<span class="keyword">this</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          timer.pendingTimeouts.decrementAndGet();</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>将 HashedWheelTimeout 对象从对应的 bucket 中删除。</p><h2 id="HashedWheelBucket"><a href="#HashedWheelBucket" class="headerlink" title="HashedWheelBucket"></a>HashedWheelBucket</h2><p>用来存放包装任务的 HashedWheelTimeout ，以链表结构的形式进行管理，链表中的每一个节点都是 HashedWheelTimeout。</p><h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelBucket</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 头指针</span></span><br><span class="line">       <span class="keyword">private</span> HashedWheelTimeout head;</span><br><span class="line">       <span class="comment">// 尾指针</span></span><br><span class="line">       <span class="keyword">private</span> HashedWheelTimeout tail;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Add &#123;<span class="doctag">@link</span> HashedWheelTimeout&#125; to this bucket.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 添加 HashedWheelTimeout 到 当前 bucket 中，即加入到链中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTimeout</span><span class="params">(HashedWheelTimeout timeout)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">assert</span> timeout.bucket == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 设置 timeout 的桶</span></span><br><span class="line">           timeout.bucket = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 维护桶中的 HashedWheelTimeout</span></span><br><span class="line">           <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">               head = tail = timeout;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               tail.next = timeout;</span><br><span class="line">               timeout.prev = tail;</span><br><span class="line">               tail = timeout;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将 timeout 从链表中移除</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> HashedWheelTimeout <span class="title">remove</span><span class="params">(HashedWheelTimeout timeout)</span> </span>&#123;</span><br><span class="line">           HashedWheelTimeout next = timeout.next;</span><br><span class="line">           <span class="comment">// remove timeout that was either processed or cancelled by updating the linked-list</span></span><br><span class="line">           <span class="keyword">if</span> (timeout.prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">               timeout.prev.next = next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (timeout.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">               timeout.next.prev = timeout.prev;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (timeout == head) &#123;</span><br><span class="line">               <span class="comment">// if timeout is also the tail we need to adjust the entry too</span></span><br><span class="line">               <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">                   tail = <span class="keyword">null</span>;</span><br><span class="line">                   head = <span class="keyword">null</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   head = next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">               <span class="comment">// if the timeout is the tail modify the tail to be the prev node.</span></span><br><span class="line">               tail = timeout.prev;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// null out prev, next and bucket to allow for GC.</span></span><br><span class="line">           timeout.prev = <span class="keyword">null</span>;</span><br><span class="line">           timeout.next = <span class="keyword">null</span>;</span><br><span class="line">           timeout.bucket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// timeout 对应的 timer 的等待任务数减 1</span></span><br><span class="line">           timeout.timer.pendingTimeouts.decrementAndGet();</span><br><span class="line">           <span class="keyword">return</span> next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行任务-1"><a href="#执行任务-1" class="headerlink" title="执行任务"></a>执行任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelBucket</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Expire all &#123;<span class="doctag">@link</span> HashedWheelTimeout&#125;s for the given &#123;<span class="doctag">@code</span> deadline&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 执行 bucket 中的到期任务。注意，只执行 bucket 中轮次为 0 且到期的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireTimeouts</span><span class="params">(<span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取时间任务链表的头</span></span><br><span class="line">        HashedWheelTimeout timeout = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理链表上的所有 timeout 实例</span></span><br><span class="line">        <span class="keyword">while</span> (timeout != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            HashedWheelTimeout next = timeout.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调整当前 bucket 的任务链表</span></span><br><span class="line">                next = remove(timeout);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 到达触发时间</span></span><br><span class="line">                <span class="keyword">if</span> (timeout.deadline &lt;= deadline) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 执行具体的任务，即执行 timeout 中的 TimerTask.run 方法</span></span><br><span class="line">                    timeout.expire();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不可能进入到这个分支</span></span><br><span class="line">                    <span class="comment">// The timeout was placed into a wrong slot. This should never happen.</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(</span><br><span class="line">                            <span class="string">"timeout.deadline (%d) &gt; deadline (%d)"</span>, timeout.deadline, deadline));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 任务被取消了</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout.isCancelled()) &#123;</span><br><span class="line">                next = remove(timeout);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 轮次减 1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout.remainingRounds--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理下个任务</span></span><br><span class="line">            timeout = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>工作线程 tick 时会找到当前 tick 对应的 bucket ，然后执行上述方法进而调度延时任务。</p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>Worker 是工作线程的任务体，里面封装了时间轮任务触发和执行的逻辑。一旦工作线程启动后，就会不停地 “滴答” bucket ，直到时间轮关闭。</p><h3 id="任务体"><a href="#任务体" class="headerlink" title="任务体"></a>任务体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录没有处理的时间任务</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Timeout&gt; unprocessedTimeouts = <span class="keyword">new</span> HashSet&lt;Timeout&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录走了几个 bucket ，不拥堵的情况下每隔 tickDuration 时间走一个 bucket</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> tick;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化启动时间。</span></span><br><span class="line">            <span class="comment">// 注意，在 HashedWheelTimer 中用的都是相对时间，因此需要以启动时间为基准。这里使用 volatile 修饰</span></span><br><span class="line">            startTime = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 因为 startTime = 0 作为工作线程未开始执行任务的标志。这里开始执行了，需要设置非 0</span></span><br><span class="line">                startTime = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一个提交任务的线程在 start() 处等待，需要唤醒它</span></span><br><span class="line">            startTimeInitialized.countDown();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * do-while 执行任务逻辑：</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 工作线程是逐个 bucket 顺序处理的，所以即使有些任务执行时间超过了一次 tick 时间，也没关系，这些任务并不会被漏掉。</span></span><br><span class="line"><span class="comment">             * 但是可能被延迟执行，毕竟工作线程是单线程。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待下次 tick 到来</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> deadline = waitForNextTick();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (deadline &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前 tick 下 bucket 数组对应 index，即哪个 bucket</span></span><br><span class="line">                    <span class="keyword">int</span> idx = (<span class="keyword">int</span>) (tick &amp; mask);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理已经取消的任务</span></span><br><span class="line">                    processCancelledTasks();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取当前 tick 对应的桶</span></span><br><span class="line">                    HashedWheelBucket bucket = wheel[idx];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将 timeouts 队列中的 HashedWheelTimeout 转移到相应的桶中</span></span><br><span class="line">                    transferTimeoutsToBuckets();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 执行进入到 bucket 中的任务</span></span><br><span class="line">                    bucket.expireTimeouts(deadline);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 记录走了多少个 tick</span></span><br><span class="line">                    tick++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_STARTED);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 执行到这里，说明当前 Timer 要关闭了，做一些清理工作 */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将所有 bucket 中没有执行的任务，添加到 unprocessedTimeouts 这个 HashSet 中，用于 stop() 方法返回</span></span><br><span class="line">            <span class="keyword">for</span> (HashedWheelBucket bucket : wheel) &#123;</span><br><span class="line">                bucket.clearTimeouts(unprocessedTimeouts);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任务队列中的任务也添加到 unprocessedTimeouts 中</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!timeout.isCancelled()) &#123;</span><br><span class="line">                    unprocessedTimeouts.add(timeout);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理已经取消的任务</span></span><br><span class="line">            processCancelledTasks();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程启动的第一步是初始化全局的 <code>startTime</code>，它将作为时间轮的基准时间，用来计算延时任务的触发时间。并调用 <code>countDown</code> 方法来通知阻塞在 <code>start</code> 方法上的线程。接着进入主循环中，循环中的行为是每隔一段时间走一个 bucket ，下面我们拆解执行部分。</p><h3 id="waitForNextTick"><a href="#waitForNextTick" class="headerlink" title="waitForNextTick"></a>waitForNextTick</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+--- Worker</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">waitForNextTick</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 计算当前 tick 下的 deadline，这值是确定的。即一次 tick 期限是一个固定值</span></span><br><span class="line">            <span class="comment">// 注意，这里就体现了时间轮的核心，理论上每隔 tickDuration 就会 "滴答" 一次</span></span><br><span class="line">            <span class="keyword">long</span> deadline = tickDuration * (tick + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 等待当前 tick 时间到达</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.1 基于 startTime 计算距离当前时间的时间戳</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.nanoTime() - startTime;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.2 判断是否可以进行 tick</span></span><br><span class="line">                <span class="comment">// 标准是：tick 触发的时间值 - currentTime &lt;= 0，没有到触发时间则休眠 sleepTimeMs 毫秒</span></span><br><span class="line">                <span class="comment">// 这里加 999999 是补偿精度，不足 1ms 的补足 1ms</span></span><br><span class="line">                <span class="keyword">long</span> sleepTimeMs = (deadline - currentTime + <span class="number">999999</span>) / <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.3 因为每次执行任务消耗的时间是不受控制的，因此计算出来的 sleepTimeMs 可能为负数</span></span><br><span class="line">                <span class="comment">// 当为负数时，说明前面的任务执行时间过长，导致本该 tick 的时候错过了。这个时候不需要休眠等待，需要立刻处理</span></span><br><span class="line">                <span class="keyword">if</span> (sleepTimeMs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentTime == Long.MIN_VALUE) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -Long.MAX_VALUE;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 返回值是基于 startTime 计算的距离当前时间的时间戳</span></span><br><span class="line">                        <span class="keyword">return</span> currentTime;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// windows 平台特别处理。先除以10再乘以10，是因为windows平台下最小调度单位是10ms，如果不处理成10ms的倍数，可能导致sleep更不准了</span></span><br><span class="line">                <span class="keyword">if</span> (PlatformDependent.isWindows()) &#123;</span><br><span class="line">                    sleepTimeMs = sleepTimeMs / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">                    <span class="keyword">if</span> (sleepTimeMs == <span class="number">0</span>) &#123;</span><br><span class="line">                        sleepTimeMs = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 2.4 没有到 tick 时间，则休眠</span></span><br><span class="line">                    Thread.sleep(sleepTimeMs);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    <span class="comment">// 如果工作线程已经关闭，那么返回 Long.MIN_VALUE</span></span><br><span class="line">                    <span class="keyword">if</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="keyword">this</span>) == WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Long.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>waitForNextTick 方法的逻辑已经详细注释，该方法就是用来控制每隔一定的时间 “滴答” 一次即跳一个 bucket，此外还处理了因上一个 tick 处理任务时间过长问题，采用的是立即触发执行的方式。不难看出，当遇到较长时间执行的任务时，会打乱原本正常 tick 的节奏，导致其他任务延期执行。 <code>tickDuration</code> 控制着时间的精准度，值越小精准度越高，工作线程则越繁忙。</p><h3 id="processCancelledTasks"><a href="#processCancelledTasks" class="headerlink" title="processCancelledTasks"></a>processCancelledTasks</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--- Worker</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理已经取消的任务。将已经取消的任务从对应的 bucket 中移除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCancelledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 遍历任务取消队列</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                HashedWheelTimeout timeout = cancelledTimeouts.poll();</span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// all processed</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 将 timeout 从对应的 bucket 中移除</span></span><br><span class="line">                    timeout.remove();</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"An exception was thrown while process a cancellation task"</span>, t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>该方法是为了处理那些被取消的任务，将被取消的任务从队列和 bucket 中分别移除。</p><h3 id="transferTimeoutsToBuckets"><a href="#transferTimeoutsToBuckets" class="headerlink" title="transferTimeoutsToBuckets"></a>transferTimeoutsToBuckets</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">+--- Worker</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将 HashedWheelTimeout 队列中的任务加入到相应的 bucket 中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transferTimeoutsToBuckets</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 限制每 tick 最大转移 10 万个 HashedWheelTimeout 到 bucket，以免阻塞工作线程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                HashedWheelTimeout timeout = timeouts.poll();</span><br><span class="line">                <span class="comment">// 队列为空</span></span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// all processed</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 被取消了</span></span><br><span class="line">                <span class="keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED) &#123;</span><br><span class="line">                    <span class="comment">// Was cancelled in the meantime.</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">/*---   将任务放到相应的 bucket 中 ----*/</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算任务触发时间需要经过多少个 tick</span></span><br><span class="line">                <span class="keyword">long</span> calculated = timeout.deadline / tickDuration;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算任务所属的轮次</span></span><br><span class="line">                timeout.remainingRounds = (calculated - tick) / wheel.length;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果任务在 timeouts 队列里面放久了, 以至于已经过了执行时间(calculated &lt; tick), 这个时候就使用当前 tick 对应的 bucket，从而让那些本应该在过去执行的任务在当前 tick 快速执行掉。</span></span><br><span class="line">                <span class="comment">// 此方法调用完后就会立即执行当前 tick 对应的 bucket 中的任务</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ticks = Math.max(calculated, tick); <span class="comment">// Ensure we don't schedule for past.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算 ticks 对应 bucket</span></span><br><span class="line">                <span class="keyword">int</span> stopIndex = (<span class="keyword">int</span>) (ticks &amp; mask);</span><br><span class="line">                HashedWheelBucket bucket = wheel[stopIndex];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 单个 bucket 是由 HashedWheelBucket 实例组成的一个链表，单个线程不存在并发</span></span><br><span class="line">                <span class="comment">// 这里将 timeout 加入到 bucket 的链表中</span></span><br><span class="line">                bucket.addTimeout(timeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在每次执行 tick 对应的 bucket 中的延时任务时，会先将全局任务队列中待执行的任务加入到对应的 bucket 中。</p><h3 id="expireTimeouts"><a href="#expireTimeouts" class="headerlink" title="expireTimeouts"></a>expireTimeouts</h3><p>一次 tick 到来后找到对应的 Bucket，然后就可以处理当前 Bucket 中的延时任务了，具体实现见前文。expireTimeouts 方法中会间接执行 <code>TimeTask.run</code> 方法，如果延时任务执行时间过久则会阻塞工作线程，进一步拖慢超时检测流程。</p><p>以上对 HashedWheelTimer 主要源码进行了分析，但没有串起来。下面我们以执行过程的形式进一步说明。</p><h2 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task  任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delay 延时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit  延迟时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Timeout <span class="title">newTimeout</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 校验参数</span></span><br><span class="line">        ObjectUtil.checkNotNull(task, <span class="string">"task"</span>);</span><br><span class="line">        ObjectUtil.checkNotNull(unit, <span class="string">"unit"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 校验等待任务数是否达到阈值</span></span><br><span class="line">        <span class="keyword">long</span> pendingTimeoutsCount = pendingTimeouts.incrementAndGet();</span><br><span class="line">        <span class="keyword">if</span> (maxPendingTimeouts &gt; <span class="number">0</span> &amp;&amp; pendingTimeoutsCount &gt; maxPendingTimeouts) &#123;</span><br><span class="line">            pendingTimeouts.decrementAndGet();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Number of pending timeouts ("</span></span><br><span class="line">                    + pendingTimeoutsCount + <span class="string">") is greater than or equal to maximum allowed pending "</span></span><br><span class="line">                    + <span class="string">"timeouts ("</span> + maxPendingTimeouts + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 如果工作线程没有启动，则启动工作线程。一般由第一个提交的任务负责工作线程的启动</span></span><br><span class="line">        start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 将任务添加到队列中，该队列将在下一个 tick 时进行处理，在处理过程中，所有排队的 HashedWheelTimeout 将被添加到正确的 HashedWheelBucket 中 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 deadline 是一个相对时间，相对于工作线程启动时间。</span></span><br><span class="line">        <span class="comment">// 注意，该值作为延时任务触发的时间，后续流程虽然会判断，但是貌似用处不大。主要还是用在根据该值计算 tick 进而确定将任务分配到哪个 Bucket，因为任务触发是跟着 tick 走的。</span></span><br><span class="line">        <span class="keyword">long</span> deadline = System.nanoTime() + unit.toNanos(delay) - startTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Guard against overflow.</span></span><br><span class="line">        <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; deadline &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            deadline = Long.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 创建 HashedWheelTimeout 对象，进一步封装任务对象</span></span><br><span class="line">        HashedWheelTimeout timeout = <span class="keyword">new</span> HashedWheelTimeout(<span class="keyword">this</span>, task, deadline);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 加入到 timeouts 队列中，等待被加入到 Bucket 中</span></span><br><span class="line">        timeouts.add(timeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> timeout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>时间轮在初始化后就可以接收业务方提交的延时任务请求了，任务的处理都是交给工作线程这个后台线程。提交任务的流程主要包含 3 个关键步骤：</p><blockquote><p>1 尝试启动工作线程 workerThread<br>2 计算延时任务的触发时间，创建 HashedWheelTimeout 对象进一步封装任务对象<br>3 将创建的 HashedWheelTimeout 对象加入到任务队列</p></blockquote><p>值得一提的是启动工作线程的逻辑，源码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动工作线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException if this timer has been</span></span><br><span class="line"><span class="comment">     *                               &#123;<span class="doctag">@linkplain</span> #stop() stopped&#125; already</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (WORKER_STATE_UPDATER.get(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果是初始化状态</span></span><br><span class="line">            <span class="keyword">case</span> WORKER_STATE_INIT:</span><br><span class="line">                <span class="keyword">if</span> (WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_INIT, WORKER_STATE_STARTED)) &#123;</span><br><span class="line">                    <span class="comment">// 启动工作线程</span></span><br><span class="line">                    workerThread.start();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WORKER_STATE_STARTED:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WORKER_STATE_SHUTDOWN:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"cannot be started once stopped"</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Invalid WorkerState"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待，直到 startTime 被工作线程初始化</span></span><br><span class="line">        <span class="keyword">while</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                startTimeInitialized.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                <span class="comment">// Ignore - it will be ready very soon.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到上述方法是 public 修饰的，也就是说用户可以显示的调用，而无需等待第一次提交任务时再启动。但一般没必要显示调用，没有任务提交没必要启动。</p><h2 id="执行任务-2"><a href="#执行任务-2" class="headerlink" title="执行任务"></a>执行任务</h2><p>前文也说了，时间轮中的任务都是由工作线程触发执行的。具体是一次 tick 到来后找到对应的 Bucket，然后就可以处理当前 Bucket 中的延时任务了。源码见前文。</p><h2 id="取消任务-1"><a href="#取消任务-1" class="headerlink" title="取消任务"></a>取消任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimeout</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// only update the state it will be removed from HashedWheelBucket on next tick.</span></span><br><span class="line">     <span class="keyword">if</span> (!compareAndSetState(ST_INIT, ST_CANCELLED)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 加入到取消任务队列中</span></span><br><span class="line">         timer.cancelledTimeouts.add(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>未到期但被取消的任务会放到 <code>cancelledTimeouts</code> 队列中，工作线程周期性调用 <code>processCancelledTasks()</code> 会从 bucket 中删除对应的 HashedWheelTimeout。</p><h2 id="终止时间轮"><a href="#终止时间轮" class="headerlink" title="终止时间轮"></a>终止时间轮</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+--- HashedWheelTimer</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Timeout&gt; <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 工作线程不能停止时间轮</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() == workerThread) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    HashedWheelTimer<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>() +</span></span><br><span class="line">                            ".stop() cannot be called from " +</span><br><span class="line">                            TimerTask<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>())</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试 CAS 替换当前状态为 “停止：</span></span><br><span class="line">        <span class="keyword">if</span> (!WORKER_STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, WORKER_STATE_STARTED, WORKER_STATE_SHUTDOWN)) &#123;</span><br><span class="line">            <span class="comment">// workerState can be 0 or 2 at this moment - let it always be 2.</span></span><br><span class="line">            <span class="keyword">if</span> (WORKER_STATE_UPDATER.getAndSet(<span class="keyword">this</span>, WORKER_STATE_SHUTDOWN) != WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">                INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">                <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">assert</span> closed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 中断 worker线程，尝试把正在进行任务的线程中断掉,如果某些任务正在执行则会抛出interrupt异常，并且任务会尝试立即中断</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (workerThread.isAlive()) &#123;</span><br><span class="line">                workerThread.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    workerThread.join(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前前程会等待stop的结果</span></span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            INSTANCE_COUNTER.decrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (leak != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> closed = leak.close(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">assert</span> closed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回未处理的任务</span></span><br><span class="line">        <span class="keyword">return</span> worker.unprocessedTimeouts();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/hashedwheeltimer/hash-wheel-timer-process.jpg" alt></p><p>HashWheelTimer 是基于时间轮算法，提交的任务会被封装成 <code>HashedWheelTimeout</code> 对象并存放到全局任务队列中。时间轮的格子是用 bucket 数组表示，bucket 内部维护一个 <code>HashedWheelTimeout</code> 类型的双向链表，每一个节点都是一个 HashedWheelTimeout 对象。其内部使用一个工作线程自旋地进行 tick ，tick 的过程会先将全局任务队列中的任务添加到对应的 bucket 中，接着轮训当前 tick 对应 bucket 中的任务链表，执行轮次为 0 的任务，轮次非 0 的任务将其轮次减 1 。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p><strong>优点</strong></p><blockquote><p>1 本地机器直接执行，效率非常高。<br>2 无需扫描所有任务。通过将环切成 N 份，将查询到期延时任务的耗时降到 1/N，N 视任务量的大小可以灵活设置(1024,2048 等)</p></blockquote><p><strong>缺点</strong></p><blockquote><p>1 可靠性：<br>    -  机器重启，数据即丢失，可以使用 MySQL 等持久化存储，机器重启时从数据库 load 进内存。<br>    -  机器宕机，数据丢失，需要使用方自行处理，如由其它机器接管宕机机器的任务<br>2 时间轮调度器的时间精度可能不是很高，对于精度要求特别高的调度任务可能不太合适。因为时间轮算法的精度取决于一次 tick 的时间。</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>时间轮算法不难理解，但 HashedWheelTimer 源码中有很多细节需要注意。任务的管理，体现在任务队列和 bucket 数组的使用；任务的触发，体现在工作线程自旋进行 tick ；任务的执行，体现在工作线程轮询 bucket 的任务链表，对 TimerTask.run 的执行；需要注意的是，整个时间轮的调度都是在一个线程中完成的，因此对于那些耗时较大的定时任务会影响其他任务的正常触发和执行，但任务执行异常并不会导致工作线程退出，这是不同于 JDK 中的 Timer 。</p><p><strong>参考：</strong><br><a href="https://www.javadoop.com/post/HashedWheelTimer" target="_blank" rel="noopener">https://www.javadoop.com/post/HashedWheelTimer</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;时间轮是一种高效利用线程资源来进行批量化调度的一种调度模型。将大批量的调度任务全部都绑定到同一个调度器上，使用这一调度器来进行所有任务的管理
      
    
    </summary>
    
    
      <category term="任务调度" scheme="https://gentryhuang.com/categories/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
    
      <category term="HashedWheelTimer" scheme="https://gentryhuang.com/tags/HashedWheelTimer/"/>
    
  </entry>
  
  <entry>
    <title>并发 - ReentrantReadWriteLock</title>
    <link href="https://gentryhuang.com/posts/f3292e6c/"/>
    <id>https://gentryhuang.com/posts/f3292e6c/</id>
    <published>2021-07-10T12:46:36.000Z</published>
    <updated>2021-08-21T09:39:31.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>独占锁（排它锁）在同一时刻只允许一个线程进行访问，如 <a href="https://gentryhuang.com/posts/dd0ffc6a/">并发 - ReentrantLock</a> 一文中介绍的 <code>ReentrantLock</code> 就是一个独占锁。而读写锁在同一时刻可以允许多个<strong>读线程</strong>访问，但是在写线程访问时，所有的读线程和其它写线程都会被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，<strong>通过分离读锁和写锁，不仅保证了写操作对读操作的可见性，还使得并发性相比一般的排它锁有更大提升</strong>。在读多写少的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。</p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>读写锁除了保证写操作对读操作的可见性以及并发性的提升之外，<strong>读写锁还能够简化读写交互场景的编码实现</strong>。对于一个共享的缓存数据，一般都是读多写少，但是写操作完成之后的更新需要对后续的读操作可见，这样做的目的是使读操作能读取到正确的数据。使用读写锁实现这样的功能，只需要在读操作时获取读锁，写操作时获取写锁即可。当写锁被获取时，后续其它线程的读写操作都会被阻塞，写锁释放之后，所有操作才会继续执行。相比于使用<strong>等待-通知机制</strong>，更加简单化。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java 并发包提供读写锁的实现是 <strong>ReentrantReadWriteLock</strong> ，它支持以下特性：</p><ul><li><strong>公平性选择：</strong>支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平</li><li><strong>重入性：</strong>支持锁重入，包括读锁和写锁</li><li><strong>锁降级：</strong>同一个线程获取的写锁能够降级为读锁，反之不行。遵循获取写锁、获取读锁、释放写锁、释放读锁</li></ul><h1 id="读写状态"><a href="#读写状态" class="headerlink" title="读写状态"></a>读写状态</h1><p>读写锁 <code>ReentrantReadWriteLock</code> 同样是基于 AQS 实现的锁功能，而读写状态就是 AQS 的同步状态。在 <code>ReentrantLock</code> 中同步状态表示锁被一个线程持有的次数，而读写锁需要在同步状态上维护多个读线程和一个写线程的信息，这就使得<strong>同步状态的设计成为读写锁实现的关键</strong>。由于同步状态 <code>state</code> 是一个整型变量，4 个字节 32 位，因此读写锁将该变量切分成了两部分，高 16 位表示读，低 16 位表示写，划分方式如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/read-write-lock-state.png" alt></p><p>上图中的同步状态表示一个线程已经获取了写锁且重入了 2 次，同时也连续获取了两次读锁。<strong>读写锁是通过位运算来确定读和写各自的状态的</strong>。下面对状态的变化过程进行说明。</p><p><strong>假设当前同步状态 state 的值为 S</strong></p><ul><li>获取写状态<blockquote><p>S &amp; (1 &lt;&lt; 16 -1) -&gt; 将高16位全部抹去</p></blockquote></li><li>获取读状态<blockquote><p>S&gt;&gt;&gt;16 -&gt; 无符号补0，右移16位</p></blockquote></li><li>更新操作<blockquote><p>写状态增加 1 时 -&gt; S + 1<br>读状态增加 1 时 -&gt; S + (1&lt;&lt;16)，也就是 S + 0x00010000</p></blockquote></li></ul><p><strong>注意：</strong>读写锁 <code>ReentrantReadWriteLock</code> 虽然使用同步状态 <code>state</code> 的高低位来表示读写状态，但是同步队列依然是共用一个。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p><strong>ReentrantReadWriteLock 的类继承关系类图如下:</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/read-write-lock-uml.jpg" alt></p><p>由继承关系图可知，读写锁 ReentrantReadWriteLock 是通过内部类 Sync 继承 AQS 来行使同步器的职能。由于该读写锁支持公平和非公平模式，因此通过继承内部类 Sync 的方式定义了非公平模式的 NonfairSync 和公平模式的 FairSync 。读写锁的实现依赖组合的 Sync ，也就是说 ReadLock 和 WriteLock 获取和释放锁的功能是交给 Sync 去实现的，公平模式下使用 FairSync ，非公平模式下使用 NonfairSync 。</p><p><strong>读写锁 ReentrantReadWriteLock 组合关系如下图所示：</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/read-write-lock-combination.jpg" alt></p><p><strong>ReentrantReadWriteLock 分为读锁 ReadLock 和写锁 WriteLock 。读锁是共享锁，可被多个线程同时占有；写锁是独占锁，同时只能有一个线程占有，且写锁被线程占有后其它线程既不能获取读锁也不能获取写锁，但占有写锁的线程可以在不释放写锁的情况下继续获取读锁，这是锁降级的特点。</strong></p><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6992448646407690164L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取写锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> writerLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取读锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock <span class="title">readLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readerLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sync 继承自 AQS ,执行所有同步机制</span></span><br><span class="line"><span class="comment">     * 根据 ReentrantReadWriteLock 构造函数传入的布尔值决定要构造哪一种 Sync 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认创建非公平的 ReentrantReadWriteLock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据传入的公平策略创建 ReentrantReadWriteLock</span></span><br><span class="line"><span class="comment">     * 说明：创建 ReentrantReadWriteLock 对象同时，会依次创建对应模式的 AQS 对象、读锁对象、写锁对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair 公平策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类 Sync ，继承 AQS</span></span><br><span class="line"><span class="comment">     * 1 具体子类包括：非公平模式 NonfairSync 和 公平模式 FairSync</span></span><br><span class="line"><span class="comment">     * 2 实现 AQS 中的独占和共享模式的两对方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平版本的 Sync</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平版本的 Sync</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span>  </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用外层的 ReentrantReadWriteLock 的 AQS 管理同步状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其它方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用外层的 ReentrantReadWriteLock 的 AQS 管理同步状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其它方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过前文分析的 <code>ReentrantReadWriteLock</code> UML 类图和相关的组合关系图，不难发现与上述代码结构是一一对应的。下面我们依次对读锁和写锁依赖的 AQS 相关实现进行介绍，理解了相关的实现后也就基本理解了读写锁的实现。</p><h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 静态内部类 Sync ，继承 AQS</span></span><br><span class="line"><span class="comment">    * 具体子类包括：非公平模式 NonfairSync 和 公平模式 FairSync</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6317671515068378041L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 将同步状态 state 分为两段：高 16 位用于共享模式；低 16 位用于独占模式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 读锁的值操作单位</span></span><br><span class="line">       <span class="comment">// 由于高 16 位用于读锁，因此每次操作基于 1 左移 16 位的值，也就是从高 16 位的末尾进行计算</span></span><br><span class="line">       <span class="comment">// 即，同步状态 state 加减 1 &lt;&lt; 16 =&gt; 1 00000000 00000000</span></span><br><span class="line">       <span class="comment">// 写锁是低 16 位，直接对同步状态 state 加减</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 锁持有次数溢出的阈值，即 2^16 -1</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 独占模式掩码，即 1 &lt;&lt; 16 -1 =&gt; 11111111 11111111</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 取 c 的高 16 位的值，代表读锁的获取次数，包括重入</span></span><br><span class="line"><span class="comment">        * 注意：该值是所有线程获取次数总和，包括每个线程重入情况</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 取 c 的低 16 位的值，代表写锁的重入次数（写锁是独占模式）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//----------------------- 🌟线程读锁计数器 --------------------/</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 用于记录每个线程持有的读锁次数(包括读锁重入)</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">           <span class="comment">// 线程持有读锁次数</span></span><br><span class="line">           <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">           <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ThreadLocal 的子类，保存线程变量副本 HoldCounter</span></span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 初始化 HoldCounter</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 当前线程读锁计数器</span></span><br><span class="line">       <span class="comment">// 说明：使用 ThreadLocal 来记录当前线程持有的读锁次数</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 最后获取读锁的线程读锁计数器</span></span><br><span class="line">       <span class="comment">// 说明：缓存最后一个获取读锁的线程持有读锁的次数，这里不是全局的概念，所以不管哪个线程获取到读锁后，就把这个值占为已用</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 首个获取读锁的线程(并且其未释放读锁)读锁计数器</span></span><br><span class="line">       <span class="comment">// 说明：</span></span><br><span class="line">       <span class="comment">// 1 这里不是全局的概念，该值被设置的条件是，当获取读锁时此时读锁没有线程持有。等这个 firstReader 代表的线程释放掉读锁以后，会有新的线程占用这个属性，也就是这个"第一个"是动态的。</span></span><br><span class="line">       <span class="comment">// 2 在读锁不产生竞争的情况下，记录读锁重入次数是非常方便的</span></span><br><span class="line">       <span class="comment">// 3 如果一个线程使用了 firstReader，那么它就不需要占用 cachedHoldCounter 变量了</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//-------------------- 线程读锁计数器🌟 --------------------/</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 构造方法中初始化</span></span><br><span class="line">       Sync() &#123;</span><br><span class="line">           <span class="comment">// 初始化 readHolds 这个 ThreadLocal 属性</span></span><br><span class="line">           readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">           <span class="comment">// 为了保证 readHolds 的内存可见性</span></span><br><span class="line">           setState(getState()); <span class="comment">// ensures visibility of readHolds</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取读锁是否需要阻塞，交给子类实现</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取写锁是否需要阻塞，交给子类实现</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 省略获取和释放同步状态方法对，即获取和释放读锁/写锁方法。</span></span><br><span class="line">       <span class="comment">// 在分析读锁和写锁时结合分析，这里先不展示源码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承 AQS 的静态内部类 Sync 负责读锁 ReadLock 和写锁 WriteLock 的获取与释放工作，对读写锁 ReentrantReadWriteLock 的公平和非公平支持交给了两个子类实现。下面对 Sync 中的属性和抽象方法进行介绍，这些属作为最基础的数据支持读写锁的运行与统计。</p><p><strong>同步状态</strong></p><blockquote><ul><li>读写锁将 int 类型的同步状态 state 同时赋予两种语义，高 16 位表示读锁的持有次数，包括线程重入锁的情况。获取到读锁一次：<code>state + (1&lt;&lt;16)</code>，释放掉读锁一次：<code>state - (1&lt;&lt;16)</code>；</li><li>低 16 位表示写锁的获取次数，因为写锁是独占锁，同时只能被一个线程获取，因此它代表的重入次数。获取写锁一次：<code>state + 1</code>，释放写锁一次：<code>state -1</code> 。</li></ul></blockquote><p><strong>线程读锁计数器</strong></p><blockquote><ol><li>每个线程都需要记录获取的读锁次数，这样才能知道到底是不是读锁重入。注意，判断读锁重入和写锁重入完全不一样。写锁属于独占锁，同一时刻写锁只能一个线程持有，因此同步状态的低 16 位的值就是该线程持有写锁的次数（包括重入）；读锁属于共享锁，同一时刻允许多个线程持有，而同步状态的高 16 位的值是所有线程持有的总次数（包括各个线程重入），因此不能借助同步状态得出各个读线程持有读锁的次数，也就不能判断是否读锁重入，因此需要线程读锁计数器来辅助完成该诉求。</li><li>读写锁使用 ThreadLocal<HoldCounter> 维护每个线程读锁计数器，这样就能识别出哪个线程持有多少次读锁，进而可以判断线程是否是读锁重入以及线程持有读锁的次数。此外，读写锁基于性能考虑，又引入 <strong>“首个线程读锁计数器”</strong> 和 <strong>“最后线程读锁计数器”</strong>。其实 <code>ThreadLocal&lt;HoldCounter&gt; readHolds</code> 完全可以完成计数，只是 ThreadLocal 内部基于 Map 来查询的，相比直接使用变量记录线程读锁计数信息性能要差了那么一丢丢，不过这两个计数器只能记录一个线程持读锁信息，并且是动态变化的，提升性能的依据是尽可能先用这两个计数器，然后才使用通用的 <code>ThreadLocal&lt;HoldCounter&gt; readHolds</code> 记录线程读锁信息。</HoldCounter></li><li><strong>“首个线程读锁计数器”</strong> 是使用 <strong>firstReader</strong> 和 <strong>firstReaderHoldCount</strong> 两个属性组合而成的。<strong>“最后线程读锁计数器”</strong> 是使用 <code>HoldCounter</code> 类型的 <strong>cachedHoldCounter</strong> 属性表示。</li></ol></blockquote><p><strong>读写公平策略</strong></p><blockquote><p>读写锁 ReentrantReadWriteLock 具体分为读锁 ReadLock 和写锁 WriteLock ，在公平和非公平模式下读锁和写锁的表现不同，因此将具体的实现交给公平和非公平子类实现。</p></blockquote><h3 id="非公平-Sync"><a href="#非公平-Sync" class="headerlink" title="非公平 Sync"></a>非公平 Sync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+--- ReentrantReadWriteLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平版本的 Sync</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8159625535654395037L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取写锁是否需要阻塞</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果是非公平模式，那么 lock 的时候就可以直接用去抢锁，抢不到再排队</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取读锁是否需要阻塞</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 判断同步队列中 head 的第一个后继节点是否是来获取写锁的，如果是，就算是非公平模式，也先让该节点获取写锁，避免线程饥饿</span></span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">            <span class="comment">//     final boolean apparentlyFirstQueuedIsExclusive() &#123;</span></span><br><span class="line">            <span class="comment">//        Node h, s;</span></span><br><span class="line">            <span class="comment">//        return (h = head) != null &amp;&amp;</span></span><br><span class="line">            <span class="comment">//            (s = h.next)  != null &amp;&amp;</span></span><br><span class="line">            <span class="comment">//            !s.isShared()         &amp;&amp;</span></span><br><span class="line">            <span class="comment">//            s.thread != null;</span></span><br><span class="line">            <span class="comment">//    &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在非公平模式下，写锁优先尝试抢占锁，抢占失败才会去排队；一般来说，非公平模式下读锁也应该直接尝试抢占锁，但是<strong>写锁被定义了更高的优先级</strong>，读锁会先判断队列中等待的第一个线程节点是否是获取写锁的，如果是就算是非公平模式也先让该节点获取写锁，避免线程饥饿。</p><h3 id="公平-Sync"><a href="#公平-Sync" class="headerlink" title="公平 Sync"></a>公平 Sync</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+--- ReentrantReadWriteLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平版本的 Sync</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2274990926593161451L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取写锁是否需要阻塞</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 那么如果阻塞队列有线程等待的话，就乖乖去排队</span></span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断读是否要阻塞</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 同步队列中有线程节点在等待</span></span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在公平模式下，无论是写锁还是读锁，都遵循先来后到原则。<strong>需要说明的是，对于读锁的获取，无论是公平还是非公平模式，它都没有抢占的概念，即使是在非公平模式下，还是需要判断同步队列中的第一个线程节点是否是写线程</strong>。</p><p>至此，读锁和写锁的前置准备已经完成，下面我们进入到读锁和写锁的源码。</p><h2 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h2><p>读锁内部持有 <code>ReentrantReadWriteLock</code> 中的 Sync 类型的对象，可能是 <code>FairSync</code> 对象，也可能是 <code>NonfairSync</code> 对象，具体由 <code>ReentrantReadWriteLock</code> 构造函数决定。ReadLock 锁获取与释放功能全部委托给 <strong>sync</strong> 对象完成。 </p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+--- ReentrantReadWriteLock</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5992448646407690164L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 使用 AQS 管理同步状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> lock</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="获取读锁"><a href="#获取读锁" class="headerlink" title="获取读锁"></a>获取读锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">+--- ReadLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 模版方法，获取共享同步状态</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+--- AQS</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试获取读锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+--- Sync</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS 模版方法，获取共享同步状态 - 获取读锁</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1 读锁是一个支持重入的共享锁，它能被多个线程同时获取，在没有其它写线程访问时（注意非公平模式下同步队列中首个获取写锁的线程节点的情况），读锁总会被成功地获取，而所做的也只是增加读状态。</span></span><br><span class="line"><span class="comment">     * 2 如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其它线程获取，则进入等待状态。</span></span><br><span class="line"><span class="comment">     * 3 读锁的实现有两部分逻辑，一个是获取读锁，另一个是设置线程的读锁计数器。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取同步状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 exclusiveCount(c) != 0 ，说明有线程持有写锁。如果不是当前线程持有的写锁，那么当前线程获取读锁失败。</span></span><br><span class="line">        <span class="comment">// 由于读写锁的降级，如果当前线程持有写锁，是可以继续获取读锁的</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 读锁的获取次数</span></span><br><span class="line">        <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 获取读锁是否需要被阻塞（需要考虑公平与非公平的情况）</span></span><br><span class="line">        <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                <span class="comment">// 判断持有读锁次数是否会溢出 (2^16-1)</span></span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                <span class="comment">// 使用  CAS 是将 state 属性的高 16 位加 1，低 16 位不变，如果成功就代表获取到了读锁</span></span><br><span class="line">                <span class="comment">// c + 1 00000000 00000000</span></span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 进入当前代码区域，表示获取到了读锁。下面的逻辑是记录线程读锁计数器，用于标记当前线程持读锁次数，为判断是否读锁重入以及线程获取读锁次数做基础数据准备 */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.1 r == 0 说明当前线程是第一个获取读锁的线程，或者是在它之前的读锁都已经释放了</span></span><br><span class="line">            <span class="comment">// 记录 firstReader 为当前线程，及其持有的读锁数量：1</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5.2 当前线程重入锁，加 1 即可</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5.3 当前线程不是第一个获取读锁，并且已经有其它线程获取了读锁</span></span><br><span class="line">                <span class="comment">// - 使用 readHolds 保存当前线程持有的读锁次数</span></span><br><span class="line">                <span class="comment">// - 将当前线程持有读锁信息更新为 cachedHoldCounter 的值，该变量用于记录最后一个获取读锁的线程持锁信息</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取最后一个获取读锁的线程信息。</span></span><br><span class="line">                Sync.HoldCounter rh = cachedHoldCounter;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 cachedHoldCounter 缓存的不是当前线程，则将当前线程持有读锁信息缓存到 HoldCounter</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    cachedHoldCounter = rh = readHolds.get();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// cachedHoldCounter 缓存的是当前线程，但 count 为 0</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将当前线程持有读锁次数 count 加 1</span></span><br><span class="line">                rh.count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// return 大于 0 代表获取到了共享锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进入下面方法，可能是以下三种情况：</span></span><br><span class="line">        <span class="comment">// - compareAndSetState(c, c + SHARED_UNIT) 存在竞争，CAS 失败</span></span><br><span class="line">        <span class="comment">// - 公平模式 FairSync 下同步队列中有其它线程节点在等待锁</span></span><br><span class="line">        <span class="comment">// - 非公平模式 NonFairSync 下，同步队列中第一个线程节点（head.next）是获取写锁的，为了避免写锁饥饿，获取读锁的线程不应该和它竞争</span></span><br><span class="line">        <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>读锁获取使用 AQS 的共享模式获取同步状态，整个流程如下：</p><ol><li>判断写锁是否被其它线程占有（支持锁降级获取读锁），如果被其它线程占有直接获取读锁失败。</li><li>根据具体的公平或非公平模式判断获取读锁是否需要阻塞，阻塞的话会进入后续二次确认方法，即判断是否是重入获取读锁，重入获取读锁不需要阻塞。</li><li>获取读锁成功后，记录线程读锁计数器。</li></ol><p><strong>获取读锁的注意事项如下：</strong></p><ul><li>获取读锁前提条件是写锁没有被其它线程持有，当前线程持有写锁是可以继续获取读锁的，这是读写锁的锁降级特性。</li><li>在公平模式下，获取读锁时同步队列中有等待的线程节点，如果此时不是重入获取读锁，那么获取锁失败。</li><li>在非公平模式下，获取读锁时同步队列中第一个线程节点是获取写锁的情况，此时如果不是重入获取读锁，那么获取锁失败。写锁被定义更高的优先级。</li><li>获取锁成功后，需要记录当前线程读锁计数器。<strong>线程读锁计数器有两个作用，一个是用于判断线程是否是重入读锁，另一个是提供当前线程获取读锁的次数</strong>。</li></ul><h4 id="fullTryAcquireShared"><a href="#fullTryAcquireShared" class="headerlink" title="fullTryAcquireShared"></a>fullTryAcquireShared</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">+--- Sync</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这段代码与 tryAcquireShared 中的代码在一定程度上是冗余的，但由于没有使用重试和惰性读取保持计数之间的交互使 tryAcquireShared 复杂化，所以总体上更简单。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> current 当前线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录线程获取读锁的次数</span></span><br><span class="line">        Sync.HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for 循环</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">// 1 获取同步状态</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 如果其它线程获取了写锁，那么当前线程是不能获取到读锁的，只能去同步队列中排队</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                <span class="comment">// would cause deadlock.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3 获取读锁应该阻塞，说明同步队列中有其它线程在等待。</span></span><br><span class="line">                <span class="comment">// 注意： 既然是获取读锁应该阻塞，那么进入有什么用呢？ 是用来处理读锁重入的</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// firstReader 线程重入锁，暂不做操作，直接执行后面的 CAS</span></span><br><span class="line">                <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 非 firstReader 线程重入锁，则继续判断其它情况重入锁</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 判断是否是 cachedHoldCounter 重入锁，如果也不是，那就是既不是 firstReader 可重入也不是 lastReader 可重入，</span></span><br><span class="line">                        <span class="comment">// 这是只需从 ThreadLocal 取出当前线程持有读锁信息，如果没有占有，则进行兜底操作，让线程去排队</span></span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 那么到 ThreadLocal 中获取当前线程的 HoldCounter</span></span><br><span class="line">                            <span class="comment">// 注意，如果当前线程从来没有初始化过 ThreadLocal 中的值，get() 会执行初始化</span></span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 如果发现 count == 0，也就是说是上一行代码初始化的，之前该线程并没有持有读锁，那么执行 remove 操作清空信息，因为接下来该线程要入队等待了</span></span><br><span class="line">                            <span class="comment">// 然后往下两三行，乖乖排队去</span></span><br><span class="line">                            <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                readHolds.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 非重入，去同步队列中排队</span></span><br><span class="line">                    <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里 CAS 成功，那么就意味着成功获取读锁了</span></span><br><span class="line">            <span class="comment">// 下面需要做的是设置 firstReader 或 cachedHoldCounter，以及 readHolds，记录线程读锁信息</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 注意这里 c 是上面的快照，上面修改的不是 c 而是 state</span></span><br><span class="line">                <span class="comment">// 如果发现 sharedCount(c) 等于 0，也就是当前没有线程持有读锁，就将当前线程设置为 firstReader</span></span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果是重 firstReader 重入，直接累加持有读锁的次数即可</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将 cachedHoldCounter 设置为当前线程持有读锁信息，并且使用 ThreadLocal 记录当前线程持有读锁信息</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                        rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 累加当前线程持读锁次数</span></span><br><span class="line">                    rh.count++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 更新 cachedHoldCounter 为当前线程持有读锁信息</span></span><br><span class="line">                    cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回大于 0 的数，代表获取到了读锁</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>上述方法在一定程度上是对 <code>tryAcquireShared</code> 方法的冗余，主要是对并发获取读锁失败以及重入获取锁的处理。具体作用如下：</strong></p><blockquote><ol><li>tryAcquireShared 方法中 CAS 获取同步状态失败后增加获取读锁成功的机会，尽可能不进入同步队列。</li><li>处理 tryAcquireShared 中因获取读锁需要阻塞的情况（上述方法只会处理重入读锁的情况，因为重入读锁不需要阻塞，非重入就需要阻塞，也就是获取读锁再次失败）<ul><li>在非公平模式 NonFairSync 情况下，如果同步队列中 head.next 是获取写锁的节点，那么如果该线程不是重入读锁则获取失败，如果是重入读锁则获取成功，因为重入优先级更高。</li><li>在公平模式 FairSync 情况下，如果同步队列中有线程节点等待，那么如果不是重入读锁则获取失败，如果是重入读锁则获取成功，同样地，因为重入优先级更高。</li></ul></li></ol></blockquote><h3 id="释放读锁"><a href="#释放读锁" class="headerlink" title="释放读锁"></a>释放读锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">+--- ReadLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">+--- AQS</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">+--- Sync</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS模版方法，释放共享同步状态 - 释放读锁</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 读锁的每次释放均减少读状态，减少的值是 1&lt;&lt;16</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 如果当前线程是 firstReader ，说明当前线程是第一个读线程</span></span><br><span class="line">        <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 firstReaderHoldCount 等于 1 ，那么本次解锁后就不再持有锁了，需要把 firstReader 置为 null</span></span><br><span class="line">            <span class="comment">// 没有设置 firstReaderHoldCount = 0 ，是因为没必要，其他线程使用的时候自己会重新设置该值</span></span><br><span class="line">            <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                firstReader = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                firstReaderHoldCount--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 当前线程不是首个获取读锁的线程</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断当前线程是不是最后获取读锁的线程，不是的话要到 ThreadLocal 中取</span></span><br><span class="line">            Sync.HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                rh = readHolds.get();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取计数</span></span><br><span class="line">            <span class="keyword">int</span> count = rh.count;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 将 ThreadLocal remove 掉，防止内存泄漏。因为已经不再持有读锁了</span></span><br><span class="line">                readHolds.remove();</span><br><span class="line">                <span class="comment">// 防止释放锁和获取锁次数不匹配</span></span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// count 减 1</span></span><br><span class="line">            --rh.count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 将同步状态 state 的高 16 位减 1，如果发现读锁和写锁都释放完了，那么唤醒后继的等待线程节点</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取同步状态 state</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// nextc 是 state 高 16 位减 1 后的值</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 nextc == 0，那就是 state 全部 32 位都为 0，也就是读锁和写锁都没有被占有</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="comment">// 释放读锁对读操作没有影响，但是如果现在读锁和写锁都是空闲的，那么释放读锁可能允许等待的写操作继续进行。</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>读锁释放过程比较简单，主要还是对应的两个操作，具体如下：</p><ul><li>更新当前释放读锁的线程对应的读锁计数器，如果是完全释放锁，则需要销毁对应的读锁计数器。</li><li>更新同步状态的高 16 位的值，表示释放读锁。如果是完全释放锁，则当前线程去唤醒同步队列中的线程节点。</li></ul><h2 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h2><p>写锁是一个支持重入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p><p>写锁内部持有 <code>ReentrantReadWriteLock</code> 中的 Sync 类型的对象，可能是 <code>FairSync</code> 对象，也可能是 <code>NonfairSync</code> 对象，具体由 <code>ReentrantReadWriteLock</code> 构造函数决定。ReadLock 锁获取与释放功能全部委托给 <strong>sync</strong> 对象完成。 </p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--- ReentrantReadWriteLock</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写锁</span></span><br><span class="line"><span class="comment">     * 1 写锁是独占锁</span></span><br><span class="line"><span class="comment">     * 2 如果有读锁被占用，写锁获取要进入同步队列中等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4992448646407690164L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取写锁"><a href="#获取写锁" class="headerlink" title="获取写锁"></a>获取写锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">+--- WriteLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+--- AQS</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+--- Sync</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS 模版方法，获取独占同步状态 - 获取写锁</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1 该方法除了重入条件（当前线程是获取了写锁的线程）之外，增加了一个读锁是否存在的判断。</span></span><br><span class="line"><span class="comment">     * 2 如果存在读锁，则写锁不能被获取，原因在于，读写锁要确保写锁的操作对读锁可见，如果允许读锁在已经被获取的情况下对写锁的获取，</span></span><br><span class="line"><span class="comment">     * 那么正在运行的其它读线程就无法感知到当前写线程的操作。因此，只有等待其它读线程都释放了读锁，写锁才能被当前线程获取。</span></span><br><span class="line"><span class="comment">     * 3 写锁一旦被获取，则其它读写线程的后续访问都被阻塞。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取同步状态 state</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 根据 state 获取写锁的持有次数</span></span><br><span class="line">        <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4  c != 0 表示要么有线程持有读锁，要么有线程持有写锁</span></span><br><span class="line">        <span class="comment">// 由于该方法是获取写锁，因此下面只能是写锁重入分支（存在持有读锁的情况直接失败）</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c != 0 &amp;&amp; w == 0: 写锁可用，但是有线程持有读锁(也可能是自己持有，但由于不支持锁升级，因此不能获取写锁)</span></span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> ||</span><br><span class="line">                    <span class="comment">// c != 0 &amp;&amp; w !=0 &amp;&amp; current != getExclusiveOwnerThread(): 非重入，其他线程持有写锁</span></span><br><span class="line">                    current != getExclusiveOwnerThread())</span><br><span class="line">                <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断写锁持有次数是否超过阈值（65535）</span></span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 能到这里的，只可能是写锁重入，更新同步状态即可</span></span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行到这里，此时 state == 0 ，读锁和写锁都没有被获取</span></span><br><span class="line">        <span class="comment">// 5 获取写锁，这里判断是否需要阻塞（这里考虑到公平还是非公平）</span></span><br><span class="line">        <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                <span class="comment">// 不需要阻塞，则更新 state</span></span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 当前线程独占锁</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>写锁获取使用 AQS 的独占模式获取同步状态的流程，整个流程如下：</p><ol><li>判断读锁是否被线程持有（包括当前线程自身），如果被持有则获取写锁直接失败。</li><li>判断是否是重入获取写锁，如果不是直接获取写锁失败。</li><li>根据具体的公平或非公平模式判断获取写锁是否需要阻塞，如果不需要阻塞则尝试获取写锁，成功后当前线程独占锁。</li></ol><h3 id="释放写锁"><a href="#释放写锁" class="headerlink" title="释放写锁"></a>释放写锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+--- WriteLock</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写锁释放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+-- AQS</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">+--- Sync</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS 模版方法，释放独占同步状态 - 释放写锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> releases</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  当前线程是否占有锁，否则没有资格尝试释放写锁</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算同步状态剩余值</span></span><br><span class="line">        <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写锁重入次数是否为 0 ，为 0 表示可以释放</span></span><br><span class="line">        <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完全释放</span></span><br><span class="line">        <span class="keyword">if</span> (free)</span><br><span class="line">            <span class="comment">// 清空独占线程</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 state</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>写锁的释放与 <code>ReentrantLock</code> 的释放过程基本类似，每次释放均减少写状态，当写状态为 0 时表示写锁可以被释放。</p><h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>ReentrantReadWriteLock 锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。<strong>锁降级是指持有写锁的线程在不释放写锁的同时，再获取到读锁，随后释放写锁，最后释放读锁</strong>。</p><p><strong>锁降级示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> ReentrantReadWriteLock reentrantReadWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"> ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line"> ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">volatile</span> Boolean updateFlag = Boolean.FALSE;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取缓存，一旦缓存被修改破坏，需要更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取读锁，该方法主要是读取缓存数据</span></span><br><span class="line">        readLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 共享数据发生改变，需要重新计算缓存数据</span></span><br><span class="line">        <span class="keyword">if</span> (updateFlag) &#123;</span><br><span class="line">            <span class="comment">// 必须先释放掉读锁，后续加写锁更新缓存</span></span><br><span class="line">            readLock.unlock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 获取写锁，用于只有一个线程更新缓存</span></span><br><span class="line">            writeLock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (updateFlag) &#123;</span><br><span class="line">                    <span class="comment">// 更新缓存值</span></span><br><span class="line">                    cacheData = caculateCacheData();</span><br><span class="line">                    updateFlag = Boolean.FALSE;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 获取读锁</span></span><br><span class="line">                readLock.lock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 3 释放写锁</span></span><br><span class="line">                writeLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以上 1、2、3 步完成锁降级，即写锁降级为读锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用缓存</span></span><br><span class="line">            System.out.println(<span class="string">"print cache: "</span> + cacheData);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述示例中，缓存数据可用时，每个线程只需获取读锁然后访问，数据访问完成后释放读锁。但当共享的缓存数据被破坏，此时所有访问 processData 方法的线程都能感知到，但只有一个线程能够获取写锁然后更新缓存，其它线程都会被阻塞。当线程更新完缓存数据后，会接着获取读锁，随后才会释放写锁，完成锁的降级。</p><p>锁降级中的读锁获取是否有必要？答案是必要的，主要是为了保证数据的可见性。如果线程计算完缓存后没有获取读锁而是直接释放掉了写锁，那么此时如果存在另一个线程 t 获取了写锁并修改了缓存，那么当前线程就无法感知线程 t 的数据更新。如果当前线程在释放掉写锁前获取读取，也就是遵循锁降级的步骤，则线程 t 就无法获取写锁，直到当前线程访问数据并释放掉读锁后，线程 t 才能有机会获取写锁更新缓存数据。</p><p><strong>注意:</strong> ReentrantReadWriteLock 不支持锁升级，即持有读锁时再获取写锁，随后释放读锁。不支持的目的是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新数据，则其更新对其它获取到读锁的线程是不可见的。此外，是为了避免发生死锁，试想一个线程先获取读锁，然后再获取写锁，那么该线程会由于获取写锁失败进入同步队列中等待，可能之后就不会被唤醒了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>ReentrantReadWriteLock 读写锁正如其名，具体分为读锁和写锁。无论是读锁还是写锁，整个获取与释放锁的流程都是交给实现 AQS 的 Sync 类型的对象完成，准确来说是公平 Sync 或者非公平 Sync 对象。对于读锁和写锁的语义，是将同步状态 <code>state</code> 划分为高低位，高 16 位表示读锁状态，低 16 位表示写锁状态。写锁的获取和释放锁类似重入锁 <code>ReentrantLock</code> 过程，唯一不同的是写锁需要考虑读锁的占有情况。读锁的获取和释放比较复杂，复杂的主要原因是读锁允许多个线程同时获取且支持可重入，此时同步状态的高 16 位的值没办法表示各个线程持有读锁的情况，因此读写锁新增了<strong>线程读锁计数器</strong>的概念，有了这个概念就可以很轻松判断读线程重入锁的情况以及实时获取当前线程持有读锁的次数。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/reentrant-read-write-lock-summary.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;独占锁（排它锁）在同一时刻只允许一个线程进行访问，如 &lt;a href=&quot;https://gentryhuang.com/posts/dd0f
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
      <category term="AQS" scheme="https://gentryhuang.com/tags/AQS/"/>
    
      <category term="Lock" scheme="https://gentryhuang.com/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - Redis主流程</title>
    <link href="https://gentryhuang.com/posts/19fe4bc5/"/>
    <id>https://gentryhuang.com/posts/19fe4bc5/</id>
    <published>2021-06-24T06:59:01.000Z</published>
    <updated>2021-07-09T07:08:44.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章将从源码层面对 Redis 主干轮廓进行说明。以主线程执行流程为主干，对途径的枝枝蔓蔓简单介绍，不会过度展开，后续将针对每一个模块进行详细分析。由于 Redis 是用 C 语言实现的，当然应该从 main 函数开启阅读源码旅程。需要说明的是，笔者阅读的 Redis 版本是 <code>#define REDIS_VERSION &quot;6.2.4&quot;</code>，之所以选择较新的版本，因为笔者对 Redis 一些新特性比较感兴趣，特别是 Redis 在 6.0 版本中提出的 IO 多线程。</p><h1 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h1><p>Redis 服务器启动的入口是 main 函数，其它的无需多说，下面直接上代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis Server 启动入口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *  Redis是用C语言实现的，从 main 函数启动。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">char</span> config_from_stdin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INIT_SETPROCTITLE_REPLACEMENT</span></span><br><span class="line">    <span class="comment">// 1 初始化库</span></span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 检查服务器是否以 Sentinel 模式启动</span></span><br><span class="line">    <span class="comment">// 这一点非常重要，因为 Sentinel 和普通的实例不同</span></span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3  初始化服务器配置</span></span><br><span class="line">    initServerConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 ACL 初始化（6.0 对 ACL 进行了功能丰富）</span></span><br><span class="line">    ACLInit(); <span class="comment">/* The ACL subsystem must be initialized ASAP because the</span></span><br><span class="line"><span class="comment">                  basic networking code and client creation depends on it. */</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 5 如果服务器以 Sentinel 模式启动，那么需要进行 Sentinel 功能相关的初始化，并为要监视的主服务器创建一些相应的数据结构</span></span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">        <span class="comment">// Sentinel 所属的属性覆盖服务器默认的属性</span></span><br><span class="line">        initSentinelConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哨兵模式初始化</span></span><br><span class="line">        initSentinel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 6 是否需要在 redis-check-rdb/aof模式下启动，这样可以校验持久化文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>], <span class="string">"redis-check-rdb"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_rdb_main(argc, argv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>], <span class="string">"redis-check-aof"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_aof_main(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7 检查用户是否指定了配置文件，或者配置选项</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">background</span> = server.daemonize &amp;&amp; !server.supervised;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8 将服务器设置为守护进程运行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">background</span>) daemonize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9 创建并初始化服务器</span></span><br><span class="line">    initServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🌟 服务器不是运行在 SENTINEL 模式，那么执行以下代码</span></span><br><span class="line">    <span class="keyword">if</span> (!server.sentinel_mode) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 10  bio 和 io 线程的初始化</span></span><br><span class="line">        InitServerLast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11 从 AOF 文件或者 RDB 文件中载入数据</span></span><br><span class="line">        loadDataFromDisk();</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                          <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">                          <span class="string">"Cluster mode. Exiting."</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 以 SENTINEL 模式运行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ACLLoadUsersAtStartup();</span><br><span class="line">        <span class="comment">// bio 和 io 线程的初始化</span></span><br><span class="line">        InitServerLast();</span><br><span class="line">        <span class="comment">// Sentinel 准备就绪后执行</span></span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12 🌟 启动事件处理循环</span></span><br><span class="line">    <span class="comment">// 主要围绕 IO多路复用 展开的，驱动注册的时间事件回调和 IO 事件回调</span></span><br><span class="line">    aeMain(server.el);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12 退出事件循环，回收内存</span></span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retun 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 服务启动后，主线程 main 会依次执行以上流程，直到进入 <strong>aeMain</strong> 事件处理循环方法中。需要说明的是，上述代码片段删除掉了不关心的逻辑，本篇文章我们只关注以下两个逻辑：</p><ul><li>执行各种初始化</li><li>执行事件循环</li></ul><p>Redis 服务器初始化逻辑较为复杂，从底层的数据结构到服务器不同的角色，初始化的逻辑和属性都不一样，这里就不展开了。下面对流程进行概括：</p><p><img src="/posts/19fe4bc5/redis-outline-main-process.jpg" alt></p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>事件循环逻辑是 Redis 核心的直接体现，它就是在这个循环中不断处理网络请求和内部自身逻辑的。下面我们直接上代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;<span class="built_in">stop</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程进入主循环，一直处理事件，直到服务器关闭</span></span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;<span class="built_in">stop</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始处理事件</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS |</span><br><span class="line">                                   AE_CALL_BEFORE_SLEEP |</span><br><span class="line">                                   AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，只要事件循环 <code>aeEventLoop</code> 没有被停止，主线程 main 就会一直自旋，不断执行 <code>aeProcessEvents</code> 方法。不难看出 <code>aeProcessEvents</code> 方法封装了 Redis 的所有功能逻辑，这里提前说下，Redis 的功能逻辑总共两大类：一个是网络事件，也称为文件事件；另一个是时间事件；前者用于处理网络中的交互，后者用于处理 Redis 自身的一些逻辑。</p><p>下面继续贴出 <code>aeProcessEvents</code> 方法的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing to do? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line">        <span class="keyword">int64_t</span> usUntilTimer = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取最近的时间事件</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            usUntilTimer = usUntilEarliestTimer(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.1 使用 usUntilTimer 来决定文件事件的阻塞时间</span></span><br><span class="line">        <span class="keyword">if</span> (usUntilTimer &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            tv.tv_sec = usUntilTimer / <span class="number">1000000</span>;</span><br><span class="line">            tv.tv_usec = usUntilTimer % <span class="number">1000000</span>;</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.2 执行到这里，说明没有时间事件。那么根据 AE_DONT_WAIT 是否设置来决定是否阻塞，以及阻塞的时间长度</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                <span class="comment">// 设置文件事件不阻塞</span></span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Otherwise we can block */</span></span><br><span class="line">                <span class="comment">// 文件事件阻塞直到有事件到达为止</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">            tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2 前置回调函数 - beforeSleep */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_BEFORE_SLEEP)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">        <span class="number">3</span> 调用多路复用 API，只会在超时或某些事件触发时返回。即等待事件产生</span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* 4 后置回调函数 - beforeSleep */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.1 从已就绪数组中获取文件描述符信息</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> fired = <span class="number">0</span>; <span class="comment">/* Number of events fired for current fd. */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.2 如果是套接字上发生读事件，调用读事件处理器处理读事件</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">                fired++;</span><br><span class="line">                fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Fire the writable event. */</span></span><br><span class="line">            <span class="comment">// 5.3 如果是套接字上发生写事件，调用写事件处理器处理写事件</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we have to invert the call, fire the readable event now</span></span><br><span class="line"><span class="comment">             * after the writable one.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 如果需要反转调用，在可写事件之后触发可读事件</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (invert) &#123;</span><br><span class="line">                fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">                <span class="keyword">if</span> ((fe-&gt;mask &amp; mask &amp; AE_READABLE) &amp;&amp;</span><br><span class="line">                    (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc)) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 6 如果是时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        <span class="comment">// 执行时间事件</span></span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码片段中也可以看到，主线程在不断轮询时间事件和文件事件，找到就尝试执行。上述代码虽然简短，但是却几乎包含了 Redis 的所有功能，秘密就在以下几个组件中：</p><ul><li>前置处理器 beforeSleep </li><li>IO多路复用库（及多种回调函数）</li><li>后置处理器 afterSleep</li></ul><p>关于以上代码片段背后的信息，会在后面的文章中介绍 Redis 事件一文中详细说明，这里先不展开。下面对以上方法进行概括：</p><p><img src="/posts/19fe4bc5/redis-outline-multi-process.jpg" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章简单介绍了 Redis 启动的入口以及执行的主干流程，这里有个印象即可，后续会对每个模块展开说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章将从源码层面对 Redis 主干轮廓进行说明。以主线程执行流程为主干，对途径的枝枝蔓蔓简单介绍，不会过度展开，后续将针对每一个模块进
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>网络通信 - IO多路复用</title>
    <link href="https://gentryhuang.com/posts/b25f5b99/"/>
    <id>https://gentryhuang.com/posts/b25f5b99/</id>
    <published>2021-06-12T02:43:23.000Z</published>
    <updated>2021-08-03T07:48:22.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>IO多路复用简单来说就是，单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力，IO多路复用解决的本质问题是用更少的资源完成更多的事。需要说明的是，处理IO多路复用的问题需要操作系统提供内核级别的支持，操作系统充当观察者的角色。本篇文章我们就来分析IO多路复用底层实现原理，我们以 Linux 操作系统提供的IO复用API <code>select</code>、<code>poll</code> 以及<code>epoll</code> 为例，逐一进行分析。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>实现IO多路复用直接使用用户线程轮询查看若干个文件描述符的状态难道不行吗？为什么要操作系统内核支持？在请求量比较小的时候确实可以使用该方案，但是在大量请求的情况下，这对于 CPU 的使用率来说无疑是种灾难。而使用操作系统内核帮我们观察文件描述符就可以优雅、高效地实现IO多路复用。</p><p>操作系统内核虽然清楚知道每个文件描述符对应的 Socket 的状态变化，但是内核如何知道该把哪个文件描述符信息给哪个进程呢？一个 Socket 文件可以由多个进程使用，而一个进程也可以使用多个 Socket 文件，进程和 Socket 之间是多对多的关系。此外，一个 Socket 也会对应多个事件类型。操作系统表示太难了，它很难判断将哪种事件给哪个进程。因此，在进程内部就需要维护自己关注哪些 Socket 文件的哪些事件，如读事件、写事件以及异常事件等。也就是说，内核帮应用程序盯着感兴趣的 Socket ，应用程序可以根据内核反馈的信息进一步处理网络请求。</p><p>下面我们带着这些问题，结合 Linux 下的IO复用API进行分析。</p><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>select 实现IO多路复用的思想是：操作系统内核会扫描用户进程传入的 3 类 fd_set 文件描述数组(本质是 bitmap)，当对应的 Socket 准备就绪时会置位（标志对应的 Socket 有数据来了） fd_set 数组中对于元素，最后将内核置位后的 fd_set 数组们拷贝回用户空间。由于 select 并不会明确指出是哪些文件描述符就绪（一股脑返回全部 fd），因此用户进程需要根据内核返回的 fd_set 数组们自行判断哪个文件描述符对应的 Socket 发生了哪种事件，然后再进一步处理。</p><h2 id="API定义"><a href="#API定义" class="headerlink" title="API定义"></a>API定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* According to earlier standards */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 监听感兴趣的文件描述符上的事件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, </span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *readfds, fd_set *writefds,fd_set *exceptfds, </span></span></span><br><span class="line"><span class="function"><span class="params">           struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd_set 可以理解为一个集合，这个集合中存放的是文件描述符，可通过以下四个宏进行设置：</span></span><br><span class="line"><span class="comment">// 1 将一个文件描述符移除集合中 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2  检查一个文件描述符是否在集合中，可以用这个来检测一次select调用之后有哪些文件描述符可以进行IO操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 添加一个文件描述符到集合中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 清空给定集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>select 将监听的文件描述符分为了 3 类，每一类都对应一个 fd_set 数组，本质上是一个 bitmap，也就是字节数组。分别是 <strong>writefds（写文件描述符）</strong>、<strong>readfds（读文件描述符）</strong>以及 <strong>exceptfds（异常事件文件描述符）</strong>。每一类都代表 Socket 对应的事件，每一类存储的都是 Socket 对应的文件描述符。用户进程可以根据需要准备相关 fd_set 数组，在调用 select 函数时，这三个事件参数可以用 NULL 来表示对应的事件不需要监听。其实也不难看出，select 模型下操作系统内核并没有维护存储文件描述符相关的数据结构，只是定义了 fd_set ，将维护工作交给了用户进程。</p><p>下面我们对 select 相关的每个函数进行说明。</p><p><strong>void FD_SET</strong></p><blockquote><p>用户进程可以调用 FD_SET 函数将指定的文件描述符 fd 设置到准备的 fd_set 数组中。</p></blockquote><p><strong>void FD_CLR</strong></p><blockquote><p>用户进程可以调用 FD_CLR 函数将指定的文件描述符 fd 从准备的 fd_set 数组移除。</p></blockquote><p><strong>void FD_ZERO</strong></p><blockquote><p>用户进程可以调用 FD_ZERO 函数将 fd_set 数组清空。该函数主要用来每次调用 select 函数之前，清空 fd_set 数组，因为每次调用 select 函数监听就绪的 Socket 时，内核会根据就绪的 Socket 情况修改用户进程传入的数组，将就绪的 Socket 对应在 fd_set 数组中元素置位，也就是说 fd_set 不可重用。</p></blockquote><p><strong>int select</strong></p><blockquote><p>用户进程可以在超时时间内，监听感兴趣的文件描述符上的事件（读/写/异常事件）发生。下面我们对相关参数和返回值进行说明。</p></blockquote><p>参数：</p><blockquote><ul><li><strong>int nfds:</strong> fd_set 数组当中最大描述符加 1，用来告知内核扫描的bitmap的范围。</li><li><strong>fd_set *readfds:</strong> 要监听的读事件就绪的 Socket 的文件描述符数组，传 NULL 表示对应的事件不需要监听。</li><li><strong>fd_set *writefds:</strong> 要监听的写事件就绪的 Socket 的文件描述符数组，传 NULL 表示对应的事件不需要监听。</li><li><strong>fd_set *exceptfds:</strong> 要监听的异常事件对应的 Socket 的文件描述符数组，传 NULL 表示对应的事件不需要监听。</li><li><strong>struct timeval *timeout:</strong> 超时时间</li></ul></blockquote><p>返回值：</p><blockquote><p>监听的就绪 Socket 的描述符其数目，若超时则为0，若出错则为-1</p></blockquote><p><strong>int  FD_ISSET</strong></p><blockquote><p>用户进程可以调用 FD_ISSET 函数判断文件描述符是否置位了，如果置位就说明对应的 Socket 已就绪。</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>准备监听的文件描述符上的事件</strong></p><p>应用程序可以根据具体需要，将 Socket 对应的文件描述符放入到 fd_set 数组中，在调用 select 函数时根据要监听的事件类型传入对应的 fd_set 数组。注意，Socket 不限于客户端的 Socket，服务端的 Socket 也可以，比如监听服务端 Socket 的连接事件发生。其中的用户进程通过调用 FD_SET 函数，将文件描述符写入到 fd_set 数组中，也就是将对应的位设置为 1，具体如下：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/io-multi-select-1.jpg" alt></p><p>对于 select 模型，操作系统内核只是定义了文件描述符事件相关数据结构 fd_set，并没有在内核中提供维护文件描述符事件的数据结构。也就是说，应用程序需要根据系统系统内核提供的 fd_set 自行处理文件描述符相关数据。</p><p><strong>等待文件描述符就绪</strong></p><p>应用进程调用 select 函数，操作系统内核会依次遍历传入的每类 fd_set 数组，判断 fd_set 中元素对应的 Socket 有没有数据，这个过程的事件复杂度为 O(n)。如果有数据就对 fd_set 数组中的该 Socket 对应的元素进行置位，最后内核将 fd_set 拷贝回用户空间，不会阻塞当前调用进程。如果要监听的 fd_set 中的所有 Socket 都没有数据，那么进程将会阻塞在 select 函数上，直到超时或有 Socket 就绪，才会唤醒进程。</p><p>在内核遍历 fd_set 数组时，如果对应的 Socket 没有数据，那么内核会将用户进程加入到该 Socket 的等待队列中，这一点非常重要。</p><p><strong>文件描述符就绪</strong></p><p>当监听的任何一个 Socket 就绪时，中断程序将唤醒 Socket 等待队列中的进程，即每次唤醒都需要从每个 Socket 等待队列中移除进程。当用户进程被唤醒时，它知道至少有一个监视的 Socket 发生了感兴趣的事件。同时，内核会对该 Socket 对应在 fd_set 数组中的元素进行置位，然后将修改后的 fd_set 数组们拷贝回用户空间。</p><p>注意，select 虽然可以拿到内核修改后的 fd_set 数组，但是它并不知道是哪个 Socket 发生了哪个事件，需要用户进程自己去判断。</p><p><strong>处理网络请求</strong></p><p>用户进程拿到内核返回的 fd_set 数组包含整个文件描述符，程序不知道哪些 Socket 就绪，因此需要自行判断是哪个或哪些 Socket 发生了哪个事件，找到对应的 Socket 后，处理网络请求。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个服务端 Socket 套接字，</span></span><br><span class="line">sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span> (addr));</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">2000</span>);</span><br><span class="line">addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">bind(sockfd,(struct sockaddr*)&amp;addr ,<span class="keyword">sizeof</span>(addr));</span><br><span class="line"><span class="built_in">listen</span> (sockfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备客户端连接对应的文件描述符</span></span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">  addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">  <span class="comment">// 创建客户端 Socket 套接字,并保存对应的文件描述符</span></span><br><span class="line">  <span class="comment">// 注意，文件描述符是操作系统随机分配的一个非负整数</span></span><br><span class="line">  fds[i] = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存最大的文件描述符</span></span><br><span class="line">  <span class="keyword">if</span>(fds[i] &gt; <span class="built_in">max</span>)</span><br><span class="line">      <span class="built_in">max</span> = fds[i];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select 实现多路复用</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">   <span class="comment">// 1 调用  FD_ZERO 清理 rset 数组</span></span><br><span class="line">   FD_ZERO(&amp;rset);</span><br><span class="line">   <span class="comment">// 2 调用 FD_SET 设置监听的文件描述符到 rset 数组中</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">       FD_SET(fds[i],&amp;rset);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3 调用 slect 函数阻塞等待数据的到来，内核会判断 Socket 就绪情况</span></span><br><span class="line">   <span class="comment">// max+1 告知内核扫描 fd_set 数组范围</span></span><br><span class="line">   <span class="comment">// 这里只传入了 fd_set *readfds 参数，表示只监听读事件</span></span><br><span class="line">   select(<span class="built_in">max</span>+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4 监听的 Socket 有读就绪</span></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">       <span class="comment">// 调用 FD_ISSET 判断 rset 是否有置位</span></span><br><span class="line">       <span class="keyword">if</span> (FD_ISSET(fds[i], &amp;rset))&#123;</span><br><span class="line">           <span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,MAXBUF);</span><br><span class="line">           <span class="built_in">read</span>(fds[i], <span class="built_in">buffer</span>, MAXBUF);</span><br><span class="line">           <span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>单个进程能够监视的文件描述符的数量存在最大限制，通常是 1024 ，当然可以更改数量，但由于 select 采用轮询的方式扫描文件描述符，文件描述符数量越多，性能越差。</li><li>每次调用 select，都需要把 fd 数组在用户空间与内核空间来回拷贝，并且内核需要遍历传递进来的所有 fd 才能知道是否有 fd 准备就绪，这个开销随着 fd 变多而增大。</li><li>select 返回的是含有整个文件描述符的数组，并非明确指出哪些文件描述符就绪了，因此应用程序需要遍历整个数组才能发现哪些文件描述符号对应的 Socket 发生了事件。</li></ol><h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><p>poll 的实现和 select 非常相似，只是描述 fd 集合的方式不同，它们的工作原理是一样的。select 是将文件描述符分为了 3 类，使用 fd_set 结构存储，针对每一类文件描述符可关联对应的事件。poll 对所有文件描述符一视同仁，针对每个文件描述关联事件即可。具体的做法是是通过定义了一个结构体 pollfd，将文件描述符和感兴趣的事件绑定在一起。这就是 poll 和 select 的主要区别，也就是说 poll 使用 pollfd 数组解决了 select 使用 bitmap 存储文件描述符数量限制问题。需要注意的是，poll 仍然没有解决 select 中的其它问题。</p><h2 id="API-定义"><a href="#API-定义" class="headerlink" title="API 定义"></a>API 定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 感兴趣的事件</span></span><br><span class="line">    short events; <span class="comment">/* requested events to watch */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核检测到的实际事件</span></span><br><span class="line">    short revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">    </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>下面对 poll 函数的参数和返回值说明。</p><p>参数：</p><blockquote><ul><li><strong>struct pollfd *fds:</strong> 该数组用于存放用户进程监听的 Socket 文件描述符事件信息，每一个元素都是 pollfd 结构。fd 属性用于存放关注的 Socket 文件描述符；events 属性用于存方关注的事件；revents 是内核检测到 fd 对应的 Socket 实际发生的事件。</li><li><strong>nfds_t nfds:</strong> 用于告诉内核 fds 数组的大小，内核会根据该参数去遍历 fds 数组。</li><li><strong>int timeout:</strong> 阻塞等待的超时时间</li></ul></blockquote><p>返回值：</p><blockquote><p>fds 集合中就绪的描述符数量，返回 0 表示超时，返回 -1 表示出错。</p></blockquote><h2 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">   addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">   <span class="comment">// 1 使用 pollfd 结构准备文件描述符</span></span><br><span class="line">   pollfds[i].fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">   <span class="comment">// 设置感兴趣的事件</span></span><br><span class="line">   pollfds[i].events = POLLIN;</span><br><span class="line">  &#125;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 调用 poll 阻塞等待数据的到来，内核会判断 Socket 就绪情况</span></span><br><span class="line">    poll(pollfds, <span class="number">5</span>, <span class="number">50000</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 用户进程自己判断哪个 Socket 发生了 POLLIN </span></span><br><span class="line">        <span class="keyword">if</span> (pollfds[i].revents &amp; POLLIN)&#123;</span><br><span class="line">            <span class="comment">// 重置 revents ，</span></span><br><span class="line">            pollfds[i].revents = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,MAXBUF);</span><br><span class="line">            <span class="built_in">read</span>(pollfds[i].fd, <span class="built_in">buffer</span>, MAXBUF);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>poll 的改进主要是围绕着存储文件描述符事件的结构体 pollfd 来展开的</strong>，用户进程准备的各种文件描述符事件都是由该结构体存储的，此外内核检测到 Socket 就绪会设置对应的 pollfd 中的 revents 属性的值。虽然 poll 提供了更优质的编程接口，但是本质和 select 模型相同。因此千级并发以下的 I/O，可以考虑 select 和 poll 模型，但是如果出现更大的并发量，就需要用 epoll 模型。可以看到，当套接字 Socket 比较多的时候，不管哪个 Socket 是活跃的，对于使用 select 或 poll 模型都需要遍历一遍,这会浪费很多CPU资源。如果能给套接字 Socket 注册某个回调函数，当他们活跃时自动完成相关操作，那就避免了轮询，这正是 epoll 做的。</p><h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><p><strong>epoll</strong> 是对 <strong>select</strong> 和 <strong>poll</strong> 的改进。它的核心思想是基于<strong>事件驱动</strong>来实现的，操作系统内核维护<strong>一颗红黑树</strong>来存储文件描述符相关信息和维护一个<strong>链表</strong>来存放准备就绪的文件描述符对应的 Socket 相关的事件信息。其实，这两个数据结构存储的元素都和 epitem 结构有关，不过为了方便描述，通常都会说存储的是文件描述符，后面我们会详细介绍 epitme 结构。</p><h2 id="API-定义-1"><a href="#API-定义-1" class="headerlink" title="API 定义"></a>API 定义</h2><p>下面列举 epoll 提供的API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 epoll 实例，返回 epoll 专用文件描述符（Linux 优化后废弃了参数）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于往 epoll 实例中增删改要检测的文件描述符事件</span></span><br><span class="line">    <span class="comment">// 根据具体操作调整调整红黑树和就绪链表</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于阻塞等待可以执行IO操作的文件描述符事件，直到超时</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>上面列举了Linux中提供的epoll相关API，下面我们依次介绍这些函数。</p><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><p>当某一进程成功调用<strong>epoll_create</strong>函数时，Linux 内核会创建一个 <strong>epoll</strong> 实例，并返回其文件描述符。下面是 epoll 实例对应的结构体，我们只关注核心属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_wait 使用的等待队列，和用户进程唤醒有关</span></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> wq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就绪队列，用于存放就绪的文件描述符事件信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树的根节点，这颗树中存储着所有添加到 epoll 中的文件描述符信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般一个进程对应一个 <strong>epoll</strong> 实例，每个 <strong>epoll</strong> 实例都有一个独立的 <strong>eventpoll</strong> 结构体。更详细的结构如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/io-multi-epoll-1.jpg" alt></p><p>值得注意的是，进程在调用以上函数创建 <strong>epoll</strong> 对象的同时，会初始化以上三个核心数据结构：</p><ul><li><strong>wq:</strong> 等待队列链表。中断数据就绪的时候会通过 wq 来找到阻塞在 epoll 对象上的用户进程（调用 epoll_wait 函数的进程）。</li><li><strong>rdllist:</strong> 就绪链表。当有文件描述符对应的 Socket 就绪时，内核会将该 Scocket 等待队列中的 epitem 的 rdllink 成员添加到该就绪链表中。</li><li><strong>rbr:</strong> 一颗红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll 内部使用了一颗红黑树。通过这颗树来管理用户进程下添加进来的文件描述符。注意，红黑树节点并不是文件描述符，而是内核对文件描述符和事件信息封装的 epitem 的 rbn 成员。</li></ul><p>至此，这些成员其实还只是刚被定义或初始化，都还没有用到，它们会在下面被用到。</p><h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><p>某一进程通过调用 <strong>epoll_ctl</strong> 函数向 epoll 对象中添加、删除、修改感兴趣的<strong>文件描述符事件信息</strong>，返回0标识成功，返回-1表示失败。该方法的参数很重要，下面我们详细分析各个参数的作用。</p><p><strong>int epfd</strong><br>表示 epoll 实例的文件描述符，也就是 <strong>epoll_create</strong> 函数调用成功返回的值。随便说一句，文件描述符是一个非负整数。</p><p><strong>int op</strong><br>表示对文件描述符 fd 的监听事件的操作，操作类型如下：</p><blockquote><ul><li>EPOLL_CTL_ADD：注册新的 fd 的监听事件</li><li>EPOLL_CTL_MOD：修改已经注册的 fd 的监听事件</li><li>EPOLL_CTL_DEL：删除 fd 的监听事件</li></ul></blockquote><p><strong>int fd</strong><br>表示要监听的文件描述符，该文件描述符对应的 Socket 可能发生不同的操作，进而产生不同的事件。</p><p><strong>struct epoll_event *event</strong><br>表示要监听的文件描述符 fd 对应的 Socket 发生的事件，该事件的结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户附加数据定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span>        *ptr; <span class="comment">/*指向用户自定义数据*/</span></span><br><span class="line">    <span class="keyword">int</span>          fd;  <span class="comment">/*注册的文件描述符*/</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     u32; </span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll 监听事件定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="comment">// 描述 epoll 事件</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 专门给用户使用的，具体见上面的结构体</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>epoll_event</strong> 包括两部分信息，一个是文件描述符的事件信息，另一个是为使用方提供的属性。这个结构非常重要，使用方向 epoll 实例注册监听事件信息时，需要在 <strong>data</strong> 域写入文件描述符相关信息，当有文件描述符对应的 Socket 准备就绪时，会间接将对应的 epoll_event 拷贝会用户空间，用户进程就可以根据 epoll_event 中的 events 事件信息和 data 中用户指定的文件描述符 fd，进而可以根据事件信息去操作文件描述符对应 Socket 。</p><p>常用的 epoll 事件描述如下：</p><ul><li>EPOLLIN：描述符处于可读状态</li><li>EPOLLOUT：描述符处于可写状态</li><li>EPOLLET：将epoll event通知模式设置成 edge triggered</li><li>EPOLLONESHOT：第一次进行通知，之后不再监测</li><li>EPOLLHUP：本端描述符产生一个挂断事件，默认监测事件</li><li>EPOLLRDHUP：对端描述符产生一个挂断事件</li><li>EPOLLPRI：描述符有紧急的数据可读</li><li>EPOLLERR：描述符产生错误时触发，默认检测事件</li></ul><p>下面我们只考虑注册新的文件描述符的监听事件。在调用 epoll_clt 函数注册文件描述符事件时，Linux 内核会做以下工作：</p><ol><li>根据传入的参数初始化一个 epitem 对象，该对象是内核管理文件描述符的基础，后续红黑树和就绪链表中的数据都要用到它。</li><li>为传入的文件描述符对应的 Socket 新建一个等待队列项，其中的回调函数为 ep_poll_callback（该回调函数会在 Socket 准备就绪后触发），base 指针指向步骤 1 初始化的 epitem，它将来会作为添加到就绪链表的数据源。然后将该等待队列项加入到 Socket 的等待队列中。</li><li>将 epitem 的 rbn 成员插入到红黑树中。红黑树主要用来维护进程添加的文件描述符，这样就可以避免每次获取就绪 Socket 信息时都要重新拷贝一遍所有的文件描述符到内核态，并能在插入，查找和删除的操作发生高效执行。</li></ol><p>在 epoll 中，内核会根据传入的文件描述和事件，将相关信息封装成 <strong>epitem</strong> 对象，epitem 结构如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>&#123;</span></span><br><span class="line">    <span class="comment">// 红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>  <span class="title">rbn</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 就绪链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">rdllink</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件描述符具体信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>  <span class="title">ffd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向其所属的 eventpoll 对象  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span>   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听的事件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span>&#123;</span></span><br><span class="line">    <span class="comment">// Socket 文件地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单说明下，epoll 为啥要使用红黑树呢？使用红黑树是基于 epoll 在查询效率、插入效率、删除效率以及内存开销等多方面均衡的结果。</p><h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><p>某一进程通过调用 <strong>epoll_wait</strong> 函数阻塞等待就绪文件描述符，成功时返回就绪的事件数目，调用失败时返回 -1，等待超时返回 0。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><strong>int epfd</strong><br>表示 epoll 实例的文件描述符，也就是 <strong>epoll_create</strong> 函数调用成功返回的值。</p><p><strong>struct epoll_event *events</strong><br>关注的文件描述符对应的 Socket 有事件触发时，内核会将对应的事件信息写入 events 数组中并拷贝回用户空间。</p><p><strong>int maxevents</strong><br>通知内核 events 的大小，内核会根据该值从就绪链表中写数据到 events 数组中。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>epoll_wait 做的事情相对比较简单，当用户进程调用它时会直接观察<strong>就绪链表</strong>中有没有数据即可。</p><p><strong>有数据</strong><br>内核会将就绪链表中元素对应的事件信息写入到 events 并拷贝回用户空间就结束了。</p><p><strong>等待文件描述符就绪</strong><br>没有数据，则创建一个等待队列项，将用户进程设置到等待队列项，并且设置一个 default_wake_function 回调函数（将来用来唤醒当前进程），然后添加到 eventpoll 的等待队列上，阻塞当前用户进程。需要注意的是，epoll_ctl 过程中是为文件描述符对应的 Socket 创建等待队列项，这里是为 epoll 创建等待队列项。从这个过程也可以看出，epoll 也是会阻塞当前进程的，这个是合理的，因为没有事情可做了占着 CPU 也没啥意义。</p><p><strong>文件描述符就绪</strong></p><p>当 Socket 就绪时，内核会找到 Socket 等待队列中设置的回调函数 ep_poll_callback 并执行该函数，该函数会根据等待队列项的 base 属性找到 epitem 对象，进而也可以找到 eventpoll 对象。接着将找到的 epitem 的 rdllink 添加到 epoll 的就绪链表中，最后会查看 eventpoll 的等待队列中是否有等待项，也就是查看是否有用户进程在等待，如果没有则执行中断的事情就做完了。如果有就查找到等待项里设置的回调函数 default_wake_function 并执行，唤醒阻塞的用户进程。</p><p><strong>处理网络请求</strong></p><p>当进程醒来之后，继续从 epoll_await 时暂停的代码继续执行，同时内核向用户空间拷贝就绪事件信息到 events 参数中，用户进程可以根据返回的具体信息处理网络请求。</p><h2 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[5];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 创建一个 epoll 实例</span></span><br><span class="line"><span class="keyword">int</span> epfd = epoll_create(<span class="number">10</span>);</span><br><span class="line"> ...</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line"> &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 2 epoll 监听事件定义</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">  addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.1 设置 fd </span></span><br><span class="line">  ev.data.fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">  <span class="comment">// 2.2 设置监听事件</span></span><br><span class="line">  ev.events = EPOLLIN;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3 向 epoll 注册 文件描述符事件</span></span><br><span class="line">  epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4 调用 epoll_wait 阻塞等待数据的到来，内核会判断 Socket 就绪情况，并把就绪的 Socket 相关的 epoll_event 拷贝出用户空间</span></span><br><span class="line">   <span class="comment">// 返回的就绪 Socket 的个数</span></span><br><span class="line">   nfds = epoll_wait(epfd, events, <span class="number">5</span>, <span class="number">10000</span>);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 只需要遍历 nfds 个数即可</span></span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;i++) &#123;</span><br><span class="line">           <span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,MAXBUF);</span><br><span class="line">           <span class="built_in">read</span>(events[i].data.fd, <span class="built_in">buffer</span>, MAXBUF);</span><br><span class="line">           <span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ol><li>epoll 为了减少文件描述符频繁的拷贝开销，在内核中维护了一颗红黑树用来存储文件描述符信息。并不是说 epoll 完全避免了文件描述符的拷贝，epoll 只会在新增/修改/删除的时候进行拷贝工作，避免了每次获取就绪数据信息时的重复拷贝。</li><li>epoll 使用了一个就绪链表来解决准确通知问题，也就是只会将就绪的 Socket 信息返回给用户空间，即可以直接从 events 参数中获取就绪的文件描述符的信息，无需遍历整个所有文件描述符集合。</li><li>epoll 阻塞用户进程时只会将其添加到 epoll 实例的等待队列中，而不需要将用户进程轮流加入到文件描述符对应的 Socket 的等待队列中。并且 epoll 模型为文件描述符对应的 Socket 设置一个回调函数，当 Socket 就绪时会触发该函数的调用，这就是基于事件驱动模型。基于事件驱动内核就可以避免遍历所有文件描述符的开销。</li></ol><h1 id="方案比较"><a href="#方案比较" class="headerlink" title="方案比较"></a>方案比较</h1><ol><li>select 和 poll 基本类似，都是使用内核定义的数据结构来进行文件描述符的存储，select 采用 bitmap ，poll 采用数组。select 会受到最大连接数的限制，而 poll 在一定程度上解决了这个问题。而 epoll 则是内核专门维护了一颗红黑树来存储文件描述符信息。前两个文件描述符信息需要用户空间维护，而后者是在内核空间维护的。</li><li>select 和 poll 都需要将有关文件描述符的数据结构在用户空间和内核空间来回拷贝，而 epoll 只会在新增/修改/删除的时候进行拷贝工作。</li><li>select 和 poll 采用轮询的方式来检查文件描述符是否处于就绪状态，而 epoll 采用回调机制。造成的结果是，随着文件描述符的增加，select 和 poll 的效率会线性降低，而 epoll 受到的影响较小，除非活跃的 Socket 较多。 </li><li>select 、poll 以及 epoll 虽然都会返回就绪的文件描述符数量。但是 select 和 poll 并不会明确指出是哪些文件描述符就绪，而 epoll 可以做到。用户进程返回后，调用 select 和 poll 的程序需要遍历监听整个文件描述符，而 epoll 得益于内核就绪链表则可以直接处理。</li></ol><p>注意，虽然 epoll 的性能最好，但是在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，毕竟 epoll 的通知机制需要很多函数回调，这也是需要有开销的。</p><h1 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h1><h2 id="水平触发"><a href="#水平触发" class="headerlink" title="水平触发"></a>水平触发</h2><p>当内核有事件到达，会拷贝给用户空间，如果应用程序没有处理完或者压根都没有处理，那么会在下一次再次返回没有处理的事件。这样，如果应用程序永远不处理这个事件，就导致每次都会有该事件从内核空间到用户空间的拷贝，消耗性能。但是水平触发相对安全，最起码事件不会丢掉，除非用户处理完毕。</p><h2 id="边缘触发"><a href="#边缘触发" class="headerlink" title="边缘触发"></a>边缘触发</h2><p>边缘触发，相对跟水平触发相反，当内核有事件到达，只会通知应用程序一次，至于应用程序处理还是不处理，以后将不会再通知。这样减少了拷贝过程，增加了性能，但是会产生事件丢失的情况。</p><p>对于 select 和 poll 来说，其触发都是水平触发。而 epoll 既支持水平触发也支持边缘触发。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对IO多路复用的实现方案进行了介绍，主要以 Linux 系统的 slect、poll 和 epoll 为主线进行说明。下面给出总结表：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/io-multi-2.jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;IO多路复用简单来说就是，单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力，IO多路复用解决的本质问题是用更少的资源完成更多
      
    
    </summary>
    
    
      <category term="网络通信" scheme="https://gentryhuang.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="I/O" scheme="https://gentryhuang.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>网络通信 - IO模型</title>
    <link href="https://gentryhuang.com/posts/51fff883/"/>
    <id>https://gentryhuang.com/posts/51fff883/</id>
    <published>2021-06-05T07:36:47.000Z</published>
    <updated>2021-08-03T07:48:22.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章将对网络通信相关的基本概念进行说明，并重点对常见的 I/O 模型进行介绍，接着介绍套接字并引出 I/O 多路复用。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><p>输入输出(input/output)的对象可以是文件(file)、网络(socket)、进程之间的管道。在Linux系统中，都用文件描述符(fd)来表示。</p><h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>没有数据传过来时，读会阻塞直到有数据；缓冲区满了，写操作也会阻塞。非阻塞都是直接返回。阻塞和非阻塞强调的是调用者是否等待。</p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>数据就绪后需要应用程序自己去读是同步。数据就绪后通过回调给到应用程序是异步。同步与异步强调的是获取数据的操作是由调用者还是被调用者完成。</p><h2 id="内核空间与用户空间"><a href="#内核空间与用户空间" class="headerlink" title="内核空间与用户空间"></a>内核空间与用户空间</h2><p>在 Linux 中，应用程序的稳定性远远比不上操作系统程序，为了保证操作系统的稳定性，分出了<strong>内核空间</strong>和<strong>用户空间</strong>。内核空间运行操作系统程序和驱动程序，用户空间运行应用程序。所有的系统资源操作都在内核空间进行，比如读写磁盘文件、内存分配和回收以及网络接口调用等。不难看出，一次网络IO读取过程中，数据并不是直接从网卡读取到用户空间中的应用程序缓冲区，而是先从网卡拷贝到内核空间缓冲区，然后再从内核拷贝到用户空间中的应用程序缓冲区。对于网络IO写入过程则相反，先将数据从用户空间中的应用程序缓冲区拷贝到内核缓冲区，再从内核缓冲区把数据通过网卡发送出去。</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>零拷贝是一种避免多次内存复制的技术，用来优化读写IO操作。</p><p>Linux 内核中的 mmap 函数可以将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址，不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理内存地址。这种方式实现用户空间和内核空间共享一个缓存数据，避免了内核空间与用户空间的数据交换。I/O 复用中的 epoll 函数中就是使用了 mmap 减少了内存拷贝。</p><p>在 Java 中，在用户空间中又存在一个拷贝，即从 Java 堆内存中拷贝到临时的直接内存中，通过临时的直接内存拷贝到内核空间中去。此时的直接内存和堆内存都是属于用户空间。<code>DirectBuffer</code> 是直接分配物理内存（非堆内存）的，它直接将过程简化为数据直接保存到非堆内存，这样就减少了一次拷贝。注意，<code>DirectBuffer</code> 只优化了用户空间内部的拷贝。而在 NIO 中，<code>MappedByteBuffer</code> 是通过本地类调用 mmap 进行文件内存映射的，可以直接将文件从网卡拷贝到用户空间，只进行一次数据拷贝，从而减少了传统的 read() 方法从网卡拷贝到内核空间这一步。</p><h1 id="网络IO模型"><a href="#网络IO模型" class="headerlink" title="网络IO模型"></a>网络IO模型</h1><p>Linux 网络IO模型包括：<strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong> 。需要说明的是，操作系统层面的IO模型和Java中的IO模型是一一对应的，Java只是堆操作系统API进行了封装。</p><p>对于一个网络IO通信过程会涉及两个对象，一个是执行IO操作的用户线程，另一个是操作系统内核。一个进程的地址空间分为用户空间和内核空间，用户线程不能直接访问内核空间。</p><h2 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h2><p>用户线程发起read 请求后就阻塞了，此时会让出 CPU 。内核等待网卡数据到来，把数据从网卡拷贝到内核空间，接着把数据拷贝到用户空间，再把用户线程唤醒。这样情况下，需要为每个连接都分配一个线程，在大量连接的场景下就需要大量的线程，会造成巨大的性能损耗，这也是传统阻塞IO的最大缺陷。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/net-io-base-1.png" alt></p><h2 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h2><p>用户线程在发起 read 请求后立即返回，如果没读取到数据，用户线程会不断轮询发起 read 请求，直到数据到达（内核准备好数据）后才停止轮询，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的，等数据到了用户空间再把线程唤醒。非阻塞IO模型虽然避免了由于线程阻塞问题带来的大量线程消耗，但是频繁地重复轮询大大增加了请求次数，对CPU消耗也比较明显。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/net-io-base-2.png" alt></p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>用户线程的读取操作分成两步了，线程先发起 select 调用，目的是问内核数据准备好了吗？等内核把数据准备好了，用户线程再发起 read 调用。在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的。注意，等待 select 返回过程也是阻塞的，所以说IO多路复用并非完全非阻塞。那为什么叫 I/O 多路复用呢？因为一次 select 调用可以向内核查多个数据通道（Channel）的状态，所以叫多路复用。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/net-io-base-3.png" alt></p><h2 id="信号驱动式IO"><a href="#信号驱动式IO" class="headerlink" title="信号驱动式IO"></a>信号驱动式IO</h2><p>用户线程发起 read 请求，会通过系统调用 sigaction 函数，给对应的套接字注册一个信号回调，此时不阻塞用户进程，进程会继续工作。当内核数据就绪时，内核就为该进程生成一个 SIGIO 信号，通过信号回调通知进程进行相关 IO 操作。</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>用户线程发起 read 请求的同时注册一个回调函数，read 立即返回，等内核已经读取完数据并把数据放到了应用进程的缓冲区中，再调用指定的回调函数完成处理。在这个过程中，用户线程一直没有阻塞。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/net-io-base-4.png" alt></p><p>介绍完常见的网络IO模型后，下面我们对 Socket(套接字) 进行说明。</p><h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><p>所谓套接字(Socket)，可以抽象成两个程序进行通讯连接中的一个端点，提供了应用层进程利用网络协议交换数据的机制。要通过互联网进行通信，至少需要一对套接字，一个运行于客户机端，另一个运行于服务器端。不同编程语言对套接字（Socket）都有对应的封装，如 Java 中的 <strong>ServerSocket/Socket</strong>，Python 中引用套接字的模式是 socket 。本质上来说，套接字是操作系统层面的产物，它既是一种编程模型，同时又是一个文件（操作系统提供支持网络通信的一种文件格式）。</p><h2 id="Socket-编程模型"><a href="#Socket-编程模型" class="headerlink" title="Socket 编程模型"></a>Socket 编程模型</h2><p>套接字（Socket）通信过程如下图所示，这里以流式套接字（TCP）为例：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/socket-process-1.jpg" alt></p><p>下面对上图的流程简单说明：</p><ol><li>应用程序通过系统调用 <strong>socket</strong> 创建一个套接字，它是操作系统分配给应用程序的一个文件描述符（用来标识套接字（Socket）的）。</li><li>应用程序会通过系统调用 <strong>bind</strong>，绑定地址和端口，给套接字命名一个名称。</li><li>系统会调用 <strong>listen</strong> 创建一个<strong>队列</strong>用于存放客户端进来的连接。</li><li>应用服务会通过系统调用 accept 来监听客户端的连接请求。</li></ol><h2 id="双向管道文件"><a href="#双向管道文件" class="headerlink" title="双向管道文件"></a>双向管道文件</h2><p>套接字（Socket）是一个支持网络通信的文件，存储的是数据。服务端 Socket 文件存储的是客户端 Socket 文件描述符；客户端 Socket 文件存储的是传输数据。</p><p>当一个客户端连接到服务端的时候，操作系统就会创建一个客户端 Socket 的文件。然后操作系统将这个文件的文件描述符写入服务端程序创建的服务端 Socket 文件中。进程可以通过 accept() 方法，从服务端 Socket 文件中读出客户端的 Socket 文件描述符，从而拿到客户端的 Socket 文件。Socket 是一个双向的管道文件，当线程想要读取客户端传输来的数据时，就从客户端 Socket 文件中读取数据；当线程想要发送数据到客户端时，就向客户端 Socket 文件中写入数据。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/IO/socket-process-2.jpg" alt></p><p><strong>注意：</strong></p><blockquote><p>1 服务端维护的 Socket 数量是 N+1，包括 N 个与客户端对应的 Socket 和一个监听 Socket 。<br>2 操作系统创建的 Socket 是由文件系统管理的，内核中有一个文件列表(fd)管理这些 Socket。</p></blockquote><h2 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h2><p>如何同时监视多个 Socket 呢？答案就是多路复用。</p><p>在 IO 多路复用技术中，应用进程（或线程）需要维护一个 Socket 集合（可以是数组、链表等），然后定期遍历这个集合，判断每个 Socket 文件的状态。这些 Socket 文件的状态如：服务端 Socket 文件写入客户端 Socket 文件描述符，客户端 Socket 文件的读、写等操作。这样的做法在客户端 Socket 较少的情况下没有问题，但是如果接入的客户端 Socket 较多，比如达到上万，那么每次轮询的开销都会很大。</p><p>为了解决这个问题，就需要一个观察者角色，观察者需要知道每个 Socket 文件的状态，这样就可以在 Socket 文件状态发生改变时，把相关信息推送应用进程了。这种方式就不需要应用进程主动轮询。不难发现，最合适的观察者其实就是操作系统本身，因为操作系统非常清楚每一个 Socket 文件的状态（包括服务端和客户端的 Socket），毕竟对 Socket 文件的读写都要经过操作系统。具体来说，每个 Socket 对应着一个端口号，而网络数据包中包含了 ip 和端口的信息，内核可以通过端口号找到对应的 Socket 。</p><p>总结起来就是：单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力，IO多路复用解决的本质问题是用更少的资源完成更多的事。注意，处理IO多路复用的问题，需要操作系统提供内核级别的支持。如 Linux 下有三种提供IO多路复用的 API，分别是 <code>select</code>、<code>poll</code> 以及<code>epoll</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章将对网络通信相关的基本概念进行说明，并重点对常见的 I/O 模型进行介绍，接着介绍套接字并引出 I/O 多路复用。&lt;/p&gt;
&lt;h1 
      
    
    </summary>
    
    
      <category term="网络通信" scheme="https://gentryhuang.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="I/O" scheme="https://gentryhuang.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - 事务</title>
    <link href="https://gentryhuang.com/posts/a26fab1/"/>
    <id>https://gentryhuang.com/posts/a26fab1/</id>
    <published>2021-05-27T12:08:59.000Z</published>
    <updated>2021-06-28T06:23:41.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Redis 通过 <strong>MULTI</strong>、<strong>EXEC</strong>、<strong>DISCARD</strong> 以及 <strong>WATCH</strong> 命令来实现事务功能。与我们所熟知的事务最大的不同是，Redis 实现的事务不支持回滚特性。此外，Redis 事务的 ACID 特性也并不完整，不同的情况下表现会有不同。Redis 事务也被称为 <strong>半事务</strong>，它是简单地使用队列存放一组 Redis 命令。</p><h1 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h1><p>Redis 事务的执行过程包含三个阶段，如下：</p><blockquote><ol><li>开启事务</li><li>命令入队</li><li>事务执行/取消</li></ol></blockquote><p>下面我们分别对以上三个阶段进行说明，并介绍核心的实现逻辑。</p><h2 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h2><p>Redis 客户端执行 <strong>MULTI</strong> 命令标志着事务的开启:</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt;</span><br></pre></td></tr></table></figure><p><strong>MULTI</strong> 命令可以将执行该命令的客户端从<strong>非事务状态</strong>切换到<strong>事务状态</strong>，这一切换是将客户端的 <code>flags</code> 属性设置为 <code>CLIENT_MULTI</code> 标识来完成的。</p><p><strong>MULTI 命令的实现逻辑如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * multi 命令对应的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 检测客户端状态，不支持在事务中嵌套事务</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReplyError(c, <span class="string">"MULTI calls can not be nested"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 开启事务，即设置客户端的状态标志为 CLIENT_MULTI</span></span><br><span class="line">    c-&gt;flags |= CLIENT_MULTI;</span><br><span class="line"></span><br><span class="line">    addReply(c, shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，Redis 开启事务主要是将当前客户端的状态标志属性 <code>flags</code> 设置为 <code>CLIENT_MULTI</code>。Redis 事务的生命周期是和该状态标志紧密相关的，除此状态外，命令入队出错需要将客户端的状态设置为 <code>REDIS_DIRTY_EXEC</code>，客户端监视的键被改动需要将客户端的状态设置为 <code>REDIS_DIRTY_CAS</code>，这两种情况将在下文进行介绍。</p><h2 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h2><p>Redis 在没有开启事务时，即一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行，这个也是我们日常多使用的方式。与此不同的是，当一个客户端开启事务，即一个客户端处于事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：</p><ul><li>如果客户端发送的命令为 <code>EXEC</code> 或 <code>DISCARD</code> ，那么服务器会立即执行这个命令，进行事务的提交或取消。</li><li>如果客户端发送的命令是操作数据命令，那么服务器并不会立即执行这个命令，而是将这个命令加入到<strong>事务队列</strong>中，然后向客户端返回 <code>QUEUED</code> 回复，标识加入事务队列完成。</li></ul><p><strong>将命令入队的实现逻辑如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a new command into the MULTI commands queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将一个新命令添加到事务队列中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueMultiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    multiCmd *mc;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 检测客户端状态，如果要入队的命令出现类似语法错误，则不允许入队</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_DIRTY_EXEC)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 为命令分配对应的空间，如存储命令结构的队列、封装命令的命令结构 multiCmd</span></span><br><span class="line">    c-&gt;mstate.commands = zrealloc(c-&gt;mstate.commands,</span><br><span class="line">                                  <span class="keyword">sizeof</span>(multiCmd) * (c-&gt;mstate.count + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 指向新元素</span></span><br><span class="line">    mc = c-&gt;mstate.commands + c-&gt;mstate.count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 设置命令、命令参数数量、以及命令的参数</span></span><br><span class="line">    mc-&gt;cmd = c-&gt;cmd;</span><br><span class="line">    mc-&gt;argc = c-&gt;argc;</span><br><span class="line">    mc-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj *) * c-&gt;argc);</span><br><span class="line">    <span class="built_in">memcpy</span>(mc-&gt;argv, c-&gt;argv, <span class="keyword">sizeof</span>(robj *) * c-&gt;argc);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        incrRefCount(mc-&gt;argv[j]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 事务队列长度增一</span></span><br><span class="line">    c-&gt;mstate.count++;</span><br><span class="line"></span><br><span class="line">    c-&gt;mstate.cmd_flags |= c-&gt;cmd-&gt;flags;</span><br><span class="line">    c-&gt;mstate.cmd_inv_flags |= ~c-&gt;cmd-&gt;flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 每次在入队的命令出现类似语法错误时调用，将客户端的状态设置为 DIRTY_EXEC，让之后的 EXEC 命令失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flagTransaction</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前客户端的状态处于事务状态</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI)</span><br><span class="line">        <span class="comment">// 将客户端的状态设置为 CLIENT_DIRTY_EXEC，表示该客户端的事务安全性已经被破坏</span></span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_EXEC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，以上函数只是命令入队逻辑，在该方法上层会对当前客户端的状态标志进行判断，并结合当前命令选择对应处理方式，因为涉及的内容相对较多且不是本文的重点，暂不展开说明。</p><h2 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h2><p>前文介绍了 Redis 事务中的命令入队逻辑，但是并没有详细说明事务队列的结构以及命令封装结构，本小节就来对 Redis 事务中涉及的相关数据结构进行介绍。</p><p>每个 Redis 客户端都有自己的状态，其它状态我们暂不介绍，这里我们围绕着事务相关状态进行说明。下面只列举客户端结构体中涉及事务相关的属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前正在使用的数据库</span></span><br><span class="line">    redisDb *db;            <span class="comment">/* Pointer to currently SELECTed DB. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;               <span class="comment">/* Num of arguments of current command. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数对象数组</span></span><br><span class="line">    robj **argv;            <span class="comment">/* Arguments of current command. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录被客户端执行的命令</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span>  <span class="comment">/* Last command executed. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端的状态标志</span></span><br><span class="line">    <span class="keyword">uint64_t</span> flags;         <span class="comment">/* Client flags: CLIENT_* macros. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务状态（本质上是事务队列的封装）</span></span><br><span class="line">    multiState mstate;      <span class="comment">/* MULTI/EXEC state */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被监视的键，用于存放当前客户端使用 WATCH 命令监视键的链表</span></span><br><span class="line">    <span class="built_in">list</span> *watched_keys;     <span class="comment">/* Keys WATCHED for MULTI/EXEC CAS */</span></span><br><span class="line"></span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure><p>客户端的状态标志是通过 <code>flags</code> 属性记录的。如果客户端开启事务，那么客户端的 <code>mstate</code> 属性封装了事务队列信息，用来管理事务中的命令；客户端的 <code>watched_keys</code> 链表结构用来管理客户端使用 <strong>WATCH</strong> 命令监视的键信息。下文我们会分别详细介绍这些关键属性。</p><p>客户端的 <code>mstate</code> 属性主要包含一个<strong>事务队列</strong>和一个<strong>记录事务队列长度的属性</strong>，具体结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 主要包含一个事务队列，以及一个已入队命令的计数器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 事务队列，是一个 multiCmd 类型的数组</span></span><br><span class="line">    multiCmd *commands;     <span class="comment">/* Array of MULTI commands */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已入队命令计数（事务队列的长度）</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">/* Total number of MULTI commands */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cmd_flags;          <span class="comment">/* The accumulated command flags OR-ed together.</span></span><br><span class="line"><span class="comment">                               So if at least a command has a given flag, it</span></span><br><span class="line"><span class="comment">                               will be set in this field. */</span></span><br><span class="line">    <span class="keyword">int</span> cmd_inv_flags;      <span class="comment">/* Same as cmd_flags, OR-ing the ~flags. so that it</span></span><br><span class="line"><span class="comment">                               is possible to know if all the commands have a</span></span><br><span class="line"><span class="comment">                               certain flag. */</span></span><br><span class="line">&#125; multiState;</span><br></pre></td></tr></table></figure><p>从 <strong>multiState</strong> 结构中可以看出，事务队列本质上是一个 <strong>multiCmd</strong> 类型的数组。<strong>multiCmd</strong> 结构用于封装了一个已入队命令的信息，具体结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存了一个已入队命令的相关信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line">    <span class="comment">// 参数数组</span></span><br><span class="line">    robj **argv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令指针，指向具体的命令（命令结构中封装了对应的命令函数）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure><p>事务队列以先进先出（FIFO）的方式保存入队的命令信息，较先入队的命令会被放到数组的前面，而较后入队的命令则会放到数组的后面。下面结合示例，对事务队列结构进行说明。</p><p><strong>事务中的命令入队过程：</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; SET name "Practical Common Lisp"</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; GET "name"</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; SET author "Peter Seibel"</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; GET author</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt;</span><br></pre></td></tr></table></figure><p><strong>事务队列结构如下图所示：</strong><br><img src="/posts/a26fab1/redis-tx-multistate.jpg" alt></p><p>上图很直观地展示了客户端中的 <code>multiState</code> 属性的平铺结构。</p><p>了解了 Redis 事务的开启以及事务相关的数据结构后，下面我们看看 Redis 提交事务的逻辑。</p><h2 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h2><p>当一个处于事务状态的客户端向服务器发送 <code>EXEC</code> 命令时，该命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，依次执行队列中保存的命令，最后将执行命令得到的结果全部返回给客户端。</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) "Practical Common Lisp"</span><br><span class="line">3) OK</span><br><span class="line">4) "Peter Seibel"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>执行事务逻辑如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * exec 命令对应的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    robj **orig_argv;</span><br><span class="line">    <span class="keyword">int</span> orig_argc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">orig_cmd</span>;</span></span><br><span class="line">    <span class="keyword">int</span> was_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 检测当前客户端状态，非事务状态直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c, <span class="string">"EXEC without MULTI"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 2 检查是否需要阻止事务执行，因为：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1) Some WATCHed key was touched.</span></span><br><span class="line"><span class="comment">     *    存在被客户端监视的键被修改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2) There was a previous error while queueing commands.</span></span><br><span class="line"><span class="comment">     *    命令在入队时发生错误</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A failed EXEC in the first case returns a multi bulk nil object</span></span><br><span class="line"><span class="comment">     * (technically it is not an error but a special behavior), while</span></span><br><span class="line"><span class="comment">     * in the second an EXECABORT error is returned. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_DIRTY_CAS | CLIENT_DIRTY_EXEC)) &#123;</span><br><span class="line">        addReply(c, c-&gt;flags &amp; CLIENT_DIRTY_EXEC ? shared.execaborterr :</span><br><span class="line">                    shared.nullarray[c-&gt;resp]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行 discard 逻辑，即取消事务</span></span><br><span class="line">        discardTransaction(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前客户端的状态标记</span></span><br><span class="line">    <span class="keyword">uint64_t</span> old_flags = c-&gt;flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we do not want to allow blocking commands inside multi */</span></span><br><span class="line">    <span class="comment">// 我们不希望在multi中允许阻塞命令</span></span><br><span class="line">    c-&gt;flags |= CLIENT_DENY_BLOCKING;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 已经可以保证安全性了，取消客户端对所有键的监视</span></span><br><span class="line">    <span class="comment">// 将当前客户端的 watched_keys 链表回收</span></span><br><span class="line">    <span class="comment">// 从当前客户端操作的数据库的 watched_keys 字典中移除当前客户端</span></span><br><span class="line">    unwatchAllKeys(c); <span class="comment">/* Unwatch ASAP otherwise we'll waste CPU cycles */</span></span><br><span class="line"></span><br><span class="line">    server.in_exec = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 因为事务中的命令在执行时可能会修改命令和命令的参数，所以为了正确地传播命令，需要现备份这些命令和参数</span></span><br><span class="line">    orig_argv = c-&gt;argv;</span><br><span class="line">    orig_argc = c-&gt;argc;</span><br><span class="line">    orig_cmd = c-&gt;cmd;</span><br><span class="line"></span><br><span class="line">    addReplyArrayLen(c, c-&gt;mstate.count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5 执行事务队列中的命令</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.1 因为 Redis 的命令必须在客户端的上下文中执行，所以需要将事务队列中的命令、命令参数等设置到客户端</span></span><br><span class="line">        c-&gt;argc = c-&gt;mstate.commands[j].argc;</span><br><span class="line">        c-&gt;argv = c-&gt;mstate.commands[j].argv;</span><br><span class="line">        c-&gt;cmd = c-&gt;mstate.commands[j].cmd;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/* 省略 ACL权限检查逻辑 */</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 5.2 执行命令</span></span><br><span class="line">        call(c, server.loading ? CMD_CALL_NONE : CMD_CALL_FULL);</span><br><span class="line">        serverAssert((c-&gt;flags &amp; CLIENT_BLOCKED) == <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Commands may alter argc/argv, restore mstate. */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 因为命令执行后命令、命令参数可能会被改变，比如 SPOP 会被改写为 SREM</span></span><br><span class="line"><span class="comment">         * 所以这里需要更新事务队列中的命令和参数，确保附属节点和 AOF 的数据一致性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c-&gt;mstate.commands[j].argc = c-&gt;argc;</span><br><span class="line">        c-&gt;mstate.commands[j].argv = c-&gt;argv;</span><br><span class="line">        c-&gt;mstate.commands[j].cmd = c-&gt;cmd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore old DENY_BLOCKING value</span></span><br><span class="line">    <span class="keyword">if</span> (!(old_flags &amp; CLIENT_DENY_BLOCKING))</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_DENY_BLOCKING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原命令</span></span><br><span class="line">    c-&gt;argv = orig_argv;</span><br><span class="line">    c-&gt;argc = orig_argc;</span><br><span class="line">    c-&gt;cmd = orig_cmd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6 清理事务状态</span></span><br><span class="line">    <span class="comment">// 释放事务队列相关的资源 &amp; 重置客户端的状态</span></span><br><span class="line">    discardTransaction(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure the EXEC command will be propagated as well if MULTI</span></span><br><span class="line"><span class="comment">     * was already propagated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果已经传播了 MULTI，也要确保传播 EXEC 命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (server.propagate_in_transaction) &#123;</span><br><span class="line">        <span class="keyword">int</span> is_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="comment">/* If inside the MULTI/EXEC block this instance was suddenly</span></span><br><span class="line"><span class="comment">         * switched from master to slave (using the SLAVEOF command), the</span></span><br><span class="line"><span class="comment">         * initial MULTI was propagated into the replication backlog, but the</span></span><br><span class="line"><span class="comment">         * rest was not. We need to make sure to at least terminate the</span></span><br><span class="line"><span class="comment">         * backlog with the final EXEC. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog &amp;&amp; was_master &amp;&amp; !is_master) &#123;</span><br><span class="line">            <span class="keyword">char</span> *execcmd = <span class="string">"*1\r\n$4\r\nEXEC\r\n"</span>;</span><br><span class="line">            feedReplicationBacklog(execcmd, <span class="built_in">strlen</span>(execcmd));</span><br><span class="line">        &#125;</span><br><span class="line">        afterPropagateExec();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.in_exec = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>事务执行逻辑比较复杂，下面进行概要总结：</strong></p><ol><li>在事务执行时会判断客户端的状态，如果没有开启事务直接返回。</li><li>对阻止事务执行的情况进行检查，检测到任何一种非法的情况，需要取消事务。</li><li>取消客户端对所有键的监视</li><li>依次执行事务队列中的任务</li><li>清理事务列表并重置客户端状态</li><li>传播 EXEC 命令</li></ol><p>事务执行时涉及的监视机制会在下文进行介绍，这里暂不展开。</p><h2 id="取消事务"><a href="#取消事务" class="headerlink" title="取消事务"></a>取消事务</h2><p>当一个处于事务状态的客户端向服务器发送 <code>DISCARD</code> 命令时，该命令将立即被服务器执行。服务器会释放事务状态资源并重置客户端的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * discard 命令对应的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检测当前客户端状态，非事务状态直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c, <span class="string">"DISCARD without MULTI"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// discard 逻辑</span></span><br><span class="line">    discardTransaction(c);</span><br><span class="line"></span><br><span class="line">    addReply(c, shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * discard 操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardTransaction</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重置事务状态</span></span><br><span class="line">    <span class="comment">// 释放所有事务状态相关的资源</span></span><br><span class="line">    freeClientMultiState(c);</span><br><span class="line">    <span class="comment">// 初始化客户端的事务状态</span></span><br><span class="line">    initClientMultiState(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置客户端状态标志</span></span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_MULTI | CLIENT_DIRTY_CAS | CLIENT_DIRTY_EXEC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消对所有键的监视</span></span><br><span class="line">    unwatchAllKeys(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WATCH-机制"><a href="#WATCH-机制" class="headerlink" title="WATCH 机制"></a>WATCH 机制</h2><p><strong>WATCH</strong> 命令可以在 <strong>EXEC</strong> 命令执行之前，监视任意数量的数据库键，并在 <strong>EXEC</strong> 命令执行时检查是否存在被监视的键被修改的情况，如果存在服务器会拒绝执行事务。前文介绍事务执行和取消时，都有 <strong>WATCH</strong> 机制逻辑，它是 Redis 事务实现的一部分，本小节我们就来详细说明该机制。</p><h3 id="监视键信息"><a href="#监视键信息" class="headerlink" title="监视键信息"></a>监视键信息</h3><p>客户端监视键的时候，被监视的键信息会分别保存在客户端的监视键链表中和当前数据库的监视键字典中，下面我们分别介绍。</p><p><strong>客户端的监视键链表</strong></p><p>每个客户端创建的时候都会初始化一个用于存放监视键的链表。前文在介绍客户端的结构有列举对应的属性，这里直接拿过来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于存放被监视的键的链表</span></span><br><span class="line">    <span class="built_in">list</span> *watched_keys;     <span class="comment">/* Keys WATCHED for MULTI/EXEC CAS */</span></span><br><span class="line"></span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure><p>客户端结构中的这个链表的节点的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 在监视一个键时：</span></span><br><span class="line"><span class="comment"> * 我们既需要保存被监视的键，还需要保存该键所在的数据库</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchedKey</span> &#123;</span></span><br><span class="line">    <span class="comment">// 被监视的键对象</span></span><br><span class="line">    robj *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键所在的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">&#125; watchedKey;</span><br></pre></td></tr></table></figure><p>watched_keys 链表数据举例如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># before:</span><br><span class="line"> [</span><br><span class="line">  &#123;</span><br><span class="line">    'key': 'key1',  # 被监视的键</span><br><span class="line">    'db': 0  # 客户端操作的数据库</span><br><span class="line">   &#125;</span><br><span class="line"> ]</span><br><span class="line">#  after client watch key-2 in db 0:</span><br><span class="line"> [</span><br><span class="line">  &#123;</span><br><span class="line">   'key': 'key1',</span><br><span class="line">   'db': 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   'key': 'key2',</span><br><span class="line">   'db': 0</span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><p><strong>数据库的监视键字典</strong></p><p>每个 Redis 数据库都有一个 <code>watched_keys</code> 字典，这个字典的<code>键</code>就是被 <code>WATCH</code> 命令监视的键，而字典的<code>值</code>则是一个链表，该链表中记录了监视当前键的客户端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>watched_keys 字典数据举例如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> # before :</span><br><span class="line"> &#123;</span><br><span class="line">   'key1' : [c1, c2]</span><br><span class="line"> &#125;</span><br><span class="line"> # after c3 WATCH key1 and key2:</span><br><span class="line">&#123;</span><br><span class="line">   'key1' : [c1, c2, c3],</span><br><span class="line">   'key2' : [c3]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="监视键"><a href="#监视键" class="headerlink" title="监视键"></a>监视键</h3><p><strong>监视键命令操作如下：</strong></p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; WATCH name</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>客户端监视给定键的逻辑如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Watch for the specified key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 客户端监视给定的键</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">watchForKey</span><span class="params">(client *c, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients = <span class="literal">NULL</span>;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    watchedKey *wk;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are already watching for this key */</span></span><br><span class="line">    <span class="comment">// 1 检查 key 是否已经保存在 watched_keys 链表中，如果已经存在，则直接返回</span></span><br><span class="line">    listRewind(c-&gt;watched_keys, &amp;li);</span><br><span class="line">    <span class="keyword">while</span> ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        wk = listNodeValue(ln);</span><br><span class="line">        <span class="keyword">if</span> (wk-&gt;db == c-&gt;db &amp;&amp; equalStringObjects(key, wk-&gt;key))</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* Key already watched */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This key is not already watched in this DB. Let's add it */</span></span><br><span class="line">    <span class="comment">// 2 检查 key 是否存在于数据库的 watched_keys 字典中</span></span><br><span class="line">    clients = dictFetchValue(c-&gt;db-&gt;watched_keys, key);</span><br><span class="line">    <span class="comment">// 2.1 如果不存在则，添加它</span></span><br><span class="line">    <span class="keyword">if</span> (!clients) &#123;</span><br><span class="line">        <span class="comment">// 值是一个链表</span></span><br><span class="line">        clients = listCreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关联键值对到字典</span></span><br><span class="line">        dictAdd(c-&gt;db-&gt;watched_keys, key, clients);</span><br><span class="line">        incrRefCount(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将客户端添加到链表的末尾</span></span><br><span class="line">    listAddNodeTail(clients, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add the new key to the list of keys watched by this client */</span></span><br><span class="line">    <span class="comment">// 3 构建 watchedKey 结构并添加到客户端的 watched_key 链表的末尾</span></span><br><span class="line">    wk = zmalloc(<span class="keyword">sizeof</span>(*wk));</span><br><span class="line">    wk-&gt;key = key;</span><br><span class="line">    wk-&gt;db = c-&gt;db;</span><br><span class="line">    incrRefCount(key);</span><br><span class="line">    listAddNodeTail(c-&gt;watched_keys, wk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上方法是监视给定的键，本质上就是将指定的键关联上当前客户端，然后分别添加到客户端的监视键链表中和数据库监视字典中。关于取消监视的键逻辑就不再介绍。</p><h3 id="监视机制的触发"><a href="#监视机制的触发" class="headerlink" title="监视机制的触发"></a>监视机制的触发</h3><p>所有对数据库进行写操作的命令，在执行后都会尝试触发监视机制，试图将正在监视当前键的客户端的状态设置为 <code>CLIENT_DIRTY_CAS</code>，表示该客户端的事务安全性已经被破坏了(客户端开启事务的前提下，没开启则没影响)。监视机制的触发逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "Touch" a key, so that if this key is being WATCHed by some client the</span></span><br><span class="line"><span class="comment"> * next EXEC will fail.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * "触碰" key，如果该 key 正在被某个/某些客户端监视着，那么这个/这些客户端在执行 EXEC 时，事件将失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touchWatchedKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 当前数据库的 watched_leys 字典为空，没有任何键被监视</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 从监视键字典中获取所有监视这个键的客户端</span></span><br><span class="line">    clients = dictFetchValue(db-&gt;watched_keys, key);</span><br><span class="line">    <span class="keyword">if</span> (!clients) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark all the clients watching this key as CLIENT_DIRTY_CAS */</span></span><br><span class="line">    <span class="comment">/* Check if we are already watching for this key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3 遍历所有客户端，打开它们的 CLIENT_DIRTY_CAS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    listRewind(clients, &amp;li);</span><br><span class="line">    <span class="keyword">while</span> ((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 将客户端的状态设置为 CLIENT_DIRTY_CAS，表示该客户端的事务安全性已经被破坏</span></span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_CAS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当服务器执行客户端的 <strong>EXEC</strong> 命令时，服务器会校验客户端的状态来决定是否执行事务。如果客户端的状态是 <code>CLIENT_DIRTY_EXEC</code> 或者 <code>CLIENT_DIRTY_CAS</code> 时，服务器会拒绝执行客户端提交的事务。</p><p>至此，Redis 的事务原理已经全部介绍完毕了。下面我们从事务的 ACID 特性角度对 Redis 的事务进行说明。</p><h1 id="事务的-ACID-性质"><a href="#事务的-ACID-性质" class="headerlink" title="事务的 ACID 性质"></a>事务的 ACID 性质</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>对于 Redis 的事务功能来说，事务队列中的命令要么全部执行，要么一个都不执行。Redis 事务的原子性需要分以下三种情况来考虑。</p><p><strong>命令入队时出错</strong></p><p>在执行 EXEC 命令前，客户端发送的操作命令本身就有错误，比如语法错误或者使用了不存的命令，在命令入队过程就被 Redis 实例检测出来了，进而导致事务失败。</p><p>命令操作如下：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行一个 Redis 不支持的命令，返回报错信息</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; SETT num 1</span><br><span class="line">(error) ERR unknown command `SETT`, with args beginning with: `num`, `1`, </span><br><span class="line">(51.33s)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 继续执行命令</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; SET num 1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交事务，但由于存在命令入队失败的情况，因此 Redis 拒绝执行事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure><p>对于这种情况，Redis 实例检测出错误后会记录错误信息并调用 <strong>flagTransaction</strong> 函数将客户端的状态设置为 <code>CLIENT_DIRTY_EXEC</code>，然后执行入队逻辑时，命令入队就会失败。此时，虽然还能继续提交命令操作，但是等到执行 <strong>EXEC</strong> 命令时，Redis 服务器就会拒绝执行提交的事务，返回事务失败的结果，因为此时客户端的状态为 <code>CLIENT_DIRTY_EXEC</code>。关于命令入队和事务执行逻辑，上文已经详细说明。</p><p><strong>结论：</strong>命令入队时出现错误，会放弃事务的执行，能够保证原子性。</p><p><strong>命令执行时出错</strong></p><p>客户端发送的操作命令和操作的数据类型不匹配，在命令入队过程 Redis 实例无法检测出错误。但是在执行 <strong>EXEC</strong> 命令时，当 Redis 从事务队列中取出异常操作命令并执行时就会报错。需要注意的是，虽然 Redis 会对异常操作命令报错，但还是会继续将事务队列中的命令执行完。在这种情况下，事务的原子性就无法得到保证了，根本原因在于 Redis 并没有提供回滚机制。</p><p>命令操作如下：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开始事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行 SADD 命令</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; SADD st gentryhuang</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行 GET 命令，GET 命令操作的数据类型不匹配，此时不会影响入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; GET st</span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交事务，事务中的第二个命令会报错</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; EXEC</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><strong>结论：</strong>命令入队时没有出错，实际执行时报错，不能保证原子性。</p><p><strong>实例故障</strong></p><p>在执行 <strong>EXEC</strong> 命令时，Redis 实例发生了故障，导致事务执行失败。由于 Redis 的持久化机制，实例重启后会加载 AOF 日志文件或 RDB 快照，如果只有部分的事务操作被记录，那么就无法保证原子性。但是事实是，RDB 快照不会在事务执行时执行，所以事务命令操作的结果不会被保存到 RDB 快照中。即使开启了 AOF 日志，我们可以使用 <strong>redis-check-aof</strong> 工具检查 AOF 日志文件，这个工具可以把未完成的事务操作从 AOF 文件中去除。这样一来，不管 AOF 日志文件中是否保存完整的事务操作，还是根本就没有保存事务操作，AOF 文件不再是导致原子性问题的因素。</p><p><strong>结论：</strong>实例故障可以保证原子性。</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>事务的一致性指的是数据符合数据库本身的定义和要求，事务执行过程不会产生非法或者无效的错误数据。Redis 通过语法错误检查机制和简单的设计来保证事务的一致性。Redis 事务的一致性依然需要分以下三种情况来考虑。</p><p><strong>命令入队时出错</strong></p><p>命令入队时出错，事务本身就会被放弃，所以可以保证事务的一致性。</p><p><strong>命令执行时出错</strong></p><p>在事务执行的过程中，出错的命令会被服务器识别出来，并进行相应的错误处理，这些出错的命令不会对数据库做任何改动。也就不会对事务的一致性产生任何影响。如果硬从无效的错误数据角度来看，这种情况是破坏了事务的一致性，毕竟出错的命令虽然没有执行，但没有达到预期的目的。</p><p><strong>实例故障</strong></p><p>Redis 实例发生了故障，无论 Redis 使用哪种持久化模式，都不会影响数据库的一致性。这种情况和前文介绍的实例故障是否影响原子性的因素是一致的。</p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。</p><p>由于 Redis 使用单线程的方式来执行事务，并且在执行事务期间不会对事务进行中断，也就是说 Redis 的事务总是以串行的方式运行的，事务具有隔离性。</p><p>需要特别说明的是，一个客户端在开启事务之前可以利用 <strong>WATCH</strong> 机制来监视要操作的键，通过这种方式可以自定义隔离规则，规定如果在事务执行时发现要操作的键发生了改变(也就是被其它客户端修改了)，那么就认为破坏了事务的隔离性，就需要放弃事务的执行。</p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>事务的持久性指的是，当一个事务执行完毕时，执行这个事务的结果会永久性存储起来，即使服务器在事务执行完毕后宕机了，执行事务所得到的结果也不会丢失。</p><p>Redis 并没有为事务提供任何额外的持久化功能，Redis 事务的持久性由 Redis 的持久化配置模式决定。由事务的持久性特点不难看出，Redis 要实现事务的持久性必须满足以下条件：</p><ul><li>使用 AOF 模式，并且刷盘机制 <strong>appendfsync</strong> 必须设置为 <strong>always</strong>，这样数据才能尽量不丢失。</li><li>Redis 为了提高性能尽可能不阻塞主线程，允许打开 <strong>no-appendfsync-on-rewrite</strong> 配置项（默认是关闭的），控制在执行快照或重写 AOF 日志文件时停止对 AOF 文件进行刷盘。那么这种情况下即使 Redis 实例运行在 <strong>always</strong> 模式的 AOF 持久化之下，事务也不具有持久性。因此，要保证事务的持久性就不能打开 <strong>no-appendfsync-on-rewrite</strong> 配置项.</li></ul><p>注意，Redis 本身是内存数据库，持久性并不是一个必须的属性，具体可以根据使用场景进行取舍。</p><h2 id="回滚实现"><a href="#回滚实现" class="headerlink" title="回滚实现"></a>回滚实现</h2><p>Redis 的事务和传统的关系型数据库事务最大的区别在于，Redis 不支持事务回滚机制，即使事务队列中的某个命令在执行时出错，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止。需要说明的是 Redis 提供的 <code>DISCARD</code> 命令，并没有回滚事务的能力，它只是用来放弃事务，把事务队列清空并重置客户端的事务状态。只要开启一个事务，就能通过 <code>DISCARD</code> 命令放弃事务。<code>DISCARD</code> 命令具体使用如下：</p><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; SADD num </span><br><span class="line">(error) ERR wrong number of arguments for 'sadd' command</span><br><span class="line">(5.99s)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 放弃事务</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; discard</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><strong>Redis 不支持事务回滚的原因有两点：</strong>其一，较为复杂的事务回滚功能和 Redis 追求简单高效的设计主旨不相符；其二，Redis 事务执行时的错误通常都是编程错误产生的，需要使用方去避免。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Redis 的事务进行了详细介绍，并结合源码层面对整个事务的执行流程进行了梳理。可以对比 MySQL 的事务机制，对比学习 Redis 的事务机制，两者使用的场景不同，对应的实现机制也有很大差别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Redis 通过 &lt;strong&gt;MULTI&lt;/strong&gt;、&lt;strong&gt;EXEC&lt;/strong&gt;、&lt;strong&gt;DISCARD&lt;
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL - 事务与隔离级别</title>
    <link href="https://gentryhuang.com/posts/d80e61c2/"/>
    <id>https://gentryhuang.com/posts/d80e61c2/</id>
    <published>2021-05-21T10:49:59.000Z</published>
    <updated>2021-07-01T02:32:51.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章将以<strong>事务</strong>为主线，分别介绍事务的基本特性、事务并发问题、封锁协议、隔离级别及基本实现，最后简单介绍下 MySQL 对标准的隔离级别规范的实现。</p><h1 id="事务基本特性"><a href="#事务基本特性" class="headerlink" title="事务基本特性"></a>事务基本特性</h1><ul><li><strong>原子性(Atomicity)</strong><blockquote><p>要么全部完成，要么全部不完成。</p></blockquote></li><li><strong>一致性(Consistency)</strong><blockquote><p>一个事务单元需要提交之后才会被其它事务可见。</p></blockquote></li><li><strong>隔离性(Isolation)</strong><blockquote><p>并发事务之间不会相互影响。</p></blockquote></li><li><strong>持久性(Durability)</strong><blockquote><p>事务提交后即持久化到存储设备上。</p></blockquote></li></ul><p>注意，隔离性和一致性是有冲突的，有时候为了提高性能，会适度的破坏一致性，而这个权衡的结果会造成事务并发问题。</p><h1 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h1><ul><li><p><strong>丢失修改</strong></p><blockquote><p>回滚覆盖：回滚一个事务时，在该事务内的写操作要回滚，把其它已提交的事务写入的数据覆盖了。<br>提交覆盖：提交一个事务时，把其它已提交的事务写入的数据覆盖了。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-transaction-concurrent-problem-1.jpg" alt><br>上图描述的是回滚覆盖问题。</p></blockquote></li><li><p><strong>脏读</strong></p><blockquote><p>一个事务读取到另一个未提交事务修改过的数据。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-transaction-concurrent-problem-2.jpg" alt></p></blockquote></li><li><p><strong>不可重复读</strong></p><blockquote><p>一个事务中先后根据相同条件读取到的数据不一致。强调更新和删除操作。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-transaction-concurrent-problem-3.jpg" alt></p></blockquote></li><li><p><strong>幻读</strong></p><blockquote><p>一个事务中先后根据相同条件读取的数据记录数不一致。强调新增操作。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-transaction-concurrent-problem-4.jpg" alt></p></blockquote></li></ul><h1 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h1><h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><p>为了解决并发问题，数据库系统引入了锁锁机制。在事务T对某个数据对象操作之前，先向系统发出请求对其加锁。基本的封锁类型有两种，<strong>排它锁(Exclusive locks 简记为X锁)</strong> 和 <strong>共享锁(Share locks 简记为S锁)</strong>，其中前者又称写锁，后者又称读锁。</p><ul><li>排它锁（X锁）：若事务T对数据对象A加上X锁，其它任何事务都不能在对A加任何类型的锁，直到事务T释放A上的锁为止。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。</li><li>共享锁（S锁）：若事务T对数据对象A加上S锁，其它事务只能再对A加S锁而不能加X锁，直到事务T释放A上的S锁为止。</li></ul><h2 id="封锁协议-1"><a href="#封锁协议-1" class="headerlink" title="封锁协议"></a>封锁协议</h2><p>在运用X锁和S锁对数据对象加锁时，还需要约定一些规则，例如何时申请X锁或S锁、持锁时间、何时释放等，称这些加锁规则为封锁协议（Locking Protocol）。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。</p><ul><li><p><strong>一级封锁协议</strong></p><blockquote><p><strong>定义</strong>：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。<br><strong>说明</strong>：一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。使用一级封锁协议可以解决丢失修改问题。在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，它不能保证可重复读和不读“脏”数据。</p></blockquote></li><li><p><strong>二级封锁协议</strong></p><blockquote><p><strong>定义</strong>：一级封锁协议基础上加事务T在读取数据R之前必须先对其加S锁，读完后方可释放S锁。<br><strong>说明</strong>：二级封锁协议除防止了丢失修改，还可以进一步防止读“脏”数据。但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。</p></blockquote></li><li><p><strong>三级封锁协议</strong></p><blockquote><p><strong>定义</strong>：一级封锁协议基础上加事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。<br><strong>说明</strong>：三级封锁协议除防止了丢失修改和不读“脏”数据外，还进一步防止了不可重复读。</p></blockquote></li></ul><p>上述三级协议的主要区别在于什么操作需要申请封锁，以及何时释放。</p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>为了解决事务并发问题，进行并发控制，数据库系统提供了四种事务隔离级别。本质上三级封锁协议反映在实际的数据库系统上，就是四种事务隔离机制。总的来说，四种事务隔离机制就是在逐渐的限制事务的自由度，以满足对不同并发控制程度的要求。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul><li><strong>读未提交(Read Uncommitted)</strong><blockquote><p>可以读取未提交的记录，会出现脏读，幻读，不可重复读，所有并发问题都可能遇到。</p></blockquote></li><li><strong>读已提交(Read Committed)</strong><blockquote><p>只能读取到已经提交的数据。不会出现脏读现象，但是会出现幻读，不可重复读；（大多数数据库的默认隔离级别都是 RC，但是 MySQL InnoDb 默认是 RR）。</p></blockquote></li><li><strong>可重复读(Repeated Read)</strong><blockquote><p>在同一个事务内的查询都是事务开始时刻一致的，MySQL InnoDb 默认的隔离级别，解决了不可重复读问题，但是仍然存在幻读问题。</p></blockquote></li><li><strong>串行化(Serializable)</strong><blockquote><p>所有的增删改查串行执行，啥并发问题都没有。</p></blockquote></li></ul><p>需要明确的是，以上的隔离级别是在SQL规范层面的定义，不同数据库的实现方式和使用方式并不相同，类似于JVM规范和JVM厂商的关系。</p><h2 id="传统的隔离级别实现"><a href="#传统的隔离级别实现" class="headerlink" title="传统的隔离级别实现"></a>传统的隔离级别实现</h2><p>SQL 规范中定义的四种隔离级别，分别是为了解决事务并发时可能遇到的四种问题，至于如何解决，实现方式是什么，规则中并没有严格定义。锁作为最简单最显而易见的实现方式被广为人知，因此我们在讨论某个隔离级别的时候，通常会说这个隔离级别的加锁方式是什么样的。其实，锁只是实现隔离级别的方式之一，除了锁，实现并发问题的方式还有时间戳，多版本控制等等，这些也可以称为无锁的并发控制。</p><p>采用基于锁的并发控制实现，通过对读写操作加不同的锁，以及对释放锁的时机进行不同的控制，就可以实现四种隔离级别。</p><h1 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h1><p>虽然数据库的四种隔离级别通过基于锁的并发控制（Lock-Based Concurrent Control，简写 LBCC） 技术都可以实现，但是它最大的问题是只实现了并发的读读，对于并发的读写还是冲突的，写时不能读，读时不能写，当读写操作都很频繁时，数据库的并发性将大大降低。针对这种场景，MVCC 技术应运而生，全称叫做 Multi-Version Concurrent Control（多版本并发控制），为了兼容落后的规范，数据库引擎厂商都想办法贴近四大隔离级别，但是和标准可能会有差别。</p><p>InnoDB 对事务隔离级别的实现依赖两个重要手段：LBCC、MVCC(多版本并发控制)。MVCC 可以认为是对锁机制的优化，让普通 SELECT 避免加锁，同时保证事务隔离级别的语义。</p><p>InnoDB 默认的事务隔离级别是 RR 隔离级别，它采用通过 <code>MVCC</code> 和 <code>间隙锁</code> 解决了标准的 RR 级别下存在的幻读问题。因为 <code>幻读</code> 的这个<code>读</code>字在 MySQL 里本身就存在歧义，这个<code>读</code>指的是<strong>快照读</strong>还是<strong>当前读</strong>呢？如果是快照读，MySQL 通过版本链来保证同一个事务里每次查询得到的结果集都是一致的；如果是当前读，MySQL 通过<code>间隙锁</code>保证其他事务无法插入新的数据，从而避免幻读问题。当然，如果场景中一会是快照读，一会是当前读，导致幻读现象，那就太为难 MySQL 了。</p><p>InnoDB 对串行化隔离级别是通过 <code>临键锁</code> 实现的，普通 SELECT 语句使用 <code>S临键锁</code>，当前读语句使用 <code>X临键锁</code>，加锁规则和 RR 隔离级别一致。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章主要对事务隔离级别的规范以及传统实现原理进行了介绍，并对 MySQL 的事务隔离级别的实现进行了简单说明。有了对事务整体的深入了解，对于理解 MySQL 中的锁机制、MVCC 原理会有很大的帮助。如果不知道事务隔离级别的基本实现，或者不清楚事务隔离级别和锁的关系，那么对于 MySQL 只能是管中窥豹。关于锁机制、MVCC原理会在后面的文章详细说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章将以&lt;strong&gt;事务&lt;/strong&gt;为主线，分别介绍事务的基本特性、事务并发问题、封锁协议、隔离级别及基本实现，最后简单介绍下
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://gentryhuang.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL - 慢查询日志</title>
    <link href="https://gentryhuang.com/posts/4132ef9f/"/>
    <id>https://gentryhuang.com/posts/4132ef9f/</id>
    <published>2021-05-14T11:17:14.000Z</published>
    <updated>2021-05-25T03:06:04.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MySQL 慢查询日志是排查问题 SQL 语句，以及检查当前 MySQL 性能的一个重要手段。默认情况下，MySQL 并不启动慢查询日志，需要我们手动来开启。如果不是调优需要的话，一般不建议开启慢查询，毕竟开启慢查询或多或少会带来一定的性能影响。</p><h1 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h1><ul><li><strong>slow_query_log:</strong>  是否开启慢查询日志，默认 OFF，开启则设置为 ON。</li><li><strong>slow_query_log_file:</strong>  慢查询日志文件存储位置。</li><li><strong>long_query_time:</strong>  超过多少秒的查询才会记录到日志中。单位是秒。</li><li><strong>log_queries_not_using_indexes:</strong>  是否把没有使用到索引的 SQL 记录到日志中，默认 OFF,开启则设置为 ON。</li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>默认情况下是没有开启慢查询日志，下面通过两种配置方式进行设置。</p><h2 id="临时配置"><a href="#临时配置" class="headerlink" title="临时配置"></a>临时配置</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global slow_query_log='ON';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; set global slow_query_log_file='/var/lib/mysql/instance-1-slow.log';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; set global long_query_time=2; # 下次会话才会生效</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="永久配置"><a href="#永久配置" class="headerlink" title="永久配置"></a>永久配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;mysql.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">slow_query_log &#x3D; ON</span><br><span class="line">slow_query_log_file &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;instance-1-slow.log</span><br><span class="line">long_query_time &#x3D; 2</span><br></pre></td></tr></table></figure><p>配置好慢 SQL 相关参数后，重启 MySQL 即可。</p><h1 id="查看慢查询功能"><a href="#查看慢查询功能" class="headerlink" title="查看慢查询功能"></a>查看慢查询功能</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'slow_query%';</span><br><span class="line">+<span class="comment">---------------------+----------------------------------+</span></span><br><span class="line">| Variable_name       | Value                            |</span><br><span class="line">+<span class="comment">---------------------+----------------------------------+</span></span><br><span class="line">| slow_query_log      | ON                               |</span><br><span class="line">| slow_query_log_file | /var/lib/mysql/mysql001-slow.log |</span><br><span class="line">+<span class="comment">---------------------+----------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.05</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'long_query_time';</span><br><span class="line">+<span class="comment">-----------------+----------+</span></span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+<span class="comment">-----------------+----------+</span></span><br><span class="line">| long_query_time | 1.000000 |</span><br><span class="line">+<span class="comment">-----------------+----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'log_queries_not_using_indexes';</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| log_queries_not_using_indexes | OFF   |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><h1 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h1><p><strong>mysqldumpslow</strong> 是 MySQL 官方提供的慢查询日志分析工具，使用 <strong>mysqldumpslow</strong> 命令可以非常明确的得到各种我们需要的查询语句。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>慢查询日志是排查SQL问题以及优化的重要手段，在生产环境中一般都会实时采集慢查询日志，对 MySQL 查询语句监控、分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;MySQL 慢查询日志是排查问题 SQL 语句，以及检查当前 MySQL 性能的一个重要手段。默认情况下，MySQL 并不启动慢查询日志，需
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://gentryhuang.com/categories/MySQL/"/>
    
    
      <category term="慢查询日志" scheme="https://gentryhuang.com/tags/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>缓存一致性问题</title>
    <link href="https://gentryhuang.com/posts/fa9a5340/"/>
    <id>https://gentryhuang.com/posts/fa9a5340/</id>
    <published>2021-05-04T04:44:15.000Z</published>
    <updated>2021-06-24T09:59:07.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>使用 DB + Cache 的架构时，会带来缓存和数据库一致性问题。理论上来说，给缓存设置过期时间是保证最终一致性的解决方案。基于此，所有的写操作以 DB 为准，对 Cache 操作尽最大努力即可，也就是说如果 DB 写成功，缓存更新失败，那么只要到达过期时间缓存就会失效，后续的读请求获取的自然就是最新的数据并回填 Cache。</p><p>对于缓存和数据库一致性问题有很多的解决方案，没有最完美的方案，只有适合业务场景的方案。注意，本文讨论的相关更新策略是不考虑缓存过期时间问题。</p><h1 id="Cache-操作方式"><a href="#Cache-操作方式" class="headerlink" title="Cache 操作方式"></a>Cache 操作方式</h1><p>当数据 data 发生改变时，对 Cache 的操作有两种方式：<strong>更新 Cache 中的数据</strong>和<strong>淘汰 Cache 中的数据</strong> 。</p><p><strong>更新 Cache</strong></p><blockquote><p>更新 Cache 是指数据 data 不仅会写入 DB，还会写入 Cache 。更新 Cache 的优点：缓存不会增加一次 miss，命中率高。</p></blockquote><p><strong>淘汰 Cache</strong></p><blockquote><p>淘汰 Cache 是指数据 data 只会写入 DB，不会写入 Cache，并且把 Cache 清除。</p></blockquote><p>使用<strong>更新 Cache</strong> 还是<strong>淘汰 Cache</strong> 取决于设置 Cache 的复杂度。Cache 可能是单一的值，也可能是通过复杂的计算得到的值，前者适合使用更新 Cache，后者适合使用淘汰 Cache。但从总体上考虑，淘汰 Cache 操作简单，并且带来的副作用只是增加了一次 Cache miss，因此推荐使用淘汰 Cache 的处理方式。</p><h1 id="Cache-和-DB-操作序列"><a href="#Cache-和-DB-操作序列" class="headerlink" title="Cache 和 DB 操作序列"></a>Cache 和 DB 操作序列</h1><p>当数据 data 发生改变时，除了需要对 Cache 的操作进行选择（推荐使用淘汰 Cache），还需要对 Cache 和 DB 的操作序列进行选择：</p><ul><li>先更新 DB，后淘汰 Cache</li><li>先淘汰 Cache，后更新 DB</li></ul><p>对于不能保证事务性的操作，选择标准是：<strong>当出现不一致，哪个操作影响较小，就选择该操作先执行</strong>。由于更新 DB 和淘汰 Cache 不能保证原子性，因此需要判断哪一个先执行影响更小。</p><p><strong>先更新 DB，后淘汰 Cache</strong></p><blockquote><p>操作 DB 失败没有影响，重试即可。一旦更新 DB 成功，淘汰 Cache 失败，则会出现 DB 中是新数据，Cache 中是旧数据，导致<strong>数据不一致</strong>。</p></blockquote><p><strong>先淘汰 Cache，后更新 DB</strong></p><blockquote><p>淘汰 Cache 失败没有影响，重试即可。一旦淘汰 Cache 成功，更新 DB 失败，<strong>只会引发一次 Cache miss</strong>。</p></blockquote><p>结论：<strong>先淘汰 Cache，再更新 DB</strong> 。</p><p><strong>特别说明：</strong>这里给出的先淘汰 Cache ，再更新 DB 是针对没有额外处理手段的情况下，这种操作序列即使出现问题影响是最小的。如果使用类似重试机制保证操作序列的完整性，那么这两种序列就没有多大差异了，下文会着重分析。</p><h1 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h1><p><strong>淘汰 Cache</strong> 是一种推荐的处理方式，<strong>先淘汰 Cache 后更新 DB</strong> 的时序产生问题相对更小。下面我们对常见方案进行分析：</p><ul><li><strong>先更新 DB，再更新 Cache</strong></li><li><strong>先淘汰 Cache，再更新 DB</strong></li><li><strong>先更新 DB，再淘汰 Cache</strong></li></ul><p>需要说明的是，先更新 Cache，再更新 DB 的策略问题较大，一旦出现不一致就存在超前的脏数据，这样的不一致是要不得的。根据上文我们分析的，先更新 DB，再更新 Cache 也是不推荐的。</p><h2 id="先更新-DB-后更新-Cache"><a href="#先更新-DB-后更新-Cache" class="headerlink" title="先更新 DB 后更新 Cache"></a>先更新 DB 后更新 Cache</h2><p>该策略也是不推荐使用的，主要原因如下：</p><ol><li>并发更新导致缓存更新顺序问题<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-1.jpg" alt><br>如上图，线程 A、B 同时进行更新操作，那么会出现：<blockquote><ol><li>线程 A 更新了 DB</li><li>线程 B 更新了 DB</li><li>线程 B 更新了 Cache</li><li>线程 A 更新了 Cache</li></ol></blockquote></li></ol><p>线程 A 先进行了 DB 更新操作，理论上也应该是线程 A 先更新 Cache，但因为线程 A 处理的较慢，缓存最后是线程 A 更新后的值。这就导致了脏数据。可以使用串行化解决，但是会导致效率变低。<br>2. 更新 DB 成功，但更新 Cache 失败时会导致 Cache 中的脏数据。</p><p>这里为了完整性，把该策略列举出来，了解即可。我们重点关注另外两种方式。</p><h2 id="先淘汰-Cache-后更新-DB"><a href="#先淘汰-Cache-后更新-DB" class="headerlink" title="先淘汰 Cache 后更新 DB"></a>先淘汰 Cache 后更新 DB</h2><p>针对以上更新 Cache 出现的问题，有人就提出淘汰 Cache 的策略。先淘汰 Cache ，如果成功，则更新 DB；如果失败则不更新 DB，后续可以通过重试来解决失败的问题，但是增加了一次 Cache 的 miss。该策略导致不一致的原因不在于后更新 DB 失败了，而是汰 Cache 成功，但更新 DB 完成前存在读请求将旧数据设置到 Cache 中造成脏数据（并发问题），具体场景如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-2.jpg" alt><br>如上图，同时有一个线程 A 进行更新操作，另一个线程 B 进行查询操作，那么就会出现：</p><blockquote><ol><li>线程 A 淘汰 Cache</li><li>线程 B 没有命中 Cache</li><li>线程 B 查询 DB</li><li>线程 B 将查询结果写入 Cache ，对<strong>后续读</strong>就是脏数据</li><li>线程 A 更新 DB</li></ol></blockquote><p>上述情况会导致不一致的问题，而且，如果不采用给 Cache 设置过期时间策略，该脏数据会一直保留到下次更新操作。</p><p>针对以上问题可以采用 <strong>延时双删策略</strong> 将 Cache 脏数据删除，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 数据 key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data 数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String key, Object data)</span> </span>&#123;</span><br><span class="line">    cache.delKey(key);<span class="comment">// 1 淘汰 Cache</span></span><br><span class="line">    db.updateData(data); <span class="comment">// 2 更新 DB</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 3 延时 delay</span></span><br><span class="line">    cache.delKey(key);<span class="comment">// 4 再次淘汰 Cache</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在更新 DB 完成后，评估一定的延时时间再次淘汰 Cache 。这里的延时时间不好确定，一般需要评估项目读数据业务逻辑的耗时，在此基础上加一定的毫秒值即可。值得一说的是，延时一定的时间才会再次淘汰 Cache 是为了确保读请求结束，写请求可以删除读请求造成的缓存脏数据。这里也可以看出，并不是更新 DB 后立刻再次淘汰 Cache ，因为可能有线程读取到了更新前的旧数据还没来得及写入缓存，因此需要等待它写入缓存。</p><p>如果 DB 采用读写分离架构，可能产生以下问题：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-3.jpg" alt><br>如上图，过程如下：</p><blockquote><ol><li>线程 A 淘汰 Cache</li><li>线程 A 更新 DB</li><li>线程 B 没有命中缓存</li><li>线程 B 查询从库 DB，此时并没有完成主从同步，因此查询的是旧值</li><li>线程 B 将旧值放入 Cache</li><li>主从同步完成</li></ol></blockquote><p>上述解决方案还是使用 <strong>延时双删策略</strong>，只需要延时时间确保完成主从同步，即主从同步完成再删一次 Cache 即可。</p><p><strong>存在问题</strong></p><p>第二次淘汰 Cache 是为了防止 Cache 中的脏数据（旧的数据）而做的操作，而非业务要求。因此，<strong>延时双删策略</strong>虽然在<strong>一定程度上</strong>能保证 Cache 中不会有脏数据，但对业务是有损的，具体表现为：</p><ul><li>吞吐量降低<blockquote><p>问题描述：因为要实现延时淘汰 Cache，写的请求需要休眠等待一段时间。<br>解决方案：将第二次淘汰 Cache 以异步处理，这样写请求完成后就能立即返回，提高吞吐量。</p></blockquote></li><li>第二次淘汰 Cache 失败<blockquote><p>问题描述：写请求完成了 DB 更新，再次淘汰 Cache 失败了，导致 Cache 和 DB 一致性问题<br>解决方案：理论上可以依赖 Cache 的失效时间，但是可能不及时，因此最好采用重试机制，具体实现下文详细分析。</p></blockquote></li></ul><p>此外，<strong>延时双删策略</strong>只能在<strong>一定程度上</strong>能保证 Cache 中不会有脏数据，具体哪种程度要看<strong>延时时间</strong>的准确性。</p><h2 id="先更新-DB-后淘汰-Cache"><a href="#先更新-DB-后淘汰-Cache" class="headerlink" title="先更新 DB 后淘汰 Cache"></a>先更新 DB 后淘汰 Cache</h2><p>基于同样套路，我们先分别从并发和操作完整性出发，分析该策略存在的问题。</p><p><strong>并发问题</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-4-fix.jpg" alt><br>如上图，线程 A 执行查询，线程 B 执行更新，那么会有如下情况：</p><blockquote><ol><li>线程 A 没有命中 Cache</li><li>线程 A 查询 DB</li><li>线程 B 更新 DB</li><li>线程 B 淘汰 Cache</li><li>线程 A 将查询到的旧值放入 Cache</li></ol></blockquote><p>由于 DB 读操作速度远快于写操作，因此这样的并发问题（放入值到缓存还没有一次磁盘IO快）导致的脏数据概率非常非常低。如果非要解决，依然可以采用<strong>延时双删策略</strong>，即保证读请求完成后再一次淘汰 Cache。</p><p><strong>淘汰 Cache 时延问题</strong><br>在更新 DB 后还没来得及淘汰 Cache，其它请求就开始读取数据了，那么此时由于能命中缓存，就会直接从缓存中取旧数据，因此会有不一致数据短暂存在。不过，在这种情况下如果并发读缓存的请求不多，对业务影响还是小的，毕竟缓存很快就会被淘汰，后续请求就不会读取到旧的值了。再严格就需要使用分布式事务了。</p><h3 id="淘汰-Cache-失败"><a href="#淘汰-Cache-失败" class="headerlink" title="淘汰 Cache 失败"></a>淘汰 Cache 失败</h3><p>淘汰 Cache 失败也是<strong>延时双删策略</strong>中存在的问题，也同样会产生脏数据问题，<strong>根本策略就是重试，保证淘汰 Cache 成功</strong>。</p><p><strong>如果对一致性要求不是很高，可以使用以下两种方案：</strong></p><blockquote><ol><li>等待 Cache 过期失效</li><li>直接在程序中另起一个线程，定时重试</li></ol></blockquote><p>如果对一致性要求相对较高，就需要采用其它手段来保证及时淘汰掉 Cache 。下面就先更新 DB 后淘汰 Cache 给出两个具体方案，其中淘汰 Cache 的流程是通用的。</p><h3 id="消息队列重试"><a href="#消息队列重试" class="headerlink" title="消息队列重试"></a>消息队列重试</h3><p>通过消息 MQ 来实现重试，即将淘汰 Cache 失败的数据 key 发送到 MQ 中，然后消费MQ，执行淘汰 Cache 操作，直到淘汰成功。流程图如下：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-5.jpg" alt></p><p><strong>上图流程描述如下：</strong></p><blockquote><ol><li>更新 DB</li><li>淘汰 Cache 失败</li><li>将数据 key 发送到消息队列</li><li>消费消息，获得数据 key</li><li>继续重试淘汰 Cache 操作，直到成功</li></ol></blockquote><p>使用该方案有一个缺点，会对业务代码造成一定侵入，因为业务方需要关心将数据 key 写入到 MQ 中。采用订阅 binlog 的方式就可以做到对业务代码无侵入，下面我们就来看这种方式。</p><h3 id="订阅-binlog-重试"><a href="#订阅-binlog-重试" class="headerlink" title="订阅 binlog 重试"></a>订阅 binlog 重试</h3><p>启动一个订阅程序去订阅 DB 的 binlog，获取 binlog 中的数据的key，然后执行淘汰 Cache 操作，如果失败，则发送数据 key 到 MQ，后续同方案一。流程图如下：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/cache_db/cache-db-consistency-6.jpg" alt></p><p><strong>上图流程描述如下：</strong></p><blockquote><ol><li>更新 DB</li><li>DB 将操作信息写入 binlog 日志中</li><li>binlog 订阅程序提取出所需的数据 key</li><li>非业务代码获取数据 key</li><li>尝试根据数据 key 淘汰 Cache</li><li>如果淘汰 Cache 失败，则将数据 key 发送到消息队列</li><li>重新从消息队列中获得数据 key</li><li>继续重试淘汰 Cache，直到成功</li></ol></blockquote><p>其中订阅程序在 Mysql 中有 Canal 中间件，可以直接使用它完成订阅 binlog 日志的功能。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>本文介绍的缓存一致性解决方案都不能保证操作的原子性。如果需要严格保证缓存和数据库的一致性，也就是保证两者操作的原子性，就需要用到分布式事务来解决。常见的解决方案：两阶段提交（2PC）、三阶段提交（3PC）、TCC、消息队列等，这些方案相对比较复杂，一般用在对于一致性要求较高的业务场景中。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章着重点在于，DB 更新完成后，Cache 淘汰失败了，基于这种情况可以根据业务的特点选择对应的方式进行处理。如果对一致性要求不是很高，那么在淘汰 Cache 失败后可以选择等待缓存失效和异步定时重试；如果对一致性要求相对较高，那么可以使用消息队列和订阅 binlog 的方式重试淘汰 Cache 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;使用 DB + Cache 的架构时，会带来缓存和数据库一致性问题。理论上来说，给缓存设置过期时间是保证最终一致性的解决方案。基于此，所有的
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://gentryhuang.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="缓存" scheme="https://gentryhuang.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 健康检测</title>
    <link href="https://gentryhuang.com/posts/4760cec/"/>
    <id>https://gentryhuang.com/posts/4760cec/</id>
    <published>2021-05-01T10:56:21.000Z</published>
    <updated>2021-05-08T08:48:14.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 心跳检测是为了保证连接的可用性，在需要的时候及时采取重连、断开等措施。需要说明的是，Dubbo 心跳检测是针对 TCP 层面的协议（如：Dubbo 协议），HTTP 层面的协议是无需进行连接管理的。心跳检测需要容错，一次心跳失败不能认定连接不通，多次心跳失败才能采取相应措施。此外，心跳检测不应该忙检测，如果一条通道上有频繁的 RPC 调用，会给系统带来额外的负担。</p><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><h2 id="长短连接"><a href="#长短连接" class="headerlink" title="长短连接"></a>长短连接</h2><p>TCP 本身并没有长短连接之分，长短连接与否取决于对它的使用。</p><ul><li><strong>短连接：</strong> 每次通信时创建一个连接，一次通信结束关闭连接即可。短连接的好处是管理简单，存在的连接都是可用的连接，不需要额外的控制手段。</li><li><strong>长连接：</strong> 每次通信完毕后，不会立即关闭连接，这样可以做到连接的复用。长连接的好处是省去了创建连接的开销。</li></ul><p>长短连接各自的优势，分别是对方的劣势。对于不追求高性能，使用短连接合适，省去了连接状态管理的工作。追求性能最好使用长连接，但是需要额外工作，如端点之间连接的维护和保活。</p><h2 id="Dubbo-中的长连接"><a href="#Dubbo-中的长连接" class="headerlink" title="Dubbo 中的长连接"></a>Dubbo 中的长连接</h2><p>Dubbo 协议是基于 TCP 进行网络传输的，它采用的就是长连接。下面分别启动服务提供者应用和服务消费者应用，提供者负责监听本地 <code>20880</code> 端口（Dubbo 默认端口），服务消费者负责发起请求。</p><ul><li>服务提供方启动完成<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-heartbeat-provider-listen.jpg" alt><br>从上图可知，Dubbo 正在监听本地的 <code>20880</code> 端口，处理发送到本地 <code>20880</code> 端口的请求。</li><li>服务消费方发起请求<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-heartbeat-consumer-invoke-provider.jpg" alt><br>从上图可以验证，TCP 是一个双向的通信过程。</li></ul><h2 id="连接的保活"><a href="#连接的保活" class="headerlink" title="连接的保活"></a>连接的保活</h2><p>当端点间建立长连接后，由于网络问题，建立的连接可能不可用，这时就需要保证连接的可用。保证连接的可用常用的手段就是连接保活。</p><h3 id="TCP-KeepAlive"><a href="#TCP-KeepAlive" class="headerlink" title="TCP KeepAlive"></a>TCP KeepAlive</h3><p>TCP KeepAlive 是面向网络的，并不是面向应用的。<strong>连接不可用并不一定是网络问题，可能是由于应用本身的负载过高、GC频繁等导致的，此时应用失去了活性，连接也不可用</strong>。</p><h3 id="应用层心跳"><a href="#应用层心跳" class="headerlink" title="应用层心跳"></a>应用层心跳</h3><p>网络层面的 KeepAlive 不足以支撑应用层面的连接可用性，这种情况下应该使用应用层的心跳机制来实现连接保活，这也是业内常用的检测方法。</p><h1 id="Dubbo-心跳检测"><a href="#Dubbo-心跳检测" class="headerlink" title="Dubbo 心跳检测"></a>Dubbo 心跳检测</h1><p>介绍完健康检测相关基础后，下面我们详细介绍 Dubbo 是如何设计应用层心跳的。注意，以下讨论的 Dubbo 版本是 2.7.7 。</p><p>Dubbo 在改进心跳方案之前是双向心跳设计，客户端会给服务端发送心跳，反之，服务端也会向客户端心跳。关于双向心跳设计可以参见<a href="https://gentryhuang.com/posts/26722deb/#%E4%BB%BB%E5%8A%A1%E9%80%BB%E8%BE%91">心跳任务</a>，这里介绍的是 Dubbo 2.6.x 版本，任务执行没有使用时间轮，依然使用 schedule 方案。</p><p>Dubbo 心跳机制改进后，主要分为两类。其一，对于底层使用 Netty 通信的连接检测交给 Netty 本身而非 Dubbo 心跳检测逻辑，即完全使用 <code>IdleStateHandler</code> 来检测连接空闲状态。其二，对于其它 NIO 通信组件，Dubbo 优化了之前的双向心跳设计，改为了客户端在连接空闲时发送单向心跳，服务端定时检测连接可用性。下面我们就结合 Dubbo 心跳检测改进后的版本进行说明。</p><h2 id="IdleStateHandler"><a href="#IdleStateHandler" class="headerlink" title="IdleStateHandler"></a>IdleStateHandler</h2><p>Netty 对空闲连接的检测提供了天然的支持，使用 <code>IdleStateHandler</code> 可以很方便的实现空闲检测逻辑。其内部使用了 <code>EventLoop.schedule(task)</code> 来实现定时任务，使用该线程可以保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>, readerIdleTime, writerIdleTime, allIdleTime, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>readerIdleTime：</strong> 读超时时间</li><li><strong>writerIdleTime：</strong> 写超时时间</li><li><strong>allIdleTime：</strong> 所有类型的超时时间</li></ul><p>IdleStateHandler 会根据设置的超时参数，循环检测通道 Channel 的读写多久没有调用。当在 Netty 的 Pipeline 中加入 <code>IdleStateHandler</code> 后，可以在此 Pipeline 的任意 Handler 的 <code>userEventTriggered</code> 方法之中检测 <code>IdleStateEvent</code> 空闲事件。</p><h2 id="IdleSensible"><a href="#IdleSensible" class="headerlink" title="IdleSensible"></a>IdleSensible</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleSensible</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否具有处理空闲连接的能力</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">canHandleIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo 新增该接口，以区分 Netty 和其它通信组件对空闲连接的处理能力。<code>NettyServer</code> 和 <code>NettyClient</code> 作为 Netty 通信组件的封装类实现了该接口，重写了接口中的方法，返回值为 <code>true</code>，表示具有处理空闲连接的能力。也就是说，如果使用 Netty 作为通信组件，那么监控空闲连接就交给 Netty 底层自己处理。而其它通信组件暂不支持，因此仍然需要 Dubbo 框架的心跳设计方案。</p><h2 id="网络传输层"><a href="#网络传输层" class="headerlink" title="网络传输层"></a>网络传输层</h2><p>下面我们先从 Dubbo 的网络传输层分析心跳检测的实现，需要说明的是网络传输层主要针对的是 Netty 组件，其它 NIO 组件几乎没有在网络传输层实现心跳逻辑（这里不包括统一处理心跳交互的 HeartbeatHandler）。</p><h3 id="NettyServer"><a href="#NettyServer" class="headerlink" title="NettyServer"></a>NettyServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyServer</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Init and start netty server</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        bossGroup = NettyEventLoopFactory.eventLoopGroup(<span class="number">1</span>, <span class="string">"NettyServerBoss"</span>);</span><br><span class="line">        workerGroup = NettyEventLoopFactory.eventLoopGroup(getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS), <span class="string">"NettyServerWorker"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> NettyServerHandler nettyServerHandler = <span class="keyword">new</span> NettyServerHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">        channels = nettyServerHandler.getChannels();</span><br><span class="line">        bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NettyEventLoopFactory.serverSocketChannelClass())</span><br><span class="line">                .option(ChannelOption.SO_REUSEADDR, Boolean.TRUE)</span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)</span><br><span class="line">                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 1 心跳超时时间，是心跳间隔的 3 倍。心跳间隔默认 60s </span></span><br><span class="line">                        <span class="keyword">int</span> idleTimeout = UrlUtils.getIdleTimeout(getUrl());</span><br><span class="line">                        NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">if</span> (getUrl().getParameter(SSL_ENABLED_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="string">"negotiation"</span>, SslHandlerInitializer.sslServerHandler(getUrl(), nettyServerHandler));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 2 设置 ChannelPipeline 上的 ChannelHandler</span></span><br><span class="line">                        ch.pipeline()</span><br><span class="line">                                <span class="comment">// 2.1 编解码 Handler</span></span><br><span class="line">                                .addLast(<span class="string">"decoder"</span>, adapter.getDecoder())</span><br><span class="line">                                .addLast(<span class="string">"encoder"</span>, adapter.getEncoder())</span><br><span class="line">                                <span class="comment">// 2.2 心跳检测 Handler，注意超时时间针对所有类型</span></span><br><span class="line">                                .addLast(<span class="string">"server-idle-handler"</span>, <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, idleTimeout, MILLISECONDS))</span><br><span class="line">                                <span class="comment">// 2.3 Netty 融合 Dubbo Handler 的 处理器</span></span><br><span class="line">                                .addLast(<span class="string">"handler"</span>, nettyServerHandler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// bind</span></span><br><span class="line">        ChannelFuture channelFuture = bootstrap.bind(getBindAddress());</span><br><span class="line">        channelFuture.syncUninterruptibly();</span><br><span class="line">        channel = channelFuture.channel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 IdleSensible 中的方法，表示自己实现心跳检测</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canHandleIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在初始化和启动 Netty Server 时，会为 Pipeline 设置 <code>IdleStateHandler</code> 处理器，用于检测空闲连接。注意，<code>IdleStateHandler</code> 是 Netty 提供的一个工具型 Handler，用于定时心跳请求的功能以及自动关闭长时间空闲连接。<strong>如果超过设置的阈值（超时时间），则会触发 <code>IdleStateEvent</code> 事件并传递给后续的 ChannelHandler 进行处理，后续的 ChannelHandler 的 <code>userEventTriggered()</code> 方法会根据接收到的 <code>IdleStateEvent</code> 事件，决定是关闭空闲连接还是发送心跳探活</strong>。这里提到的 ChannelHandler 其实就是下文要介绍的 <code>NettyServerHandler</code> 和 <code>NettyClientHandler</code> 。</p><h3 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyClient</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Init bootstrap</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> NettyClientHandler nettyClientHandler = <span class="keyword">new</span> NettyClientHandler(getUrl(), <span class="keyword">this</span>);</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(NIO_EVENT_LOOP_GROUP)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class="line">                <span class="comment">//.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout())</span></span><br><span class="line">                .channel(socketChannelClass());</span><br><span class="line"></span><br><span class="line">        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, Math.max(<span class="number">3000</span>, getConnectTimeout()));</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1 心跳间隔，默认 60s</span></span><br><span class="line">                <span class="keyword">int</span> heartbeatInterval = UrlUtils.getHeartbeat(getUrl());</span><br><span class="line">                <span class="keyword">if</span> (getUrl().getParameter(SSL_ENABLED_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="string">"negotiation"</span>, SslHandlerInitializer.sslClientHandler(getUrl(), nettyClientHandler));</span><br><span class="line">                &#125;</span><br><span class="line">                NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 设置 ChannelPipeline 上的 ChannelHandler</span></span><br><span class="line">                ch.pipeline()<span class="comment">//.addLast("logging",new LoggingHandler(LogLevel.INFO))//for debug</span></span><br><span class="line">                        <span class="comment">// 2.1 编解码 Handler</span></span><br><span class="line">                        .addLast(<span class="string">"decoder"</span>, adapter.getDecoder())</span><br><span class="line">                        .addLast(<span class="string">"encoder"</span>, adapter.getEncoder())</span><br><span class="line">                        <span class="comment">// 2.2 心跳检测 Handler，注意超时时间针对读类型</span></span><br><span class="line">                        .addLast(<span class="string">"client-idle-handler"</span>, <span class="keyword">new</span> IdleStateHandler(heartbeatInterval, <span class="number">0</span>, <span class="number">0</span>, MILLISECONDS))</span><br><span class="line">                        <span class="comment">// 2.3 Netty 融合 Dubbo Handler 的处理</span></span><br><span class="line">                        .addLast(<span class="string">"handler"</span>, nettyClientHandler);</span><br><span class="line"></span><br><span class="line">                String socksProxyHost = ConfigUtils.getProperty(SOCKS_PROXY_HOST);</span><br><span class="line">                <span class="keyword">if</span> (socksProxyHost != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> socksProxyPort = Integer.parseInt(ConfigUtils.getProperty(SOCKS_PROXY_PORT, DEFAULT_SOCKS_PROXY_PORT));</span><br><span class="line">                    Socks5ProxyHandler socks5ProxyHandler = <span class="keyword">new</span> Socks5ProxyHandler(<span class="keyword">new</span> InetSocketAddress(socksProxyHost, socksProxyPort));</span><br><span class="line">                    ch.pipeline().addFirst(socks5ProxyHandler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 IdleSensible 中的方法，表示自己实现心跳检测</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canHandleIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>NettyClient 的初始化逻辑和 NettyServer 类似，这里就不再重复说明。</p><h3 id="IdleStateHandler-参数"><a href="#IdleStateHandler-参数" class="headerlink" title="IdleStateHandler 参数"></a>IdleStateHandler 参数</h3><ol><li>客户端和服务端配置的超时时间不一致<blockquote><p>由于客户端有重试机制，不断发送心跳失败 N 次后才会进行断开、重连。而服务端超时后是直接断开的，留给服务端时间需要长一点，默认情况是服务端超时时间是客户端超时时间的 3 倍。此外，两端都拥有断开连接的能力，但连接的创建是客户端主动发起的，那么客户端也更有权利去主动断开连接。</p></blockquote></li><li>客户端检测的是读超时，服务端检测的是读写超时<blockquote><p>这属于心跳的共识。一般情况下客户端先发起心跳（写）[IdleStateHandler 是单向的，客户端-&gt;服务端]，所以整个链路中不通的情况只可能是：（1）服务接收（读） （2）服务端发送（写） （3）客户端接收（读） 。</p></blockquote></li></ol><h3 id="NettyServerHandler"><a href="#NettyServerHandler" class="headerlink" title="NettyServerHandler"></a>NettyServerHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyServerHandler</span><br><span class="line"><span class="meta">@io</span>.netty.channel.ChannelHandler.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到 IdleStateEvent 事件时会断开连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// server will close channel when server don't receive any heartbeat from client util timeout.</span></span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                logger.info(<span class="string">"IdleStateEvent triggered, close channel "</span> + channel);</span><br><span class="line">                <span class="comment">// 断开链接</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>NettyServerHandler 作为 Netty 服务端侧的 ChannelHandler，当收到 <code>IdleStateEvent</code> 事件时会断开连接。</p><h3 id="NettyClientHandler"><a href="#NettyClientHandler" class="headerlink" title="NettyClientHandler"></a>NettyClientHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyClientHandler</span><br><span class="line"><span class="meta">@io</span>.netty.channel.ChannelHandler.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到 IdleStateEvent 事件会发送心跳消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// send heartbeat when read idle.</span></span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"IdleStateEvent triggered, send heartbeat to channel "</span> + channel);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 发送心跳请求</span></span><br><span class="line">                Request req = <span class="keyword">new</span> Request();</span><br><span class="line">                req.setVersion(Version.getProtocolVersion());</span><br><span class="line">                req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">                req.setEvent(HEARTBEAT_EVENT);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送心跳消息</span></span><br><span class="line">                channel.send(req);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                NettyChannel.removeChannelIfDisconnected(ctx.channel());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>NettyClientHandler 作为 Netty 客户端侧的 ChannelHandler，当收到 <code>IdleStateEvent</code> 事件时会进行心跳探活。</p><h2 id="信息交换层"><a href="#信息交换层" class="headerlink" title="信息交换层"></a>信息交换层</h2><p>信息交换层是触发心跳检测的入口。</p><h3 id="HeaderExchangeServer"><a href="#HeaderExchangeServer" class="headerlink" title="HeaderExchangeServer"></a>HeaderExchangeServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeServer</span> <span class="keyword">implements</span> <span class="title">ExchangeServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RemotingServer server;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean closed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashedWheelTimer IDLE_CHECK_TIMER = <span class="keyword">new</span> HashedWheelTimer(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-server-idleCheck"</span>, <span class="keyword">true</span>), <span class="number">1</span>,</span><br><span class="line">            TimeUnit.SECONDS, TICKS_PER_WHEEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CloseTimerTask closeTimerTask;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeServer</span><span class="params">(RemotingServer server)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(server, <span class="string">"server == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.server = server;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 开始心跳检测任务</span></span><br><span class="line">        startIdleCheckTask(getUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startIdleCheckTask</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// server 自己是否可以心跳检测，如果自己不能，则启动一个 CloseTimerTask 定时任务，定期关闭长时间空闲的连接</span></span><br><span class="line">        <span class="comment">// NettyServer 是自己完成心跳检测的，具体依赖 NettyServerHandler 和 IdleStateHandler 实现，原理与 NettyClient 类似</span></span><br><span class="line">        <span class="keyword">if</span> (!server.canHandleIdle()) &#123;</span><br><span class="line">            AbstractTimerTask.ChannelProvider cp = () -&gt; unmodifiableCollection(HeaderExchangeServer.<span class="keyword">this</span>.getChannels());</span><br><span class="line">            <span class="comment">// 心跳超时时间</span></span><br><span class="line">            <span class="keyword">int</span> idleTimeout = getIdleTimeout(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据心跳超时时间计算出一个 tick 时间（除以了 3 得到），作为定时任务执行的频率</span></span><br><span class="line">            <span class="keyword">long</span> idleTimeoutTick = calculateLeastDuration(idleTimeout);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建闭关连接的任务</span></span><br><span class="line">            CloseTimerTask closeTimerTask = <span class="keyword">new</span> CloseTimerTask(cp, idleTimeoutTick, idleTimeout);</span><br><span class="line">            <span class="keyword">this</span>.closeTimerTask = closeTimerTask;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将任务加载到时间轮</span></span><br><span class="line">            IDLE_CHECK_TIMER.newTimeout(closeTimerTask, idleTimeoutTick, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 Exchange 层的 Server 时会开启心跳检测任务，如果使用的是 Netty 通信组件则不会使用 Dubbo 的心跳检测逻辑而是直接使用 Netty 提供的心跳检测机制，如果是其它通信组件则依赖 Dubbo 提供的心跳检测逻辑。</p><p>HeaderExchangeServer 启动的心跳检测任务用于服务端侧连接超时关闭连接，这个针对非 Netty 通信组件。Netty 实现的服务端侧心跳检测是交给 <code>IdleStateHandler</code> 完成的， 连接超时关闭连接由 <code>NettyServerHandler</code> 完成。</p><p>以上关闭空闲连接相关的定时任务不再展开说明。</p><h3 id="HeaderExchangeClient"><a href="#HeaderExchangeClient" class="headerlink" title="HeaderExchangeClient"></a>HeaderExchangeClient</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeClient</span> <span class="keyword">implements</span> <span class="title">ExchangeClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Client client;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeChannel channel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashedWheelTimer IDLE_CHECK_TIMER = <span class="keyword">new</span> HashedWheelTimer(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-client-idleCheck"</span>, <span class="keyword">true</span>), <span class="number">1</span>, TimeUnit.SECONDS, TICKS_PER_WHEEL);</span><br><span class="line">    <span class="keyword">private</span> HeartbeatTimerTask heartBeatTimerTask;</span><br><span class="line">    <span class="keyword">private</span> ReconnectTimerTask reconnectTimerTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client     封装 Transport 层的 Client 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startTimer 参与控制是否开启心跳定时任务和重连任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeClient</span><span class="params">(Client client, <span class="keyword">boolean</span> startTimer)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="string">"Client can't be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.channel = <span class="keyword">new</span> HeaderExchangeChannel(client);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启心跳定时任务和重连任务</span></span><br><span class="line">        <span class="keyword">if</span> (startTimer) &#123;</span><br><span class="line">            URL url = client.getUrl();</span><br><span class="line">            startReconnectTask(url);</span><br><span class="line">            startHeartBeatTask(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启心跳任务</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeartBeatTask</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// client 是否可以自己检测心跳，如果自己可以发送心跳请求，则无须 HeaderExchangeClient 再启动一个定时任务</span></span><br><span class="line">        <span class="comment">// 这里的 client 是 NettyClient ，它依靠 IdleStateHandler 中的定时任务来触发心跳事件，依靠 NettyClientHandler 来发送心跳请求，对于无法自己发送心跳请求的 Client 实现，HeaderExchangeClient 会为其启动 HeartbeatTimerTask 心跳定时任务</span></span><br><span class="line">        <span class="keyword">if</span> (!client.canHandleIdle()) &#123;</span><br><span class="line">            <span class="comment">// 获取客户端测通道</span></span><br><span class="line">            AbstractTimerTask.ChannelProvider cp = () -&gt; Collections.singletonList(HeaderExchangeClient.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取心跳间隔</span></span><br><span class="line">            <span class="keyword">int</span> heartbeat = getHeartbeat(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理心跳间隔，最小间隔不能低于 1s</span></span><br><span class="line">            <span class="keyword">long</span> heartbeatTick = calculateLeastDuration(heartbeat);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建心跳任务</span></span><br><span class="line">            <span class="keyword">this</span>.heartBeatTimerTask = <span class="keyword">new</span> HeartbeatTimerTask(cp, heartbeatTick, heartbeat);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将心跳任务加载到时间轮</span></span><br><span class="line">            IDLE_CHECK_TIMER.newTimeout(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意，无论使用哪种 NIO 组件，重连逻辑使用的都是 Dubbo 提供的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startReconnectTask</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从 URL 中读取重连配置，判断是否开启重连</span></span><br><span class="line">        <span class="keyword">if</span> (shouldReconnect(url)) &#123;</span><br><span class="line">            <span class="comment">// 获取客户端测通道</span></span><br><span class="line">            AbstractTimerTask.ChannelProvider cp = () -&gt; Collections.singletonList(HeaderExchangeClient.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 心跳超时时间</span></span><br><span class="line">            <span class="keyword">int</span> idleTimeout = getIdleTimeout(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理心跳超时时间</span></span><br><span class="line">            <span class="keyword">long</span> heartbeatTimeoutTick = calculateLeastDuration(idleTimeout);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建重连任务</span></span><br><span class="line">            <span class="keyword">this</span>.reconnectTimerTask = <span class="keyword">new</span> ReconnectTimerTask(cp, heartbeatTimeoutTick, idleTimeout);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将重连任务加载到时间轮</span></span><br><span class="line">            IDLE_CHECK_TIMER.newTimeout(reconnectTimerTask, heartbeatTimeoutTick, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建 Exchange 层的 Client 时会开启心跳检测任务和重连任务。如果使用的 Netty 通信组件则不会使用 Dubbo 的心跳检测逻辑，同样是使用 Netty 提供的心跳检测机制，如果是其它通信组件则依赖 Dubbo 提供的心跳检测逻辑。重连任务无论是使用 Netty 通信组件还是其它通信组件，都会依赖 Dubbo 提供的重连逻辑。</p><p>HeaderExchangeClient 启动的心跳检测任务用于客户端侧连接超时不断发送心跳，这个针对非 Netty 通信组件。Netty 实现客户端侧心跳检测是交给 <code>IdleStateHandler</code> 完成的， 连接超时发送心跳由 <code>NettyClientHandler</code> 完成。HeaderExchangeClient 启动的重连任务针对所有的 NIO 通信组件，它们都依赖 Dubbo 实现的重连逻辑。</p><p>以上相关的定时任务不再展开说明。</p><h2 id="健康检测精度"><a href="#健康检测精度" class="headerlink" title="健康检测精度"></a>健康检测精度</h2><p>Dubbo 中默认的心跳间隔是 60s ，心跳超时时间是 3 * 60s，<strong>由于时间窗口问题，非健康连接可能不能够被及时检测出来，最坏情况为一个周期</strong>。Dubbo 目前的解决方案是，根据心跳间隔时间和心跳超时时间计算出对应的实际触发频率，使它们的值缩小，通过减少检测间隔时间来增大及时发现非健康状态连接的概率。实际触发频率需要根据场景进行权衡折中，要考虑到资源消耗问题。</p><p>注意，几乎所有的定时检测逻辑都会存在时间窗口问题，解决方案就是根据具体的场景合理地计算检测任务的触发频率。</p><h2 id="HeartbeatHandler"><a href="#HeartbeatHandler" class="headerlink" title="HeartbeatHandler"></a>HeartbeatHandler</h2><p>HeartbeatHandler 是专门用于心跳消息处理的 ChannelHandler 实现。注意哦，它是一个 ChannelHandler，意味着会接收到各种消息（不仅限心跳消息）并能处理相关消息，它的主要职能就是处理心跳消息。在通信的不同阶段会更新通道中的 <code>读写时间戳</code>(这些读写时间戳是判断超时的依据)，不仅是心跳消息会更新对应值其它消息也会更新。对收到的心跳消息进行处理，如接收到心跳请求，则生成对应的心跳响应并返回；如接收到心跳响应，则打印日志即可；如果接收到其它消息，则传递给底层的通道处理器。 HeartbeatHandler 更多详情可参考 <a href="https://gentryhuang.com/posts/26722deb/#HeartbeatHandler">HeartbeatHandler</a> 。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>介绍完 Dubbo 的心跳检测后，我们再从宏观上对健康检测进行说明。</p><p>调用方跟服务集群节点之间的网络状况是瞬息万变的，两者之间可能出现各种情况，保证连接的可靠终极解决方案：<strong>让调用方实时感知到节点的状态变化</strong>。</p><ul><li><p><strong>应用心跳检测</strong></p><blockquote><p>应用心跳检测是目前通用的健康检测方案，它能相对及时发现非健康的连接以及非健康的应用，本质上来说还是根据心跳请求结果做判断，这在一定程度上也可以应对应用僵死情况（应用失去活性会影响到心跳请求的响应）。但是对一些相对特殊的情况，应用层心跳检测就不能很好的感知了。比如心跳失败率较高（可能是服务节点网络问题、应用活性等问题），但是总能在阈值内恢复正常，这种情况应用层心跳就显得力不从心了，理论来说该连接或者服务属于不可用的，但是应用层心跳依然认为是正常情况。针对这类情况，就需要其它维度的健康检测。</p></blockquote></li><li><p><strong>业务请求可用率</strong></p><blockquote><p>判断连接或节点状态只有心跳检测维度是不够完美的，可以增加服务调用可用率来协助检测逻辑，这样健康检测就完整了。</p></blockquote></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>分布式系统中健康检测是非常有必要的，通过健康检测机制可以及时地发现连接是否可用或服务是否可用，调用方根据检测结果做出正确的选择，如重连、断开连接、将服务移除健康列表等。健康检测可从 <code>TCP KeepAlive</code>、<code>应用心跳</code> 以及 <code>业务请求可用率</code> 等<strong>多维度</strong>进行考虑。应用健康状况不仅包括 TCP 连接状况，还包括应用本身是否存活，很多情况下 TCP 连接没有断开，但应用可能已经“僵死了”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Dubbo 心跳检测是为了保证连接的可用性，在需要的时候及时采取重连、断开等措施。需要说明的是，Dubbo 心跳检测是针对 TCP 层面的协
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Gossip 协议</title>
    <link href="https://gentryhuang.com/posts/6001717d/"/>
    <id>https://gentryhuang.com/posts/6001717d/</id>
    <published>2021-04-28T16:00:00.000Z</published>
    <updated>2021-07-13T11:56:45.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过对 Raft 等算法的了解，我们知道它们都需要大多数节点正常运行才能稳定运行。如果我们需要系统在极端的情况下也要保证正常运行，比如集群中只有一个节点，那么就必须另辟蹊径了。其实，要求系统在极端的情况下也能稳定运行，根据 BASE 理论，这需要实现最终一致性，而 Gossip 协议就能实现这种系统。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Gossip 协议，顾名思义就像流言蜚语一样，利用一种随机、带有传染性的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>集群中一个节点上有数据被改动，如果想让这个改动迅速传遍整个集群中的节点，进而达到一致性的状态。一般常见的做法是发生改动的节点将最新的数据发送到其它节点，或者其它节点去定期拉取数据。但是上述的解决方案在分布式的情况下会存在以下问题：</p><ul><li>发生改动的节点还没有将最新数据给到其它节点宕机了</li><li>由于网络原因，可能存在某个或某些节点不能连接上发生改动的节点，那么也不能获取到数据，即使其它节点已经同步到了最新的数据。<br>以上两个问题虽然在像 Raft 等算法中能解决，但是存在效率问题。而我们今天的主角 Gossip 协议就能很好的解决以上问题，以一传十，十传百的方式最后迅速传遍整个集群。</li></ul><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>Gossip 过程是由种子节点发起，它会周期性的随机选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。需要注意的是，Gossip 过程是异步的，也就是说发消息的节点不会关注对方是否收到，即不等待响应；</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>Gossip 有两种类型：</p><ul><li>反熵：传播所有的数据</li><li>谣言传播：仅传播新到达的数据</li></ul><h2 id="反熵"><a href="#反熵" class="headerlink" title="反熵"></a>反熵</h2><p>反熵指的是集群中的节点，每隔段时间就随机选择其它节点，然后通过相互交换自己的<strong>所有数据</strong>来消除两者之间的差异，实现数据的最终一致性。</p><p>需要注意的是，反熵需要节点两两交换和对比自己所有的数据，执行反熵时通讯成本会很高。其次，反熵虽然实用，但是执行反熵时相关的节点都是已知的，而且节点数量不能太多，如果是一个动态变化或节点比较多的分布式环境，这时反熵就不适用了。</p><h2 id="谣言传播"><a href="#谣言传播" class="headerlink" title="谣言传播"></a>谣言传播</h2><p>谣言传播，指的是当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其它节点向其发送数据，直到所有的节点都存储了该新数据。谣言传播非常具有传染性，它适合动态变化的分布式系统。</p><h1 id="通信模式"><a href="#通信模式" class="headerlink" title="通信模式"></a>通信模式</h1><p>Gossip 协议最终目的是将数据分发到网络中的每一个节点。根据不同的具体应用场景，网络中两个节点之间存在三种通信方式。</p><ul><li>Push: 节点 A 将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据。</li><li>Pull：A 仅将数据 key, version 推送给 B，B 将本地比 A 新的数据（Key, value, version）推送给 A，A 更新本地。</li><li>Push/Pull：与 Pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 则更新本地。</li></ul><p>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，Push 需通信 1 次，Pull 需 2 次，Push/Pull 则需 3 次。虽然消息数增加了，但从效果上来讲，Push/Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push/Pull 的收敛速度也是最快的。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p><strong>扩展性：</strong>允许节点的任意增加和减少，新增节点的状态最终会与其他节点一致。<br><strong>容错性：</strong>任意节点的宕机和重启都不会影响 Gossip 消息的传播，一方面一个节点会多次传播信息，另一方面即使不能连通某个节点，其他被“感染”的节点也会尝试向这个节点传播信息。具有天然的分布式系统容错性。<br><strong>健壮性：</strong>无需中心节点，所有节点都是对等的，只要网络连通，任意节点可把消息散播到全网。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p><strong>消息延迟：</strong>节点随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网；不可避免的造成消息延迟。<br><strong>消息冗余：</strong>节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，不可避免的引起同一节点消息多次接收，增加了消息处理压力。</p><p>需要说明的是，Gossip 协议适用于 AP 场景的数据一致性。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Gossip 协议基本思想是，一个节点想要分享一些信息给网络中的其他节点，会周期性的随机选择一些节点，并把信息传递给这些节点。这些收到信息的节点接下来会做同样的事情，即把这些信息传递给其他一些随机选择的节点。基于 Gossip 协议的一些系统，如 Apache Cassandra，Redis（Cluster模式），Consul等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通过对 Raft 等算法的了解，我们知道它们都需要大多数节点正常运行才能稳定运行。如果我们需要系统在极端的情况下也要保证正常运行，比如集群中
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://gentryhuang.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Gossip" scheme="https://gentryhuang.com/tags/Gossip/"/>
    
  </entry>
  
  <entry>
    <title>Raft 共识算法</title>
    <link href="https://gentryhuang.com/posts/48468614/"/>
    <id>https://gentryhuang.com/posts/48468614/</id>
    <published>2021-04-23T11:28:56.000Z</published>
    <updated>2021-07-24T08:06:03.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Raft 是一个共识算法（consensus algorithm），也称作 Raft 协议。所谓共识就是多个节点就某个事情达成一致，即使是在部分节点故障、甚至网络分区的情况下也是可行的。在分布式系统中，共识算法更多用于提供系统的容错性。</p><p>Raft 算法是在兰伯特 Multi-Paxos 思想的基础上进行了简化和限制，目标就是容易理解。Raft 虽然增强了可理解性，但在性能、可靠性、可用性方面是不输于 Paxos 的。Raft 算法将共识的关键要素进行了拆分，以简化流程和提供算法的可理解性。</p><h1 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h1><p>共识算法的实现一般是基于复制状态机（Replicated state machines），即所有节点都是从同一个 <code>state</code> 出发，都经过同样的一些操作序列（log），最后到达同样的 <code>state</code> ，架构图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/architecture-raft-replicated-state-machines.jpeg" alt></p><p>这是一个<strong>共识系统的典型架构</strong>，其中涉及到三个组件：</p><blockquote><ol><li>状态机：处理来自 Log 的指令序列，将执行结果对外输出。状态机具有确定性，只要 Log 的指令序列相同，产生的结果也是相同的。</li><li>Log：保存了所有写操作记录。</li><li>共识模块：保证包含来自客户端的指令的 Log 的一致性，充当管理日志的角色。（这也是 Raft 算法核心内容） </li></ol></blockquote><p>复制状态机通常使用<strong>复制日志</strong>来实现。每个服务节点存储一个包含一系列命令的日志，日志会被其状态机所使用，用于计算其中的指令。注意，只要各个服务节点上的日志是相同的或者大多数节点日志相同，说明系统已经达成共识，这些具有相同日志的服务节点上的状态机就能以相同的顺序执行相同的命令，执行的结果也是相同的。不难看出，<strong>复制日志充当数据副本的角色</strong>。</p><p>保证复制日志的一致性是共识算法的工作。服务节点上的共识模块从客户端接收命令，并将其添加到其 Log 中，然后与其它服务节点的共识模块进行通信，以完成日志复制。正确复制指令后，每台服务节点将命令应用到状态机（状态机执行对应的指令）。</p><h1 id="Raft-算法概览"><a href="#Raft-算法概览" class="headerlink" title="Raft 算法概览"></a>Raft 算法概览</h1><p>Raft 是一种用于管理复制日志的算法，它采用领导者模式，将共识问题分解为三个相对独立的子问题：Leader 选举、日志复制、安全（约定）。下面对 Raft 算法进行总体说明，并就关键特性进行列举。图中的相关元素会在后文具体说明。</p><h2 id="算法简要"><a href="#算法简要" class="headerlink" title="算法简要"></a>算法简要</h2><h3 id="状态数据结构"><a href="#状态数据结构" class="headerlink" title="状态数据结构"></a>状态数据结构</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-node-state.jpg" alt></p><ul><li>所有服务节点上的持久性状态（在响应RPC请求之前，已经更新到了稳定的存储设备）<blockquote><ul><li>currentTerm: 服务节点已知最新任期（在服务节点首次启动时初始化为 0，该值是单调递增的）</li><li>votedFor: 当前任期内收到选票的候选者id,如果没有投给任何候选者，则为空</li><li>log[]: 日志条目</li></ul></blockquote></li><li>所有服务节点上的易失性状态<blockquote><ul><li>commitIndex: 已知已提交的最高的日志条目的索引（初始值为 0，单调递增）</li><li>lastApplied: 已经被应用到状态机的最高的日志条目的索引（初始值为 0，单调递增）</li></ul></blockquote></li><li>领导者（服务节点）上的易失性状态（选举后已经重新初始化）<blockquote><ul><li>nextIndex[]: 对于每个服务节点，发送到该服务节点的下一个日志条目的索引（初始值为领导者最后的日志条目的索引+1）</li><li>matchIndex[]: 对于每一台服务节点，已知的已经复制到该服务节点的最高日志条目的索引（初始值为0，单调递增）</li></ul></blockquote></li></ul><h3 id="选举-RPC-数据结构"><a href="#选举-RPC-数据结构" class="headerlink" title="选举 RPC 数据结构"></a>选举 RPC 数据结构</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-vote-rpc.jpg" alt></p><ul><li>由候选人负责调用，用来征集选票<blockquote><ul><li>term：候选人的任期编号</li><li>candidatedId: 请求选票的候选人的 id</li><li>lastLogIndex: 候选人最后日志条目的索引值</li><li>lastLogTerm: 候选人最后日志条目的任期编号</li></ul></blockquote></li><li>返回值<blockquote><ul><li>term: 响应中的任期号，以便于候选人去更新自己的任期号（候选人任期号较小时）</li><li>voteGranted: 候选人赢得了此张选票时为真</li></ul></blockquote></li></ul><h3 id="日志复制｜心跳-RPC-数据结构"><a href="#日志复制｜心跳-RPC-数据结构" class="headerlink" title="日志复制｜心跳 RPC 数据结构"></a>日志复制｜心跳 RPC 数据结构</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replicate-heartbeat-rpc.jpg" alt></p><ul><li>领导者用于日志条目的复制 RPC 和 心跳 RPC<blockquote><ul><li>term: 领导者任期</li><li>leaderId: 领导者Id，跟随者可以根据该值对客户端进行重定向</li><li>prevLogIndex: 上一个日志条目的索引</li><li>prevLogTerm: 上一个日志条目的任期</li><li>entries[]: 需要被保存的日志条目（如果是心跳 RPC，则为空；为了提高效率可能一次性发送多个）</li><li>leaderCommit: 领导者的已知已提交的最高的日志条目的索引</li></ul></blockquote></li></ul><p>需要特别说明的是，<code>prevLogIndex</code> 和 <code>prevLogTerm</code> 是动态变化的，不是很好理解。</p><ul><li>结果<blockquote><ul><li>term: 响应中的任期，对于领导者而言，它会更新自己的任期（其它领导者任期更高）</li><li>success: 如果跟随者所含有的条目和 prevLogIndex 以及 prevLogTerm 匹配上了，则结果为 true</li></ul></blockquote></li><li>接受者的实现<blockquote><ul><li>如果领导者的任期小于接收者的当前任期，则返回 false</li><li>如果接受者日志中不能找到一个和 prevlogIndex 以及 prevLogTerm 一样的索引和任期的日志条目，则返回 false</li><li>如果接受者的条目和新条目发生了冲突（索引相同，任期不同），那么就删除这个已存在的条目以及它之后的所有条目</li></ul></blockquote></li></ul><h3 id="服务节点规则"><a href="#服务节点规则" class="headerlink" title="服务节点规则"></a>服务节点规则</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-rules.jpg" alt></p><ul><li>所有服务节点<blockquote><ul><li>如果commitIndex &gt; lastApplied，那么 lastApplied 加一，并把log[lastApplied]应用到状态机中。</li><li>如果接收到的 RPC 请求或响应中，任期号T &gt; currentTerm，那么就令 currentTerm 等于 T，并切换状态为跟随者</li></ul></blockquote></li><li>跟随者<blockquote><ul><li>响应来自候选人和领导者的请求</li><li>如果超过选举超时时间没有收到当前领导人（即该领导人的任期需与这个跟随者的当前任期相同）的心跳/附加日志，就自己变成候选者</li></ul></blockquote></li><li>候选者<blockquote><ul><li>节点在转变成候选者后就立即开始选举过程</li><li>如果接收到大多数服务节点的选票，那么就变成领导者</li><li>如果接收到来自新的领导者的 AppendEntries RPC，转变成跟随者</li><li>如果选举过程超时，再次发起一轮选举</li></ul></blockquote></li><li>领导人<blockquote><ul><li>选举后，向每个服务节点发送 AppendEntries RPC（心跳）；以一定的时间间隔不停的重复发送，以阻止跟随者超时</li><li>如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端</li><li>如果跟随者的最后一个日志条目的索引值大于等于 nextIndex ，则以 AppendEntries RPC 发送从 nextIndex 开始的所有日志条目<ul><li>如果成功：更新相应跟随者的 nextIndex 和 matchIndex</li><li>如果因为日志不一致而失败，则递减 nextIndex 并进行重试</li></ul></li></ul></blockquote></li></ul><h3 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-property.jpg" alt></p><blockquote><ul><li><strong>Election Safety:</strong> 选举安全性。对于一个给定的任期号，最多只会有一个领导人被选举出来。</li><li><strong>Leader Append-Only:</strong> 领导者只附加原则。领导人绝对不会删除或者覆盖自己的日志，只会增加。</li><li><strong>Log Matching:</strong> 日志匹配原则。如果两个日志在相同的索引位置的日志条目的任期号相同，那么就可以认为这两个日志从头到这个索引位置之间全部完全相同。</li><li><strong>Leader Completeness:</strong> 领导者完全特性。如果某个日志条目在某个任期中已经被提交，那么该条目必然出现在更大任期号的所有领导者中。</li><li><strong>State Machine Safety:</strong> 状态机安全特性。如果一个领导者已经将给定的索引值位置的日志条目应用到状态机中，那么其它任何的服务节点在这个索引位置不会应用一个不同的日志。</li></ul></blockquote><p> <strong>Raft 在任何时候都保证以上的各个特性，这也是 Raft 实现共识算法的基础。</strong></p><h2 id="阶段状态（角色）"><a href="#阶段状态（角色）" class="headerlink" title="阶段状态（角色）"></a>阶段状态（角色）</h2><p><strong>在任何时候，每个服务节点都处于以下三种状态之一：</strong></p><blockquote><p><strong>领导者（Leader）：</strong>处理所有客户端的交互以及日志复制，一个任期内只能有一个领导者。<br><strong>跟随者（Follower）：</strong>绝大多数服务节点在大多数时间都处于跟随者的状态，这些服务节点完全处于被动状态，它们不会发起任何 RPC 请求，仅仅对其它服务节点发起的 RPC 请求做出响应。<br><strong>候选者（Candidate）：</strong>处于领导者（Leader）与跟随者（Follower）之间的一种状态，只在选举新领导者的过程中临时出现，当系统处于稳定状态，只会有一个领导者，其他的服务节点都是跟随者。</p></blockquote><p>下图展示了相关状态图，描述了三种状态以及变化情况。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-state-change.jpg" alt></p><h2 id="领导者任期"><a href="#领导者任期" class="headerlink" title="领导者任期"></a>领导者任期</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-term.jpg" alt></p><p>每届领导者都会有一个任期 term，term 是随着任期数递增的，并且不会被重复使用。Raft 系统中的服务节点会持久化相关数据，其中包括当前任期 term 值。任期这个概念非常重要，Raft 可以根据该值判断过期信息。<strong>服务节点之间在通信时会交换当前任期号。如果一个服务节点的当前任期小于另一个服务节点，则它将其当前任期更新为较大的值。如果候选者或领导者发现其当前任期已过时，则将立即恢复为跟随者状态。如果服务节点收到带有过期任期的请求，则会拒绝该请求。</strong></p><h2 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h2><p>Raft 中有两个控制选举的超时设置，第一个是选举超时时间（election timeout），另一个是心跳超时时间（heartbeat timeout）。Leader 发送心跳消息是以心跳超时指定的时间间隔进行的，也就是根据 heartbeat timeout 发送心跳信息。Follower 会在 election timeout 内等待 RPC 消息，如果没有等到则会主动发起选举请求。</p><p>在 Raft 中定义了随机超时时间，巧妙地使用随机选举超时时间策略把超时时间都分散开来，在大多数情况下只有一个服务节点先发起选举，这样就能减少因选票瓜分导致选举失败的情况。</p><p>Raft 算法中，随机超时时间具有 2 种含义：可以定义为不一样</p><blockquote><ul><li>Follower 等待 Leader 心跳信息超时的时间间隔是随机的。</li><li>Candidate 在一个随机时间间隔内没有获得 majority 投票（含自己一票），那么选举无效，然后 Candidate 发起新一轮的选举。该过程的选举超时时间间隔是随机的。</li></ul></blockquote><p>在 Raft 算法中，选举超时时间随机分配在 [150ms,300ms] 区间中，当 Follower 收到 RPC 消息时（包括选举 RPC、AppendEntries RPC） 都会重置其选举超时时间。</p><h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>Raft 服务节点使用远程过程调用（RPC）进行通信，其中主要包括以下两种类型的 RPC （Raft 在传输快照时使用的是第三种 RPC）。</p><ul><li><strong>RequestVote RPC</strong><blockquote><p>由候选人在选举期间发送的 RPC 请求，该 RPC 请求对应的数据结构可以参见前文的 <strong>选举 RPC 数据结构</strong> 。</p></blockquote></li><li><strong>AppendEntries RPC</strong><blockquote><p>领导者在发送心跳和复制日志条目时会发送该 RPC 请求，该 RPC 请求对应的数据结构可以参见前文的 <strong>日志复制｜心跳 RPC 数据结构</strong> 。需要注意的是，心跳 RPC 相比日志复制 RPC 缺少了日志条目。</p></blockquote></li></ul><p><strong>注意：AppendEntries RPC 具有一致性检查的功能，它是实现各节点间日志的一致性（或者说副本数据）的重要机制。</strong></p><h1 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h1><p>Raft 使用心跳超时机制触发领导者选举。前面已经介绍，如果存在 Follower 在 election timeout 内没有收到来自 Leader 的心跳，则会主动发起选举。没有收到 Leader 的心跳的原因可能是：此时还没有 Leader、Leader 挂了、网络故障。</p><h2 id="选举-Leader"><a href="#选举-Leader" class="headerlink" title="选举 Leader"></a>选举 Leader</h2><p>下面我们以初始化状态下，集群中所有的节点都是跟随者的状态为例介绍选举过程。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-election-1.jpg" alt></p><p>设定，节点初始化状态都是 Follower 状态，任期为 0 ，各节点随机分配的 election timeout 如上图所示 。需要注意的是，节点都会对相关属性进行持久化，防止节点宕机后数据丢失。</p><p><strong>等待超时</strong></p><p>通过上图可知，集群中没有领导者，而节点 A 的选举超时时间最小（150ms），因此它会最先因为没有等到领导者的信息（不仅仅心跳信息）而发生超时，进而主动发起选举。</p><p><strong>切换到 Candidate 状态</strong></p><p>节点 A 增加自己的任期编号并推荐自己为候选者，先给自己投上一张票，然后向其它节点发送请求投票 RPC 消息，通常这些请求是并行发出的。注意此时 RPC 消息携带的信息。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-election-2.jpg" alt></p><p><strong>响应投票请求</strong></p><p>如果其它节点收到候选者 A 的投票请求，在任期编号为 1 的这一任期内还么没有进行过投票，那么就会把票投给节点 A 并将自己记录的任期替换成候选者的任期编号（投票 RPC 中会携带），此外节点的选举超时时间会被重置。投票请求对应的数据结构可参考前文。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-election-3.jpg" alt></p><p><strong>切换到 Leader 状态</strong></p><p>如果候选人在选举超时时间内获得 majority 投票，那么它就会成为本届任期内新的领导者。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-election-4.jpg" alt></p><p><strong>发送心跳消息</strong><br>节点 A 当选领导者后，它会立刻向其它节点发送心跳消息（AppendEntries RPC），避免其它节点触发新的选举，以维护自己领导者的地位。注意心跳消息一致性检查的作用，通过这种机制，领导者在获得权力的时候就不需要任何特殊的操作来恢复一致性，只需要进行正常的操作，然后日志就能自动的在回复附加日志 RPC 的一致性检查失败的时候自动趋于一致。关于日志复制内容下文详细介绍。以上是正常流选举 Leader 的过程，下面对候选者选举的所有可能情况进行介绍。</p><h2 id="选举结果"><a href="#选举结果" class="headerlink" title="选举结果"></a>选举结果</h2><p>第一、在选举超时时间内得到了 majority 投票，然后它会将自己的状态切换到 Leader 并立即向集群中其它服务节点发送心跳消息，以建立它的领导者地位并防止进行新的选举。注意，收到 Leader 的 RPC 消息后（包括日志复制消息和心跳消息），其它节点的心跳超时时间会重置。这也是前面介绍的正常流的过程。</p><p>第二、在等待投票结果时收到其它节点发送的 AppendEntries RPC 消息（以领导者身份），如果该领导者的任期（包括在此次 RPC 消息中）不小于候选者当前任期，则候选者转成 Follower 状态，并更新自己的任期，否则候选者拒绝该 RPC 请求并继续处于候选人的状态。</p><p>第三、没有任何服务节点获胜。可能存在有多个服务节点同时成为 Candidate 导致了分票，没有服务节点获得 majority 投票。发生这种情况时，每一个 Candidate 都等待选举超时，其中先超时的会增加其任期，然后进行一轮新的选举。<strong>注意这里选举超时时间的重要性，没有该机制的话，选票就可能会被无限地瓜分，那么就延长了系统不可用的时间（没有leader是不能处理客户端相关请求的）。</strong></p><h2 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h2><p>选举过程涉及的约定如下，其中包含了 Raft 安全约定中的部分内容。</p><blockquote><ol><li>Leader 会周期性地向所有 Follower 发送心跳请求（不包含日志项的 AppendEntries RPC）来维持自己的权威，以并行的方式执行，防止 Follower 发起新的选举。</li><li>如果在 Follower 的选举超时时间内没有收到来自领导者的消息（心跳或日志复制），那么就推荐自己为候选人，发起领导者选举。</li><li>选举中获得 majority 投票（含自己一票）的 Candidate 将晋升为 Leader 。</li><li><strong>一个任期内只允许有一个领导者，除非领导者宕机、网络故障等发生，其它节点才会发起新一轮的选举。</strong></li><li><strong>每一个服务节点最多会对一个任期号投出一张选票，按照先来先服务的原则。</strong><br> <img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-election-same-term.jpg" alt><br> 节点 C 的任期编号为 1，先收到一个来自节点 A 的包含任期编号为 2 的投票请求，接着又收到一个来自节点 B 的包含任期编号为 2 的投票请求。按照先来先服务的原则，C 会把唯一的一张票投给节点 A 并更新自己的任期编号，当再收到节点 B 的投票请求时，发现已经对任期编号为 2 的投票请求做出了响应，于是就拒绝节点 B 的投票请求。</li><li><strong>日志完整性高的跟随者不会投票给日志完整性低的候选者，日志完整性高低依据节点最后一条日志条目对应的任期编号及索引号，任期编号更大、索引号更大完整性就越高。</strong></li></ol></blockquote><p>上述涉及到的选票的安全性，会在 Raft 安全部分进行详细说明。</p><h1 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h1><h2 id="日志结构"><a href="#日志结构" class="headerlink" title="日志结构"></a>日志结构</h2><p>Log 具有持久化、保序的特点，是大多数分布式系统的基石。在 Raft 算法中，<strong>副本数据是以日志的形式存在的</strong>，Raft 中的日志结构如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-log-struct.jpg" alt></p><p>日志由有序序号标记的条目组成，每个日志条目包含了：<code>索引（index）</code>、<code>任期编码（term）</code>以及<code>指令（command）</code>。其中提交状态（ <code>committed</code>） 指日志条目被复制到大多数节点后日志条目的状态，<code>applied</code> 是指节点将日志条目应用到状态机。</p><p><strong>索引：</strong>用来标识日志条目在日志中的位置，是一个连续的、单调递增的整数。<br><strong>任期编号：</strong>创建当前日志条目的领导者的任期编号。<br><strong>指令：</strong>一般由客户端请求指定的、状态机需要执行的指令，本质上是客户端指定的数据。</p><p>每个服务节点无论是领导者还是跟随者，都各自保存一个日志副本，日志条目格式如上图所示。每个服务节点都必须保证日志能在奔溃后还可以恢复，所以日志本身需要持久化。领导者将创建的日志条目复制到大多数的服务节点上的时候，该日志条目就会被提交（例如上图中的日志条目 7），同时该日志之前的所有日志条目也都会被提交，包括由其它领导者创建的日志条目。注意，领导者不能单独直接提交其它领导者创建的日志条目，只能在提交自己任期的日志时间接提交，这也是安全性规定的。</p><h2 id="日志复制操作"><a href="#日志复制操作" class="headerlink" title="日志复制操作"></a>日志复制操作</h2><p>客户端将指令发送给领导者，领导者首先<strong>将命令封装成一个日志条目</strong>并写入自己的日志中，然后向所有其它的跟随者发送 AppendEntries 的远程调用，通常以并行的方式将调用的消息发送到所有服务节点，然后等待这些消息的响应。一旦领导者收到足够多的响应，该日志条目也就具备提交状态，那么领导者就会将该日志条目的指令应用到状态机并将执行结果返回给客户端，否则返回异常给客户端。需要注意的是，领导者将日志条目应用到它的状态机时并不需要直接通知跟随者应用日志条目，领导者会通过后续的 AppendEntries 远程调用通知其它的服务节点，最终每个跟随者都会知道该记录已提交，然后也将该日志条目应用到它的状态机。</p><p>领导者不直接发送消息通知其它节点应用指定的日志条目，是 Raft 的一个优化。通过前文的 AppendEntries RPC 的数据结构，我们知道领导者的日志复制 RPC 消息或心跳消息，包含了领导者已知已提交的最高的日志条目索引，所以通过日志复制 RPC 消息或心跳消息，跟随者就可以知道领导者的日志提交位置信息。因此，当其它节点接收到领导者的心跳消息或日志复制消息后，就会将该日志条目应用到它的状态机。这个优化降低了处理客户端请求的延迟。</p><p>下图展示了正常流程的日志复制过程：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replication-simple-process.jpg" alt></p><blockquote><ol><li>接收到客户端请求后，领导者基于客户端请求中的指令会创建一个日志条目并添加到本地日志中。</li><li>领导者通过日志复制 RPC ，将新的日志条目复制到其它的服务节点上。</li><li>当领导者将日志条目成功复制到大多数的服务节点上的时候，领导者会将该日志条目应用到它的状态机中。</li><li>领导者将执行的结果返回给客户端。</li><li>当跟随者接收到心跳消息或者日志复制消息后，如果跟随者发现领导者已经提交了某个日志条目而自己还没有，那么跟随者就将这条日志条目应用到本地的状态机中。</li></ol></blockquote><p>以上是理想状态下的日志过程，在实际环境中可能会遇到进程奔溃、服务节点宕机等问题，这些问题会导致日志不一致。下面我们对日志复制过程进行讨论，主要讨论 Leader 在不同阶段宕机的情况。关于跟随者节点或候选者节点宕机比较容易处理，我们会在后文简单介绍。</p><blockquote><ol><li>客户端数据到达 Leader 节点之前，Leader 宕机了。<br> <img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replication-process-1.jpg" alt><br> 这种情况对数据的一致性没有影响。</li><li>客户端数据到达 Leader 节点，但未复制到 Follower 节点<br> <img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replication-process-2.jpg" alt><br> 该阶段 Leader 挂掉，数据属于未提交状态，客户端不会收到响应。Follower 节点上没有该数据，重新选举 Leader 后客户端重试重新提交可成功。原来的 Leader 节点恢复作为 Follower 加入集群重新从当前任期的新 Leader 同步数据，强制保持和 Leader 数据一致。</li><li>客户端数据到达 Leader 节点，成功复制到 Follower 所有节点，但还未向 Leader 响应接收<br> <img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replication-process-6.jpg" alt><br> 这个阶段 Leader 挂掉，虽然数据在 Follower 节点处于未提交状态，但是保持一致。重新选举出 Leader 后可完成数据提交。</li><li>客户端数据到达 Leader 节点，成功复制到 Follower 大多数节点，但还未向 Leader 响应接收<br> <img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replication-process-3.jpg" alt><br> 这个阶段 Leader 挂掉，数据在 Follower 节点处于未提交状态且不一致，Raft 协议要求投票只能投给拥有最新数据的节点。所以，拥有最新数据的节点会被选为 Leader ，然后再强制同步数据到 Follower ，数据不会丢失并最终一致。注意，如果是成功复制到少数 Follower ,那么数据就可能会丢失。</li><li>客户端数据到达 Leader 节点，成功复制到 Folloer 所有或多数节点，数据在 Leader 处于已提交状态，但在 Follower 处于未提交状态<br> <img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replication-process-4.jpg" alt><br> 这个阶段 Leader 挂掉，选出的新 Leader 拥有最新的数据，对于数据缺失的 Follower 节点，执行同步机制会保证最终一致。</li><li>网络分区导致脑裂，出现双 Leader<br> <img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-replication-process-5.jpg" alt><br> 网络分区将原先的 Leader 节点和 Follower 节点分隔开，Follower 收不到 Leader 的心跳将发起选举产生新的 Leader。这时就产生了双 Leader，原先的 Leader 独自在一个区，向它提交数据不可能复制到多数节点所以永远提交不成功。向新的 Leader 提交数据可以提交成功，网络恢复后旧的 Leader 发现集群中有更新任期的 Leader（任期更大），则自动降级为 Follower 并更新任期且从新 Leader 同步数据达成集群数据一致。</li></ol></blockquote><p>通过上述穷举不难看出，Raft 能很好地应对一致性问题。此外，跟随者崩溃了或处于慢响应状态，领导者会反复重试这个调用，直到跟随者恢复后，领导者就能重试成功。但是领导者并不需要等待每个跟随者的响应，它只需要等到足够数量的响应，保证记录已被大多数服务节点存储即可。所以这样就能在一般情况下获得很好的性能提升。也就是说，在通常情况下，只需要获得大多数最快的服务器的应答，领导者就可以立即执行命令，并将结果返回至客户端。</p><h2 id="任期更新"><a href="#任期更新" class="headerlink" title="任期更新"></a>任期更新</h2><p>出现网络分区时，可能使集群中出现两个 Leader，网络恢复时该如何处理两个 Leader 的问题呢？Raft 使用任期号来处理。每个 RPC 请求都包括发送者的任期号，接收者收到请求后会将其与自己的任期号相比较，如果不匹配，则会更新那些过期的记录。所以如果发送者的任期比接收者小，接收者会立即拒绝 RPC 请求，并将包括了接受者任期信息的响应发送回发送者，当发送者接收到响应时会发现自己的任期号是过期的，此时它就会停下并作为跟随者继续运行，同时更新自己的任期号。反之，如果接受者的任期号更小，它同样会更新自己的任期号。</p><p>选举过程也会导致任期号的更新。候选者发起投票请求时会将自己的任期号随着 RPC 请求发送出去，这样所有的接收者都会更新自己的任期号，与候选者保持一致。</p><h2 id="日志的一致性"><a href="#日志的一致性" class="headerlink" title="日志的一致性"></a>日志的一致性</h2><p>在 Raft 算法中，<strong>领导者处理不一致日志是通过强制跟随者直接复制自己的日志来解决的</strong>。也就是说，Raft 是通过以领导者的日志为准来实现各节点日志的一致，这意味着在跟随者中的冲突的日志条目会被领导者的日志覆盖。</p><p>日志记录的索引以及任期编号可以唯一标识一条日志条目。Raft 维护着以下特性：</p><ol><li>如果两条日志条目拥有相同的索引和任期号，那么它们存储的指令也是相同的。</li><li>如果两条日志条目拥有相同的索引和任期号，那么它们之前的所有日志条目也全部相同。</li></ol><p>第一个特性来自领导者创建日志条目的原则，领导者最多在一个任期里在指定的日志索引位置创建一条日志条目，而且日志条目在日志中的位置不会改变。第二个特性由一致性检查来保证。此外，如果某条日志条目是已提交的，那么其所有前序的记录都应该处于已提交状态。</p><h2 id="AppendEntries-一致性检查"><a href="#AppendEntries-一致性检查" class="headerlink" title="AppendEntries 一致性检查"></a>AppendEntries 一致性检查</h2><p><strong>Raft 强制在 AppendEntries 远程（日志复制和心跳）调用时进行一致性检查，如果发现问题则需要修复跟随者日志</strong>。要使得跟随者的日志和领导者一致，领导者就必须找到最后两者达成一致的地方，然后删除从那个点之后的所有日志条目，发送自己的日志给跟随者。而这些操作都在进行 AppendEntries 的一致性检查时完成。</p><p>领导者会为每个跟随者维护一个状态变量 <code>nextIndex</code> ，这个变量存储下一个需要发送给跟随者的日志条目的下标位置索引。当一个服务节点成为领导者后，它会将 nextIndex 值统一设置为自己最后一条日志条目的 index 加 1 。领导者会根据 AppendEntries 调用发现一致性问题，因为当跟随者接收到 AppendEntries 调用时都会进行检查。当领导者与跟随者进行 AppendEntries 通信时，都会包括日志条目下标索引 index 以及任期号 term 作为请求参数，这里日志条目就是 log[nextIndex-1] 的值。当消息到达跟随者后，它会将接收到的下标位置索引与任期与自己的日志信息进行比较，如果不一致就会拒绝当前请求。在被跟随者拒绝之后，领导者就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得领导者和跟随者的日志达成一致。当这种情况发生，附加日志 RPC 就会成功，这时就会把跟随者冲突的日志条目全部删除并且加上领导人的日志。一旦附加日志 RPC 成功，那么跟随者的日志就会和领导人保持一致，并且在接下来的任期里一直继续保持。</p><p><strong>一致性检查流程概括如下：</strong></p><blockquote><ol><li>Leader 初始化 nextIndex 为自己最后一个 log index + 1</li><li>AppendEntries 中的 prevLogTerm 、prevLogindex 来自 logs[nextIndex -1]</li><li>Follower 会将接收到的下标索引与任期与自己的日志信息进行比较，如果一致则返回 true，否则返回 false。</li><li>Leader 收到 Follower 的回复，如果返回值是 false，则 nextIndex -= 1，回到第 2 步进行重试，否则同步 nextIndex 后的所有日志条目。</li></ol></blockquote><p>从一致性检查的过程不难发现，如果 Follower 和 Leader 的日志差异过大会造成 AppendEntries RPC 拒绝次数。但是在实践中，失败是很少发生的并且也不大可能会有这么多不一致的日志。如果一定要优化的话，那么可以采用：当 AppendEntries RPC 请求被拒绝的时候，跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的下标索引。借助这些信息，领导者可以减小 nextIndex 越过所有那个任期冲突的所有日志条目，这样就变成每个任期需要一次 AppendEntries RPC 而不是每个条目一次。</p><p>一致性检查机制非常重要，如果一个跟随者接受了来自领导者的新记录，那么它的日志记录也与领导者的日志记录是完全匹配的。此外，<strong>领导者刚当选时不需要任何特殊的操作来恢复一致性，它只需要进行正常的操作，然后日志就能自动的在回复 AppendEntries RPC 的一致性检查失败的时候自动趋于一致。</strong></p><h1 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a>日志压缩</h1><p>Raft 的日志在正常操作中不断增长，但在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响系统的可用性。Raft 采用了快照技术进行日志压缩来解决日志过大问题。快照的缺点就是不是增量的，即使内存中某个值没有变，下次做快照的时候同样会被 dump 到磁盘。</p><h2 id="快照结构"><a href="#快照结构" class="headerlink" title="快照结构"></a>快照结构</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/raft-log-compaction.png" alt></p><p>由快照结构可知，服务节点使用一个新的快照替换其日志中提交的日志条目（如上图中：索引1到索引5），快照只存储当前状态（如上图中的变量x和y）。并且快照包含一些元数据，其中 <code>last included index</code>、<code>last included term</code> 分别是快照覆盖的最后一条日志条目的索引以及任期号，这两个值用于 AppendEntries RPC 的一致性检查。此外，为了支持集群成员变更，快照中也保存了最新的配置信息。关于成员变更问题在下文中会有详细说明。</p><p>Raft 中每个节点独立的创建快照，只包括已经应用到状态机的日志条目。一旦节点完成一次快照，就可以删除最后索引位置之前的所有日志和快照了。</p><h2 id="快照发送"><a href="#快照发送" class="headerlink" title="快照发送"></a>快照发送</h2><p>正常情况下，Leader 的日志和 Follower 保持一致，但并不是所有情况都处于正常情况之下，有时可能因为 Follower 的反应缓慢或宕机造成日志不一致的情况，这时就需要 Leader 进行日志复制。如果在复制的过程中，Leader 需要发给 Follower 的日志条目被丢失了（因为 Leader 做了快照），这时会通过 InstallSnapshot RPC 发送快照给 Follower，如果没有丢失则直接从日志中复制即可。</p><p><strong>InstallSnapshot RPC 数据结构的关键字段如下：</strong></p><blockquote><ol><li>term: Leader 的任期</li><li>leaderId: Leader 的id，以便于跟随者重定向请求</li><li>lastIncludedIndex: 快照中包含的最后一条日志条目的索引值</li><li>lastIncludedTerm: 快照中包含的最后一条日志条目的任期号<br>……</li></ol></blockquote><p>当跟随者收到了 InstallSnapshot RPC 发来的快照，它会根据自身的日志进行处理：</p><blockquote><ol><li>Follower 的日志信息不包括快照中的日志信息，或者包含与快照冲突的信息，这种情况直接使用快照内容替代自己的日志。</li><li>快照中的日志仅是 Follower 日志的子集（前缀）（由于网络重传或者错误），那么 Follower 中被快照包括的部分被代替，之后的部分仍然保留。</li></ol></blockquote><h2 id="快照创建"><a href="#快照创建" class="headerlink" title="快照创建"></a>快照创建</h2><p>各节点独立创建快照的方式背离了 Raft 的强领导者原则，因为跟随者可以在不知道领导者的情况下创建快照。虽然快照创建背离 Raft 的领导者原则，但是本质上还是以领导者为中心，并且这种背离是值得的。领导者的存在是为了解决在达成一致性时的冲突，但是在创建快照时一致性已经达成，因为创建快照是基于已经提交的日志条目的，所以没有领导者也是可以的。数据依然是从领导者传给跟随者。</p><p>不使用基于领导者的快照方案，一方面减少网络带宽的使用，降低了快照处理的时间，另一方面降低了 Leader 设计的复杂性。</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p><strong>写入频率问题</strong></p><p>快照不能创建的太频繁，否则会消耗大量磁盘带宽和其它资源。快照创建的频率太低，需要承受耗尽存储容量的风险，同时增加了回放日志的时间。解决上述问题一个简单策略就是设置一个阈值。</p><p><strong>服务暂停问题</strong></p><p>写入快照需要消耗显著的一段时间，并且我们不希望影响到正常的操作。可以通过 Copy-On-Write 技术解决该问题，如利用 Linux 上的 fork 指令复制父进程及所有内存中的状态，在子进程创建快照，父进程继续提供 Raft 基本服务。</p><h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><p>Raft 的安全性是为了保证每一个状态机会按照相同顺序执行相同的指令，即保证每个服务节点上的日志（数据副本）是一致的。如果没有安全性，数据的正确性和一致性就不能得到保证。例如，一个跟随者可能会进入不可用状态，同时领导者已经提交了一些日志条目，如果没有安全性，这个跟随者可能会被选举为领导者并且覆盖这些日志条目。前面的章节主要描述了 Raft 算法是如何选举和复制日志的，其中已经穿插了不少的安全机制，本章节对安全性进行补充。</p><p><strong>选举限制</strong></p><p>Raft 是一种强领导者模型的算法，只有从集群中选举出 Leader 才能处理客户端请求和协调 Raft 内部运行机制（如：心跳、日志复制，以及它们对应的一致性检查等）。</p><p>一个任期内只允许有一个领导者，这是由<strong>一个服务节点某一任期内最多只能投一票</strong> 和 <strong>只有获得 majority 投票的服务节点才会成为 Leader</strong> 这两个原则来保证的。为了实现这种机制，服务节点需要保证将自己的投票信息持久化，这样就能在服务节点崩溃之后也能恢复到之前的状态。否则就会出现服务节点已经作出投票，但在崩溃重启后在同一任期内将票又投给了另外一个不同服务节点的情况。</p><p>当一个候选者发起投票请求，它会包括自身的日志记录信息，索引 index、任期号 term 。当跟随者接收到请求，它会将候选者的日志信息与自己的日志信息进行比较，如果投票者的日志更完整，那么它会拒绝投票。Raft 是通过比较两份日志中最后一条日志条目的索引值和任期号定义哪个日志更新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更新，如果两份日志最后的条目任期号相同，则索引值大的更新。</p><p>Raft 保证所有之前的任期号中已经提交的日志条目都会出现在新的领导者中，不需要传送这些日志条目给领导者。这意味着日志条目是单向传送的，只能从领导者传给跟随者，并且领导者从不会覆盖自身本地日志中已经存在的日志条目。</p><p><strong>当前任期提交</strong></p><p>只要日志条目被复制到大多数的服务节点上，领导者就可以提交当前任期内的这一日志条目。领导者不会根据大多数原则去提交一个之前任期内的日志条目，只会根据大多数提交当前任期的日志条目。一旦当前任期的日志条目被提交，那么根据日志匹配特性，之前的日志条目也都会被间接的提交。如果领导者被选举后迟迟收不到客户端的请求，也就是意味着该领导者还不能确认哪些日志条目被提交，基于这个问题 Raft 通过让每个 Leader 在其任期开始时向日志中提交一个空的没有任何操作的日志条目，立即尝试复制来处理这个问题。</p><p><strong>状态机安全</strong></p><p>Raft 中某个节点将某一位置的日志条目应用到状态机，那么其它节点在同一位置不能应用不同的日志，也就是说，所有节点在同一位置（index）必须应用同样的日志。</p><h1 id="成员变更"><a href="#成员变更" class="headerlink" title="成员变更"></a>成员变更</h1><p>Raft 算法是强领导者模型，领导者选举建立在大多数的基础之上，当集群中的成员变更时就可能同时存在新旧配置的 2 个大多数，进而出现两个领导者，这会破坏 Raft 集群的领导者唯一性，影响了集群的运行。</p><p>尽管可以通过暂停整个集群，更新所有配置，然后重启整个集群的方式来解决因集群变更带来的问题，但是在更改的时候集群会不可用。Raft 通过单节点变更来解决成员变更问题。这里我们需要明确两个定义：</p><p><strong>配置</strong></p><blockquote><p>这里的配置是对集群中节点的描述，包括每台服务节点的 ID 、网络地址等。比如：A、B、C 组成的集群，那么集群的配置就是 [A、B、C] 集合。这些信息都非常重要，因为我们需要用它们来决定多数票的具体数量，从而进行领导者选举或用来提交日志。</p></blockquote><p><strong>单节点变更</strong></p><blockquote><p>单节点变更是利用一次变更一个节点，不会同时存在旧配置和新配置 2 个 大多数的特性，实现成员变更。</p></blockquote><h1 id="节点奔溃"><a href="#节点奔溃" class="headerlink" title="节点奔溃"></a>节点奔溃</h1><p>前面的章节对领导者节点的奔溃进行不同场景的介绍，核心关注点在于领导者节点奔溃的时机，不同时机奔溃集群处理不同，但是关键一点是大多数共识的日志条目不会丢失。跟随者和候选者奔溃后的处理方式相对比较简单，并且它们处理的方式相同。如果跟随者或者候选者奔溃了，后续发送它们的 RPC 消息都会失败。Raft 中处理这种失败就是简单的通过无限重试，如果奔溃的节点恢复了，那么 RPC 消息就会成功。如果一个服务节点完成了一个 RPC 请求，但是还没有响应的时候奔溃了，那么恢复后就会再次收到同样的请求。Raft 的 RPC 都是幂等的，所以这样重试不会造成任何问题。</p><h1 id="客户端协议"><a href="#客户端协议" class="headerlink" title="客户端协议"></a>客户端协议</h1><p><strong>请求领导者</strong></p><p>Raft 中的客户端发送所有请求给领导者，当客户端请求的不是领导者时，那么该服务节点会拒绝客户端的请求并向客户端提供它最近接收到的领导者的信息（AppendEntries RPC包含了领导者的网络地址）。如果领导者已经崩溃了，那么客户端的请求就会超时，客户端之后会再次重试随机挑选服务节点。</p><p><strong>线性语意</strong></p><p>Raft 的目标是要实现线性语义（每一次操作立即执行，只执行一次），但 Raft 是可以执行同一条指令多次的，如领导者提交日志条目后宕机了，那么客户端会和新的领导者重试这条指令，导致这条指令被再次执行。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令。</p><p>Raft 读取的是状态机运算后的数据。Raft 的读操作虽然直接从领导者节点读取，但是在网络分区的情况下可能会返回脏数据，而线性的读操作必须不能返回脏数据，Raft 使用两个额外的措施保证这一点。首先，领导者必须有关于被提交日志的最新信息，领导者完全特性保证了领导者一定拥有所有已经被提交的日志条目，但是在它任期开始的时候，可能还不知道哪些是已经被提交的，为了知道这些信息，它需要在它的任期里提交一条日志条目。Raft 中通过领导者在任期开始的时候提交一个空白的没有任何操作的日志条目到日志中去来实现。第二，领导者在处理只读的请求之前必须检查自己是否已经被废黜了（更新的领导者被选举出来）。Raft 中通过让领导人在响应只读请求之前，先和集群中的大多数节点交换一次心跳信息来处理这个问题。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Raft 算法本质上是通过复制日志来实现共识的，和客户端的交互依赖状态机执行日志条目的指令，集群内部通过选举、心跳、日志复制来协调。Raft 具体的做法是将共识问题分解为多个独立的子问题，高度概括为：先选举出领导者，由它完全负责 <code>replicated log</code> 的管理。此外，接受客户端写请求，然后复制到跟随者节点，并在 <code>安全</code> 的时候执行这些请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Raft 是一个共识算法（consensus algorithm），也称作 Raft 协议。所谓共识就是多个节点就某个事情达成一致，即使是在
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://gentryhuang.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Raft" scheme="https://gentryhuang.com/tags/Raft/"/>
    
      <category term="共识算法" scheme="https://gentryhuang.com/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - 链表</title>
    <link href="https://gentryhuang.com/posts/2362a8ea/"/>
    <id>https://gentryhuang.com/posts/2362a8ea/</id>
    <published>2021-03-16T11:33:59.000Z</published>
    <updated>2021-04-06T08:37:27.429Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol><li><p>redis中的链表</p><p>链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置这中数据结构，所以redis构建了自己的链表实现。</p></li><li><p>redis链表节点的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">  <span class="comment">// 前置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="comment">// 后置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">// 节点的值 (可用于保存各种不同类型的值)</span></span><br><span class="line">  <span class="keyword">void</span> *value</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>redis链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数，用于复制链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数，用于释放链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数，用于对比链表节点所保存的值和其他值是否相等</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>redis链表的特点</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)</span><br><span class="line">- 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点</span><br><span class="line">- 带表头和表尾指针：使用list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)</span><br><span class="line">- 带链表长度计数器：程序使用list结构的len属性标记链表中节点的个数，程序获取链表中节点个数的复杂度为O(1)</span><br><span class="line">- 多态：链表可以保存各种不同类型的值</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>链表在redis中的应用</p><p>链表被广泛用于实现redis的各种功能，如：列表键、发布与订阅、慢查询、监视器，redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;redis中的链表&lt;/p&gt;
&lt;p&gt;链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis数据结构" scheme="https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - 简单动态字符串</title>
    <link href="https://gentryhuang.com/posts/aa1d8127/"/>
    <id>https://gentryhuang.com/posts/aa1d8127/</id>
    <published>2021-03-13T11:00:50.000Z</published>
    <updated>2021-04-06T08:37:12.759Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h3><ol><li><p>初识动态字符串</p><p>redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS作为redis的默认字符串表示。 <code>在redis中，c字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如日志。当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，redis就会使用SDS来表示字符串值。</code> 值的注意的是，对于redis中的key都是使用SDS来实现的。此外，SDS除了用来保存Redis数据库中的字符串值之外，SDS还被用作缓冲区（buffer）: AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区。</p></li><li><p>sds的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">  <span class="comment">// 记录buf数组中已使用字节的数量等价于sds所保存字符串的长度</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">  <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">  <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>sds遵循c字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在sds的len属性中，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由sds函数自动完成的。遵循空字符结尾的好处是，sds可以直接使用一部分C字符串函数库里面的函数。</p></li><li><p>sds与c字符串的区别</p><p>c语言使用的简单字符串表示方式，并不能满足redis对字符串在安全性、效率以及功能方面的要求。</p><p>3.1  常数复杂度获取字符串长度</p><blockquote><p>因为c字符串并不记录自身的长度信息，所以要获取长度就必须遍历整个字符串，故获取字符串长度的复杂度为O(N)。而redis的sds结构中通过len属性记录了sds的长度，故获取字符串长度的复杂度为O(1)。注意，设置和更新sds长度的工作是由sds的API在执行时自动完成的，使用sds无须进行任何手动修改长度的操作。</p></blockquote><p>3.2 避免缓冲区溢出</p><blockquote><p>c字符串不记录自身长度，很容易造成缓冲区溢出。与c字符串不同，sds的空间分配策略完全杜绝了发生缓冲区溢出的可能性，当sds api需要对sds进行修改时，api会先检查sds的空间是否满足需要，如果不满足的话，api会自动将sds的空间扩展至执行所需的大小，然后才执行实际的修改操作，因此使用sds既不需要手动修改sds的空间大小，也不会出现c字符串中可能出现的缓冲区溢出问题。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line">    <span class="comment">//追加时先进行扩容，后面详细说明</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//拼接字符串</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s:原数组     </span></span><br><span class="line"><span class="comment">//strlen(t) 需拼接的目标数组的长度</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>3.3 内存分配与释放</p><p>因为c字符串的长度和底层数组的长度之间存在着关联性，所以<code>每次增加或者缩短一个c字符串，程序都总要对保存这个c字符串的数字进行一次分配操作</code>，但是内存分配操作涉及到复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，为了避免c字符串的这种缺陷，sds通过未使用空间解除了字符串长度和底层数组长度之间的关联，通过未使用空间，sds实现了空间预分配和惰性空间释放两种优化策略。</p><ul><li><p>空间预分配</p><p>空间预分配用于优化sds的字符串增长操作：当sds的api对一个sds进行修改，并且需要对sds进行空间扩展的时候，程序不仅会为sds分配修改所必须要的空间，还会为sds分配额外的未使用空间。通过空间预分配策略，redis可以减少连续执行字符串增长操作所需的内存重新分配次数，在扩展sds空间之前，sds api 会先检查未使用空间是否足够，如果足够就直接使用未使用空间，而不需要执行内存重新分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis 扩容源码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，</span></span><br><span class="line"><span class="comment"> * buf 至少会有 addlen + 1 长度的空余空间</span></span><br><span class="line"><span class="comment"> * （额外的 1 字节是为 \0 准备的）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *  sds ：扩展成功返回扩展后的 sds</span></span><br><span class="line"><span class="comment"> *        扩展失败返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前的空余空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 最少需要的长度</span></span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class="line">        <span class="comment">// 那么为它分配两倍于所需长度的空间</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足，分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 sds 的空余长度</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 sds</span></span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额外分配未使用空间数量的计算策略：</p><blockquote><ol><li>对sds修改后，sds的长度（即len属性的值）小于1MB，那么程序分配和len属性同样大小的未使用空间，这时sds的len属性的值将和free属性的值相同。例如：修改后sds的len变成10字节，那么程序也会分配10字节的未使用空间，sds的buf数组的实际长度：10 + 10 + 1 = 21字节</li><li>对sds修改后，sds的长度大于等于1MB，那么程序会分配1MB的未使用空间。例如：修改后sds的len变成30MB，那么程序会分配1MB的未使用空间，sds的buf数组的时间长度：30MB + 1MB + 1byte</li></ol></blockquote></li><li><p>惰性空间释放</p><p>惰性空间释放用于优化sds的字符串缩短操作：当sds的api需要缩短sds保存的字符串时，程序并不立即使用内存重分配来回收缩短后多来的字节，而是使用free属性将这些字节的数量纪录起来，用于将来对sds进行增长操作时，这些未使用空间可能就派上用场了。注意，sds也提供了相应的api，可以真正地释放sds的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</p></li></ul><p>3.4 二进制安全</p><blockquote><p>c字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里不能包含空字符，否则在读取的时候会被默认为结束字符，这些限制使得c字符串只能保存文本数据，不能保存图片、音视频、压缩文件这类的二进制数据。sds的api都是二进制安全的，所有的sds api都会以<code>二进制的方式处理sds存放在buf数组里的数据</code>,程序不会对其中的数据做任何限制、过滤，数据写入时是什么样，它被读取时就是什么样。<code>这也是将sds的buf属性称为字节数组的原因，redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据</code>。</p></blockquote></li><li><p>c字符串和sds之间的区别</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         C字符串                                    SDS</span><br><span class="line">- 获取字符串长度的复杂度为O（n）                 获取字符串长度的复杂度O（1）</span><br><span class="line">- API是不安全的，可能造成缓冲区溢出                      API是安全的</span><br><span class="line">- 修改字符串长度N次，必然要执行N次内存重分配     修改字符长度N次，最多执行N次内存重分配</span><br><span class="line">- 只能保存文本数据                                 可以保存文本或者二进制数据</span><br><span class="line">- 可使用&lt;string.h&gt;库中的函数                   可使用一部分&lt;string.h&gt;库中的函数</span><br></pre></td></tr></table></figure></li><li><p>sds更多的api可参考源码</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简单动态字符串&quot;&gt;&lt;a href=&quot;#简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;简单动态字符串&quot;&gt;&lt;/a&gt;简单动态字符串&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初识动态字符串&lt;/p&gt;
&lt;p&gt;redis没有直接使用C语言传统的字符串表示（以空字
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis数据结构" scheme="https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 异步改造</title>
    <link href="https://gentryhuang.com/posts/c812f120/"/>
    <id>https://gentryhuang.com/posts/c812f120/</id>
    <published>2021-02-13T16:00:00.000Z</published>
    <updated>2021-04-06T08:30:21.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>从 2.7.0 版本开始，Dubbo 的所有异步编程接口开始以 <code>CompletableFuture</code> 为基础，不仅支持了服务提供方的异步执行，而且对当前的异步调用功能进行了增强。异步改造引入了一些功能接口和实现，以及对部分逻辑进行了调整，但底层逻辑并没有改变，本篇文章将对 Dubbo 的异步演进进行介绍。</p><h1 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h1><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-invoke-model.jpg" alt></p><p><strong>Dubbo 的远程调用中大致可以分为以上 4 种调用方式：</strong></p><ul><li><strong>oneway:</strong> 客户端发送消息后，不需要接收响应。对于不需要关心服务响应结果的请求适合 oneway 通信。</li><li><strong>sync:</strong> Dubbo 默认的通信方式，即同步调用。</li><li><strong>async:</strong> 异步调用范畴，使用 Future 的方式获取结果。</li><li><strong>future:</strong> 异步调用范畴，使用 CompletableFuture 获取结果，也支持通过 Future 的方式获取结果。</li></ul><p><strong>注意：</strong> Dubbo 中的调用方式可以分为两大类，oneway 和 twoway ，对于 Dubbo 协议来说，会对这两种方式做分别处理，对于非 Dubbo 协议不会特别区分。</p><h1 id="Dubbo-2-6-x-异步实现"><a href="#Dubbo-2-6-x-异步实现" class="headerlink" title="Dubbo 2.6.x 异步实现"></a>Dubbo 2.6.x 异步实现</h1><p>Dubbo 2.6.x 的异步实现是针对消费端异步，只需指定调用方式为异步调用，并在需要结果的地方从 <strong>RpcContext</strong> 中取出 <strong>Future</strong> 获取结果即可。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li>指定异步调用<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置 async = true，表示异步调用。默认是 false，同步调用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">async</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li>通过上下文取出 Future<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String hello = demoService.sayHello(<span class="string">"world"</span>); <span class="comment">// call remote method</span></span><br><span class="line">Future&lt;String&gt; future = RpcContext.getContext().getFuture();</span><br><span class="line">String result = future.get();</span><br></pre></td></tr></table></figure></li></ol><p>具体调用实现可以参考 <a href="https://gentryhuang.com/posts/26722deb/#%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8">Dubbo异步调用</a> 。</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>Dubbo 2.6.x 提供了一定的异步编程能力，但其异步方式存在以下问题：</p><ul><li>Future 获取方式不够直接，业务方需要从 RpcContext 中获取。如果同时进行多个异步调用，如果使用不当很容易造成上下文污染。</li><li>Future 接口无法实现自动回调，而且定义的 ResponseFure (2.7 已经废弃)虽然支持回调，但支持的异步场景有限，并且不支持 Future 间的相互协调。</li><li>不支持服务端异步。</li></ul><h1 id="Dubbo-2-7-x-异步实现"><a href="#Dubbo-2-7-x-异步实现" class="headerlink" title="Dubbo 2.7.x 异步实现"></a>Dubbo 2.7.x 异步实现</h1><p>Dubbo 2.7.x 异步改造是对 Dubbo 2.6.x 异步功能的增强，引入的 <code>CompletableFuture</code> 既支持 <code>Future</code> 又支持 <code>Callback</code> 的调用方式，使用方可以根据需要自行选择。</p><h2 id="基础模型"><a href="#基础模型" class="headerlink" title="基础模型"></a>基础模型</h2><p>Dubbo 2.7.x 对异步实现进行了改造，引入了相关的接口和实现类，异步实现需要这些相关的基础模型配合完成。下面我们先对基础模型进行介绍。</p><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Result 相关的继承关系如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-invoke-transform-result-uml.jpg" alt></p><p>在 Dubbo 2.6.x 中统一使用 <code>RpcResult</code> 表示调用结果，Dubbo 2.7.x 中废弃了 <code>RpcResult</code> ，采用以下三个对象表示结果状态。</p><ul><li>AsyncRpcResult<blockquote><p>表示的是一个异步的、未完成的RPC调用，是在调用链中实际传递的对象。</p></blockquote></li><li>AppResponse<blockquote><p>表示的是服务端返回的具体响应，相当于 Dubbo 2.6.x 中的 RpcResult 。其子类是 DecodeableRpcResult。</p></blockquote></li><li>CompletableFuture<blockquote><p>表示的是服务端返回的结果，由调用端创建，用于封装 AppResponse 对象。其中 DefaultFuture 继承该类。</p></blockquote></li></ul><p>三者关系：AppResponse -&gt; CompletableFuture -&gt; AsyncResult ，下面我们对其进行介绍。</p><h4 id="AppResponse"><a href="#AppResponse" class="headerlink" title="AppResponse"></a>AppResponse</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppResponse</span> <span class="keyword">implements</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6925924956850004727L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 响应结果</span></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的异常信息</span></span><br><span class="line">    <span class="keyword">private</span> Throwable exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的附加信息</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; attachments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppResponse</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppResponse</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exception = exception;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">recreate</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 1 异常处理</span></span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// fix issue#619</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// get Throwable class</span></span><br><span class="line">                Class clazz = exception.getClass();</span><br><span class="line">                <span class="keyword">while</span> (!clazz.getName().equals(Throwable<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())) </span>&#123;</span><br><span class="line">                    clazz = clazz.getSuperclass();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// get stackTrace value</span></span><br><span class="line">                Field stackTraceField = clazz.getDeclaredField(<span class="string">"stackTrace"</span>);</span><br><span class="line">                stackTraceField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                Object stackTrace = stackTraceField.get(exception);</span><br><span class="line">                <span class="keyword">if</span> (stackTrace == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    exception.setStackTrace(<span class="keyword">new</span> StackTraceElement[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它方法 getter/setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AppResponse</code> 是调用的实际返回类型，相当于 Dubbo 2.6.x 中的 <code>RpcResult</code> ，理论上不需要实现 <code>Result</code> 接口，这样做是为了兼容。 </p><h4 id="DecodeableRpcResult"><a href="#DecodeableRpcResult" class="headerlink" title="DecodeableRpcResult"></a>DecodeableRpcResult</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecodeableRpcResult</span> <span class="keyword">extends</span> <span class="title">AppResponse</span> <span class="keyword">implements</span> <span class="title">Codec</span>, <span class="title">Decodeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(DecodeableRpcResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 通道</span></span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="comment">// 序列化类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> serializationType;</span><br><span class="line">    <span class="comment">// 序列化相关的输入流</span></span><br><span class="line">    <span class="keyword">private</span> InputStream inputStream;</span><br><span class="line">    <span class="comment">// 响应对象</span></span><br><span class="line">    <span class="keyword">private</span> Response response;</span><br><span class="line">    <span class="comment">// 调用信息</span></span><br><span class="line">    <span class="keyword">private</span> Invocation invocation;</span><br><span class="line">    <span class="comment">// 标志是否已经解码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasDecoded;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecodeableRpcResult</span><span class="params">(Channel channel, Response response, InputStream is, Invocation invocation, <span class="keyword">byte</span> id)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(channel, <span class="string">"channel == null"</span>);</span><br><span class="line">        Assert.notNull(response, <span class="string">"response == null"</span>);</span><br><span class="line">        Assert.notNull(is, <span class="string">"inputStream == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        <span class="keyword">this</span>.response = response;</span><br><span class="line">        <span class="keyword">this</span>.inputStream = is;</span><br><span class="line">        <span class="keyword">this</span>.invocation = invocation;</span><br><span class="line">        <span class="keyword">this</span>.serializationType = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">+--- DecodeableRpcResult</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 没有解码，则进行解码</span></span><br><span class="line">        <span class="keyword">if</span> (!hasDecoded &amp;&amp; channel != <span class="keyword">null</span> &amp;&amp; inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 解码</span></span><br><span class="line">                decode(channel, inputStream);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Decode rpc result failed: "</span> + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                response.setStatus(Response.CLIENT_ERROR);</span><br><span class="line">                response.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                hasDecoded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">---</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            Thread thread = Thread.currentThread();</span><br><span class="line">            log.debug(<span class="string">"Decoding in thread -- ["</span> + thread.getName() + <span class="string">"#"</span> + thread.getId() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 确定序列化方式，用于反序列化</span></span><br><span class="line">        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">                .deserialize(channel.getUrl(), input);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 读取一个 byte 的标志位，其值可能有 6 种</span></span><br><span class="line">        <span class="keyword">byte</span> flag = in.readByte();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 根据标志位判断当前结果中包含的信息，并调用不同的方法进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE:</span><br><span class="line">                handleValue(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION:</span><br><span class="line">                handleException(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">                handleAttachment(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">                <span class="comment">// 根据 RpcInvocation 中记录的返回值类型读取返回结果，并设置到当前类的 result 字段</span></span><br><span class="line">                handleValue(in);</span><br><span class="line">                <span class="comment">// 读取附加信息并设置到当前类的 attachmetns 中</span></span><br><span class="line">                handleAttachment(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:</span><br><span class="line">                handleException(in);</span><br><span class="line">                handleAttachment(in);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unknown result flag, expect '0' '1' '2' '3' '4' '5', but received: "</span> + flag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) in).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">---</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleValue</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 返回结果类型</span></span><br><span class="line">            Type[] returnTypes;</span><br><span class="line">            <span class="keyword">if</span> (invocation <span class="keyword">instanceof</span> RpcInvocation) &#123;</span><br><span class="line">                returnTypes = ((RpcInvocation) invocation).getReturnTypes();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                returnTypes = RpcUtils.getReturnTypes(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2 根据返回结果类型获取结果</span></span><br><span class="line">            Object value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (ArrayUtils.isEmpty(returnTypes)) &#123;</span><br><span class="line">                <span class="comment">// This almost never happens?</span></span><br><span class="line">                value = in.readObject();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (returnTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                value = in.readObject((Class&lt;?&gt;) returnTypes[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = in.readObject((Class&lt;?&gt;) returnTypes[<span class="number">0</span>], returnTypes[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3 设置结果 result</span></span><br><span class="line">            setValue(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            rethrow(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DecodeableRpcResult</code> 主要对响应结果进行解码，从字节流中获取数据对象。</p><h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p><code>CompletableFuture</code> 是 Java 8 提供的异步编程类，Dubbo 2.7.x 中的 <code>DefaultFuture</code> 继承了 CompletableFuture ，Dubbo 协议下对于 twoway 请求都会返回一个 <code>DefaultFuutre</code> 对象。此外，<code>DefaultFuture</code> 支持在请求的时候指定线程池，用来处理请求的响应，具体的我们会在下一篇文章中分析。</p><h4 id="AsyncRpcResult"><a href="#AsyncRpcResult" class="headerlink" title="AsyncRpcResult"></a>AsyncRpcResult</h4><p><code>AsyncRpcResult</code> 是在调用链中实际传递的对象，表示一个异步的，未完成的RPC调用。注意，它并不是实际的调用结果，<code>AppResponse</code> 才是业务结果。</p><h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncRpcResult</span> <span class="keyword">implements</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AsyncRpcResult<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当回调发生时，RpcContext 可能已经被更改。即执行 AsyncRpcResult 上添加的回调方法的线程可能先后处理过多个不同的 AsyncRpcResult 。</span></span><br><span class="line">    <span class="comment">// 因此，我们应该保留当前RpcContext实例的引用，并在回调执行之前恢复它。</span></span><br><span class="line">    <span class="keyword">private</span> RpcContext storedContext;</span><br><span class="line">    <span class="keyword">private</span> RpcContext storedServerContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此次 RPC 调用关联的线程池</span></span><br><span class="line">    <span class="keyword">private</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此次 RPC 调用关联的 Invocation 对象</span></span><br><span class="line">    <span class="keyword">private</span> Invocation invocation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求返回的对象 （由调用端创建）</span></span><br><span class="line">    <span class="keyword">private</span> CompletableFuture&lt;AppResponse&gt; responseFuture;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在构造方法中除了接收发送请求返回的 CompletableFuture&lt;AppResponse&gt; 对象，还会保存当前的 RPC 上下文</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncRpcResult</span><span class="params">(CompletableFuture&lt;AppResponse&gt; future, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.responseFuture = future;</span><br><span class="line">        <span class="keyword">this</span>.invocation = invocation;</span><br><span class="line">        <span class="keyword">this</span>.storedContext = RpcContext.getContext();</span><br><span class="line">        <span class="keyword">this</span>.storedServerContext = RpcContext.getServerContext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，<code>responseFuture</code> 属性不仅针对 Dubbo 协议，HTTP等协议调用返回结果也是 <code>CompletableFuture</code> 对象，都是由调用端创建。区别在于 Dubbo 协议一般返回的是 <code>DefaultFuture</code> 对象，而 HTTP 等协议会构造一个 <code>CompletableFuture</code> 对象，我们会在下面内容提到。</p><h5 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h5><p><code>AsyncRpcResult</code> 获取结果本质上需要先获取发送请求返回的 <code>CompletableFuture</code> ，也就是 <strong>responseFuture</strong> 属性，然后再从 <strong>responseFuture</strong> 中获取 <code>AppResponse</code> 对象，最后调用其对应的方法。</p><h6 id="获取-CompletableFuture"><a href="#获取-CompletableFuture" class="headerlink" title="获取 CompletableFuture"></a>获取 CompletableFuture</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">   <span class="function"><span class="keyword">public</span> CompletableFuture&lt;AppResponse&gt; <span class="title">getResponseFuture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="获取-AppResponse"><a href="#获取-AppResponse" class="headerlink" title="获取 AppResponse"></a>获取 AppResponse</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">getAppResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果完成，则获取 AppResponse</span></span><br><span class="line">            <span class="keyword">if</span> (responseFuture.isDone()) &#123;</span><br><span class="line">                <span class="keyword">return</span> responseFuture.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// This should not happen in normal request process;</span></span><br><span class="line">            logger.error(<span class="string">"Got exception when trying to fetch the underlying result from AsyncRpcResult."</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取默认的 AppResponse</span></span><br><span class="line">        <span class="keyword">return</span> createDefaultValue(invocation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法将始终在最大 timeout 等待之后返回：</span></span><br><span class="line"><span class="comment">     * 1. 如果value在超时前返回，则正常返回。</span></span><br><span class="line"><span class="comment">     * 2. 如果timeout之后没有返回值，则抛出TimeoutException。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">       <span class="comment">// 针对 ThreadlessExecutor 的特殊处理，这里调用 waitAndDrain() 等待响应</span></span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">            threadlessExecutor.waitAndDrain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseFuture.get(timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">            threadlessExecutor.waitAndDrain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseFuture.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中 <code>ThreadlessExecutor</code> 是一个特殊的线程池，主要用来解决同步调用模式下的响应，是对线程模型的优化，我们在下一篇文章中进行详细说明。</p><h6 id="获取结果-1"><a href="#获取结果-1" class="headerlink" title="获取结果"></a>获取结果</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">recreate</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation rpcInvocation = (RpcInvocation) invocation;</span><br><span class="line">        <span class="comment">//  1 如果是服务端的异步实现，则从上下文中取。</span></span><br><span class="line">        <span class="comment">// 为什么？ 因为接口返回的结果是 CompletableFuture,属于异步范畴（服务端的异步），和消费端异步类似。</span></span><br><span class="line">        <span class="keyword">if</span> (InvokeMode.FUTURE == rpcInvocation.getInvokeMode()) &#123;</span><br><span class="line">            <span class="keyword">return</span> RpcContext.getContext().getFuture();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2 获取 AppResponse 中的结果</span></span><br><span class="line">        <span class="keyword">return</span> getAppResponse().recreate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AsyncRpcResult.recreate()</code> 方法是获取结果的方法，也就是从 <code>AppResponse</code> 中获取结果。</p><h6 id="添加回调"><a href="#添加回调" class="headerlink" title="添加回调"></a>添加回调</h6><p>回调是 Dubbo 2.7.x 异步改造的重要角色，<code>AsyncRpcResult</code> 支持添加回调方法，而这个回调方法会被包装一层并注册到 <strong>responseFuture</strong> 上，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">whenCompleteWithContext</span><span class="params">(BiConsumer&lt;Result, Throwable&gt; fn)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在responseFuture之上注册回调</span></span><br><span class="line">        <span class="keyword">this</span>.responseFuture = <span class="keyword">this</span>.responseFuture.whenComplete((v, t) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 将当前线程的 RpcContext 记录到临时属性中，然后将构造函数中存储的 RpcContext 设置到当前线程中，为后面的回调执行做准备</span></span><br><span class="line">            beforeContext.accept(v, t);</span><br><span class="line">            <span class="comment">// 执行回调 （使用的 RpcContext 是回调所属服务方法的调用线程的 RpcContext）</span></span><br><span class="line">            fn.accept(v, t);</span><br><span class="line">            <span class="comment">// 恢复线程原有的 RpcContext</span></span><br><span class="line">            afterContext.accept(v, t);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在添加回调时，需要使用 <strong>beforeContext</strong> 和 <strong>afterContext</strong> 来保证执行回调的线程的 RpcContext 是最初创建 <code>AsyncRpcResult</code> 对象的线程对应的 RpcContext，执行完回调后需要将执行回调的线程的 RpcContext 恢复到原有值。其中 <strong>beforeContext</strong> 用于保存执行回调线程的 RpcContext，并将最初创建 <code>AsyncRpcResult</code> 对象的线程的 RpcContext 临时设置到执行回调用线程中，为执行回调做准备。<strong>afterContext</strong> 用于恢复执行回调用的线程原有的 RpcContext 。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="keyword">private</span> RpcContext tmpContext;</span><br><span class="line">    <span class="keyword">private</span> RpcContext tmpServerContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BiConsumer&lt;Result, Throwable&gt; beforeContext = (appResponse, t) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 将当前线程的 RpcContext 记录到 tmpContext 中</span></span><br><span class="line">        tmpContext = RpcContext.getContext();</span><br><span class="line">        tmpServerContext = RpcContext.getServerContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将构造函数中存储的 RpcContext (也就是创建 AsyncRpcResult 线程的 RpcContext) 设置到当前线程中</span></span><br><span class="line">        RpcContext.restoreContext(storedContext);</span><br><span class="line">        RpcContext.restoreServerContext(storedServerContext);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BiConsumer&lt;Result, Throwable&gt; afterContext = (appResponse, t) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 将当前线程的 RpcContext 恢复到原始值</span></span><br><span class="line">        RpcContext.restoreContext(tmpContext);</span><br><span class="line">        RpcContext.restoreServerContext(tmpServerContext);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>如此一来，<code>AsyncRpcResult</code> 就可以随意添加回调，无需担心 RpcContext 被污染。</p><p><code>AsyncRpcResult</code> 整个是为异步请求设计的，但是 Dubbo 中默认的请求方式是同步的，那么 Dubbo 又是如何支持同步调用的呢？Dubbo 进行服务引用时，在 <code>AbstractProtocol.refer()</code> 方法中，Dubbo 会将 <code>AbstractProtocol.protocolBindingRefer()</code> 方法实现返回的 Invoker 对象使用 <code>AsyncToSyncInvoker</code> 封装一层，该对象中的调用逻辑会对同步调用专门处理，我们在下面的内容中进行介绍。相比较而言，Dubbo 2.6.x 在 Dubbo 协议做了异步转同步处理，就是在调用时拿到 <code>DefaultFuture</code> 后立即阻塞等待结果。HTTP 协议就没有异步调用支持，而 Dubbo 2.7.x 使用了 <code>AbstractInvoker</code> 对 <strong>Future</strong> 功能进行统一支持，也就是 HTTP 协议也基本上支持了调用异步。</p><h3 id="Invoker"><a href="#Invoker" class="headerlink" title="Invoker"></a>Invoker</h3><h4 id="AsyncToSyncInvoker"><a href="#AsyncToSyncInvoker" class="headerlink" title="AsyncToSyncInvoker"></a>AsyncToSyncInvoker</h4><p><code>AsyncToSyncInvoker</code> 描述了异步转同步的逻辑，是对 <code>AsyncRpcResult</code> 获取结果的补充，触发时机是在执行调用的时候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncToSyncInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 服务引用的 Invoker</span></span><br><span class="line">    <span class="keyword">private</span> Invoker&lt;T&gt; invoker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncToSyncInvoker</span><span class="params">(Invoker&lt;T&gt; invoker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.invoker = invoker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> invoker.getInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        Result asyncResult = invoker.invoke(invocation);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是同步调用，则调用 get() 方法，阻塞等待响应返回。</span></span><br><span class="line">            <span class="comment">// 调用的是 AsyncRpcResult.get 方法，其底层调用的是 CompletableFuture 的 get 方法</span></span><br><span class="line">            <span class="keyword">if</span> (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * NOTICE!</span></span><br><span class="line"><span class="comment">                 * must call &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get(long, TimeUnit)&#125; because</span></span><br><span class="line"><span class="comment">                 * &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get()&#125; 被证明有严重的性能下降。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Interrupted unexpectedly while waiting for remote result to return!  method: "</span> +</span><br><span class="line">                    invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> TimeoutException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> +</span><br><span class="line">                        invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RemotingException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> +</span><br><span class="line">                        invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.UNKNOWN_EXCEPTION, <span class="string">"Fail to invoke remote method: "</span> +</span><br><span class="line">                        invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非同步调用直接返回调用结果 AsyncRpcResult</span></span><br><span class="line">        <span class="keyword">return</span> asyncResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AsyncToSyncInvoker</code> 是 Invoker 的装饰器，负责将异步调用转换成同步调用，也就是调用 <code>AsyncRpcResult</code> 中的 <code>CompletableFuture.get</code> 方法实现同步等待。相比 Dubbo 2.6.x 还是有很大区别的，Dubbo 2.6.x 使用 <strong>Future.get</strong> 功能阻塞等待，业务线程将处于阻塞等待状态，返回结果时需要消费端 Dubbo 线程池将结果写到 DefaultFuture 中，业务线程才能取出并返回。Dubbo 2.7.x 彻底优化了这种线程模型，关于优化的背景和实现会在下一篇文章中进行介绍，这里先了解即可。</p><h4 id="AbstractProxyInvoker"><a href="#AbstractProxyInvoker" class="headerlink" title="AbstractProxyInvoker"></a>AbstractProxyInvoker</h4><p><code>AbstractProxyInvoker</code> 是 Dubbo 框架在服务暴露过程中创建的对象，由 <code>ProxyFactory.getInvoker</code> 创建，是对服务接口实现的封装。该过程对 Dubbo 中所有协议一致。</p><h4 id="AbstractInvoker"><a href="#AbstractInvoker" class="headerlink" title="AbstractInvoker"></a>AbstractInvoker</h4><p>Dubbo 在服务引用时会创建消费端的 <code>Invoker</code>，对于不同的协议创建的 <code>Invoker</code> 有所不同。下面我们对 <strong>Dubbo 协议</strong> 和 <strong>使用 HTTP 通信的协议</strong> 创建 <code>Invoker</code> 流程进行分析。其中每个协议创建的 <code>Invoker</code> 都会继承 <code>AbstractInvoker</code> 抽象类，该抽象类中定义了通用的执行逻辑，如调用模式的确定。</p><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 Invoker 对象封装的业务接口类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="comment">// 当前 Invoker 关联的 URL 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="comment">// 当前 Invoker 关联的一些附加信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attachment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标志 Invoker 的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> available = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractInvoker</span><span class="params">(Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(type, url, (Map&lt;String, Object&gt;) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractInvoker</span><span class="params">(Class&lt;T&gt; type, URL url, String[] keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(type, url, convertAttachment(url, keys));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractInvoker</span><span class="params">(Class&lt;T&gt; type, URL url, Map&lt;String, Object&gt; attachment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"service type == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"service url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.attachment = attachment == <span class="keyword">null</span> ? <span class="keyword">null</span> : Collections.unmodifiableMap(attachment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="invoke-方法"><a href="#invoke-方法" class="headerlink" title="invoke 方法"></a>invoke 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// if invoker is destroyed due to address refresh from registry, let's allow the current invoke to proceed</span></span><br><span class="line">        <span class="keyword">if</span> (destroyed.get()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Invoker for service "</span> + <span class="keyword">this</span> + <span class="string">" on consumer "</span> + NetUtils.getLocalHost() + <span class="string">" is destroyed, "</span></span><br><span class="line">                    + <span class="string">", dubbo version is "</span> + Version.getVersion() + <span class="string">", this invoker should not be used any longer"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcInvocation invocation = (RpcInvocation) inv;</span><br><span class="line">        invocation.setInvoker(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(attachment)) &#123;</span><br><span class="line">            invocation.addObjectAttachmentsIfAbsent(attachment);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 从上下文中取出 附加信息</span></span><br><span class="line">        Map&lt;String, Object&gt; contextAttachments = RpcContext.getContext().getObjectAttachments();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(contextAttachments)) &#123;</span><br><span class="line">            invocation.addObjectAttachments(contextAttachments);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 设置调用模式  SYNC, ASYNC, FUTURE 。注意，oneway 调用方式</span></span><br><span class="line">        <span class="comment">// 根据以下方式确定调用模式：</span></span><br><span class="line">        <span class="comment">// 1) 根据返回值类型是否是 CompletableFuture ，或方法名是 $invokeAsync，则是 FUTURE 模式。这个属于服务端异步。</span></span><br><span class="line">        <span class="comment">// 2) 根据 async 属性，如果设置 async=true ，则是 ASYNC 模式</span></span><br><span class="line">        <span class="comment">// 3) 默认是 SYNC 模式</span></span><br><span class="line">        invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3 如果是异步调用的模式，则给本次调用添加一个唯一id (FUTURE 模式不属于)</span></span><br><span class="line">        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">        AsyncRpcResult asyncResult;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 调用子类实现的 doInvoker() 方法</span></span><br><span class="line">            asyncResult = (AsyncRpcResult) doInvoke(invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对调用异常的处理</span></span><br><span class="line">            <span class="comment">// 4.1 创建 CompletableFuture 对象，使用该对象包装 AppResponse 对象</span></span><br><span class="line">            <span class="comment">// 4.2 使用 AppResponse 对象包装异常信息</span></span><br><span class="line">            <span class="comment">// 4.3 使用 AsyncRpcResult 最后包装 CompletableFuture 对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123; <span class="comment">// biz exception</span></span><br><span class="line">            Throwable te = e.getTargetException();</span><br><span class="line">            <span class="keyword">if</span> (te == <span class="keyword">null</span>) &#123;</span><br><span class="line">                asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (te <span class="keyword">instanceof</span> RpcException) &#123;</span><br><span class="line">                    ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);</span><br><span class="line">                &#125;</span><br><span class="line">                asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, te, invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.isBiz()) &#123;</span><br><span class="line">                asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            asyncResult = AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e, invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 使用 FutureContext 保存 FutureAdapter，FutureAdapter 中会封装 AsyncRpcResult 中的 CompletableFuture 对象</span></span><br><span class="line">        RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter(asyncResult.getResponseFuture()));</span><br><span class="line">        <span class="keyword">return</span> asyncResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AbstractInvoker</code> 的 <strong>invoke</strong> 方法是调用服务的模版方法，具体调用细节交给具体子类实现。</p><ol><li>设置附加信息到调用信息 Invocation 中。</li><li>设置调用模式<ul><li><strong>FUTURE:</strong> 根据返回值类型是否是 <code>CompletableFuture</code> ，或方法名是否是 <code>$invokeAsync</code>，则是 FUTURE 模式。这个属于服务端异步。</li><li><strong>ASYNC:</strong> 根据 async 属性，如果设置 async=true ，则是 ASYNC 模式。</li><li><strong>SYNC:</strong> 默认调用模式。</li></ul></li><li>异步调用时，给本地调用添加一个唯一id，并设置到附加属性中。</li><li>调用具体子类 Invoker 对象的 <code>doInvoke</code> 方法，不管是哪个子类实现，调用的结果都是 <code>AsyncRpcResult</code> 类型。</li><li>如果调用异常，则对异常进行处理。</li><li>使用上下文保存 FutureAdapter ，其中 FutureAdapter 中会封装 AsyncRpcResult 中的 CompletableFuture 对象。在后续的链路中可以使用 <strong>Future</strong> 的异步功能。</li></ol><p><strong>注意:</strong></p><blockquote><p>相比 Dubbo 2.6.x，<code>AbstractInvoker</code> 的模版方法中实现了异步逻辑，也就是任何协议的服务调用都支持 <code>Future</code> 的异步功能。在 Dubbo 2.6.x 中非 Dubbo 协议大都不支持异步调用特性。</p></blockquote><h2 id="Dubbo协议异步实现"><a href="#Dubbo协议异步实现" class="headerlink" title="Dubbo协议异步实现"></a>Dubbo协议异步实现</h2><h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><p><code>DubboInvoker</code> 是 Dubbo 协议在消费端创建的 Invoker 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取此次调用的方法名</span></span><br><span class="line">        <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 向 Invocation 中添加附加信息，这里将 URL 的 path 和 version 添加到附加信息中</span></span><br><span class="line">        inv.setAttachment(PATH_KEY, getUrl().getPath());</span><br><span class="line">        inv.setAttachment(VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 选择一个 ExchangeClient 实例</span></span><br><span class="line">        ExchangeClient currentClient;</span><br><span class="line">        <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">            currentClient = clients[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4 判断是否是 oneway 调用，不关心服务端的响应结果。调用后直接返回一个空 AsyncRpcResult</span></span><br><span class="line">            <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            <span class="comment">// 根据调用方法名和配置，计算此次调用的超时时间</span></span><br><span class="line">            <span class="keyword">int</span> timeout = calculateTimeout(invocation, methodName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 request() 方法会相应创建 DefaultFuture 对象以及检测超时的定时任务，而 send() 方法则不会创建这些东西。</span></span><br><span class="line">            <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">                <span class="comment">// 是否等待底层 NIO 将请求发出，等待时间默认 1s，1s未发送则抛出异常</span></span><br><span class="line">                <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">                currentClient.send(inv, isSent);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回已完成状态的 AsynRpcResult 即 AsynRpcResult -&gt; CompletableFuture（已完成状态） -&gt; AppResponse（空结果）</span></span><br><span class="line">                <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(invocation);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 需要关注返回值的请求</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5 获取处理响应的线程池 </span></span><br><span class="line">                ExecutorService executor = getCallbackExecutor(getUrl(), inv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 6 调用 ExchangeClient.request() 方法，将 Invocation 包装成 Request 请求发送出去，同时会创建相应的 DefaultFuture 返回。</span></span><br><span class="line">                CompletableFuture&lt;AppResponse&gt; appResponseFuture =</span><br><span class="line">                        <span class="comment">// currentClient.request 返回的是 DefaultFuture，DefaultFuture 继承了 CompletableFuture 。</span></span><br><span class="line">                        currentClient.request(inv, timeout, executor)</span><br><span class="line">                                <span class="comment">// 增加了一个回调，取出其中的 AppResponse 对象。</span></span><br><span class="line">                                <span class="comment">// thenApply 是一个回调,obj 是 上一个任务的结果。返回的 AppResponse 表示的是 服务端返回的具体响应。</span></span><br><span class="line">                                .thenApply(obj -&gt; (AppResponse) obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter</span></span><br><span class="line">                FutureContext.getContext().setCompatibleFuture(appResponseFuture);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7 这里将 CompletableFuture （其实是 DefaultFuture） 封装成 AsyncRpcResult 并返回</span></span><br><span class="line">                AsyncRpcResult result = <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, inv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 8 设置处理响应的线程池</span></span><br><span class="line">                result.setExecutor(executor);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 9 返回调用</span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DubboInvoker</code> 进行远程调用时，会分别对 <strong>oneway</strong> 和 <strong>twoway</strong> 进行处理。</p><ul><li>处理 <strong>oneway</strong> 调用方式<blockquote><p>不需要响应结果，直接使用客户端的 <strong>send</strong> 方法即可，该方法不会返回服务端的响应。<code>DubboInvoker</code> 会返回一个空结果的 <code>AsyncRpcResult</code> 对象给业务方。</p></blockquote></li><li>处理 <strong>twoway</strong> 调用方式<blockquote><p>需要响应结果，使用客户端的 <strong>request</strong> 方法发送请求，该方法会创建并返回本次调用的 DefaultFuture 对象，当服务端响应时会更新 DefaultFuture 中的结果信息。此外，Dubbo 对线程模型进行了优化，可以指定处理响应的线程池，特别是同步调用的线程池，这个我们在下一篇文章中详细介绍。</p></blockquote></li></ul><p>相比较 Dubbo 2.6.x 中的 <code>DefaultFuture</code>，引入了 <code>CompletableFuture</code> 可以支持多异步场景，并且支持 <code>Future</code> 间的相互协调，此外提供了良好的回调方法，避免等待响应而阻塞。这是对 <code>ExchangeClient</code> 的改造，将 Dubbo 2.6.x 中异步编程接口都替换成了 <code>CompletableFuture</code> 。介绍完消费端的异步实现后，下面我们来看看服务端的异步实现。</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p><code>AbstractProxyInvoker</code> 是 Dubbo 协议在服务端创建的 Invoker，它封装的是服务接口实现。Dubbo 协议下的服务暴露会使用 <code>ProxyFactory#getInvoker</code> 将服务接口实现封装成 <code>AbstractProxyInvoker</code>。当收到请求时，通道处理器链上的每个处理器都会对该请求进行各自逻辑的处理，其中 <code>HeaderExchangeHandler#handleRequest</code> 会将请求交给 <code>DubboProtocol</code> 中的 <code>ExchangeHandler</code> 处理，Dubbo 协议下的服务端异步实现处理逻辑就在这三者中。在分析源码之前，我们先看服务端异步实现的例子：</p><h4 id="异步实现"><a href="#异步实现" class="headerlink" title="异步实现"></a>异步实现</h4><p>服务提供端异步执行将阻塞的业务从 Dubbo 内部线程池切换到业务自定义线程，在一定程度上避免 Dubbo 线程池的过度占用，有助于避免不同服务间的互相影响。</p><h5 id="定义-CompletableFuture-签名接口"><a href="#定义-CompletableFuture-签名接口" class="headerlink" title="定义 CompletableFuture 签名接口"></a>定义 <code>CompletableFuture</code> 签名接口</h5><ul><li>服务接口定义<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line">    <span class="function">CompletableFuture&lt;String&gt; <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>服务实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncServiceImpl</span> <span class="keyword">implements</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        RpcContext savedContext = RpcContext.getContext();</span><br><span class="line">        <span class="comment">// 建议为supplyAsync提供自定义线程池，避免使用JDK公用线程池</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"async response from provider."</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过 <code>return CompletableFuture.supplyAsync()</code> ，业务执行已从 Dubbo 线程切换到业务线程，避免了对 Dubbo 线程池的阻塞。</p><h5 id="服务消费方"><a href="#服务消费方" class="headerlink" title="服务消费方"></a>服务消费方</h5><p> <code>CompletableFuture</code> 签名接口是服务提供方的异步实现，消费端同普通消费一致，Dubbo 内部会根据调用的方法返回值类型等方式确定 <strong>调用模式</strong>，具体的在后面的源码部分介绍。</p><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p>Dubbo 2.7 虽然支持了服务端的异步，但 Dubbo 的线程模型本身就是异步处理的方式，因此服务端的异步特性相对还是有点鸡肋的。</p><p>了解了服务端异步实现后，下面我们从代码层面分析，Dubbo 如何就 <code>CompletableFuture</code> 签名服务接口方法实现异步的。</p><h4 id="HeaderExchangeHandler-处理请求"><a href="#HeaderExchangeHandler-处理请求" class="headerlink" title="HeaderExchangeHandler 处理请求"></a>HeaderExchangeHandler 处理请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+--- HeaderExchangeHandler</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">        <span class="comment">// 省略异常处理代码</span></span><br><span class="line"></span><br><span class="line">        Object msg = req.getData();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 使用上层通道处理器处理消息，其实就是 DubboProtocol 中的 ExchangeHandler </span></span><br><span class="line">            CompletionStage&lt;Object&gt; future = handler.reply(channel, msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 请求处理完成回调，将结果发送到对端</span></span><br><span class="line">            future.whenComplete((appResult, t) -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        res.setStatus(Response.OK);</span><br><span class="line">                        res.setResult(appResult);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">                        res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3 将处理后的结果发送到对端</span></span><br><span class="line">                    channel.send(res);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Send result to consumer failed, channel is "</span> + channel + <span class="string">", msg is "</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">            res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">            channel.send(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>相比较与 Dubbo 2.6.x 中的处理请求逻辑，这里使用了 <code>CompletableFuture</code> 的完成回调，避免了阻塞等待请求完成。这得益于对通道处理 ExchangeHandler 的异步方法的改造，也就是 DubboProtocol 中的 ExchangeHandler 的实现。</p><h4 id="DubboProtocol-的处理器"><a href="#DubboProtocol-的处理器" class="headerlink" title="DubboProtocol 的处理器"></a>DubboProtocol 的处理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboProtocol</span><br><span class="line"><span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> ExchangeHandlerAdapter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CompletableFuture&lt;Object&gt; <span class="title">reply</span><span class="params">(ExchangeChannel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line"></span><br><span class="line">            Invocation inv = (Invocation) message;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取暴露的 Invoker，这里是 AbstractProxyInvoker</span></span><br><span class="line">            Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">           </span><br><span class="line">            RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果服务端异步实现，这里返回的 result 是一个 AsyncRpcResult 类型对象，其中的 AppResonse 中的值并非 CompletableFuture 类型，而是 CompletableFuture 封装的 AppResponse</span></span><br><span class="line">            Result result = invoker.invoke(inv);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result.thenApply(Function.identity());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DubboProtocol 中的 ExchangeHandler 的请求处理方法返回的是 CompletableFuture 对象，这同样是 Dubbo 2.7.x 中的改造，服务方法的结果统一包装成 <code>CompletableFuture</code> 类型，在服务端的 Invoker 的执行逻辑中就可以体现这一点，下面我们就来看 <code>AbstractProxyInvoker</code> 。</p><h4 id="AbstractProxyInvoker-1"><a href="#AbstractProxyInvoker-1" class="headerlink" title="AbstractProxyInvoker"></a>AbstractProxyInvoker</h4><p>服务端的 Invoker，直接封装服务接口实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractProxyInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 执行服务方法，如 DemoService.sayHello </span></span><br><span class="line">            Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 将方法结果以 CompletableFuture 对象形式进行封装。</span></span><br><span class="line">            <span class="comment">// 注意：如果服务方法返回类型是 CompletableFuture ，则无需再使用 CompletableFuture 包装。这个针对服务端的异步实现。</span></span><br><span class="line">            CompletableFuture&lt;Object&gt; future = wrapWithFuture(value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 执行 future 逻辑</span></span><br><span class="line">            CompletableFuture&lt;AppResponse&gt; appResponseFuture = future.handle((obj, t) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4 使用 AppResponse 封装实际结果</span></span><br><span class="line">                AppResponse result = <span class="keyword">new</span> AppResponse();</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t <span class="keyword">instanceof</span> CompletionException) &#123;</span><br><span class="line">                        result.setException(t.getCause());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.setException(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.setValue(obj);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 统一包装成 AsyncRpcResult 对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (RpcContext.getContext().isAsyncStarted() &amp;&amp; !RpcContext.getContext().stopAsync()) &#123;</span><br><span class="line">                logger.error(<span class="string">"Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e.getTargetException(), invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to invoke remote proxy method "</span> + invocation.getMethodName() + <span class="string">" to "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>AbstractProxyInvoker</code> 的执行逻辑主要有四点，下面进行总结：</p><ol><li>执行服务接口实例方法，如 demoService.sayhello 方法。</li><li>将服务实例方法的调用结果包装成 <code>CompletableFuture</code> ，<strong>如果是服务端异步实现（服务接口方法返回类型是 CompletableFuture），则无需对结果进行包装，直接使用返回的 <code>CompletableFuture</code></strong> 即可。</li><li>执行 <code>CompletableFuture</code> 的回调方法，将实际结果封装到 AppResponse 中。</li><li>将返回结果包装成 AsyncRpcResult 对象。</li></ol><h2 id="HTTP-协议实现"><a href="#HTTP-协议实现" class="headerlink" title="HTTP 协议实现"></a>HTTP 协议实现</h2><h3 id="消费端-1"><a href="#消费端-1" class="headerlink" title="消费端"></a>消费端</h3><p>Dubbo 中的 HTTP 协议在消费端创建的 Invoker 是一个 <code>AbstractInvoker</code> 匿名对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">+--- AbstractProxyProtocol</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">protocolBindingRefer</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; type, <span class="keyword">final</span> URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 调用子类实现的 doRefer() 方法返回一个目标服务接口的代理对象</span></span><br><span class="line">        <span class="comment">// 2 使用 ProxyFactory.getInvoker() 方法将服务接口的代理对象封装成一个 Invoker ，类型是 AbstractProxyInvoker。</span></span><br><span class="line">        <span class="keyword">final</span> Invoker&lt;T&gt; target = proxyFactory.getInvoker(doRefer(type, url), type, url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 创建 AbstractInvoker 的匿名对象</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = <span class="keyword">new</span> AbstractInvoker&lt;T&gt;(type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 4 调用 AbstractProxyInvoker.invoke 方法，返回的结果是 AsyncRpcResult</span></span><br><span class="line">                    Result result = target.invoke(invocation);</span><br><span class="line">                    <span class="comment">// FIXME result is an AsyncRpcResult instance.</span></span><br><span class="line">                    Throwable e = result.getException();</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Class&lt;?&gt; rpcException : rpcExceptions) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (rpcException.isAssignableFrom(e.getClass())) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> getRpcException(type, url, invocation, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.getCode() == RpcException.UNKNOWN_EXCEPTION) &#123;</span><br><span class="line">                        e.setCode(getErrorCode(e.getCause()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> getRpcException(type, url, invocation, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        invokers.add(invoker);</span><br><span class="line">        <span class="keyword">return</span> invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Dubbo 协议下的服务调用不仅引入 CompletableFuture ，还对方法等进行改造，如 <code>HeaderExchangeClient.request</code> 方法。<strong>HTTP 协议下的服务调用异步改造力度相对不大</strong>，异步实现主要依赖引入的 CompletableFuture ，以及在 <code>AbstractInvoker</code> 中统一的 <code>Future</code> 异步功能。</p><p><strong>特别说明：</strong></p><blockquote><p>为什么将 <code>doRefer</code> 返回的代理对象通过 <code>ProxyFactory.getInvoker</code> 包装成 <code>AbstractProxyInvoker</code> 对象？因为此代理对象具备和远程服务通信的能力，原则上可以使用该代理对象调用服务接口方法，但是调用信息是存在 <code>Invocation</code> 中，将该代理对象包装成 <code>AbstractProxyInvoker</code> 可以根据 <code>Invocation</code> 中的信息动态选择目标服务方法。本质上和 DubboInvoker 类似，DubboInvoker 和远程服务通信需要使用 <code>ExchangeClient</code>，将调用信息 <code>Invocation</code> 交给它即可实现目标服务的调用，这里的代理对象就相当于 DubboInvoker 中的 <code>ExchangeClient</code> 。</p></blockquote><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p>使用 <code>JsonRpcServer</code> 暴露服务，具体过程可参考：<a href="https://gentryhuang.com/posts/c5a37c18/#%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2-2">HTTP协议服务暴露</a> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--- HttpProtocol.doExport</span><br><span class="line"><span class="comment">// 5 创建 JsonRpcServer，暴露服务</span></span><br><span class="line">JsonRpcServer skeleton = <span class="keyword">new</span> JsonRpcServer(impl, type);</span><br><span class="line">JsonRpcServer genericServer = <span class="keyword">new</span> JsonRpcServer(impl, GenericService<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中的具有服务能力的 <strong>impl</strong> 是 <code>ProxyFactory#getProxy(org.apache.dubbo.rpc.Invoker&lt;T&gt;, boolean)</code>  创建的代理对象，具体逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractProxyProtocol</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 省略无关代码</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String uri = serviceKey(invoker.getUrl());</span><br><span class="line">        Exporter&lt;T&gt; exporter = (Exporter&lt;T&gt;) exporterMap.get(uri);</span><br><span class="line">        <span class="keyword">if</span> (exporter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// When modifying the configuration through override, you need to re-expose the newly modified service.</span></span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(exporter.getInvoker().getUrl(), invoker.getUrl())) &#123;</span><br><span class="line">                <span class="keyword">return</span> exporter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其中的 invoker 是由 ProxyFactory#getInvoker 创建</span></span><br><span class="line">        <span class="keyword">final</span> Runnable runnable = doExport(proxyFactory.getProxy(invoker, <span class="keyword">true</span>), invoker.getInterface(), invoker.getUrl());</span><br><span class="line">        exporter = <span class="keyword">new</span> AbstractExporter&lt;T&gt;(invoker) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.unexport();</span><br><span class="line">                exporterMap.remove(uri);</span><br><span class="line">                <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        runnable.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        logger.warn(t.getMessage(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        exporterMap.put(uri, exporter);</span><br><span class="line">        <span class="keyword">return</span> exporter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>不难看出最终处理请求的还是上面方法传入的 <code>invoker</code> 对象，该对象中包含真正的服务实例。而传入的 <code>invoker</code> 对象是由 <code>ProxyFactory#getInvoker</code> 创建的，对象类型是 <code>AbstractProxyInvoker</code> ，下面以 <code>JavassistProxyFactory</code> 工厂为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistProxyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Wrapper cannot handle this scenario correctly: the classname contains '$'</span></span><br><span class="line">        <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">'$'</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把前文的 <code>AbstractProxyInvoker</code> 的代码实现粘贴过来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractProxyInvoker</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1 执行服务方法，如 DemoService.sayHello </span></span><br><span class="line">            Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 将方法结果以 CompletableFuture 对象形式进行封装。</span></span><br><span class="line">            <span class="comment">// 注意：如果服务方法返回类型是 CompletableFuture ，则无需再使用 CompletableFuture 包装。这个针对服务端的异步实现。</span></span><br><span class="line">            CompletableFuture&lt;Object&gt; future = wrapWithFuture(value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 执行 future 逻辑</span></span><br><span class="line">            CompletableFuture&lt;AppResponse&gt; appResponseFuture = future.handle((obj, t) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4 使用 AppResponse 封装实际结果</span></span><br><span class="line">                AppResponse result = <span class="keyword">new</span> AppResponse();</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t <span class="keyword">instanceof</span> CompletionException) &#123;</span><br><span class="line">                        result.setException(t.getCause());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.setException(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.setValue(obj);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 统一包装成 AsyncRpcResult 对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (RpcContext.getContext().isAsyncStarted() &amp;&amp; !RpcContext.getContext().stopAsync()) &#123;</span><br><span class="line">                logger.error(<span class="string">"Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> AsyncRpcResult.newDefaultAsyncResult(<span class="keyword">null</span>, e.getTargetException(), invocation);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to invoke remote proxy method "</span> + invocation.getMethodName() + <span class="string">" to "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于使用 HTTP 协议的服务实现，更多的是在形式上保持统一，和 Dubbo 协议的服务实现类似。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Dubbo 2.6.x 及之前版本中使用 <code>Future</code> 实现异步功能，并且不支持服务端的异步，这在功能设计上存在一些问题，Dubbo 2.7.x 基于 <code>CompletableFuture</code> 对异步功能进行了增强，弥补了功能设计上的一些问题。由于 <code>CompletableFuture</code> 实现了 <code>CompletionStage</code> 和 <code>Future</code> 接口，因此仍然支持 Dubbo 2.6 中通过 <strong>get()</strong> 或者 <strong>isDone()</strong> 方法轮询结果。但是，不建议使用 <strong>get()</strong> 这样阻塞的方式获取结果，因为这样做的的话就丢失了异步操作带来的性能提升。<code>CompletableFuture</code> 提供了良好的回调支持，如 <strong>whenComplete()</strong> 等方法可以在逻辑完成后，执行回调逻辑。同时 <code>CompletableFuture</code> 支持 <code>Future</code> 间的相互协调，如 <strong>thenApply()</strong> 等方法。正是由于 <code>CompletableFuture</code> 强大的功能，我们可以更加流畅地使用回调而无需等待响应而阻塞调用线程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;从 2.7.0 版本开始，Dubbo 的所有异步编程接口开始以 &lt;code&gt;CompletableFuture&lt;/code&gt; 为基础，不仅支
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 线程模型改造</title>
    <link href="https://gentryhuang.com/posts/13d5a11a/"/>
    <id>https://gentryhuang.com/posts/13d5a11a/</id>
    <published>2021-02-05T16:00:00.000Z</published>
    <updated>2021-04-06T08:30:05.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 <a href="https://gentryhuang.com/posts/c812f120/">异步改造</a> 中对 Dubbo 2.7.x 中异步调用和异步实现进行了详细说明。其中 Dubbo 协议下，在对异步调用进行分析时，我们发现 <code>ThreadlessExecutor</code> 被多次使用，此外 <code>ExchangeChannel#request</code> 方法支持设置处理响应的线程池。本篇文章我们将对 Dubbo 线程池模型优化进行介绍，其中消费端线程池模型优化就是从这两个方面进行改造的。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo 协议下创建 NIO 服务器和客户端都会分别创建各自的线程池。2.7.x 之前版本的线程池的创建是由派发器 <code>Dispatcher</code> 创建的 <code>WrappedChannelHandler</code> 完成的。<code>Dispatcher</code> 和 <code>WrappedChannelHandler</code> 之间的关系可以参考 <a href="https://gentryhuang.com/posts/53cd7ee7/#WrappedChannelHandler">线程模型</a> 。2.7.x 新增了 <code>ExecutorRepository</code> 用于创建和管理线程池。 <code>WrappedChannelHandler</code> 的子类实现了消息派发功能，即决定了 Dubbo 以哪种线程模型处理收到的消息和事件。因为 NIO 服务器端和客户端都会初始化线程池，这意味着服务端和客户端都可能使用自己的线程池来处理本端收到的消息和事件，具体的策略由 <code>WrappedChannelHandler</code> 的子类决定。</p><h1 id="从-Issues-谈起"><a href="#从-Issues-谈起" class="headerlink" title="从 Issues 谈起"></a>从 Issues 谈起</h1><p>点这里：<a href="https://github.com/apache/dubbo/issues/1896" target="_blank" rel="noopener">消费者中建立了太多DubboClientHandler线程</a></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote><p>Dubbo Version: 2.5.3<br>我有一个非常大的provider 集群（30个实例）。然后我们发现在客户端，为每一个实例，都准备了一个独立线程池，所以我们看到有30个线程池以去发起消费请求，这个从jstack堆栈上可以证明，因为里面很多线程组的名字是类似DubboClientHandler-IP1-XXX，其中ip都是不一样的。</p></blockquote><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>之所以我们提供如此大的服务集群，是因为我们希望最大化TPS，但现在集群是大了，但是消费者又因此导致巨大的线程消耗（高CPU）。我们能否通过配置改变这个线程的模型，例如用一个共享的线程池去处理所有的服务实例，这样最大的线程数便可控了。</p></blockquote><h2 id="待优化"><a href="#待优化" class="headerlink" title="待优化"></a>待优化</h2><blockquote><p>对 2.7.5 版本之前的 Dubbo 应用，在 <code>WrappedChannelHandler</code> 中会为 <strong>每个客户端连接启动一个线程池</strong>，因为不会根据 URL 复用线程池，这意味着每个消费端都浪费着一定的资源。此外，对于同步调用，业务线程发起调用后要阻塞等待响应，服务端返回响应后需要消费端线程池将结果保存起来然后通知业务线程，这个过程业务线程处于空闲状态，而接收响应却是消费端线程池完成，<strong>被阻塞的业务线程没有被有效利用</strong>。当面临需要消费大量服务且并发数比较大的大流量场景时（典型如网关类场景），经常会出现消费端线程数分配过多的问题。</p></blockquote><h1 id="Dubbo-2-6-x-线程模型"><a href="#Dubbo-2-6-x-线程模型" class="headerlink" title="Dubbo 2.6.x 线程模型"></a>Dubbo 2.6.x 线程模型</h1><p>这里以 Netty 实现为例，Mina 等 NIO 组件类似。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyServer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// ChannelHandlers.wrap方法，用来包装 ChannelHandler，实现Dubbo 线程模型的功能</span></span><br><span class="line">        <span class="comment">// 线程名前缀 DubboServerHandler</span></span><br><span class="line">        <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在创建、启动 Netty 服务时会通过 <code>ChannelHandlers.wrap</code> 方法为传入的 ChannelHandler 依次包装 <code>AllChannelHandler(默认)</code>、<code>HeartbeatHandler</code>以及 <code>MultiMessageHandler</code> 。其中 <code>AllChannelHanlder</code> 是消息派发处理器，其父类 <code>WrappedChannelHandler</code> 会开启一个线程池，也就是每启动一个服务器就创建对应的一个线程池。</p><h2 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- NettyClient</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// wrapChannelHandler方法，包装ChannelHandler，其中实现了 Dubbo 线程模型的功能。</span></span><br><span class="line">        <span class="keyword">super</span>(url, wrapChannelHandler(url, handler));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> ChannelHandler <span class="title">wrapChannelHandler</span><span class="params">(URL url, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 设置线程名前缀，即URL.threadname=xxx ，默认：DubboClientHandler</span></span><br><span class="line">        url = ExecutorUtil.setThreadName(url, CLIENT_THREAD_POOL_NAME);</span><br><span class="line">        <span class="comment">// 2 设置使用的线程池类型，即 URL.threadpool=xxx ，默认： cached。注意这个和Server的区别</span></span><br><span class="line">        url = url.addParameterIfAbsent(Constants.THREADPOOL_KEY, Constants.DEFAULT_CLIENT_THREADPOOL);</span><br><span class="line">        <span class="comment">// 3 包装通道处理器</span></span><br><span class="line">        <span class="keyword">return</span> ChannelHandlers.wrap(handler, url);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在创建、启动 Netty 客户端时会通过 <code>ChannelHandlers.wrap</code> 方法为传入的 ChannelHandler 依次包装 <code>AllChannelHandler(默认)</code>、<code>HeartbeatHandler</code>以及 <code>MultiMessageHandler</code> 。其中 <code>AllChannelHanlder</code> 是消息派发处理器，其父类 <code>WrappedChannelHandler</code> 会开启一个线程池，也就是每创建一个连接就创建对应的一个线程池。</p><h2 id="开启线程池"><a href="#开启线程池" class="headerlink" title="开启线程池"></a>开启线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+--- WrappedChannelHandler</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrappedChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 基于SPI机制创建线程池</span></span><br><span class="line">        executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>().<span class="title">getExecutor</span>(<span class="title">url</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String componentKey = Constants.EXECUTOR_SERVICE_COMPONENT_KEY;</span><br><span class="line">        <span class="comment">// 2 如果是消费端</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(Constants.SIDE_KEY))) &#123;</span><br><span class="line">            componentKey = Constants.CONSUMER_SIDE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 基于SPI机制创建线程池存储对象</span></span><br><span class="line">        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 添加线程池到 DataStore中</span></span><br><span class="line">        <span class="comment">// 注意： AbstractClient 或 AbstractServer 从 DataStore 获得线程池</span></span><br><span class="line">        dataStore.put(componentKey, Integer.toString(url.getPort()), executor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="缓存线程池"><a href="#缓存线程池" class="headerlink" title="缓存线程池"></a>缓存线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataStore 只有一个实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDataStore</span> <span class="keyword">implements</span> <span class="title">DataStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存已有的线程池</span></span><br><span class="line"><span class="comment">     * key1: 表示线程池属于服务端侧还是消费端侧</span></span><br><span class="line"><span class="comment">     * key2: 线程池关联服务的端口</span></span><br><span class="line"><span class="comment">     * value: 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt; data = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, Object&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码层面上也说明了，在 <code>WrappedChannelHandler</code> 中会为每个连接启动一个线程池，并没有根据 URL 的信息对同一个线程池进行复用，而是直接通过 SPI 机制找到 ThreadPool 具体实现，然后创建线程池。注意，最终缓存的是最新的线程池。</p><h2 id="线程池模型"><a href="#线程池模型" class="headerlink" title="线程池模型"></a>线程池模型</h2><p>注意，创建 Dubbo 线程池都是强调消费端而没有强调服务端，因为一个节点部署 Dubbo 应用，一般只会创建一个 NIO 服务（以主机绑定的ip和port启动NIO服务），对应的线程池也只会初始化一个。</p><p>消费端同步请求的线程模型如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/consumer-threadpool-model-old.png" alt></p><p><strong>请求-响应流程如下：</strong></p><ol><li>业务线程发出请求，拿到一个 <strong>Future</strong> 实例。</li><li>业务线程紧接着调用 <strong>Future.get</strong> 阻塞等待请求结果返回。</li><li>当响应返回之后，交由连接关联的 Consumer 端线程池进行反序列化等处理。</li><li>待处理完成之后，通过 Future.set 方法将业务结果置回，然后通知业务线程取结果。</li></ol><p>当前版本的设计，消费端会维护一个线程池，而且<strong>线程池是按照连接隔离的</strong> ，也就是每个连接独享一个线程池。此外，当面临需要消费大量服务且并发数比较大的场景时，如 网关类场景，可能会导致消费端的线程数不断增加，最终引发CPU飙升、内存溢出。</p><h1 id="Dubbo-2-7-5-线程模型"><a href="#Dubbo-2-7-5-线程模型" class="headerlink" title="Dubbo 2.7.5 线程模型"></a>Dubbo 2.7.5 线程模型</h1><p>为了解决以上两个问题，Dubbo 2.7.5 对线程模型进行了改造，并且引入了 <code>ThreadlessExecutor</code>，以及 <code>ExchangeChannel#request</code> 方法支持设置处理响应的线程池，这样就可以通过 <strong>复用业务端被阻塞的线程，从而避免消费端线程池过度占用</strong>。</p><h2 id="ExecutorRepository"><a href="#ExecutorRepository" class="headerlink" title="ExecutorRepository"></a>ExecutorRepository</h2><p><code>ExecutorRepository</code> 负责创建并管理 Dubbo 中的线程池，该扩展接口只有一个实现。在 Dubbo 2.6.x 中之所以没有复用同一个线程池，很大原因就是没有一个管理 Dubbo 线程池的工具，它仅有一个缓存 Dubbo 线程池的工具。下面我们看看是怎么管理线程池的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultExecutorRepository</span> <span class="keyword">implements</span> <span class="title">ExecutorRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存已有的线程池</span></span><br><span class="line"><span class="comment">     * key1: 表示线程池属于服务端侧还是消费端侧</span></span><br><span class="line"><span class="comment">     * key2: 线程池关联服务的端口</span></span><br><span class="line"><span class="comment">     * value: 线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;Integer, ExecutorService&gt;&gt; data = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当服务或客户端初始化时，根据 URL 参数创建相应的线程池并缓存在合适的位置</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">createExecutorIfAbsent</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 根据 URL 中的 side 参数值确定线程池缓存的第一层 key</span></span><br><span class="line">        String componentKey = EXECUTOR_SERVICE_COMPONENT_KEY;</span><br><span class="line">        <span class="keyword">if</span> (CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY))) &#123;</span><br><span class="line">            componentKey = CONSUMER_SIDE;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, ExecutorService&gt; executors = data.computeIfAbsent(componentKey, k -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 根据 URL 中的 port 值确定线程池缓存的第二层 key</span></span><br><span class="line">        Integer portKey = url.getPort();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取或创建线程池</span></span><br><span class="line">        ExecutorService executor = executors.computeIfAbsent(portKey, k -&gt; createExecutor(url));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 如果缓存中相应的线程池已经关闭，则创建新的线程池，并替换掉缓存中已关闭的线程池</span></span><br><span class="line">        <span class="keyword">if</span> (executor.isShutdown() || executor.isTerminated()) &#123;</span><br><span class="line">            executors.remove(portKey);</span><br><span class="line">            executor = createExecutor(url);</span><br><span class="line">            executors.put(portKey, executor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getExecutor</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 根据 URL 中的 side 参数值确定线程池缓存的第一层 key</span></span><br><span class="line">        String componentKey = EXECUTOR_SERVICE_COMPONENT_KEY;</span><br><span class="line">        <span class="keyword">if</span> (CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY))) &#123;</span><br><span class="line">            componentKey = CONSUMER_SIDE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 从缓存中获取线程池</span></span><br><span class="line">        Map&lt;Integer, ExecutorService&gt; executors = data.get(componentKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * It's guaranteed that this method is called after &#123;<span class="doctag">@link</span> #createExecutorIfAbsent(URL)&#125;, so data should already</span></span><br><span class="line"><span class="comment">         * have Executor instances generated and stored.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (executors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">"No available executors, this is not expected, framework should call createExecutorIfAbsent first "</span> +</span><br><span class="line">                    <span class="string">"before coming to here."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Integer portKey = url.getPort();</span><br><span class="line">        ExecutorService executor = executors.get(portKey);</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (executor.isShutdown() || executor.isTerminated()) &#123;</span><br><span class="line">                executors.remove(portKey);</span><br><span class="line">                executor = createExecutor(url);</span><br><span class="line">                executors.put(portKey, executor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 URL 创建线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ExecutorService <span class="title">createExecutor</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过 Dubbo SPI 查找 ThreadPool 接口的扩展实现，并调用 getExecutor() 方法创建线程池。默认使用 FixedThreadPool 扩展实现。</span></span><br><span class="line">        <span class="keyword">return</span> (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>().<span class="title">getExecutor</span>(<span class="title">url</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExecutorRepository</code> 会根据 URL 复用同一个线程，这解决了每个连接（连接同一个节点上服务）都启动一个线程池问题。</p><h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><p>当服务端和客户端启动时会初始化线程池，遵循先缓存后创建的原则。相比 Dubbo 2.6.x ，<code>WrappedChannelHandler</code> 不会在初始化时创建线程池，而是封装了公共的获取线程池的方法。</p><h2 id="获取线程池"><a href="#获取线程池" class="headerlink" title="获取线程池"></a>获取线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrappedChannelHandler</span> <span class="keyword">implements</span> <span class="title">ChannelHandlerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WrappedChannelHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ChannelHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrappedChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取线程池，ThreadlessExecutor 或 共享线程池</span></span><br><span class="line"><span class="comment">     * 1. 使用 ThreadlessExecutor ，将回调直接委托给发起调用的线程</span></span><br><span class="line"><span class="comment">     * 2. 使用共享线程池执行回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getPreferredExecutorService</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是响应，尝试从 DefaultFuture 中取出线程池，没有的话再获取共享线程池</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">            Response response = (Response) msg;</span><br><span class="line">            DefaultFuture responseFuture = DefaultFuture.getFuture(response.getId());</span><br><span class="line">            <span class="keyword">if</span> (responseFuture == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> getSharedExecutorService();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果请求关联了线程池，则会获取相关的线程来处理响应</span></span><br><span class="line">                ExecutorService executor = responseFuture.getExecutor();</span><br><span class="line">                <span class="keyword">if</span> (executor == <span class="keyword">null</span> || executor.isShutdown()) &#123;</span><br><span class="line">                    executor = getSharedExecutorService();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> executor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 非响应，则直接使用共享线程池</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getSharedExecutorService();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前服务器或客户端的共享线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getSharedExecutorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从 ExecutorRepository 中获取线程池</span></span><br><span class="line">        ExecutorRepository executorRepository = ExtensionLoader.getExtensionLoader(ExecutorRepository<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>()</span>;</span><br><span class="line">        ExecutorService executor = executorRepository.getExecutor(url);</span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor = executorRepository.createExecutorIfAbsent(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">getExecutorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSharedExecutorService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是 <code>getPreferredExecutorService</code> 方法，如果请求在发送的时候指定了关联的线程池，则收到响应时会优先根据请求 ID 从 <code>DefaultFuture</code> 中取出对应的线程池，可能是 <code>ThreadlessExecutor</code>线程池或共享线程池。</p><h2 id="DefaultFuture"><a href="#DefaultFuture" class="headerlink" title="DefaultFuture"></a>DefaultFuture</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 DefaultFuture</span></span><br><span class="line"><span class="comment"> * 1. 初始化 DefaultFuture</span></span><br><span class="line"><span class="comment"> * 2. 超时检查</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> channel  channel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request  the request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout  timeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executor 线程池</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new DefaultFuture</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DefaultFuture <span class="title">newFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout, ExecutorService executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, request, timeout);</span><br><span class="line">    future.setExecutor(executor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadlessExecutor 需要持有本次请求关联的 DefaultFuture，主要用于当调用出现异常时（如调用超时），ThreadlessExecutor 可以及时更新 DefaultFuture 的调用状态，避免业务方一直傻傻地等待</span></span><br><span class="line">    <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">        ((ThreadlessExecutor) executor).setWaitingFuture(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为每次请求创建一个超时检查任务 </span></span><br><span class="line">    timeoutCheck(future);</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timeoutCheck</span><span class="params">(DefaultFuture future)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 创建超时任务</span></span><br><span class="line">    TimeoutCheckTask task = <span class="keyword">new</span> TimeoutCheckTask(future.getId());</span><br><span class="line">    <span class="comment">// 2 将超时任务加入时间轮，到了指定的超时时间触发任务</span></span><br><span class="line">    future.timeoutCheckTask = TIME_OUT_TIMER.newTimeout(task, future.getTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DefaultFuture</span><span class="params">(Channel channel, Request request, <span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    <span class="keyword">this</span>.request = request;</span><br><span class="line">    <span class="keyword">this</span>.id = request.getId();</span><br><span class="line">    <span class="keyword">this</span>.timeout = timeout &gt; <span class="number">0</span> ? timeout : channel.getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);</span><br><span class="line">    <span class="comment">// put into waiting map.</span></span><br><span class="line">    FUTURES.put(id, <span class="keyword">this</span>);</span><br><span class="line">    CHANNELS.put(id, channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，Dubbo 协议下 <strong>twoway</strong> 调用不仅会创建一个和本次调用的相关的 <code>DefaultFuture</code> 对象，还会为当前请求创建一个调用超时检测任务，该任务用于当调用超时时及时响应一个超时异常结果给调用方，尽可能减少业务方等待时间，不仅同步调用可以及时收到调用结果，异步调用也是，只是一般情况下异步调用不会立刻阻塞等待结果而已。Dubbo 2.6.x 没有使用时间轮，而是使用定时任务检测任务的超时，本质上是一样的。</p><h3 id="超时任务"><a href="#超时任务" class="headerlink" title="超时任务"></a>超时任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">+--- DefaultFuture</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutCheckTask</span> <span class="keyword">implements</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  请求id</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Long requestID;</span><br><span class="line"></span><br><span class="line">        TimeoutCheckTask(Long requestID) &#123;</span><br><span class="line">            <span class="keyword">this</span>.requestID = requestID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 根据请求id取出对应的 DefaultFuture</span></span><br><span class="line">            DefaultFuture future = DefaultFuture.getFuture(requestID);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断 timeout 到了，结果是否返回，没有返回则请求超时了</span></span><br><span class="line">            <span class="keyword">if</span> (future == <span class="keyword">null</span> || future.isDone()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求超时需要响应一个超时结果</span></span><br><span class="line">            <span class="keyword">if</span> (future.getExecutor() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                future.getExecutor().execute(() -&gt; notifyTimeout(future));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                notifyTimeout(future);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyTimeout</span><span class="params">(DefaultFuture future)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 创建一个超时异常响应</span></span><br><span class="line">            Response timeoutResponse = <span class="keyword">new</span> Response(future.getId());</span><br><span class="line">            <span class="comment">// set timeout status.</span></span><br><span class="line">            timeoutResponse.setStatus(future.isSent() ? Response.SERVER_TIMEOUT : Response.CLIENT_TIMEOUT);</span><br><span class="line">            timeoutResponse.setErrorMessage(future.getTimeoutMessage(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理响应</span></span><br><span class="line">            DefaultFuture.received(future.getChannel(), timeoutResponse, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">+--- DefaultFuture</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response, <span class="keyword">boolean</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DefaultFuture future = FUTURES.remove(response.getId());</span><br><span class="line">            <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Timeout t = future.timeoutCheckTask;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 请求没有超时，则取消超时任务</span></span><br><span class="line">                <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">                    <span class="comment">// decrease Time</span></span><br><span class="line">                    t.cancel();</span><br><span class="line">                &#125;</span><br><span class="line">                future.doReceived(response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(<span class="string">"The timeout response finally returned at "</span></span><br><span class="line">                        + (<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>).format(<span class="keyword">new</span> Date()))</span><br><span class="line">                        + <span class="string">", response status is "</span> + response.getStatus()</span><br><span class="line">                        + (channel == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">", channel: "</span> + channel.getLocalAddress()</span><br><span class="line">                        + <span class="string">" -&gt; "</span> + channel.getRemoteAddress()) + <span class="string">", please check provider side for detailed result."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            CHANNELS.remove(response.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Response res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"response cannot be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常响应结果</span></span><br><span class="line">        <span class="keyword">if</span> (res.getStatus() == Response.OK) &#123;</span><br><span class="line">            <span class="keyword">this</span>.complete(res.getResult());</span><br><span class="line">            <span class="comment">// 超时异常</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123;</span><br><span class="line">            <span class="keyword">this</span>.completeExceptionally(<span class="keyword">new</span> TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()));</span><br><span class="line">            <span class="comment">// 其它异常</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.completeExceptionally(<span class="keyword">new</span> RemotingException(channel, res.getErrorMessage()));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 已经有了请求结果，但可能是超时异常结果，这种情况下应该通知在 ThreadlessExecutor.queue 上等待的线程，避免其一直等待。</span></span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 通知在 ThreadlessExecutor.queue 上等待的线程返回</span></span><br><span class="line">            <span class="keyword">if</span> (threadlessExecutor.isWaiting()) &#123;</span><br><span class="line">                threadlessExecutor.notifyReturn(<span class="keyword">new</span> IllegalStateException(<span class="string">"The result has returned, but the biz thread is still waiting"</span> +</span><br><span class="line">                        <span class="string">" which is not an expected state, interrupt the thread manually by returning an exception."</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>DefaultFuture</code> 处理响应分为两种情况，一种是正常响应结果，另一种是异常响应结果。如果是异常结果，则还需要判断处理响应的线程池类型，如果是 <code>ThreadlessExecutor</code> 且其状态是等待状态，则需要通知阻塞的业务线程返回。此外，如果因为调用超时而返回异常结果时，也会将本次调用相关的 <code>DefaultFuture</code> 移除，当服务提供方返回响应（超时是针对消费端的，服务端不受影响）时是找不到对应的 DefaultFuture 对象的。</p><p>相比较 Dubbo 2.6.x , <code>DefaultFuture</code> 新维护了一个 <code>ExecutorService</code> 线程池，作为处理响应的线程池，可以参考 <code>WrappedChannelHandler.getPreferredExecutorService</code> 方法中的逻辑。</p><h2 id="ThreadlessExecutor"><a href="#ThreadlessExecutor" class="headerlink" title="ThreadlessExecutor"></a>ThreadlessExecutor</h2><p><code>ThreadlessExecutor</code> 是一种特殊类型的线程池，它并不会管理任何线程，以线程池的身份作为一个中间容器使用。其中维护了一个阻塞队列 <strong>queue</strong> 和一个共享线程池 <strong>shareExecutor</strong> 。阻塞队列用来存储响应任务，最终会将响应任务交给等待的业务线程处理。共享线程池主要用于当业务线程不再等待响应时，会由该线程池处理任务。整个核心逻辑在 <strong>execute()</strong> 方法和 <strong>waitAndDrain()</strong> 方法。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadlessExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ThreadlessExecutor<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞队列，用来在 IO线程和业务线程之间传递任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadlessExecutor 底层关联的共享线程池。当业务线程已经不再等待响应时，会由该共享线程执行提交任务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService sharedExecutor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指向请求对应的 DefaultFuture</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CompletableFuture&lt;?&gt; waitingFuture;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * finished 和 waiting 字段控制着等待任务的处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> waiting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadlessExecutor</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 判断业务线程是否还在等待响应，不等待则直接交给共享线程池处理</span></span><br><span class="line">            <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">                sharedExecutor.execute(runnable);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 业务线程还在等待，则将任务写入队列，最终由业务线程自己执行（业务线程在 waitAndDrain 方法上等待任务）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue.add(runnable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>ThreadlessExecutor</code> 重写了 <code>execute(Runnable)</code> 方法，通过该方法提交给这个执行器的任务不会被调度到特定的线程。如果业务线程在等待响应则将任务放入阻塞队列，最终业务线程自己执行。如果业务线程没有等待（可能业务线程已经执行了响应任务），则直接交给共享线程池处理。</p><h3 id="任务等待"><a href="#任务等待" class="headerlink" title="任务等待"></a>任务等待</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadlessExecutor</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitAndDrain</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 检测当前 ThreadlessExecutor 状态</span></span><br><span class="line">        <span class="keyword">if</span> (finished) &#123; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取阻塞队列中的任务</span></span><br><span class="line">        Runnable runnable = queue.take();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 修改waiting 状态</span></span><br><span class="line">            waiting = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果阻塞队列还有其它任务，则需要一起执行</span></span><br><span class="line">        runnable = queue.poll();</span><br><span class="line">        <span class="keyword">while</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.info(t);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            runnable = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记 ThreadlessExecutor 是完成状态，无业务线程等待</span></span><br><span class="line">        finished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法一般与一次 RPC 调用绑定，只会执行一次。存储在阻塞队列中的任务，只有当线程调用该方法时才会执行，执行任务的线程和调用该方法的线程是同一个线程。</p><h3 id="关联-DefaultFuture"><a href="#关联-DefaultFuture" class="headerlink" title="关联 DefaultFuture"></a>关联 DefaultFuture</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWaitingFuture</span><span class="params">(CompletableFuture&lt;?&gt; waitingFuture)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.waitingFuture = waitingFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为 <code>ThreadlessExecutor</code> 设置本次调用相关的 <code>DefaultFuture</code> 对象，主要用于同步调用异常（如超时异常）时，可以更新 <code>DefaultFuture</code> 的调用状态，即使用 <code>notifyReturn</code> 方法。</p><h3 id="异常任务通知"><a href="#异常任务通知" class="headerlink" title="异常任务通知"></a>异常任务通知</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知阻塞 &#123;<span class="doctag">@link</span> #waitAndDrain()&#125; 的线程返回，避免调用出现异常还傻傻地等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyReturn</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// an empty runnable task.</span></span><br><span class="line">    execute(() -&gt; &#123;</span><br><span class="line">        waitingFuture.completeExceptionally(t);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h2><h3 id="AsyncToSyncInvoker"><a href="#AsyncToSyncInvoker" class="headerlink" title="AsyncToSyncInvoker"></a>AsyncToSyncInvoker</h3><p>前面已经对该 Invoker 进行了介绍，在服务引用时会使用该类对消费端的 Invoker 进行包装，负责将异步调用转换成同步调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">       Result asyncResult = invoker.invoke(invocation);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 如果是同步调用，则调用 get() 方法，阻塞等待响应返回。</span></span><br><span class="line">           <span class="comment">// 调用的是 AsyncRpcResult.get 方法，其底层调用的是 CompletableFuture 的 get 方法</span></span><br><span class="line">           <span class="keyword">if</span> (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) &#123;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * NOTICE!</span></span><br><span class="line"><span class="comment">                * must call &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get(long, TimeUnit)&#125; because</span></span><br><span class="line"><span class="comment">                * &#123;<span class="doctag">@link</span> java.util.concurrent.CompletableFuture#get()&#125; 被证明有严重的性能下降。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 省略异常处理逻辑</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> asyncResult;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>业务线程进行 Invoker 调用时，会执行到 <code>AsyncToSyncInvoker.invoke</code> 方法，执行完调用后会返回一个 <code>AsyncRpcResult</code> 对象，如果是 SYNC 同步调用模式，则会调用其 <strong>get</strong> 方法，本质上是调用 <code>ThreadlessExecutor</code> 的 <strong>waitAndDrain()</strong> 方法阻塞等待响应任务。 </p><p>Dubbo 2.6.x 的异步转同步是通过 <strong>等待通知机制</strong> 实现的，使用的是 <code>Lock</code> 和 <code>Condition</code> 的组合。Dubbo 2.7.x 的异步转同步也是通过 <strong>等待通知机制</strong> 实现的，等待部分使用的是 <code>LinkedBlockingQueue.take()</code> 方法实现的，通知部分使用的是 <code>LinkedBlockingQueue.add(Runnable)</code> 实现的，由于 <code>LinkedBlockingQueue</code> 底层的实现机制也是基于 <code>Lock</code> 和 <code>Condition</code> 的组合，因此本质上实现机制是一致的。</p><h3 id="AsyncRpcResult"><a href="#AsyncRpcResult" class="headerlink" title="AsyncRpcResult"></a>AsyncRpcResult</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--- AsyncRpcResult</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span> &amp;&amp; executor <span class="keyword">instanceof</span> ThreadlessExecutor) &#123;</span><br><span class="line">            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;</span><br><span class="line">            threadlessExecutor.waitAndDrain();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> responseFuture.get(timeout, unit);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里可能会有疑问，业务线程调用 <strong>threadlessExecutor.waitAndDrain()</strong> 方法阻塞等待结果时并没有时间限制，那怎么知道调用是否超时呢？这个就是前文介绍的，在创建请求相关的 <code>DefaultFuture</code> 时还会创建一个超时检测任务，当请求超时时会立即返回一个超时异常结果，并且会通知阻塞等待的业务线程。</p><h3 id="DubboInvoker"><a href="#DubboInvoker" class="headerlink" title="DubboInvoker"></a>DubboInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">+--- DubboInvoker</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此次调用的方法名称</span></span><br><span class="line">        <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向 Invocation 中添加附加信息，这里将 URL 的 path 和 version 添加到附加信息中</span></span><br><span class="line">        inv.setAttachment(PATH_KEY, getUrl().getPath());</span><br><span class="line">        inv.setAttachment(VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择一个 ExchangeClient 实例</span></span><br><span class="line">        ExchangeClient currentClient;</span><br><span class="line">        <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">            currentClient = clients[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 是否是 oneway 调用 （不需要返回值）</span></span><br><span class="line">            <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            <span class="comment">// 根据调用方法名和配置，计算此次调用的超时时间</span></span><br><span class="line">            <span class="keyword">int</span> timeout = calculateTimeout(invocation, methodName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不需要关注返回值的请求</span></span><br><span class="line">            <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">              <span class="comment">// 省略调用逻辑</span></span><br><span class="line">               </span><br><span class="line">                <span class="comment">// 需要关注返回值的请求</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1 对于同步请求会使用 ThreadlessExecutor （SYNC 模式）， 对于异步请求，则会使用共享的线程池 （ASYNC 和 FUTURE 模式 ）</span></span><br><span class="line">                ExecutorService executor = getCallbackExecutor(getUrl(), inv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 使用上面选出的 ExchangeClient 执行 request() 方法将请求发出去，并传入线程池 executor。该线程池会作为处理响应的线程池，将保存到 DefaultFuture 中</span></span><br><span class="line">                CompletableFuture&lt;AppResponse&gt; appResponseFuture =</span><br><span class="line">                        <span class="comment">// currentClient.request 返回的是 DefaultFuture，DefaultFuture 继承了 CompletableFuture 。</span></span><br><span class="line">                        currentClient.request(inv, timeout, executor)</span><br><span class="line">                                <span class="comment">// 增加了一个回调，取出其中的 AppResponse 对象。</span></span><br><span class="line">                                <span class="comment">// thenApply 是一个回调,obj 是 上一个任务的结果。返回的 AppResponse 表示的是 服务端返回的具体响应。</span></span><br><span class="line">                                .thenApply(obj -&gt; (AppResponse) obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">// save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter</span></span><br><span class="line">                FutureContext.getContext().setCompatibleFuture(appResponseFuture);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3 这里将 CompletableFuture （其实是 DefaultFuture） 封装成 AsyncRpcResult 并返回</span></span><br><span class="line">                AsyncRpcResult result = <span class="keyword">new</span> AsyncRpcResult(appResponseFuture, inv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置处理结果的线程池</span></span><br><span class="line">                result.setExecutor(executor);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">"Invoke remote method timeout. method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">"Failed to invoke remote method: "</span> + invocation.getMethodName() + <span class="string">", provider: "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>DubboInvoker 在发起调用之前，会先通过 getCallbackExecutor 方法根据调用模式获取不同的线程池实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- AbstractInvoker</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ExecutorService <span class="title">getCallbackExecutor</span><span class="params">(URL url, Invocation inv)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 从 ExecutorRepository 中获取线程池</span></span><br><span class="line">        ExecutorService sharedExecutor = ExtensionLoader.getExtensionLoader(ExecutorRepository<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>().<span class="title">getExecutor</span>(<span class="title">url</span>)</span>;</span><br><span class="line">        <span class="comment">// 2 如果是同步请求，则使用 ThreadlessExecutor 线程池，它会对共享线程池进行封装</span></span><br><span class="line">        <span class="keyword">if</span> (InvokeMode.SYNC == RpcUtils.getInvokeMode(getUrl(), inv)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ThreadlessExecutor(sharedExecutor);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 非同步请求，则使用共享线程池</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sharedExecutor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h2><p>端点收到数据时（这里假设是响应数据）先由 IO 线程从二进制流中解码出响应，然后调用 <code>WrappedChannelHandler.received</code> 方法的实现，下面我们以 <code>AllChannelHandler</code> 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- AllChannelHandler</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前端点收到数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取线程池，如果是响应消息则优先获取发送请求时指定的关联线程池</span></span><br><span class="line">        ExecutorService executor = getPreferredExecutorService(message);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2 将消息封装成ChannelEventRunnable任务，提交到第 1 步获取的线程池中</span></span><br><span class="line">            executor.execute(<span class="keyword">new</span> ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 3 如果线程池满了，请求会被拒绝，这里会根据请求配置决定是否返回一个说明性的响应</span></span><br><span class="line">            <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request &amp;&amp; t <span class="keyword">instanceof</span> RejectedExecutionException) &#123;</span><br><span class="line">                sendFeedback(channel, (Request) message, t);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(message, channel, getClass() + <span class="string">" error when process received event ."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>符合以下条件 <code>getPreferredExecutorService</code> 方法获取的线程池就是 <code>ThreadlessExecutor</code>，否则一律使用共享线程池</strong></p><ol><li>收到的是响应消息。</li><li>响应对应的请求调用模式是 SYNC 同步调用。</li></ol><p><code>ThreadlessExecutor</code> 执行 <strong>execute</strong> 方法时，会将任务提交到阻塞队列中，处于阻塞的业务线程会从阻塞队列中获取任务并执行。</p><h2 id="线程池模型-1"><a href="#线程池模型-1" class="headerlink" title="线程池模型"></a>线程池模型</h2><p>通过复用业务端被阻塞的线程，解决了消费端线程池过度占用问题。同步调用优化后的线程模型如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/consumer-threadpool-model-new.png" alt></p><ol><li>业务线程发出请求后，拿到一个 Future 对象。</li><li>业务线程会调用 <code>ThreadlessExecutor.waitAndDrain()</code> 方法，该方法会使业务线程在阻塞队列上等待，直到队列中被加入任务。</li><li>当收到响应时，IO 线程会生成一个任务并放入 <code>ThreadlessExecutor</code> 阻塞队列中。</li><li>处于阻塞的业务线程将第 3 步添加的任务取出，并在本线程中执行。得到结果之后，调用 <code>Future.set</code> 方法进行设置，然后业务线程从 <strong>waitAndDrain()</strong> 方法返回。</li><li>业务线程继续执行，最后拿到结果值。</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章主要对 Dubbo 的线程模型改造进行了介绍，首先解决了以连接维度的消费端线程池，根据 URL 复用线程池即合理地缓存线程池实现。接着解决了消费端线程池过度占用问题，通过引入 <code>ThreadlessExecutor</code> 复用业务端被阻塞的线程实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/c812f120/&quot;&gt;异步改造&lt;/a&gt; 中对 Dubbo 
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>集合 - CopyOnWriteArrayList</title>
    <link href="https://gentryhuang.com/posts/bd5fd437/"/>
    <id>https://gentryhuang.com/posts/bd5fd437/</id>
    <published>2021-01-24T11:14:17.000Z</published>
    <updated>2021-08-21T09:35:51.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ArrayList 是一个非线程安全集合，需要使用方自行处理线程安全问题，或者使用 <code>Collections.synchronizedList</code> 包装。从 JDK 1.5 开始 JUC 中提供了使用<strong>写时复制</strong>机制实现的并发容器 <code>CopyOnWriteArrayList</code>。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>CopyOnWriteArrayList</code> 遵从 <strong>CopyOnWrite</strong>，顾名思义就是写时复制。简单来说就是当我们操作容器时并不直接操作当前容器，而是先根据当前容器复制出一个新的容器，然后在这个新的容器上操作，完成操作后再将原容器引用指向新容器。</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p><strong>CopyOnWriteArrayList 的类继承关系类图如下:</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/collection/copy-on-write-array-list.jpg" alt></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保护所有更改操作的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部数组。</span></span><br><span class="line"><span class="comment">     * 所有的读操作都是基于当前 array 进行的；所有的写操作都会复制一个新的 array，然后在新复制的数组上执行操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CopyOnWriteArrayList</strong> 核心属性就是以上两个。<code>lock</code> 用于保护所有更改操作，控制并发写操作。<code>array</code> 作为内部数组用于保存数据，读操作都是操作当前 <code>array</code>，写操作都是根据当前 <code>array</code> 复制一个新的 <code>array</code>，然后在这个新的数组中进行操作。</p><h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 1 获得独占锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获得 array 数组</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获得 array 数组长度</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 根据当前 array 复制一个新的数组，长度 +1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 将元素加入到新数组</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 6 替换旧数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 7 释放独占锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对上述代码流程进行说明：</p><ol><li>使用 <code>ReentrantLock</code> 独占锁保证同时只有一个线程对集合进行写操作。</li><li>数据存储在 <code>CopyOnWriteArrayList</code> 的内部 array 数组中。</li><li>元素并不是直接存储到 array 数组中，而是复制出一个新的数组，并且复制出的数组的长度是旧数组长度+1，然后将元素加入到新数组中，最后再把旧的数组替换成新的数组。</li></ol><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于整个 get 方法是没有加锁的，而 <code>CopyOnWriteArrayList</code> 的写操作是通过复制出新的数组来完成操作的，这可能会导致读写的短暂不一致。</p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       <span class="comment">// 1 获得独占锁</span></span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 2 获得当前 数组 array</span></span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 3 根据下标，获得旧的元素</span></span><br><span class="line">           E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 4 如果旧的元素不等于新的元素，等同于 add 方法，不过这里没有增加数组容量大小</span></span><br><span class="line">           <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">               <span class="keyword">int</span> len = elements.length;</span><br><span class="line">               Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">               newElements[index] = element;</span><br><span class="line">               setArray(newElements);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 5 为了保证 volatile 语义，即使元素没有改变也要替换成新的数组</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">               setArray(elements);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 6 释放独占锁</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>和 add 方法类似，不同的是对要修改的元素进行判断。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">// 1 获取独占锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2 获取对应下标元素</span></span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            E oldValue = get(elements, index);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3 确定调整位置，并根据该位置移动元素</span></span><br><span class="line">            <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3.1 要删除的元素在末尾</span></span><br><span class="line">            <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">                setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3.2 要删除的元素在数组中间</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">                System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                        numMoved);</span><br><span class="line">                setArray(newElements);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 4 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除方法和其它修改方法类似，先是获取独占锁来保证线程安全，接着判断要删除的元素是否是最后一个，如果是最后一个则复制出一个长度-1的新数组然后替换掉旧数组；如果要删除的元素不是最后一个，则分两次复制，随后替换旧数组。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 迭代器</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 数据快照</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 遍历数组元素的游标</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">           cursor = initialCursor;</span><br><span class="line">           snapshot = elements;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 判断是否还有下一个元素</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 判断是否有上一个元素</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 获取下个元素</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!hasNext())</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">           <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!hasPrevious())</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">           <span class="keyword">return</span> (E) snapshot[--cursor];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 不支持写操作</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当获取迭代器时，内部会调用 <code>COWIterator</code> 的构造方法，该构造方法有两个参数，一个是 array 数组，另一个是下标 0 。构造方法中会把 array 数组赋值给 <code>snapshot</code> 变量，当其他线程进行了增删改的操作，旧的数组会被新的数组给替换掉，但是 <code>snapshot</code> 还是原来旧的数组的引用。当我们使用迭代器遍历 CopyOnWriteArrayList 的时候，不能保证拿到的数据是最新的，这是弱一致性问题。</p><h1 id="设计特点"><a href="#设计特点" class="headerlink" title="设计特点"></a>设计特点</h1><p>CopyOnWriteArrayList 仅适用于<strong>写操作非常少的场景，而且能够容忍读写的短暂不一致</strong>。虽然采用了读写分离思想，但写操作时内存里会同时存在两个对象的内存，若这些对象占用内存较大，可能会带来系列问题，如造成频繁 GC。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>CopyOnWriteArrayList 是 Java 并发包中相对比较简单的一个实现，它的核心思想是写时复制机制，支持并发读写，但带来的后果是内存 double 和数据一致性问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;ArrayList 是一个非线程安全集合，需要使用方自行处理线程安全问题，或者使用 &lt;code&gt;Collections.synchroniz
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="CopyOnWrite" scheme="https://gentryhuang.com/tags/CopyOnWrite/"/>
    
  </entry>
  
  <entry>
    <title>集合 - ConcurrentHashMap</title>
    <link href="https://gentryhuang.com/posts/218dc61f/"/>
    <id>https://gentryhuang.com/posts/218dc61f/</id>
    <published>2021-01-18T12:30:35.000Z</published>
    <updated>2021-08-03T07:35:24.263Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="ConcurrentHashMap" scheme="https://gentryhuang.com/tags/ConcurrentHashMap/"/>
    
  </entry>
  
</feed>
