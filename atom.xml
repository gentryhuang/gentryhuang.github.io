<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gentryhuang‘s blog</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gentryhuang.com/"/>
  <updated>2020-11-05T15:46:20.745Z</updated>
  <id>https://gentryhuang.com/</id>
  
  <author>
    <name>gentryhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis原理 - 链表</title>
    <link href="https://gentryhuang.com/posts/2362a8ea/"/>
    <id>https://gentryhuang.com/posts/2362a8ea/</id>
    <published>2020-10-20T11:33:59.000Z</published>
    <updated>2020-11-05T15:46:20.745Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol><li><p>redis中的链表</p><p>链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置这中数据结构，所以redis构建了自己的链表实现。</p></li><li><p>redis链表节点的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">  <span class="comment">// 前置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="comment">// 后置节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">// 节点的值 (可用于保存各种不同类型的值)</span></span><br><span class="line">  <span class="keyword">void</span> *value</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>redis链表结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数，用于复制链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数，用于释放链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数，用于对比链表节点所保存的值和其他值是否相等</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>redis链表的特点</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)</span><br><span class="line">- 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点</span><br><span class="line">- 带表头和表尾指针：使用list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)</span><br><span class="line">- 带链表长度计数器：程序使用list结构的len属性标记链表中节点的个数，程序获取链表中节点个数的复杂度为O(1)</span><br><span class="line">- 多态：链表可以保存各种不同类型的值</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>链表在redis中的应用</p><p>链表被广泛用于实现redis的各种功能，如：列表键、发布与订阅、慢查询、监视器，redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;redis中的链表&lt;/p&gt;
&lt;p&gt;链表作为一种常用的数据结构，内置在很多高级编程语言中，因为redis使用c语言并没有内置
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis数据结构" scheme="https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - 简单动态字符串</title>
    <link href="https://gentryhuang.com/posts/aa1d8127/"/>
    <id>https://gentryhuang.com/posts/aa1d8127/</id>
    <published>2020-10-18T11:00:50.000Z</published>
    <updated>2020-11-05T15:46:20.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h3><ol><li><p>初识动态字符串</p><p>redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS作为redis的默认字符串表示。 <code>在redis中，c字符串只会作为字符串字面量用在一些无须对字符串值进行修改的地方，比如日志。当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，redis就会使用SDS来表示字符串值。</code> 值的注意的是，对于redis中的key都是使用SDS来实现的。此外，SDS除了用来保存Redis数据库中的字符串值之外，SDS还被用作缓冲区（buffer）: AOF模块中的AOF缓冲区，以及客户端状态中的输入缓冲区。</p></li><li><p>sds的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">  <span class="comment">// 记录buf数组中已使用字节的数量等价于sds所保存字符串的长度</span></span><br><span class="line">  <span class="keyword">int</span> len;</span><br><span class="line">  <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">  <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">  <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>sds遵循c字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在sds的len属性中，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由sds函数自动完成的。遵循空字符结尾的好处是，sds可以直接使用一部分C字符串函数库里面的函数。</p></li><li><p>sds与c字符串的区别</p><p>c语言使用的简单字符串表示方式，并不能满足redis对字符串在安全性、效率以及功能方面的要求。</p><p>3.1  常数复杂度获取字符串长度</p><blockquote><p>因为c字符串并不记录自身的长度信息，所以要获取长度就必须遍历整个字符串，故获取字符串长度的复杂度为O(N)。而redis的sds结构中通过len属性记录了sds的长度，故获取字符串长度的复杂度为O(1)。注意，设置和更新sds长度的工作是由sds的API在执行时自动完成的，使用sds无须进行任何手动修改长度的操作。</p></blockquote><p>3.2 避免缓冲区溢出</p><blockquote><p>c字符串不记录自身长度，很容易造成缓冲区溢出。与c字符串不同，sds的空间分配策略完全杜绝了发生缓冲区溢出的可能性，当sds api需要对sds进行修改时，api会先检查sds的空间是否满足需要，如果不满足的话，api会自动将sds的空间扩展至执行所需的大小，然后才执行实际的修改操作，因此使用sds既不需要手动修改sds的空间大小，也不会出现c字符串中可能出现的缓冲区溢出问题。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line">    <span class="comment">//追加时先进行扩容，后面详细说明</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//拼接字符串</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s:原数组     </span></span><br><span class="line"><span class="comment">//strlen(t) 需拼接的目标数组的长度</span></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p>3.3 内存分配与释放</p><p>因为c字符串的长度和底层数组的长度之间存在着关联性，所以<code>每次增加或者缩短一个c字符串，程序都总要对保存这个c字符串的数字进行一次分配操作</code>，但是内存分配操作涉及到复杂的算法，并且可能需要执行系统调用，所以通常是一个比较耗时的操作。redis作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，为了避免c字符串的这种缺陷，sds通过未使用空间解除了字符串长度和底层数组长度之间的关联，通过未使用空间，sds实现了空间预分配和惰性空间释放两种优化策略。</p><ul><li><p>空间预分配</p><p>空间预分配用于优化sds的字符串增长操作：当sds的api对一个sds进行修改，并且需要对sds进行空间扩展的时候，程序不仅会为sds分配修改所必须要的空间，还会为sds分配额外的未使用空间。通过空间预分配策略，redis可以减少连续执行字符串增长操作所需的内存重新分配次数，在扩展sds空间之前，sds api 会先检查未使用空间是否足够，如果足够就直接使用未使用空间，而不需要执行内存重新分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redis 扩容源码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，</span></span><br><span class="line"><span class="comment"> * buf 至少会有 addlen + 1 长度的空余空间</span></span><br><span class="line"><span class="comment"> * （额外的 1 字节是为 \0 准备的）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值</span></span><br><span class="line"><span class="comment"> *  sds ：扩展成功返回扩展后的 sds</span></span><br><span class="line"><span class="comment"> *        扩展失败返回 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 复杂度</span></span><br><span class="line"><span class="comment"> *  T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前的空余空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 最少需要的长度</span></span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class="line">        <span class="comment">// 那么为它分配两倍于所需长度的空间</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存不足，分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 sds 的空余长度</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 sds</span></span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额外分配未使用空间数量的计算策略：</p><blockquote><ol><li>对sds修改后，sds的长度（即len属性的值）小于1MB，那么程序分配和len属性同样大小的未使用空间，这时sds的len属性的值将和free属性的值相同。例如：修改后sds的len变成10字节，那么程序也会分配10字节的未使用空间，sds的buf数组的实际长度：10 + 10 + 1 = 21字节</li><li>对sds修改后，sds的长度大于等于1MB，那么程序会分配1MB的未使用空间。例如：修改后sds的len变成30MB，那么程序会分配1MB的未使用空间，sds的buf数组的时间长度：30MB + 1MB + 1byte</li></ol></blockquote></li><li><p>惰性空间释放</p><p>惰性空间释放用于优化sds的字符串缩短操作：当sds的api需要缩短sds保存的字符串时，程序并不立即使用内存重分配来回收缩短后多来的字节，而是使用free属性将这些字节的数量纪录起来，用于将来对sds进行增长操作时，这些未使用空间可能就派上用场了。注意，sds也提供了相应的api，可以真正地释放sds的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</p></li></ul><p>3.4 二进制安全</p><blockquote><p>c字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里不能包含空字符，否则在读取的时候会被默认为结束字符，这些限制使得c字符串只能保存文本数据，不能保存图片、音视频、压缩文件这类的二进制数据。sds的api都是二进制安全的，所有的sds api都会以<code>二进制的方式处理sds存放在buf数组里的数据</code>,程序不会对其中的数据做任何限制、过滤，数据写入时是什么样，它被读取时就是什么样。<code>这也是将sds的buf属性称为字节数组的原因，redis不是用这个数组来保存字符，而是用它来保存一系列二进制数据</code>。</p></blockquote></li><li><p>c字符串和sds之间的区别</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         C字符串                                    SDS</span><br><span class="line">- 获取字符串长度的复杂度为O（n）                 获取字符串长度的复杂度O（1）</span><br><span class="line">- API是不安全的，可能造成缓冲区溢出                      API是安全的</span><br><span class="line">- 修改字符串长度N次，必然要执行N次内存重分配     修改字符长度N次，最多执行N次内存重分配</span><br><span class="line">- 只能保存文本数据                                 可以保存文本或者二进制数据</span><br><span class="line">- 可使用&lt;string.h&gt;库中的函数                   可使用一部分&lt;string.h&gt;库中的函数</span><br></pre></td></tr></table></figure></li><li><p>sds更多的api可参考源码</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简单动态字符串&quot;&gt;&lt;a href=&quot;#简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;简单动态字符串&quot;&gt;&lt;/a&gt;简单动态字符串&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初识动态字符串&lt;/p&gt;
&lt;p&gt;redis没有直接使用C语言传统的字符串表示（以空字
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis数据结构" scheme="https://gentryhuang.com/tags/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>并发 - Java并发工具类</title>
    <link href="https://gentryhuang.com/posts/37f29896/"/>
    <id>https://gentryhuang.com/posts/37f29896/</id>
    <published>2020-10-05T16:00:00.000Z</published>
    <updated>2020-10-13T05:44:20.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 JDK 的并发包中提供了几个非常有用的并发工具类。 <code>CountDownLatch</code>、<code>CyclicBarrier</code> 和 <code>Semaphore</code> 工具类提供了并发流程控制的手段，它们都是对 AQS 应用。本篇文章将介绍其简单使用以及内部原理。</p><table><thead><tr><th align="left">工具类</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td align="left">Semaphore</td><td>信号量，通过控制 ‘许可证’ 的数量来协调各个线程，以保证合理的使用公共资源。</td><td>线程只有拿到 ‘许可证’ 才能继续运行</td></tr><tr><td align="left">CyclicBarrier</td><td>循环栅栏，让一组线程到达一个栅栏（同步点）时被阻塞，直到最后一个线程到达栅栏时，被栅栏拦截的线程才会继续运行。</td><td>强调一组线程都到达同步点才会继续往下执行</td></tr><tr><td align="left">CountDownLatch</td><td>门栓，等待多线程完成</td><td>强调一个或多个线程等待其它线程完成操作</td></tr></tbody></table><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><p><strong>场景</strong></p><blockquote><p>加工厂生产产品，产品需要三道工序进行检测，只有三道工序检测通过才能进入下一个环节。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定线程数线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品质量检测</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要3个工人进行检测，就用3来初始化一个 CountDownLatch</span></span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> no = i;</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 检测</span></span><br><span class="line">                            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                            log.info(<span class="string">"No."</span> + no + <span class="string">" 完成检测。"</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">// 调用 countDown() 代表完成。这里指某个员工完成检测任务</span></span><br><span class="line">                            latch.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"产品质量检测中....."</span>);</span><br><span class="line">        <span class="comment">// 调用await() 代表线程阻塞等待其它线程完成，即同步状态 state 减为 0。这里指产品等待检测完成</span></span><br><span class="line">        latch.await();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"产品质量检测完毕，进入下一个环节。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[main] INFO com.code.juc.tool.CountDownLatchDemo - 产品质量检测中.....</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.CountDownLatchDemo - No.2 完成检测。</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.CountDownLatchDemo - No.3 完成检测。</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CountDownLatchDemo - No.1 完成检测。</span><br><span class="line">[main] INFO com.code.juc.tool.CountDownLatchDemo - 产品质量检测完毕，进入下一个环节。</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>以上例子中，main 线程调用了 <code>latch.await()</code> 进行阻塞等待，即它阻塞在门栓上（叫啥无所谓，中文是门栓、栅栏），只有当条件满足时（其它线程调用 <code>latch.countDown()</code> 递减 state 为0）它才能通过这个门栓。这个例子比较简单，只有一个线程调用 <code>await</code> 方法等待其它线程完成，这属于 <code>一对多</code> 关系。CountDownLatch 还可以实现复杂的 <code>多对多</code> 关系的场景，有 m 个线程在门栓上等待 n 个线程完成任务，直到 n 个线程都完成任务，这 m 个线程才能同时通过门栓。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-1.jpg" alt></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>根据 CountDownLatch 的使用例子分析源码，按照执行流程逐一分析。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatch</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Synchronization control For CountDownLatch. // 继承AQS的内部类</span></span><br><span class="line"><span class="comment">     * Uses AQS state to represent count. // 使用 AQS 的状态表示 数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 有参构造方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> count 数量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="comment">// 调用父类方法，设置状态值</span></span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取数量</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 调用父类方法，获取状态值</span></span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 覆写父类方法 （获取同步状态（这里表示数量） - 共享方式）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 覆写父类方法（释放同步状态（这里表示数量） - 共享方式）</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> releases 没有意义的参数，用不到</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> nextc = c - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，需要一个 &gt;= 0 的整数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count the number of times &#123;<span class="doctag">@link</span> #countDown&#125; must be invoked</span></span><br><span class="line"><span class="comment">     *              before threads can pass through &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> count&#125; is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch 类是对 AQS 共享模式的使用。既然是使用 AQS 框架，那么就是一个固定的模式，AQS 已经处理好了同步状态的获取与释放以及阻塞与唤醒，自定义组件只需继承 AQS 以及根据同步状态获取方式（独占/共享）实现模版方法即可。前面也说了，AQS 准备好了一切，只需要条件触发就可以执行对应的任务，而实现的模版方法正是触发条件。</p><p>CountDownLatch 主要有两个核心方法，<code>await</code> 和 <code>countDown</code> 。<code>countDown</code> 方法每次调用都会将 <code>state</code> 减 1 ，直到 <code>state</code> 的值为 0。<code>await</code> 方法可以被多个线程调用，调用 <code>await</code> 方法的线程进入 AQS 的阻塞队列中并挂起，当且仅当 <code>state</code> 为 0 时，线程会从阻塞队列中依次被唤醒过来。</p><h4 id="await-等待"><a href="#await-等待" class="headerlink" title="await 等待"></a>await 等待</h4><p>await 方法是一个阻塞方法，当且仅当同步状态 state 减至 0，该方法才会返回，否则调用该方法的线程将阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">--- CountDownLatch</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 可中断获取同步状态</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="comment">// 中断则抛出中断异常</span></span><br><span class="line">      <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// main 线程调用 await 时，state = 3，条件成立 </span></span><br><span class="line">      <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 接下来就是 AQS 的工作了，共享方式可中断获取同步状态</span></span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch 的 await 方法简单，直接传入数量值为 1 尝试获取同步状态（其实传入值是没有意义的，用不到）。CountDownLatch 覆写了模版方法即条件，条件成立则 AQS 完成阻塞任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 1 入队 ，即当前线程加入阻塞队列，共享方式</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 尝试获取前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// CountDownLatch 实现的条件，state != 0 时，返回 -1</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2 找大哥，找到大哥就挂起自己，然后等待大哥唤醒自己。没有找到则继续找，直到找到或其前驱节点是 head 节点，找到则挂起等待，是 head 则尝试获取同步状态。</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="comment">// 线程被中断则抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch 的 await 方法到此就结束了，下面总结下该方法的核心步骤。</p><ul><li><p>main 线程没有获取到同步状态会进入阻塞队列<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-2.jpg" alt><br>main 线程对应的节点入队完成，如上图。需要注意的是，因为 main 线程对应节点入队时阻塞队列为空，因此需要构建阻塞队列，使用一个虚节点作为 head 。如果节点在入队时已经存在阻塞队列，那么直接挂到阻塞队列尾部即可。</p></li><li><p>尝试获取同步状态<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-3.jpg" alt><br>入队后进入for 循环，此时main线程对应的节点的前驱节点是 head，但 tryAcquireShared 返回 -1,此时进入 <code>找大哥</code> 的流程中。<code>找大哥</code> 就是将当前节点的<strong>有效</strong>前驱节点等待状态 waitStatus 设置为 -1。这里是将 main 线程对应节点的前驱节点 head 的 waitStatus 设置为 -1。</p></li><li><p>挂起，等待前置节点唤醒<br>找到大哥后挂起自己，等待大哥（有效前置节点）唤醒自己。</p></li></ul><br>以上是 main 线程获取同步状态失败后，进入阻塞队列等待唤醒的过程。需要说明的是，CountDownLatch 可以有多个线程等待其它线程完成，例子中只是使用一个线程等待而已。<h4 id="countDown-唤醒"><a href="#countDown-唤醒" class="headerlink" title="countDown 唤醒"></a>countDown 唤醒</h4><p>countDown 方法每次调用都会将同步状态 state 减 1，直到减少至 0 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">--- CountDownLatch</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 释放同步状态</span></span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有当 state 减到 0 时， tryReleaseShared 方法才返回 true，否则仅是将 state 减 1 并返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            <span class="comment">// state == 0 时，唤醒阻塞的线程。 注意，这里是 t1 唤醒阻塞的线程即 main 线程</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 唤醒阻塞队列中等待的线程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; </span><br><span class="line">            <span class="comment">// 将当前 head 保存起来，因为其它线程可能会占领它，此时是虚节点</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="comment">// main 线程入队时已经把 head 当作大哥了，即 将 head 的 waitStatus 设置为 -1 (Node.SIGNAL)</span></span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                     <span class="comment">// cas 将 head 的 waitStatus 设置 为 0。</span></span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 唤醒 head 下一个有效节点。这里是 main 线程对应的节点</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">            </span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面代码只是正常情况下一个完整流程，即 main 线程加入阻塞队列并挂起后，t2、t3、t1 分别执行 <code>countDown</code> 方法递减 <code>state</code> 的值，到了 t1 调用该方法时，刚好 <code>state</code> 的值被减至 0 ，然后执行唤醒阻塞队列中的线程逻辑。下面对该过程进行总结。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-4.jpg" alt></p><p>至此，唤醒条件已经具备，即 <code>state = 0</code> ，下面我们回到之前线程挂起的代码处，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 尝试获取前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// CountDownLatch 实现的条件，state != 0 时，返回 -1</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 2 main 占据 head 并继续唤醒后置阻塞的线程</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// 1 线程 t1 唤醒阻塞的 main 线程，该方法返回，即 main 线程继续执行尝试再次获取同步状态</span></span><br><span class="line">                    parkAndCheckInterrupt())  </span><br><span class="line">                    <span class="comment">// 如果线程被中断则抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>main 线程被唤醒后从 parkAndCheckInterrupt 方法返回，如果没有被中断，则继续尝试获取同步状态，此时可以获取到同步状态（r &gt;= 0 成立）。接下来 main 线程会进入到 setHeadAndPropagate 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将当前 head 保存起来，因为其它线程可能会占领它</span></span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below </span></span><br><span class="line">        <span class="comment">// node 节点占领 head，即 main 线程占领 head</span></span><br><span class="line">        setHead(node); </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里条件判断对应的场景比较多，毕竟是 AQS 统一处理方法，因此考虑的情况比较全面。对于 CountDownLatch ，就是唤醒 node 之后的有效节点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点的后置节点</span></span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="comment">// 如果为 null 或者 是共享方式的节点</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                <span class="comment">// 接着唤醒阻塞线程 （共享式）。注意，这里是醒来的阻塞线程继续唤醒后置还在阻塞的线程。</span></span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 占领 head </span></span><br><span class="line"><span class="comment">     * Sets head of queue to be node, thus dequeuing. Called only by</span></span><br><span class="line"><span class="comment">     * acquire methods.  Also nulls out unused fields for sake of GC</span></span><br><span class="line"><span class="comment">     * and to suppress unnecessary signals and traversals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>setHeadAndPropagate 方法主要做了两件事，node 占领 head 并唤醒 node 后置的<strong>有效</strong>节点。由于例子中只有 main 线程进入了阻塞队列，它后面没有等待唤醒的线程节点，但为了研究源码我们假设 main 线程对应节点后面还有一个 线程 t 节点等待唤醒，那么 main 线程会执行 doReleaseShared 方法来唤醒线程 t ，此时 head 是 main 线程对应的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 将当前 head 保存起来，因为其它线程可能会占领它</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//  h == null 说明阻塞队列为空，h == tail 说明头节已经是最后一个节点或者是刚刚初始化的节点，这对应 CountDownLatch 来说都应该结束。</span></span><br><span class="line">        <span class="comment">//  按照例子走到这里，head 就 main线程对应的节点，同时 tail 也是 main 线程对应的节点。不过我们假设了 线程 t ，因此条件是成立的</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="comment">// h 的状态，即 main 线程对应节点状态，由入队方法可知，t 线程对应节点会把 main 线程对应节点作为 大哥节点，即 waitStatus 设置为 -1（Node.SIGNAL)</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 可能会失败</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 唤醒 h 的后置节点，也就是阻塞队列中的第一个节点。这里是线程 t 对应的节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; </span><br><span class="line">                          <span class="comment">// todo 这里可能会失败 </span></span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">          &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 线程执行到这里，如果唤醒的线程已经占领了 head，此时 h != head，当前线程继续循环。如果 h == head ，说明，唤醒的线程还没有占领 head，当前线程退出循环</span></span><br><span class="line">        <span class="comment">// 这里可能 main 线程执行到这里时，main 线程唤醒的线程 t 已经占领了 head ,此时 h != head </span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setHeadAndPropagate 方法和 doReleaseShared 方法配合，依次唤醒阻塞的线程，即 执行 doReleaseShared 方法的线程唤醒它的后置阻塞线程，醒来的线程会再次尝试获取同步状态然后进入到 setHeadAndPropagate 方法中先占领 head，然后调用 doReleaseShared 方法继续唤醒它的后置阻塞节点。需要说明的是，AQS 的 <code>doReleaseShared</code> 方法极端场景还是挺多的，这里结合 CountDownLatch 来说明。</p><p>我们抛开给出的例子，根据以下场景分析几个特殊的情况</p><blockquote><p>要进行体能测试，每组三个同学进行短跑，在体育老师发出起跑指令前，这三个同学都要在起跑线待着，当体育老师准备完毕后会发出开始跑的指令，那这三个同学就会一起跑向终点的测试仪。这里 CountDownLatch 的数量 为 1，即同步状态为 1 。</p></blockquote><ul><li><p><strong>h != head 的情况</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-5.jpg" alt><br>当 t1 被唤醒后，唤醒 t1 的线程 t 执行到上图中的代码处，还没有退出循环，t1 已经占领了 head（此时图中的 head 要指向 t1 线程对应的节点，且 t1 线程节点 thread 置空，prev 置空。图中没有体现出来），此时 head != h ，线程 t 将会进行下一轮循环。</p></li><li><p><strong>compareAndSetWaitStatus(h, Node.SIGNAL, 0) 失败</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-6.jpg" alt><br>线程 t 进行第二轮循环时，刚好被唤醒的线程 t1 也进入该循环，此时两个线程并发执行，假设线程 t CAS 操作成功，然后退出循环，线程 t1 失败，将会进行下一轮循环。注意，此时虚节点的 next 指针还存在，因为我们假设的是 t1 线程失败了，t 线程成功退出了，t 线程不属于阻塞队列中的线程，它不会维护阻塞队列节点关系，如果是 t1 线程成功并退出循环就会清除它上一个节点的 next ，这里就是虚节点。</p></li><li><p><strong>执行 else if (ws == 0 &amp;&amp;..) 分支</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cdl-7.jpg" alt><br>t1 线程第二次循环时，唤醒的 t2 线程还没有占领 head，此时的 head 还是 t1 线程对应的节点，但是 waitStatus 被之前的 t 线程通过 CAS 设置为 0 了，因此进入到 else if 分支，然后再次把节点 watiStatus 设置为 -3 。执行到 h == head 判断处时，假设 t2 还是没有占领 head ，此时 t1 退出循环，然后清除其前置节点的 next 指针，即虚节点。</p></li><li><p><strong>compareAndSetWaitStatus(h, 0, Node.PROPAGATE) 失败</strong><br>进入这个方法的前提是 ws == 0，即 head 的 waitStatus 出现了 0，此时如果 CAS 失败，一般有两种可能，一种是线程并发执行 CAS 只有一个会成功，另一种是其它的线程把该节点的 waitStatus 值修改了，此时能改 head 的状态值的很可能是节点入队引起的修改，因为新节点要把有效的前驱节点状态值设置为 -1 。在 CountDownLatch 中一般不会发生第二种可能，因为一旦唤醒条件成立，就不会再有节点需要入队阻塞了。</p></li></ul><p>剩下的 t2 线程、t3 线程依次会被唤醒，需要注意的是 t3 线程被唤醒占领头节点后也会进入到 doReleaseShared 方法的循环中，此时它对应的节点既是 head 又是 tail，就直接退出循环，结束整个流程了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>CountDownLatch 的构造函数需要一个 int 类型的参数作为数量（用来计数），如果想等待 N 个任务完成（N 个线程执行完任务），就需要传入 N 。CountDownLatch 的 countDown 方法用于将 N 减 1 ,await 方法会阻塞当前调用线程（阻塞在门栓上，门栓是一个同步点的概念），直到 N 减至 0 被阻塞的线程才会继续往下执行。此外，CountDownLatch 还提供了一个带有指定时间的 await 方法，用于等待超时的场景，超过等待时间就不会再等，被阻塞线程继续往下执行。这个方法很简单，就是在 await 方法的基础上增加了超时判断，下面粘贴下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">--- CountDownLatch</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">            doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared timed mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nanosTimeout max wait time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if acquired</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 计算出等待的最迟时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 计算出等待剩余时间</span></span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="comment">// 超过等待时间，则不再等待，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">// 执行挂起的最小时间粒度</span></span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    <span class="comment">// 挂起 nanosTimeout 时间后自动醒来</span></span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意，N 值必须 大于等于 0，如果 N 等于 0 ，调用 await 方法时当前线程不会被阻塞，此外 CountDownLatch 不支持重新初始化，也不支持修改数量的值。</p></blockquote><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h3 id="使用例子-1"><a href="#使用例子-1" class="headerlink" title="使用例子"></a>使用例子</h3><p><strong>场景</strong></p><blockquote><p>某个公司部门举办团建活动，需要员工自行拼车前往目的地，司机会在指定的地点等待拼车的 4 个人到齐后才发车。我们假设该部门某个团队有 8 个人，那么就需要拼 2 辆车前往目的地。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定线程数线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要等待 4 个同学到齐，到齐后发车，因此这里初始化一个带有 Runnable 参数的 CyclicBarrier</span></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, () -&gt; log.info(<span class="string">"4人已到齐，请系好安全带，现在出发赶往目的地 !"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8个人，需要 2 辆车。这里会循环使用 CyclicBarrier</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 赶往拼车地点</span></span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">                    log.info(<span class="string">"到达指定拼车地点 !"</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                   </span><br><span class="line">                    <span class="comment">// 一组人员全部到达后，才能出发。 即 一组线程全部到达栅栏后，被阻塞的线程才能继续执行</span></span><br><span class="line">                    log.info(<span class="string">"出发了 !"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException exception) &#123;</span><br><span class="line">                    exception.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CyclicBarrierDemo - 4人已到齐，请系好安全带，现在出发赶往目的地 !</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-8] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-7] INFO com.code.juc.tool.CyclicBarrierDemo - 到达指定拼车地点 !</span><br><span class="line">[pool-1-thread-7] INFO com.code.juc.tool.CyclicBarrierDemo - 4人已到齐，请系好安全带，现在出发赶往目的地 !</span><br><span class="line">[pool-1-thread-7] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-8] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.CyclicBarrierDemo - 出发了 !</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>以上例子中，使用循环体和线程池模拟 8 个线程执行任务，其中每 4 个线程为一组，只有这 4 个线程都到达栅栏，例子中是到达指定拼车点，才能继续往下执行，否则都会阻塞在栅栏上等待其它线程到达栅栏。到达栅栏的定义是 线程调用 await 方法。一组线程都到达栅栏后，由最后到达的线程执行及时任务，没有任务则不执行。CyclicBarrier 是可循环使用的栅栏，当一组线程都到齐后，CyclicBarrier 进行下一个循环，下一组线程进行同样的操作。</p><h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><p>CyclicBarrier 的字面意思是可循环使用的栅栏，因为它的栅栏可以重复使用（通过重置关键属性）。它要做的事情是，让一组线程到达一个栅栏（是一个同步点）时被阻塞，直到最后一个线程到达栅栏时，栅栏才会打开，所有被栅栏拦截的线程才能继续运行。它的功能是通过组合 <code>ReentrantLock</code> 和 <code>Condition</code> 来达到的。我们还是基于使用例子来分析源码。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cb-1.jpg" alt></p><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栅栏所处的代。栅栏上阻塞的线程被唤醒或者栅栏被重置，就开启新的一代</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 栅栏是否被打破，默认为 false</span></span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁对应的条件，阻塞线程在栅栏或者唤醒阻塞在栅栏上的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栅栏要拦截的线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一组线程都到达栅栏后优先执行的任务，即如果设置这个这个任务，那么被阻塞在栅栏上的线程要等这个任务结束后才能被唤醒。注意，这个任务是被最后到达的线程执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前栅栏所处的代，如果第一次就是 1 代，如果第2次使用就是 2 代</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 还要等待的线程数，即还没有到栅栏的线程数。这个初始值 是 parties 值，每个线程到栅栏就减 1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CyclicBarrier 高级构造函数，支持优先执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.parties = parties;</span><br><span class="line">        <span class="keyword">this</span>.count = parties;</span><br><span class="line">        <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CyclicBarrier 默认的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier 默认的构造方法的参数表示栅栏拦截的线程数，每个线程调用 await 方法都会告诉 CyclicBarrier 我已经到达栅栏，此时栅栏要把拦截的线程数减 1 ，然后阻塞当前线程，直到要拦截的线程都到达栅栏时，栅栏才会打开，即最后到达的线程唤醒阻塞在栅栏上的线程，然后这组线程都从 await 方法处继续往下执行。 CyclicBarrier 还提供一个高级构造函数，用于在最后一个线程到达栅栏时，优先执行的任务，便于处理复杂的业务场景。注意，<strong>执行优先任务先于唤醒阻塞线程</strong> ，代码中所有体现。</p><h4 id="下一代栅栏"><a href="#下一代栅栏" class="headerlink" title="下一代栅栏"></a>下一代栅栏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---CyclicBarrier</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开启下一代栅栏</span></span><br><span class="line"><span class="comment">     * 1 唤醒阻塞在上一代栅栏上的线程</span></span><br><span class="line"><span class="comment">     * 2 重置 count 和 generation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// signal completion of last generation</span></span><br><span class="line">        trip.signalAll();</span><br><span class="line">        <span class="comment">// set up next generation</span></span><br><span class="line">        count = parties;</span><br><span class="line">        generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>开启下一代栅栏很好理解，因为要开启下一代栅栏了，当前代栅栏上阻塞的线程需要被唤醒，同时初始化好下一代栅栏。</p><h4 id="打破栅栏"><a href="#打破栅栏" class="headerlink" title="打破栅栏"></a>打破栅栏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---CyclicBarrier</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 打破栅栏</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 设置栅栏已破标志</span></span><br><span class="line">          generation.broken = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">// 重置 count</span></span><br><span class="line">          count = parties;</span><br><span class="line">          <span class="comment">// 唤醒阻塞在栅栏上的线程</span></span><br><span class="line">          trip.signalAll();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打破栅栏需要标记当前代的栅栏不可用，并且要唤醒阻塞在这个不可用的栅栏上的线程，因为这里不进行唤醒的话，阻塞的线程将一直挂起。这里重制 count 不明白是干嘛的。</p><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">--- CyclicBarrier</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不带超时机制的方法，例子中使用的就是这个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// false , 0</span></span><br><span class="line">            <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 带有超时机制的方法，如果超过等待时间，当前线程没有被唤醒则 抛出 TimeoutException</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">               BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier 提供了 await 两个重载方法，一个是不带超时机制的方法，另一个是带有超时机制的方法。下面我们分析 CyclicBarrier 核心代码 <code>dowait</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">--- CyclicBarrier</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用可重入锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取标志着当前栅栏的 代</span></span><br><span class="line">            <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查当前代的栅栏是否被打破，如果当前代的栅栏被打破需要 抛出 BrokenBarrierException 异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查当前线程中断状态，如果被中断了，则要抛出 InterruptedException 异常，并且打破栅栏</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递减 count 的值</span></span><br><span class="line">            <span class="keyword">int</span> index = --count;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果 count 递减后的值为 0 ，说明当前代的栅栏要拦截的最后一个线程也到达栅栏</span></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 标志优先任务是否失败，默认是 false</span></span><br><span class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果指定了优先任务，就交给最后到达的线程执行</span></span><br><span class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 设置标志</span></span><br><span class="line">                    ranAction = <span class="keyword">true</span>;</span><br><span class="line">                   </span><br><span class="line">                    <span class="comment">// 唤醒当前代的栅栏上阻塞的任务，并开启下一代 （栅栏可以重复使用）</span></span><br><span class="line">                    nextGeneration();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果执行优先任务失败，则打破栅栏</span></span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">   </span><br><span class="line">           <span class="comment">// ---------------------- 执行到这里的线程不是最后一个线程，因此需要阻塞，等待最后一个线程到来并唤醒自己 ---------------/</span></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 不带超时机制</span></span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        <span class="comment">// 释放锁，加入等待队列 (ConditionObject)</span></span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="comment">// 带超时机制，并且超时时间 &gt; 0</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        <span class="comment">// 释放锁，加入等待队列 (ConditionObject)，如果到时间还没有被唤醒则不再阻塞</span></span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 执行到这里说明，线程进入等待队列后被中断了</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="comment">// 栅栏仍是进入等待队列的前的栅栏，此时应该打破栅栏，并且抛出中断异常</span></span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 1 g != generation，说明新一代的栅栏生成了，即最后一个线程也到达了栅栏，此时只需复位被中断线程的中断标志</span></span><br><span class="line">                        <span class="comment">// 2 栅栏被打破了（一定要抛出异常），被打破异常交由后续逻辑处理，此时只需复位被中断线程的中断标志</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 线程被唤醒后，还没从 await 方法返回栅栏就被打破了，直接抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 这个方法很重要，被唤醒后的线程正常逻辑都会从该方法返回出去</span></span><br><span class="line"><span class="comment">                 * 1 最后一个线程到达后会做三件事：执行优先任务、唤醒当前代的栅栏上阻塞的线程、开启栅栏的下一代</span></span><br><span class="line"><span class="comment">                 * 2 当前所在的方法是加了 ReentrantLock 锁的，因此我们要知道以下信息：</span></span><br><span class="line"><span class="comment">                 *   1）最后一个到达线程在没有执行完三件事前，是不会释放锁的</span></span><br><span class="line"><span class="comment">                 *   2）唤醒的阻塞线程并不能马上从 await 方法返回，它需要先去竞争锁，获取锁后才能从 await 方法返回</span></span><br><span class="line"><span class="comment">                 *   3）即使最后一个线程开启了栅栏的下一代，在它没有释放锁前，其它组的线程也要阻塞，比如例子中的后四个线程</span></span><br><span class="line"><span class="comment">                 * 3 被最后一个线程唤醒的线程执行到这里时，新一代的栅栏一定已经存在了。注意，这里说的是被最后一个线程唤醒的线程，并不是由于超时机制醒来的线程</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 超时机制醒来的线程，如果发现已经超时了，则打破栅栏，抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>涉及到的源码已经分析过了，下面结合使用例子简单分析下过程</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-cb-2.jpg" alt></p><p>CyclicBarrier 整个过程还是挺清晰的，没有使用 CAS 重试等机制，因为栅栏等待线程的 await 方法直接使用了ReentrantLock 锁，线程要到达栅栏必须拿到锁才行，整个过程是串行化的。分析完核心方法后，我们再看下其它几个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">--- CyclicBarrier</span><br><span class="line">    <span class="comment">// 重置栅栏</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">            nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在栅栏上等待线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberWaiting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parties - count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断栅栏是否被打破</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generation.broken;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>CyclicBarrier 和 CountDownLatch 还是有点像的，前者强调的是一组线程到达同步点即栅栏，后者强调的是阻塞在同步点的线程等待其它线程完成任务。具体区别如下：</p><ul><li>作用不同<br>CyclicBarrier 要等固定数量线程到达同步点，CountDownLatch 等待的不是线程而是同步状态state递减为 0。前者针对线程，后者针对事件/任务（根据需要调用 countDown 方法）。</li><li>重用性不同<br>CyclicBarrier 可以重复使用，上一代使用完后自动初始化下一代，也可以调用 reset 方法重置。 CountDownLatch 只能使用一次，在同步状态减为 0 后门栓打开后，就不能再次使用，想要使用需要新建实例。</li><li>唤起任务数不同<br>CyclicBarrier 只能唤醒一个任务，CountDownLatch 可以唤醒多个任务</li></ul><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="使用例子-2"><a href="#使用例子-2" class="headerlink" title="使用例子"></a>使用例子</h3><p><strong>场景</strong></p><blockquote><p>有一些加工厂是对环境有很大污染的，如果要生产产品必须要有关机构申请生产许可证，拿到许可证后才可以生产，完成一定规模后需要归还许可证，便于其它工厂可以申请。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定线程数线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有 3 个许可证书，每个加工厂公平获取。</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有 6 个加工厂想要获取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            service.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取许可证</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    log.info(<span class="string">"拿到了许可证"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理任务</span></span><br><span class="line">                    log.warn(<span class="string">"凭借许可证处理任务..."</span>);</span><br><span class="line">                    Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log.info(<span class="string">"归还许可证"</span>);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-1] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-2] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-3] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-3] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-4] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-1] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-5] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-4] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.SemaphoreDemo - 拿到了许可证</span><br><span class="line">[pool-1-thread-6] WARN com.code.juc.tool.SemaphoreDemo - 凭借许可证处理任务...</span><br><span class="line">[pool-1-thread-2] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-6] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br><span class="line">[pool-1-thread-5] INFO com.code.juc.tool.SemaphoreDemo - 归还许可证</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>以上例子中，使用循环体和线程池模拟 6 个线程，即 6 个加工厂获取生产许可证。Semaphore 的许可证数量为 3，即监管部门目前只有 3 个生产许可证，此时 6 个工厂只能有其中三个可以获取到，另外 3 个工厂只能等待生产许可证的归还，如果不归还将一直等着。</p><h3 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h3><p>Semaphore 是用来控制同时访问特定资源的线程数据量，它通过协调各个线程来保证合理的使用有限的公共资源。Semaphore 也是对 AQS 共享模式的使用，因此套路也是一样的。它接收一个整形的数字 permits，也是 AQS 的 state，表示可用的许可证数量，即允许 permits 个线程获取许可证，也就是最大并发数是 permits。因为是共享模式的使用，因此需要重写对应的模版方法 <code>tryAcquireShared</code> 和 <code>tryReleaseShared</code> ，前者用来判断能否获取到许可证，后者用来判断能否归还许可整（总是返回true）。此外，Semaphore 在此基础上增加了公平和非公平获取同步状态的功能。Semaphore 的用法很简单，它的 <code>acquire</code> 方法获取许可证，<code>release</code> 方法归还许可证，获取不到许可证的线程就加入阻塞队列中，等待其它线程释放许可证。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-1.jpg" alt></p><h4 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h4><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-2.jpg" alt></p><p>前面也提到了，Semaphore 是对 AQS 共享模式的使用，并且支持公平和非公平的状态管理方式，即对同步状态 state 的操作。通过上图的 UML 类图更加清晰，Semaphore 既可以公平实现方式创建对象，又能以非公平方式创建对象。</p><h4 id="Sync-内部类"><a href="#Sync-内部类" class="headerlink" title="Sync 内部类"></a>Sync 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 AQS 的内部类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信号量的同步实现。使用 AQS 的同步状态 state 表示许可证。分为 公平和非公平两种实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法，设置 AQS 的同步状态 state。对于 Semaphore 来说表示许可证</span></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取同步状态，即许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非公平实现，共享式获取许可证。返回剩余许可证数量</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式释放同步状态方法，即归还许可证。该方法总是返回 true</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="comment">// 归还 releases 个许可证 (注意，如果不获取先释放的话，许可证会变多的)</span></span><br><span class="line">                <span class="keyword">int</span> next = current + releases;</span><br><span class="line">                <span class="comment">// 这里判断归还数量不能小于 0</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                <span class="comment">// CAS 更新 state （AQS 中的方法 ）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync 内部类首先对同步状态 state 进行了初始化，先确定同步状态 state 的值，即表示的意义，这里指许可证。第二个是获取同步状态 - tryAcquireShared，这里指获取许可证，Sync 中没有进行实现而是交给了两个子类。第三个是释放同步状态 - tryReleaseShared，这里指归还许可证，Sync 中统一实现了这个逻辑。下面我们分别看下其子类实现。</p><h4 id="NonfairSync-内部类"><a href="#NonfairSync-内部类" class="headerlink" title="NonfairSync 内部类"></a>NonfairSync 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 AQS 的内部类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信号量的同步实现。使用 AQS 的同步状态 state 表示许可证。分为 公平和非公平两种实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法，设置 AQS 的同步状态 state。对于 Semaphore 来说表示许可证</span></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取同步状态，即许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非公平实现要执行的方法，共享式获取许可证。返回剩余许可证数量</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式释放同步状态方法，即归还许可证。该方法总是返回 true</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="comment">// 归还 releases 个许可证 (注意，如果不获取先释放的话，许可证会变多的)</span></span><br><span class="line">                <span class="keyword">int</span> next = current + releases;</span><br><span class="line">                <span class="comment">// 这里判断归还数量不能小于 0</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                <span class="comment">// CAS 更新 state （AQS 中的方法 ）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式获取同步状态的方法，这里是非公平方式获取许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NonfairSync 内部类只做了一件事情，重写 AQS 的 tryAcquireShared 方法，需要注意它的非公平性，也就是不关心阻塞队列中有没有还在等待的线程，直接尝试获取许可证。</p><h4 id="FairSync-内部类"><a href="#FairSync-内部类" class="headerlink" title="FairSync 内部类"></a>FairSync 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3222578661600680210L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继承 AQS 的内部类对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信号量的同步实现。使用 AQS 的同步状态 state 表示许可证。分为 公平和非公平两种实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法，设置 AQS 的同步状态 state。对于 Semaphore 来说表示许可证</span></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取同步状态，即许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非公平实现，共享式获取许可证。返回剩余许可证数量</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式释放同步状态方法，即归还许可证。该方法总是返回 true</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="comment">// 归还 releases 个许可证 (注意，如果不获取先释放的话，许可证会变多的)</span></span><br><span class="line">                <span class="keyword">int</span> next = current + releases;</span><br><span class="line">                <span class="comment">// 这里判断归还数量不能小于 0</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                <span class="comment">// CAS 更新 state （AQS 中的方法 ）</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式获取同步状态的方法，这里是非公平方式获取许可证</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            <span class="keyword">super</span>(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 AQS 的共享式获取同步状态的方法， 这里是 公平方式获取许可证。返回剩余许可证数</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="comment">// 是否有线程在排队等待许可证</span></span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">// 减少 acquires 个许可证</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                        compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FairSync 内部类同样只做了一件事情，重写 AQS 的 tryAcquireShared 方法，以公平的方式实现，也就是线程在获取许可证之前，先判断阻塞队列中是否还有等待的线程，有的话就直接返回 -1 进入阻塞队列中等待。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 以非公平方式创建 Semaphore</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">     sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 可选择公平/非公平方式创建 Semaphore</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">     sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>和 ReentrantLock 有点类似，实现了公平和非公平方式，默认使用非公平实现。</p><h4 id="acquire-系列方法"><a href="#acquire-系列方法" class="headerlink" title="acquire 系列方法"></a>acquire 系列方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">--- Semaphore</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可响应中断地获取许可证（获取一个许可证）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 的方法</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">       <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- Semaphore</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取许可证（获取一个许可证），对中断不敏感</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 的方法</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// Semaphore 实现的获取同步状态，公平还是不公平看Semaphore的具体实现</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 内部会调用 doReleaseShared 方法</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- Semaphore</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 Semaphore 获取给定数量的许可证，不够就阻塞等待，对中断敏感</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        sync.acquireSharedInterruptibly(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从 Semaphore 获取给定数量的许可证，不够就阻塞等待，对中断不敏感</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        sync.acquireShared(permits);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过 acquire 方法也可以看出，AQS 框架在实现共享式获取同步状态时，当且仅当同步状态处理结果小于 0 时，线程才会走入队流程。因为都是共享式实现，AQS 底层处理是一样的，因此后续的入队、找有效前驱节点以及挂起操作和 CountDownLatch 是一样的，就不再分析了。继续看它的释放同步状态的方法。</p><h4 id="release-系列方法"><a href="#release-系列方法" class="headerlink" title="release 系列方法"></a>release 系列方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">--- Semaphore</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归还许可证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// AQS 方法</span></span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归还给定数量的许可证到 Semaphore</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">         <span class="comment">// AQS 方法</span></span><br><span class="line">        sync.releaseShared(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">--- AbstractQueuedSynchronizer</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Semaphore 实现的释放同步状态方法</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过 release 系列方法也可以看出，AQS 框架在实现共享式释放同步状态时，当且仅当同步状态处理结果为 true 时，才会唤醒阻塞队列的线程。因为都是共享式实现，AQS 底层处理是一样的，因此唤醒的流程和 CountDownLatch 是一样的。</p><h4 id="例子流程"><a href="#例子流程" class="headerlink" title="例子流程"></a>例子流程</h4><ul><li><p>Semaphore 初始化 3 个 许可证<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-3.jpg" alt><br>同一个JVM进程中，某一时刻对 resource 访问的最大并发请求数为3</p></li><li><p>某一时刻t1、t2、t3获取到许可证，t4进入阻塞队列等待<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-4.jpg" alt><br>线程t1、t2、t3拿到许可证去访问资源，此时 Semaphore 中已经没有可用的许可证了，t4只能加入阻塞队列等待许可证的释放。这里 t4 要入队。</p></li><li><p>t3 访问资源后归还许可证，t4 获取到获取到许可证<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/juc-tool-sm-5.jpg" alt><br>这个过程可能会有多种情况，如，t4 在没有挂起之前，t3 已经归还了许可证，此时 t4 直接就可以拿到。如果 t4 不太幸运的话，会挂起然后等待t3来唤醒。Semaphore 的一些特殊情况可以参考 CountDownLatch。</p></li><li><p>其它线程获取许可证依次类推</p></li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>Semaphore 使用的注意事项：</p><ol><li>获取和释放的许可证数量必须一致，否则随着许可证的获取和归还流程推进，最后会导致许可证数量不够，将出现程序卡死。</li><li>在初始化 Semaphore 的时候可以设置释放公平，这个可以根据情景选择，一般设置为 true 更合理，因为 Semaphore 本身就是限制同时请求量的，不针对某个请求的。</li><li>获取和释放许可证不一定非要同一个线程来完成，可以是 线程 A 获取，线程 B 释放，逻辑合理即可。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是 ReentrantLock，还是 CountDownLatch、CyclicBarrier、Semaphore 等 ，它们都是对 AQS 应用，至于是实现锁的功能，还是实现同步组件根据具体场景进行设计。本质上都离不开同步状态 <code>state</code>、独占方式 <code>tryAcquire-tryRelease</code> 获取与释放方法，共享方式 <code>tryAcquireShared-tryReleaseShared</code> 获取与释放方法，此外 AQS 也支持自定义同步组件同时实现独占和共享两种方式，以及公平和非公平实现，不同组件表示的意义是不同的。AQS 还提供了 <code>等待队列</code> 机制，ReentrantLock 就基于该机制实现了等待与唤醒机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 JDK 的并发包中提供了几个非常有用的并发工具类。 &lt;code&gt;CountDownLatch&lt;/code&gt;、&lt;code&gt;CyclicBa
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 本地暴露</title>
    <link href="https://gentryhuang.com/posts/751c0982/"/>
    <id>https://gentryhuang.com/posts/751c0982/</id>
    <published>2020-08-04T16:00:00.000Z</published>
    <updated>2020-11-05T15:21:22.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有了前面一系列文章铺垫，再来看服务暴露与服务引用就简单很多了。本地暴露需要配置、SPI、动态代理、协议等知识，其中协议部分会在后面的文章中着重分析。</p><h2 id="配置承载"><a href="#配置承载" class="headerlink" title="配置承载"></a>配置承载</h2><p>无论是服务暴露还是服务引用，Dubbo 框架都会根据配置覆盖策略对配置项进行聚合处理，配置覆盖策略参见<a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/xml.html" target="_blank" rel="noopener">官网</a> 。Dubbo 支持动态添加配置项即服务治理，其中不允许 Provider 端配置项透传到客户端的都会进行特殊处理. </p><h2 id="服务暴露配置"><a href="#服务暴露配置" class="headerlink" title="服务暴露配置"></a>服务暴露配置</h2><ul><li>仅本地暴露<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"local"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li>仅远程暴露<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"remote"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li>本暴露和远程暴露<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在不配置 scope 的情况下，默认两种方式都暴露</span><br></pre></td></tr></table></figure></li><li>不暴露<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">scope</span>=<span class="string">"none"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="服务暴露机制"><a href="#服务暴露机制" class="headerlink" title="服务暴露机制"></a>服务暴露机制</h2><p>Dubbo 服务暴露分为两部分，先将持有的服务信息（服务对象，服务接口，服务 URL信息）通过动态代理工厂转换成 Invoker ，再把 Invoker 通过具体的协议转成 Exporter（注意，这里涉及到多协议的知识后面文章会详细分析） 。Dubbo 框架在进行服务暴露时，无论是 API 配置、XML 配置还是注解配置，最终都会转成 ServiceBean，它继承自 ServiceConfig ，注意这里是指使用 Spring 环境时，如果仅使用 Dubbo API 配置的话，会转成 ServiceConfig 。因为 Spring 是主流，下面没有特别说明都是在 Spring 环境下。</p><h2 id="服务暴露方式"><a href="#服务暴露方式" class="headerlink" title="服务暴露方式"></a>服务暴露方式</h2><p>Dubbo 支持两种服务暴露方式，分为延迟暴露和立即暴露。延迟暴露的入口是 ServiceBean 的 afterPropertiesSet 方法，立即暴露的入口是 ServiceBean 的 onApplicationEvent 方法。</p><h3 id="Spring支持的-Dubbo-IOC"><a href="#Spring支持的-Dubbo-IOC" class="headerlink" title="Spring支持的 Dubbo IOC"></a>Spring支持的 Dubbo IOC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="comment">// 为Spring拓展工厂注入上下文 ,用于Dubbo IOC</span></span><br><span class="line">        SpringExtensionFactory.addApplicationContext(applicationContext);</span><br><span class="line">        <span class="keyword">if</span> (applicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SPRING_CONTEXT = applicationContext;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Method method = applicationContext.getClass().getMethod(<span class="string">"addApplicationListener"</span>, <span class="keyword">new</span> Class&lt;?&gt;[]&#123;ApplicationListener<span class="class">.<span class="keyword">class</span>&#125;)</span>; <span class="comment">// backward compatibility to spring 2.0.1</span></span><br><span class="line">                method.invoke(applicationContext, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">                <span class="comment">// 当前Spring容器是否支持上下文监听</span></span><br><span class="line">                supportedApplicationListener = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (applicationContext <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Method method = AbstractApplicationContext.class.getDeclaredMethod("addListener", new Class&lt;?&gt;[]&#123;ApplicationListener.class&#125;); // backward compatibility to spring 2.0.1</span><br><span class="line">                        <span class="keyword">if</span> (!method.isAccessible()) &#123;</span><br><span class="line">                            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        method.invoke(applicationContext, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>&#125;);</span><br><span class="line">                        supportedApplicationListener = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean#setApplicationContext 方法用于将 Spring 的上下文设置设置到 SpringExtensionFactory 中，这样 Dubbo IOC 就可以使用 Spring 管理的对象了。</p><h3 id="延迟暴露"><a href="#延迟暴露" class="headerlink" title="延迟暴露"></a>延迟暴露</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务暴露的入口，非延迟暴露 。收到 Spring 容器的刷新事件执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否有延迟暴露 &amp;&amp; 是否已暴露 &amp;&amp; 是不是已被取消暴露</span></span><br><span class="line">        <span class="keyword">if</span> (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"The service ready on spring started. service: "</span> + getInterface());</span><br><span class="line">            &#125;</span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 delay</span></span><br><span class="line">        Integer delay = getDelay();</span><br><span class="line">        ProviderConfig provider = getProvider();</span><br><span class="line">        <span class="keyword">if</span> (delay == <span class="keyword">null</span> &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果前面获取的 delay 为空，这里继续获取</span></span><br><span class="line">            delay = provider.getDelay();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 判断 delay 是否为空，或者等于 -1，当 delay 为空，或者等于-1时，该方法返回 true，而不是 false</span></span><br><span class="line"><span class="comment">         * 2 supportedApplicationListener 变量用于表示当前的 Spring 容器是否支持 ApplicationListener，这个值初始为 false。</span></span><br><span class="line"><span class="comment">         * 在 Spring 容器将自己设置到 ServiceBean 中时，ServiceBean 的 setApplicationContext 方法会检测 Spring 容器是否支持 ApplicationListener,若支持，则将 supportedApplicationListener 置为 true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> supportedApplicationListener &amp;&amp; (delay == <span class="keyword">null</span> || delay == -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置项</span></span><br><span class="line">        <span class="keyword">return</span> delay;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的 isDelay 方法，当方法返回 true 时，表示无需延迟导出。返回 false 时，表示需要延迟导出，与字面意思是相反的。</p><h3 id="立即暴露"><a href="#立即暴露" class="headerlink" title="立即暴露"></a>立即暴露</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务暴露的入口，延迟暴露</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"deprecation"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getProvider() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Map&lt;String, ProviderConfig&gt; providerConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (providerConfigMap != <span class="keyword">null</span> &amp;&amp; providerConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> ((protocolConfigMap == <span class="keyword">null</span> || protocolConfigMap.size() == <span class="number">0</span>)</span><br><span class="line">                        &amp;&amp; providerConfigMap.size() &gt; <span class="number">1</span>) &#123; <span class="comment">// backward compatibility</span></span><br><span class="line">                    List&lt;ProviderConfig&gt; providerConfigs = <span class="keyword">new</span> ArrayList&lt;ProviderConfig&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() != <span class="keyword">null</span> &amp;&amp; config.isDefault().booleanValue()) &#123;</span><br><span class="line">                            providerConfigs.add(config);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!providerConfigs.isEmpty()) &#123;</span><br><span class="line">                        setProviders(providerConfigs);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ProviderConfig providerConfig = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (ProviderConfig config : providerConfigMap.values()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate provider configs: "</span> + providerConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                            &#125;</span><br><span class="line">                            providerConfig = config;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (providerConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        setProvider(providerConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getApplication() == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getApplication() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Map&lt;String, ApplicationConfig&gt; applicationConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ApplicationConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (applicationConfigMap != <span class="keyword">null</span> &amp;&amp; applicationConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ApplicationConfig applicationConfig = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (ApplicationConfig config : applicationConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate application configs: "</span> + applicationConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        applicationConfig = config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (applicationConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    setApplication(applicationConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getModule() == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getModule() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Map&lt;String, ModuleConfig&gt; moduleConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ModuleConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (moduleConfigMap != <span class="keyword">null</span> &amp;&amp; moduleConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ModuleConfig moduleConfig = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (ModuleConfig config : moduleConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate module configs: "</span> + moduleConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        moduleConfig = config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (moduleConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    setModule(moduleConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((getRegistries() == <span class="keyword">null</span> || getRegistries().isEmpty())</span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getRegistries() == <span class="keyword">null</span> || getProvider().getRegistries().isEmpty())</span><br><span class="line">                &amp;&amp; (getApplication() == <span class="keyword">null</span> || getApplication().getRegistries() == <span class="keyword">null</span> || getApplication().getRegistries().isEmpty())) &#123;</span><br><span class="line">            Map&lt;String, RegistryConfig&gt; registryConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, RegistryConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (registryConfigMap != <span class="keyword">null</span> &amp;&amp; registryConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                List&lt;RegistryConfig&gt; registryConfigs = <span class="keyword">new</span> ArrayList&lt;RegistryConfig&gt;();</span><br><span class="line">                <span class="keyword">for</span> (RegistryConfig config : registryConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        registryConfigs.add(config);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (registryConfigs != <span class="keyword">null</span> &amp;&amp; !registryConfigs.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">super</span>.setRegistries(registryConfigs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getMonitor() == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getMonitor() == <span class="keyword">null</span>)</span><br><span class="line">                &amp;&amp; (getApplication() == <span class="keyword">null</span> || getApplication().getMonitor() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Map&lt;String, MonitorConfig&gt; monitorConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, MonitorConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (monitorConfigMap != <span class="keyword">null</span> &amp;&amp; monitorConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                MonitorConfig monitorConfig = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (MonitorConfig config : monitorConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (monitorConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate monitor configs: "</span> + monitorConfig + <span class="string">" and "</span> + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        monitorConfig = config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (monitorConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    setMonitor(monitorConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((getProtocols() == <span class="keyword">null</span> || getProtocols().isEmpty())</span><br><span class="line">                &amp;&amp; (getProvider() == <span class="keyword">null</span> || getProvider().getProtocols() == <span class="keyword">null</span> || getProvider().getProtocols().isEmpty())) &#123;</span><br><span class="line">            Map&lt;String, ProtocolConfig&gt; protocolConfigMap = applicationContext == <span class="keyword">null</span> ? <span class="keyword">null</span> : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (protocolConfigMap != <span class="keyword">null</span> &amp;&amp; protocolConfigMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                List&lt;ProtocolConfig&gt; protocolConfigs = <span class="keyword">new</span> ArrayList&lt;ProtocolConfig&gt;();</span><br><span class="line">                <span class="keyword">for</span> (ProtocolConfig config : protocolConfigMap.values()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isDefault() == <span class="keyword">null</span> || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        protocolConfigs.add(config);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (protocolConfigs != <span class="keyword">null</span> &amp;&amp; !protocolConfigs.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">super</span>.setProtocols(protocolConfigs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getPath() == <span class="keyword">null</span> || getPath().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; beanName.length() &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; getInterface() != <span class="keyword">null</span> &amp;&amp; getInterface().length() &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; beanName.startsWith(getInterface())) &#123;</span><br><span class="line">                setPath(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 延迟暴露</span></span><br><span class="line">        <span class="keyword">if</span> (!isDelay()) &#123;</span><br><span class="line">            export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean#afterPropertiesSet 的方法不仅支持延迟暴露，还会在 Spring 生命周期内把 Dubbo 的核心配置承载对象设置到 ServiceBean 中（或其父类中）。ServiceBean 配置继承关系如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>AbstractConfig</span><br><span class="line"><span class="bullet">  - </span>AbstractMethodConfig</span><br><span class="line"><span class="bullet">    - </span>AbstractInterfaceConfig</span><br><span class="line"><span class="bullet">      - </span>AbstractServiceConfig</span><br><span class="line"><span class="bullet">        - </span>ServiceConfig</span><br><span class="line"><span class="bullet">          - </span>ServiceBean</span><br></pre></td></tr></table></figure><p>关于配置在之前的文章中应详细介绍，可以参考 <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 。</p><h2 id="服务暴露过程"><a href="#服务暴露过程" class="headerlink" title="服务暴露过程"></a>服务暴露过程</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-local.jpg" alt></p><p>上图是服务本地暴露的主要流程，配置检查和初始化完成后，生成 URL，然后将服务导出到 JVM 中。配置加载及配置承载对象的初始对应的三种方式在前面的文章中已经详细分析过，可以参考 <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 、<a href="https://gentryhuang.com/posts/a8d76a91/">XML配置</a> 、<a href="https://gentryhuang.com/posts/1a889dcd/">注解配置</a> 。下面分析具体源码。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>以延迟暴露的方式进行分析，默认情况下就是延迟暴露的方式。ServiceBean 是 Dubbo 框架与 Spring 框架进行整合的关键，可以看做是两个框架之间的桥梁。ReferenceBean 具有同样的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类 ServiceConfig 的 export 方法进行服务暴露</span></span><br><span class="line">        <span class="keyword">super</span>.export();</span><br><span class="line">        <span class="comment">// 发布服务暴露完成的事件</span></span><br><span class="line">        publishExportEvent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publishExportEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceBeanExportedEvent exportEvent = <span class="keyword">new</span> ServiceBeanExportedEvent(<span class="keyword">this</span>);</span><br><span class="line">        applicationEventPublisher.publishEvent(exportEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceBean 中的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">213195494150089726L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">transient</span> ApplicationContext SPRING_CONTEXT;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo 服务注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> Service service;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String beanName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否支持 Spring 上下文监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">boolean</span> supportedApplicationListener;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 事件发布对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.service = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceBean</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(service);</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getSpringContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SPRING_CONTEXT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入事件发布对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationEventPublisher</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.6.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在服务暴露之前，Dubbo 需要检查配置，或者补充缺省配置。配置检查完毕后，会根据配置组装 URL 。在 Dubbo 中，URL 十分重要，详细参见 <a href="https://gentryhuang.com/posts/46f95e97/">URL统一模型</a> 。</p><h4 id="检查配置"><a href="#检查配置" class="headerlink" title="检查配置"></a>检查配置</h4><p>我们继续从入口看起，ServiceBean 的父类 ServiceConfig 类，下面我们先看下这个类中的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3033787999037024738L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应 Protocol 实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自适应 ProxyFactory 实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 随机端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Integer&gt; RANDOM_PORT_MAP = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 延时暴露线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ScheduledExecutorService delayExportExecutor = Executors.newSingleThreadScheduledExecutor(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboServiceDelayExporter"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务URL集合</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务配置暴露的Exporter:</span></span><br><span class="line"><span class="comment">     * URL: Exporter 不一定是 1:1 的关系，需要看scope的值：</span></span><br><span class="line"><span class="comment">     * 1 scope 未设置时，会暴露Local + Remote两个，也就是URL : Exporter = 1:2</span></span><br><span class="line"><span class="comment">     * 2 scope设置为空时，不会暴露，也就是URL:Exporter = 1:0</span></span><br><span class="line"><span class="comment">     * 3 scope甚至为local 或 Remote 任一个时，会暴露对应的，也就是URL:Exporter = 1:1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Exporter&lt;?&gt;&gt; exporters = <span class="keyword">new</span> ArrayList&lt;Exporter&lt;?&gt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非配置，通过interfaceName 通过反射获得</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; interfaceClass;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口的实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T ref;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法配置对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;MethodConfig&gt; methods;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供者配置对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ProviderConfig provider;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exported;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否未暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> unexported;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> String generic;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceConfig</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        appendAnnotation(Service<span class="class">.<span class="keyword">class</span>, <span class="title">service</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们从 ServiceConfig#export 方法继续进行分析，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 暴露服务入口，加jvm锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 当export 或者 delay 未配置时，从ProviderConfig对象读取</span></span><br><span class="line">       <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (export == <span class="keyword">null</span>) &#123;</span><br><span class="line">               export = provider.getExport();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (delay == <span class="keyword">null</span>) &#123;</span><br><span class="line">               delay = provider.getDelay();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 不暴露服务(export = false),则不进行暴露服务逻辑</span></span><br><span class="line">       <span class="keyword">if</span> (export != <span class="keyword">null</span> &amp;&amp; !export) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 延迟暴露的话，就是使用任务线程池ScheduledExecutorService处理</span></span><br><span class="line">       <span class="keyword">if</span> (delay != <span class="keyword">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           delayExportExecutor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   doExport();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           doExport();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果我们只是想本地启动服务进行一些调试工作，这个时候我们并不希望把本地启动的服务暴露出去，此时，我们就可以通过配置 export 禁止服务暴露，如：</p><blockquote><p>&lt;dubbo:provider export=”false” /&gt;</p></blockquote><p>我们继续跟进 doExport 方法，该方法主要进行配置的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 服务暴露，jvm锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 检查是否可以暴露，若可以，标记已经暴露然后执行服务暴露逻辑</span></span><br><span class="line">       <span class="keyword">if</span> (unexported) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already unexported!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 如果已经暴露了直接返回</span></span><br><span class="line">       <span class="keyword">if</span> (exported) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 标记已经暴露过了</span></span><br><span class="line">       exported = <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">// 校验interfaceName 是否合法，即接口名非空</span></span><br><span class="line">       <span class="keyword">if</span> (interfaceName == <span class="keyword">null</span> || interfaceName.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"&lt;dubbo:service interface=\"\" /&gt; interface not allow null!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 校验provider是否为空(为空则新建一个)并拼接属性配置（环境变量 + .properties文件中的 属性）到ProviderConfig对象</span></span><br><span class="line">       checkDefault();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检测application，module等核心配置类对象是否为空，若为空则尝试从其他配置类对象中获取对应的实例。即： 从ProviderConfig 对象中，读取application,module,registries,monitor,protocols配置对象</span></span><br><span class="line">       <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (application == <span class="keyword">null</span>) &#123;</span><br><span class="line">               application = provider.getApplication();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">module</span> = provider.getModule();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">               registries = provider.getRegistries();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               monitor = provider.getMonitor();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (protocols == <span class="keyword">null</span>) &#123;</span><br><span class="line">               protocols = provider.getProtocols();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 从ModuleConfig 对象中，读取registries,monitor配置对象</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">               registries = <span class="keyword">module</span>.getRegistries();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               monitor = <span class="keyword">module</span>.getMonitor();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 从ApplicationConfig 对象中，读取registries,monitor配置对象</span></span><br><span class="line">       <span class="keyword">if</span> (application != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (registries == <span class="keyword">null</span>) &#123;</span><br><span class="line">               registries = application.getRegistries();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (monitor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               monitor = application.getMonitor();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 检测ref是否泛化接口的实现</span></span><br><span class="line">       <span class="keyword">if</span> (ref <span class="keyword">instanceof</span> GenericService) &#123;</span><br><span class="line">           <span class="comment">// 设置 interfaceClass 为 GenericService.class</span></span><br><span class="line">           interfaceClass = GenericService<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isEmpty(generic)) &#123;</span><br><span class="line">               <span class="comment">// 设置 generic = "true"</span></span><br><span class="line">               generic = Boolean.TRUE.toString();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 普通接口的实现</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 通过反射获取对应的接口的Class</span></span><br><span class="line">               interfaceClass = Class.forName(interfaceName, <span class="keyword">true</span>, Thread.currentThread()</span><br><span class="line">                       .getContextClassLoader());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 检验接口和方法 （接口非空，方法都在接口中定义）</span></span><br><span class="line">           checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 校验引用ref是否实现了当前接口</span></span><br><span class="line">           checkRef();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 标记为非泛化实现</span></span><br><span class="line">           generic = Boolean.FALSE.toString();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** 处理服务接口客户端本地代理,即本地存根。目前已经废弃，此处主要用于兼容，使用stub属性. todo 服务端没有意义 &#123;<span class="doctag">@link</span> StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125; */</span></span><br><span class="line">       <span class="keyword">if</span> (local != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果local属性设置为ture，表示使用缺省代理类名，即：接口名 + Local 后缀</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="string">"true"</span>.equals(local)) &#123;</span><br><span class="line">               local = interfaceName + <span class="string">"Local"</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           Class&lt;?&gt; localClass;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 获取本地存根类</span></span><br><span class="line">               localClass = ClassHelper.forNameWithThreadContextClassLoader(local);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法</span></span><br><span class="line">           <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(localClass)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The local implementation class "</span> + localClass.getName() + <span class="string">" not implement interface "</span> + interfaceName);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** 处理服务接口客户端本地代理(stub 属性)相关，即本地存根。目的：想在客户端【服务消费方】执行需要的逻辑，不局限服务提供的逻辑。本地存根类编写方式是固定。todo 服务端没有意义 &#123;<span class="doctag">@link</span> StubProxyFactoryWrapper#getInvoker(java.lang.Object, java.lang.Class, com.alibaba.dubbo.common.URL)&#125;*/</span></span><br><span class="line">       <span class="keyword">if</span> (stub != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果stub属性设置为ture，表示使用缺省代理类名，即：接口名 + Stub 后缀</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="string">"true"</span>.equals(stub)) &#123;</span><br><span class="line">               stub = interfaceName + <span class="string">"Stub"</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           Class&lt;?&gt; stubClass;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 获取本地存根类</span></span><br><span class="line">               stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 判断interfaceClass 是否是 stubClass 的接口，即 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法</span></span><br><span class="line">           <span class="keyword">if</span> (!interfaceClass.isAssignableFrom(stubClass)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The stub implementation class "</span> + stubClass.getName() + <span class="string">" not implement interface "</span> + interfaceName);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 校验ApplicationConfig配置</span></span><br><span class="line">       checkApplication();</span><br><span class="line">       <span class="comment">// 校验RegistryConfig配置</span></span><br><span class="line">       checkRegistry();</span><br><span class="line">       <span class="comment">// 校验ProtocolConfig配置数组</span></span><br><span class="line">       checkProtocol();</span><br><span class="line">       <span class="comment">// 读取环境变量和properties配置到ServiceConfig对象（自己）</span></span><br><span class="line">       appendProperties(<span class="keyword">this</span>);</span><br><span class="line">       <span class="comment">// 校验Stub和Mock相关的配置</span></span><br><span class="line">       checkStubAndMock(interfaceClass);</span><br><span class="line">       <span class="comment">// 服务路径，缺省是接口名</span></span><br><span class="line">       <span class="keyword">if</span> (path == <span class="keyword">null</span> || path.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           path = interfaceName;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 暴露服务</span></span><br><span class="line">       doExportUrls();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 1 ProviderModel 表示服务提供者模型，此对象中存储了和服务提供者相关的信息，比如服务的配置信息，服务实例等。每个被导出的服务对应一个 ProviderModel</span></span><br><span class="line"><span class="comment">        * 2 ApplicationModel 持有所有的 ProviderModel</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       ProviderModel providerModel = <span class="keyword">new</span> ProviderModel(getUniqueServiceName(), <span class="keyword">this</span>, ref);</span><br><span class="line">       ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以上就是配置检查的相关分析，下面对配置检查的主要逻辑进行简单的总结，如下：</p><ol><li>检测 <a href="dubbo:service">dubbo:service</a> 标签的 interface 属性合法性，不合法则抛出异常</li><li>检测 ProviderConfig、ApplicationConfig 等核心配置类对象是否为空，若为空，则尝试创建或从其他配置类对象中获取相应的实例。</li><li>检测并处理泛化服务和普通服务类</li><li>检测本地存根配置，并进行相应的处理</li><li>对 ApplicationConfig、RegistryConfig 等配置类进行检测，并读取环境变量和properties配置到配置承载对象中</li></ol><p>设置配置到配置承载对象在之前的文章中详细说明了，可以参见 <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 。</p><h4 id="多协议多注册中心暴露"><a href="#多协议多注册中心暴露" class="headerlink" title="多协议多注册中心暴露"></a>多协议多注册中心暴露</h4><p>Dubbo 允许使用不同的协议暴露服务，也支持向多个注册中心注册服务，Dubbo 在 ServiceConifg#doExportUrls 中对多协议，多注册中心进行了支持，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 加载注册中心URL 数组 【协议已经处理过，不再是配置的注册中心协议 如：zookeeper ,而是统一替换成了registry】</span></span><br><span class="line">       List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line">       <span class="comment">// 遍历协议集合，支持多协议暴露。</span></span><br><span class="line">       <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">           doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面代码比较简单，首先是通过 loadRegistries 加载注册中心URL，然后再遍历 ProtocolConfig 集合使用具体的协议导出每个服务。并在导出服务的过程中，将服务注册到注册中心。下面，我们先来看一下 loadRegistries 方法的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 加载注册中心URL数组</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> provider 是否是服务提供者</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> URL数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> List&lt;URL&gt; <span class="title">loadRegistries</span><span class="params">(<span class="keyword">boolean</span> provider)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 校验RegistryConfig 配置数组，不存在会抛出异常，并且该方法会初始化RegistryConfig的配置属性【见API与属性配置】</span></span><br><span class="line">       checkRegistry();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建注册中心URL数组</span></span><br><span class="line">       List&lt;URL&gt; registryList = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">       <span class="keyword">if</span> (registries != <span class="keyword">null</span> &amp;&amp; !registries.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 遍历RegistryConfig 数组</span></span><br><span class="line">           <span class="keyword">for</span> (RegistryConfig config : registries) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 获取注册中心的地址</span></span><br><span class="line">               String address = config.getAddress();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 地址为空就使用 0.0.0.0 任意地址</span></span><br><span class="line">               <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                   address = Constants.ANYHOST_VALUE;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 如果配置了启动参数的注册中心地址，它的优先级最高，就进行覆盖</span></span><br><span class="line">               String sysaddress = System.getProperty(<span class="string">"dubbo.registry.address"</span>);</span><br><span class="line">               <span class="keyword">if</span> (sysaddress != <span class="keyword">null</span> &amp;&amp; sysaddress.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   address = sysaddress;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 选择有效的注册中心地址</span></span><br><span class="line">               <span class="keyword">if</span> (address.length() &gt; <span class="number">0</span> &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 创建参数集合map,用于 URL的构建</span></span><br><span class="line">                   Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 将应用配置对象和注册中心配置对象的属性添加到参数集合map中</span></span><br><span class="line">                   appendParameters(map, application);</span><br><span class="line">                   <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 需要注意的是：RegistryConfig 的 getAddress方法上使用了 <span class="doctag">@Parameter</span>(excluded = true)注解，因此它的address属性不会加入到参数集合map中</span></span><br><span class="line"><span class="comment">                    *  <span class="doctag">@Parameter</span>(excluded = true)</span></span><br><span class="line"><span class="comment">                    *  public String getAddress() &#123;return address;&#125;</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   appendParameters(map, config);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 添加 path,dubbo,timestamp,pid 到参数集合map中</span></span><br><span class="line">                   map.put(<span class="string">"path"</span>, RegistryService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>; <span class="comment">// 这里的path要和服务暴露逻辑中的path区分，注册中心的URL中的path为RegistryService的全路径名</span></span><br><span class="line">                   map.put(<span class="string">"dubbo"</span>, Version.getProtocolVersion());</span><br><span class="line">                   map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                   <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                       map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 参数集合map中不存在 protocol 参数【以上配置对象的属性中没有有效的协议protocol参数】，就默认 使用 dubbo 作为 协议protocol的值</span></span><br><span class="line">                   <span class="keyword">if</span> (!map.containsKey(<span class="string">"protocol"</span>)) &#123;</span><br><span class="line">                       <span class="comment">// todo remote扩展实现已经不存在了，不需考虑这种情况</span></span><br><span class="line">                       if (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension("remote")) &#123;</span><br><span class="line">                           map.put(<span class="string">"protocol"</span>, <span class="string">"remote"</span>);</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           map.put(<span class="string">"protocol"</span>, <span class="string">"dubbo"</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 解析地址，创建 URL数组，注意address可能包含多个注册中心ip, 【数组大小可能为一】</span></span><br><span class="line">                   List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 循环 dubbo Register url</span></span><br><span class="line">                   <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                       <span class="comment">// 设置 registry=$&#123;protocol&#125;参数,设置到注册中心的 URL的参数部分的位置上，并且是追加式的添加</span></span><br><span class="line">                       url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());</span><br><span class="line">                       <span class="comment">// 重置 URL中的 protocol属性为 'registry',即将URL的协议头设置为'registry'</span></span><br><span class="line">                       url = url.setProtocol(Constants.REGISTRY_PROTOCOL);</span><br><span class="line">                       <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        * 通过判断条件，决定是否添加url到registryList中，条件如下：</span></span><br><span class="line"><span class="comment">                        * 1 如果是服务提供者,是否只订阅不注册，如果是就不添加到注册中心URL数组中</span></span><br><span class="line"><span class="comment">                        * 2 如果是服务消费者，是否是只注册不订阅，如果是就不添加到注册中心URL数组中</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                       <span class="keyword">if</span> ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, <span class="keyword">true</span>)) || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, <span class="keyword">true</span>))) &#123;</span><br><span class="line">                           registryList.add(url);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> registryList;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析注册中心地址，创建 URL数组</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> address</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> defaults</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;URL&gt; <span class="title">parseURLs</span><span class="params">(String address, Map&lt;String, String&gt; defaults)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 判断注册中心地址的有效性</span></span><br><span class="line">       <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 注册中心地址address 可以使用"|"或";"作为分割符，设置多个注册中心分组。注意：一个注册中心集群是一个分组而不是多个。</span></span><br><span class="line">       String[] addresses = Constants.REGISTRY_SPLIT_PATTERN.split(address);</span><br><span class="line">       <span class="keyword">if</span> (addresses == <span class="keyword">null</span> || addresses.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//here won't be empty</span></span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;URL&gt; registries = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">       <span class="comment">// 遍历注册中心分组</span></span><br><span class="line">       <span class="keyword">for</span> (String addr : addresses) &#123;</span><br><span class="line">           registries.add(parseURL(addr, defaults));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> registries;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解析单个 URL，将defaults属性集合 里的参数合并到 注册中心地址address中，合并逻辑：</span></span><br><span class="line"><span class="comment">    * 使用 defaults 集合对注册中心urL的属性 进行 '查漏补缺', 即 将defaults集合中不在 注册中心url上的属性 设置到url上，存在则忽略</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> address  注册中心地址</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> defaults 参数集合</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> Dubbo URL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> URL <span class="title">parseURL</span><span class="params">(String address, Map&lt;String, String&gt; defaults)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (address == <span class="keyword">null</span> || address.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String url;</span><br><span class="line">       <span class="keyword">if</span> (address.indexOf(<span class="string">"://"</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           url = address;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           String[] addresses = Constants.COMMA_SPLIT_PATTERN.split(address);</span><br><span class="line">           url = addresses[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">if</span> (addresses.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">               StringBuilder backup = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; addresses.length; i++) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                       backup.append(<span class="string">","</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   backup.append(addresses[i]);</span><br><span class="line">               &#125;</span><br><span class="line">               url += <span class="string">"?"</span> + Constants.BACKUP_KEY + <span class="string">"="</span> + backup.toString();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       String defaultProtocol = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"protocol"</span>);</span><br><span class="line">       <span class="keyword">if</span> (defaultProtocol == <span class="keyword">null</span> || defaultProtocol.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           defaultProtocol = <span class="string">"dubbo"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       String defaultUsername = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"username"</span>);</span><br><span class="line">       String defaultPassword = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"password"</span>);</span><br><span class="line">       <span class="keyword">int</span> defaultPort = StringUtils.parseInteger(defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"port"</span>));</span><br><span class="line">       String defaultPath = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : defaults.get(<span class="string">"path"</span>);</span><br><span class="line">       Map&lt;String, String&gt; defaultParameters = defaults == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> HashMap&lt;String, String&gt;(defaults);</span><br><span class="line">       <span class="keyword">if</span> (defaultParameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">           defaultParameters.remove(<span class="string">"protocol"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"username"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"password"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"host"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"port"</span>);</span><br><span class="line">           defaultParameters.remove(<span class="string">"path"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 分离url中的各个参数，然后根据各个参数构建标准的Dubbo URL -&gt; protocol://username:password@host:port/path?key=value&amp;key=value...</span></span><br><span class="line">       URL u = URL.valueOf(url);</span><br><span class="line">       <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">       String protocol = u.getProtocol();</span><br><span class="line">       String username = u.getUsername();</span><br><span class="line">       String password = u.getPassword();</span><br><span class="line">       String host = u.getHost();</span><br><span class="line">       <span class="keyword">int</span> port = u.getPort();</span><br><span class="line">       String path = u.getPath();</span><br><span class="line">       Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(u.getParameters());</span><br><span class="line">       <span class="keyword">if</span> ((protocol == <span class="keyword">null</span> || protocol.length() == <span class="number">0</span>) &amp;&amp; defaultProtocol != <span class="keyword">null</span> &amp;&amp; defaultProtocol.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           changed = <span class="keyword">true</span>;</span><br><span class="line">           protocol = defaultProtocol;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((username == <span class="keyword">null</span> || username.length() == <span class="number">0</span>) &amp;&amp; defaultUsername != <span class="keyword">null</span> &amp;&amp; defaultUsername.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           changed = <span class="keyword">true</span>;</span><br><span class="line">           username = defaultUsername;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((password == <span class="keyword">null</span> || password.length() == <span class="number">0</span>) &amp;&amp; defaultPassword != <span class="keyword">null</span> &amp;&amp; defaultPassword.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           changed = <span class="keyword">true</span>;</span><br><span class="line">           password = defaultPassword;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (port &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (defaultPort &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               changed = <span class="keyword">true</span>;</span><br><span class="line">               port = defaultPort;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               changed = <span class="keyword">true</span>;</span><br><span class="line">               port = <span class="number">9090</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (path == <span class="keyword">null</span> || path.length() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (defaultPath != <span class="keyword">null</span> &amp;&amp; defaultPath.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               changed = <span class="keyword">true</span>;</span><br><span class="line">               path = defaultPath;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (defaultParameters != <span class="keyword">null</span> &amp;&amp; defaultParameters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : defaultParameters.entrySet()) &#123;</span><br><span class="line">               String key = entry.getKey();</span><br><span class="line">               String defaultValue = entry.getValue();</span><br><span class="line">               <span class="keyword">if</span> (defaultValue != <span class="keyword">null</span> &amp;&amp; defaultValue.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   String value = parameters.get(key);</span><br><span class="line">                   <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                       changed = <span class="keyword">true</span>;</span><br><span class="line">                       parameters.put(key, defaultValue);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 根据标准构建的Ddubbo URL中的参数的值是否有效，会重新构建Dubbo URL，区别在于之前无效的参数都是用默认值替换</span></span><br><span class="line">       <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">           u = <span class="keyword">new</span> URL(protocol, username, password, host, port, path, parameters);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> u;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，本文主要分析 Dubbo 的本地暴露，本地暴露不会向注册中心注册服务，因为仅用于 JVM 内部调用，相关信息放在内存中。在下一篇远程暴露时会用到，这里为了完整就提前分析了。</p><p>加载注册中心URL代码还是挺复杂的，主要逻辑如下：</p><ol><li>检测是否存在注册中心配置类，不存在则抛出异常。存在则初始化RegistryConfig的配置属性。</li><li>组装参数集合，应用于注册中心URL的属性 ‘查漏补缺’。</li><li>构建注册中心URL列表</li></ol><p>有关注册中心URL构建还有一个数据流向操作，上面代码中也注释了，比较简单，因为会在远程暴露时用到，这里简单介绍下，以 Redis 注册中心为例进行说明，更常用 Zookeeper 作为注册中心。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-registry.jpg" alt></p><h4 id="组装-URL"><a href="#组装-URL" class="headerlink" title="组装 URL"></a>组装 URL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用不同的协议，逐个向注册中心分组暴露服务。该方法中包含了本地和远程两种暴露方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> protocolConfig 协议配置对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registryURLs   处理过的注册中心分组集合【已经添加了ApplicationConfig和RegistryConfig的参数】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 协议名</span></span><br><span class="line">        String name = protocolConfig.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 协议名为空时，缺省设置为 dubbo</span></span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            name = <span class="string">"dubbo"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建参数集合map，用于Dubbo URL 的构建（服务提供者URL）</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将side,dubbo,timestamp,pid参数，添加到map集合中</span></span><br><span class="line">        map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class="line">        map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());</span><br><span class="line">        map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.getPid() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射将各种配置对象中的属性添加到map集合中，map用于URL的构建【注意属性覆盖问题】</span></span><br><span class="line">        appendParameters(map, application);</span><br><span class="line">        appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">        appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">        appendParameters(map, protocolConfig);</span><br><span class="line">        appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将MethodConfig 对象数组添加到 map 集合中。就是将每个MethodConfig和其对应的ArgumentConfig对象数组添加到map中【处理方法相关的属性到map】</span></span><br><span class="line">        <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// methods 为 MethodConfig 集合，MethodConfig 中存储了 &lt;dubbo:method&gt; 标签的配置信息</span></span><br><span class="line">            <span class="keyword">for</span> (MethodConfig method : methods) &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 将MethodConfig对象的属性添加到map集合中，其中属性键 = 方法名.属性名。如：</span></span><br><span class="line"><span class="comment">                 * &lt;dubbo:method name="sleep" retries="2"&gt;&lt;/dubbo:method&gt;对应的MethodConfig，属性到map的格式：&#123;"sleep.retries":2&#125;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                appendParameters(map, method, method.getName());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当配置了 MehodConfig.retry = false 时，强制禁用重试</span></span><br><span class="line">                String retryKey = method.getName() + <span class="string">".retry"</span>;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class="line">                    String retryValue = map.remove(retryKey);</span><br><span class="line">                    <span class="comment">// 检测 MethodConfig retry 是否为 false，若是，则设置重试次数为0</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"false"</span>.equals(retryValue)) &#123;</span><br><span class="line">                        map.put(method.getName() + <span class="string">".retries"</span>, <span class="string">"0"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将MethodConfig下的ArgumentConfig 对象数组即&lt;dubbo:argument&gt; 标签中的配置信息，添加到 map 集合中</span></span><br><span class="line">                List&lt;ArgumentConfig&gt; arguments = method.getArguments();</span><br><span class="line">                <span class="keyword">if</span> (arguments != <span class="keyword">null</span> &amp;&amp; !arguments.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (ArgumentConfig argument : arguments) &#123;</span><br><span class="line">                        <span class="comment">// 检测type 属性是否为空</span></span><br><span class="line">                        <span class="keyword">if</span> (argument.getType() != <span class="keyword">null</span> &amp;&amp; argument.getType().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 通过反射取出接口的方法列表</span></span><br><span class="line">                            Method[] methods = interfaceClass.getMethods();</span><br><span class="line">                            <span class="comment">// 遍历接口中的方法列表</span></span><br><span class="line">                            <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">                                    String methodName = methods[i].getName();</span><br><span class="line">                                    <span class="comment">// 比对方法名，查找目标方法</span></span><br><span class="line">                                    <span class="keyword">if</span> (methodName.equals(method.getName())) &#123;</span><br><span class="line">                                        <span class="comment">// 通过反射取出目标方法的参数类型列表</span></span><br><span class="line">                                        Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();</span><br><span class="line">                                        <span class="comment">// 若果配置index配置项，且值不为-1</span></span><br><span class="line">                                        <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123;</span><br><span class="line">                                            <span class="comment">// 从argtypes数组中获取下标index处的元素argType，并检测ArgumentConfig中的type属性与argType名称是否一致，不一致则抛出异常</span></span><br><span class="line">                                            <span class="keyword">if</span> (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                <span class="comment">// 将ArgumentConfig对象的属性添加到map集合中，键前缀=方法名.index，如：map = &#123;"sleep.2":true&#125;</span></span><br><span class="line">                                                appendParameters(map, argument, method.getName() + <span class="string">"."</span> + argument.getIndex());</span><br><span class="line">                                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config error : the index attribute and type attribute not match :index :"</span> + argument.getIndex() + <span class="string">", type:"</span> + argument.getType());</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                            <span class="comment">// 遍历参数类型数组argtypes，查找argument.type类型的参数</span></span><br><span class="line">                                            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; argtypes.length; j++) &#123;</span><br><span class="line">                                                Class&lt;?&gt; argclazz = argtypes[j];</span><br><span class="line">                                                <span class="comment">// 从参数类型列表中查找类型名称为argument.type的参数</span></span><br><span class="line">                                                <span class="keyword">if</span> (argclazz.getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                    <span class="comment">// 将ArgumentConfig对象的属性添加到map集合中</span></span><br><span class="line">                                                    appendParameters(map, argument, method.getName() + <span class="string">"."</span> + j);</span><br><span class="line">                                                    <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span> &amp;&amp; argument.getIndex() != j) &#123;</span><br><span class="line">                                                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config error : the index attribute and type attribute not match :index :"</span> + argument.getIndex() + <span class="string">", type:"</span> + argument.getType());</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 用户未配置 type 属性，但配置了index属性，且index != -1</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123; <span class="comment">// 指定单个参数的位置</span></span><br><span class="line">                            <span class="comment">// 将ArgumentConfig对象的属性添加到map集合中</span></span><br><span class="line">                            appendParameters(map, argument, method.getName() + <span class="string">"."</span> + argument.getIndex());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument config must set index or type attribute.eg: &lt;dubbo:argument index='0' .../&gt; or &lt;dubbo:argument type=xxx .../&gt;"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// end of methods for</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//--- 检测 generic 是否 为 true ,并根据检测结果向map中添加不同的信息 ---/</span></span><br><span class="line">        <span class="comment">// 将 generic,methods,revision 加入到数组</span></span><br><span class="line">        <span class="keyword">if</span> (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">            map.put(Constants.GENERIC_KEY, generic);</span><br><span class="line">            map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先从MAINFEST.MF 中获取版本号，若获取不到，再从jar包命名中可能带的版本号作为结果，如 2.6.5.RELEASE。若都不存在，返回默认版本号【源码运行可能会没有】</span></span><br><span class="line">            String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">            <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                map.put(<span class="string">"revision"</span>, revision); <span class="comment">// 修订号</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为接口生成包裹类 Wrapper，Wrapper 中包含了接口的详细信息，如接口方法，字段信息等</span></span><br><span class="line">            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加方法名到 map 中，如果包含多个方法名，则用逗号隔开，比如：method=a,b</span></span><br><span class="line">            <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">                logger.warn(<span class="string">"NO method found in service interface "</span> + interfaceClass.getName());</span><br><span class="line">                <span class="comment">// 没有方法名就添加 method=*</span></span><br><span class="line">                map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将逗号作为分隔符连接方法名，并将连接后的字符串放入 map 中</span></span><br><span class="line">                map.put(Constants.METHODS_KEY, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">","</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// token 【使暴露出去的服务更安全，使用token做安全校验】</span></span><br><span class="line">        <span class="keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">                map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(Constants.TOKEN_KEY, token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 协议为injvm时，不注册，不通知</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) &#123;</span><br><span class="line">            protocolConfig.setRegister(<span class="keyword">false</span>);</span><br><span class="line">            map.put(<span class="string">"notify"</span>, <span class="string">"false"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得基础路径</span></span><br><span class="line">        String contextPath = protocolConfig.getContextpath();</span><br><span class="line">        <span class="keyword">if</span> ((contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span>) &amp;&amp; provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            contextPath = provider.getContextpath();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ---------------------------- 主机绑定 -------------------------------------/</span></span><br><span class="line">        <span class="comment">// 获得注册到注册中心的服务提供者host，并为map设置bind.ip , anyhost 两个key</span></span><br><span class="line">        String host = <span class="keyword">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">        <span class="comment">// 获取端口，并为map设置bing.port key</span></span><br><span class="line">        Integer port = <span class="keyword">this</span>.findConfigedPorts(protocolConfig, name, map);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建Dubbo URL对象 【注意这里的 path 的值】</span></span><br><span class="line"><span class="comment">         * 1 name: 协议名</span></span><br><span class="line"><span class="comment">         * 2 host: 主机名</span></span><br><span class="line"><span class="comment">         * 3 port: 端口</span></span><br><span class="line"><span class="comment">         * 4 path: 【基础路径】/path</span></span><br><span class="line"><span class="comment">         * 5 parameters: 属性集合map</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(name, host, port, (contextPath == <span class="keyword">null</span> || contextPath.length() == <span class="number">0</span> ? <span class="string">""</span> : contextPath + <span class="string">"/"</span>) + path, map);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码比较复杂，不过总体上是将配置承载对象中的属性添加到参数集合中用于构建 Dubbo URL 。其中涉及到的将配置对象的属性添加到参数集合的 appendParameters 方法可以参见  <a href="https://gentryhuang.com/posts/1d3295e6/">API和属性配置</a> 。</p><h3 id="服务暴露"><a href="#服务暴露" class="headerlink" title="服务暴露"></a>服务暴露</h3><p>服务暴露的准备工作完成后，接下来就可以执行服务暴露工作了。服务暴露，分为本地暴露和远程暴露。我们先不研究细节，先从宏观层面上看一下服务暴露逻辑。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用不同的协议，逐个向注册中心分组暴露服务。该方法中包含了本地和远程两种暴露方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> protocolConfig 协议配置对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registryURLs   处理过的注册中心分组集合【已经添加了ApplicationConfig和RegistryConfig的参数】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果存在当前协议对应的 ConfiguratorFactory 扩展实现，就创建配置规则器 Configurator，将配置规则应用到url todo 这里应该不会存在把？</span></span><br><span class="line">        <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">url</span>.<span class="title">getProtocol</span>())) </span>&#123;</span><br><span class="line">            <span class="comment">// 加载ConfiguratorFactory ，并生成Configurator，将配置规则应用到url中</span></span><br><span class="line">            url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">url</span>.<span class="title">getProtocol</span>()).<span class="title">getConfigurator</span>(<span class="title">url</span>).<span class="title">configure</span>(<span class="title">url</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从URL中获取暴露方式</span></span><br><span class="line">        String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 scope = none，则不进行暴露，直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// scope != remote，本地暴露</span></span><br><span class="line">            <span class="keyword">if</span> (!Constants.SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                exportLocal(url);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// scope != local，远程暴露，包含了服务暴露和服务注册两个过程</span></span><br><span class="line">            <span class="keyword">if</span> (!Constants.SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to url "</span> + url);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (registryURLs != <span class="keyword">null</span> &amp;&amp; !registryURLs.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">// 遍历注册中心URL数组</span></span><br><span class="line">                    <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                        <span class="comment">// dynamic属性：服务是否动态注册，如果设为false,注册后将显示disable状态，需要人工启用，并且服务提供者停止时，也不会自动下线，需要人工禁用</span></span><br><span class="line">                        url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 获取监控中心URL</span></span><br><span class="line">                        URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 监控URL不能空，就将监控中心的URL作为monitor参数添加到服务提供者的URL中，并且需要编码。通过这样方式，服务提供者的URL中就包含了监控中心的配置</span></span><br><span class="line">                            url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(<span class="string">"Register dubbo service "</span> + interfaceClass.getName() + <span class="string">" url "</span> + url + <span class="string">" to registry "</span> + registryURL);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                     </span><br><span class="line">                        <span class="comment">// 获取配置的动态代理的生成方式 &lt;dubbo:service proxy=""/&gt;,可选jdk/javassist,默认使用javassist</span></span><br><span class="line">                        String proxy = url.getParameter(Constants.PROXY_KEY);</span><br><span class="line">                        <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                            registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);</span><br><span class="line">                        &#125;</span><br><span class="line">                     </span><br><span class="line">                        <span class="comment">// 使用ProxyFactory 创建 AbstractProxyInvoker 对象</span></span><br><span class="line">                        Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(</span><br><span class="line">                                ref,</span><br><span class="line">                                (Class) interfaceClass,</span><br><span class="line">                                registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString())</span><br><span class="line">                        );</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 创建 DelegateProviderMetaDataInvoker 对象，在Invoker对象基础上，增加了当前服务提供者ServiceConfig对象，即把Invoker和ServiceConfig结合在了一起</span></span><br><span class="line">                        DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line">  </span><br><span class="line">                        <span class="comment">// 暴露服务，生成Exporter:</span></span><br><span class="line">                        Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 添加到 Exporter 集合</span></span><br><span class="line">                        exporters.add(exporter);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 无效注册中心，仅暴露服务</span></span><br><span class="line">                    <span class="comment">// 使用ProxyFactory 创建 Invoker 对象</span></span><br><span class="line">                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                    <span class="comment">// 创建 DelegateProviderMetaDataInvoker 对象</span></span><br><span class="line">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 使用Protocol 暴露Invoker 对象</span></span><br><span class="line">                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                    <span class="comment">// 添加到 Exporter 集合</span></span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从宏观层面上看，服务暴露的方式取决于 scope 参数，该参数值在文章前面有具体说明。</p><h3 id="创建-Invoker"><a href="#创建-Invoker" class="headerlink" title="创建 Invoker"></a>创建 Invoker</h3><p>不管是本地暴露，还是远程暴露，进行服务暴露之前，都需要先创建 Invoker ，这一点非常重要。在 Dubbo 中，Invoker 是一个非常重要的模型，无论是在服务提供端，还是服务消费端均会出现 Invoker。Dubbo 官方文档中对 Invoker 进行了说明。</p><blockquote><p>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p></blockquote><p>Invoker 是由 ProxyFactory 创建的，Dubbo 默认的 ProxyFactory 实现类是 JavassistProxyFactory ，在 <a href="https://gentryhuang.com/posts/c2df2fc6/">Javassist动态代理</a> 中进行了详细的说明。</p><h3 id="本地暴露"><a href="#本地暴露" class="headerlink" title="本地暴露"></a>本地暴露</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 本地暴露</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exportLocal</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 1 若果URl的协议头是injvm，说明已经暴露到本地了，无需再次暴露</span></span><br><span class="line"><span class="comment">       * 2 非injvm协议就基于原有的URL构建协议为injvm，主机地址 127.0.0.1，端口为0 的新的 URL</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">          URL local = URL.valueOf(url.toFullString())</span><br><span class="line">                  .setProtocol(Constants.LOCAL_PROTOCOL)</span><br><span class="line">                  .setHost(LOCALHOST)</span><br><span class="line">                  .setPort(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 添加服务接口的实现类【仅用于RestProtocol协议】到线程变量中</span></span><br><span class="line">          ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 创建 Invoker，这里 proxyFactory 会在运行时执行 JavassistProxyFactory 的 getInvoker 方法 （默认情况，也可通过参数指定）</span></span><br><span class="line">          Invoker invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, local);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 这里的 protocol 会在运行时调用 InjvmProtocol 的 export 方法</span></span><br><span class="line">          Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 添加到Exporter集合中</span></span><br><span class="line">          exporters.add(exporter);</span><br><span class="line"></span><br><span class="line">          logger.info(<span class="string">"Export dubbo service "</span> + interfaceClass.getName() + <span class="string">" to local registry"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>本地暴露的代码比较简单，下面总结下流程：</p><ol><li>根据 URL 协议头决定是否暴露服务，如果需要暴露就创建 injvm 协议的 URL</li><li>然后通过 SPI 机制分别获取运行时的 proxyFactory 和 protocol 扩展实现，这就是 Dubbo SPI 自适应的好处</li><li>使用proxyFactory创建 Invoker(AbstractProxyInvoker) </li><li>使用protocol进行服务暴露</li></ol><p>以上流程的前 3 步已经分析过，下面对第 4 步进行分析。</p><h4 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h4><p>本地暴露涉及的 Protocol 类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-local-protocol.jpg" alt></p><p>由上图的 UML 类图可知，Protocol 有两个 Wrapper 类，由 Dubbo SPI 机制我们知道执行 Protocol#export 方法的顺序：</p><blockquote><p>Protocol$Adaptive =&gt; ProtocolListenerWrapper ==&gt; ProtocolFilterWrapper =&gt; InjvmProtocol</p></blockquote><p>下面对执行链进行分析，其中 Protocol 自适应扩展对象原理在 <a href="https://gentryhuang.com/posts/3e0b5964/">自适应扩展</a> 中已经详细分析。这里说明下，上图的 UML 类图中其它的先不做分析，只关注本地暴露相关的， Dubbo 中的多协议部分会单独作为一个模块分析。</p><h4 id="ProtocolListenerWrapper"><a href="#ProtocolListenerWrapper" class="headerlink" title="ProtocolListenerWrapper"></a>ProtocolListenerWrapper</h4><p>实现 Protocol 接口，是 Protocol 的 Wrapper 类，在服务暴露时用于给 Exporter 添加监听器，监听 Exporter 暴露和取消。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolListenerWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolListenerWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker Service invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// registry协议开头的服务暴露逻辑，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 服务暴露，创建 Exporter</span></span><br><span class="line">        Exporter&lt;T&gt; export = protocol.export(invoker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 ExporterListener</span></span><br><span class="line">        List&lt;ExporterListener&gt; exporterListeners = Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">getActivateExtension</span>(<span class="title">invoker</span>.<span class="title">getUrl</span>(), <span class="title">Constants</span>.<span class="title">EXPORTER_LISTENER_KEY</span>))</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 ListenerExporterWrapper 包装 Exporter，为 Exporter邦定监听器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListenerExporterWrapper&lt;T&gt;(export, exporterListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProtocolListenerWrapper 在服务暴露流程中的逻辑如下：</p><ol><li>判断当前Invoker对应的URL协议是否为 registry，远程暴露时需要用到注册中心，执行到这里时协议会为 registry，这种情况就无需绑定监听器。</li><li>使用具体协议暴露服务，创建 Exporter</li><li>获取ExporterListener，用户可以自行实现监听器。注意，实现的监听器是自动激活类型</li><li>将获取的监听器绑定到服务暴露生成的Exporter</li></ol><h4 id="Exporter"><a href="#Exporter" class="headerlink" title="Exporter"></a>Exporter</h4><p>Exporter 是 Invoker 服务在 Protocol 上的对象。更多可以参考 <a href="https://gentryhuang.com/posts/e2577ca1/">Dubbo项目结构总览</a> 。本地暴露涉及到的 UML 类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-local-exporter.jpg" alt></p><h5 id="InjvmExporter"><a href="#InjvmExporter" class="headerlink" title="InjvmExporter"></a>InjvmExporter</h5><p>实现 AbstractExporter 抽象类，Injvm Exporter 实现类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InjvmExporter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractExporter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exporter 集合</span></span><br><span class="line"><span class="comment">     * key : 服务键</span></span><br><span class="line"><span class="comment">     * 该值实际就是 &#123;<span class="doctag">@link</span> com.alibaba.dubbo.rpc.protocol.AbstractProtocol#exporterMap&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，发起暴露</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 服务键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporterMap AbstractExporter的缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    InjvmExporter(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) &#123;</span><br><span class="line">        <span class="keyword">super</span>(invoker);</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.exporterMap = exporterMap;</span><br><span class="line">        <span class="comment">// 加入到Exporter集合[会把自己加入到AbstractProtocol中的Map中]</span></span><br><span class="line">        exporterMap.put(key, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.unexport();</span><br><span class="line">        <span class="comment">// 移除 key对应的Exporter</span></span><br><span class="line">        exporterMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InjvmExporter 会将自身的对象放入到其父类 AbstractExporter 和自身的缓存中，这也是本地暴露的本质。</p><h5 id="ListenerExporterWrapper"><a href="#ListenerExporterWrapper" class="headerlink" title="ListenerExporterWrapper"></a>ListenerExporterWrapper</h5><p>实现 Exporter 接口，具有监听器功能的 Exporter 的 Wrapper 类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ListenerExporter</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 实现 Exporter接口，具有监听器功能的Exporter包装器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerExporterWrapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Exporter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ListenerExporterWrapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真实的Exporter 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exporter&lt;T&gt; exporter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Exporter 监听器数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExporterListener&gt; listeners;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListenerExporterWrapper</span><span class="params">(Exporter&lt;T&gt; exporter, List&lt;ExporterListener&gt; listeners)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exporter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"exporter == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.exporter = exporter;</span><br><span class="line">        <span class="keyword">this</span>.listeners = listeners;</span><br><span class="line">        <span class="comment">// 执行监听器</span></span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) &#123;</span><br><span class="line">            RuntimeException exception = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (ExporterListener listener : listeners) &#123;</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 事件触发【服务导出后】回调，可以进行自定义实现ExporterListener，重新该方法</span></span><br><span class="line">                        listener.exported(<span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException t) &#123;</span><br><span class="line">                        logger.error(t.getMessage(), t);</span><br><span class="line">                        exception = t;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exporter.getInvoker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消服务暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unexport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exporter.unexport();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 执行监听器</span></span><br><span class="line">            <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; !listeners.isEmpty()) &#123;</span><br><span class="line">                RuntimeException exception = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (ExporterListener listener : listeners) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            listener.unexported(<span class="keyword">this</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RuntimeException t) &#123;</span><br><span class="line">                            logger.error(t.getMessage(), t);</span><br><span class="line">                            exception = t;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> exception;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ListenerExporterWrapper是一个 Wrapper 类，是用来给 Exporter 绑定 ExporterListener 监听器的。</p><h5 id="ExporterListener"><a href="#ExporterListener" class="headerlink" title="ExporterListener"></a>ExporterListener</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExporterListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The exporter exported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当服务暴露完成</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Protocol#export(Invoker)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exported</span><span class="params">(Exporter&lt;?&gt; exporter)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The exporter unexported.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当服务取消完成</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exporter</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Exporter#unexport()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unexported</span><span class="params">(Exporter&lt;?&gt; exporter)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exporter 的监听器，是一个扩展点。用户可以自定义实现，用来监听服务暴露。</p><h4 id="ProtocolFilterWrapper"><a href="#ProtocolFilterWrapper" class="headerlink" title="ProtocolFilterWrapper"></a>ProtocolFilterWrapper</h4><p>实现 Protocol 接口，是 Protocol 的 Wrapper 类，用于给 Invoker 增加过滤链。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolFilterWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProtocolFilterWrapper</span><span class="params">(Protocol protocol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protocol == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.protocol = protocol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建带Filter链的Invoker 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker Invoker对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     URL中参数名 【如：用于获得ServiceConfig或ReferenceConfig配置的自定义过滤器】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> group   分组 【暴露服务时：group=provider; 引用服务时：group=consumer】</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 在执行的时候执行Filter </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Invoker&lt;T&gt; last = invoker;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类上带有@Active注解的过滤器集合</span></span><br><span class="line">        List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter<span class="class">.<span class="keyword">class</span>).<span class="title">getActivateExtension</span>(<span class="title">invoker</span>.<span class="title">getUrl</span>(), <span class="title">key</span>, <span class="title">group</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒序循环 Filter，递归包装Invoker，就是一个链表结构： Xx1Filter-&gt;Xx2Filter-&gt;Xx3Filter-&gt;...-&gt;Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (!filters.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Filter filter = filters.get(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br><span class="line">                <span class="comment">// 创建新的Invoker 对象， 用于包装 next</span></span><br><span class="line">                last = <span class="keyword">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.getInterface();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.getUrl();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.isAvailable();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 调用Invoker的invoke方法的时候会执行</span></span><br><span class="line"><span class="comment">                     *  1 调用Filter#invoke(invoker,invocation)方法，不断执行过滤器逻辑</span></span><br><span class="line"><span class="comment">                     *  2 在Filter中会调用Invoker#invoker(invocation)方法，最后会执行到Invoker【如：InjvmInvoker,DubboInvoker等】的invoke方法</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> filter.invoke(next, invocation);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        invoker.destroy();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> invoker.toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.getDefaultPort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 Invoker的URL中 protocol=registry,说明是注册中心的协议，这种情况无需创建Filter过滤器。</span></span><br><span class="line">        <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立带有Filter 过滤链的 Invoker，再暴露服务</span></span><br><span class="line">        <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProtocolFilterWrapper 在服务暴露时就做了一件事，为 Invoker 增加过滤链。其中key和group参数是用来获取自定义过滤器的，具体规则参见 <a href="https://gentryhuang.com/posts/5d81f464/#getActivateExtension-%E6%96%B9%E6%B3%95">Dubbo SPI</a> 。过滤器链如下，包含 Dubbo 自带过滤器和用户自定义过滤器。</p><blockquote><p>EchoFilter - 回声探测过滤器<br>ClassLoaderFilter - 类加载器切换过滤器<br>GenericFilter - 服务提供者的泛化调用过滤器<br>ContextFilter - 服务提供者的上下文过滤器<br>TraceFilter - 追踪过滤器<br>TimeoutFilter - 服务提供者的超时过滤器<br>MonitorFilter - 监控过滤器<br>ExceptionFilter - 加工异常过滤器<br>XxxFilter - 自定义过滤器</p></blockquote><p>构建 Invoker 的过器滤链过程如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-export-invoker-filter-chain.jpg" alt></p><p>需要注意的是，返回的 Invoker 是一个匿名内部类对象，该对象的 invoke 方法没有其它逻辑，仅用来执行 <code>Filter.invoke</code> 方法。当向该 Invoker 发起调用时，会先执行过滤器链，只有当过滤器链执行完毕后，才会执行真正的 Invoker 的逻辑。</p><h4 id="InjvmProtocol"><a href="#InjvmProtocol" class="headerlink" title="InjvmProtocol"></a>InjvmProtocol</h4><p>实现 AbstractProtocol 抽象类，Injvm 协议实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * InjvmProtocol</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjvmProtocol</span> <span class="keyword">extends</span> <span class="title">AbstractProtocol</span> <span class="keyword">implements</span> <span class="title">Protocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = Constants.LOCAL_PROTOCOL;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PORT = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例：在Dubbo SPI中，被初始化有且仅有一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InjvmProtocol INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InjvmProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        INSTANCE = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得单例子</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InjvmProtocol <span class="title">getInjvmProtocol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">InjvmProtocol</span>.<span class="title">NAME</span>)</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDefaultPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT_PORT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行服务暴露，创建InjvmExporter[并把自己-&gt;Exporter存入到父类的 &#123;<span class="doctag">@link</span> #exporterMap&#125; 属性中，key:当前服务键，value:Exporter]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker Service invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Exporter，并且把自己添加到 exporterMap 中，exporterMap 是父类属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>injvm 协议暴露服务比较简单，直接创建 InjvmExporter 对象，然后放入内存中即可，没有其它逻辑。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章详细分析了 Dubbo 本地服务导出过程，包括配置检测，URL 组装，Invoker 创建过程等，下一篇文章将分析远程暴露。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有了前面一系列文章铺垫，再来看服务暴露与服务引用就简单很多了。本地暴露需要配置、SPI、动态代理、协议等知识，其中协议部分会在后面的文章中着
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 优雅停机</title>
    <link href="https://gentryhuang.com/posts/ef4cfe7a/"/>
    <id>https://gentryhuang.com/posts/ef4cfe7a/</id>
    <published>2020-05-25T16:00:00.000Z</published>
    <updated>2020-10-13T11:42:54.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>优雅停机仅存在于服务重启、下线这样的部署阶段，优雅停机是一个应用生命周期的一部分，它保障了应用的健壮性。dubbo是通过jdk的ShutdownHook来完成优雅停机的，所以如果用户使用 kill -9 pid 等强制关闭指令，是不会执行优雅停机的，只有通过 kill pid 即正常退出进程，才会执行。</p><h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><ul><li>优雅停机的服务端有正在处理中的请求，不能被停机指令中断，除非超时</li><li>优雅停机的消费端不应该再发起新的请求</li><li>消费端不应该请求已经下线的服务提供者</li></ul><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>应用的重新启动、停机等操作，避免了对业务的连续性造成影响，如：集群中的某个应用存在逻辑上的bug，需要修改程序，这时候就可以使用优雅停机平滑下线，不会造成调用方异常问题。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/shutdownhook.png" alt></p><p><font color="#c7254e"> dubbo中实现优雅停机主要包含以下步骤 </font></p><ol><li>收到kill 9 进程退出信号时，spring容器会触发容器销毁事件  (其实是spring注册的jvm钩子程序执行的，后面会看到)</li><li>provider端会取消注册服务元数据信息</li><li>consumer端会收到最新地址列表（准备停机地址不在该地址列表中）</li><li>dubbo协议会发送readonly事件报文通知consumer服务不可用</li><li>服务端等待已经执行的任务结束并不再处理新的请求</li></ol><p><strong>说明</strong></p><ul><li>上图中的流程是使用spring构建的dubbo应用</li><li>上图中的流程没有体现出优雅停机的消费端角色，该角色做的工作相对简单，主要是不再发起新的调用请求和等待响应返回，超时才会强制关闭</li><li>注册中心已经通知了最新服务列表，发送readonly事件主要考虑到注册中心推送服务有网络延迟以及客户端计算服务列表也需要时间。消费端收到后会设置对应的provider为不可用状态，下次负载均衡就不会调用这个下线的服务</li></ul><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>dubbo对优雅停机的实现在不同的版本中有所差异，下面从2.5.x、2.6.x以及2.7.x这三个版本分别分析。</p><h4 id="2-5-x的优雅停机"><a href="#2-5-x的优雅停机" class="headerlink" title="2.5.x的优雅停机"></a>2.5.x的优雅停机</h4><p>注册shutdown hook</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 省略其它代码    </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">"Run shutdown hook now."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 销毁资源</span></span><br><span class="line"><span class="comment">                     * 1 注册中心数据销毁： 删除注册中心中本节点对应的提供者地址以及订阅数据</span></span><br><span class="line"><span class="comment">                     * 2 协议流程数据销毁： 取消该协议所有已经暴露和引用的服务，释放协议所占用的所有资源，比如连接和端口</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    ProtocolConfig.destroyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">"DubboShutdownHook"</span>));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p> ProtocolConfig.destroyAll()方法是用来释放资源的，由于dubbo支持多注册中心和多协议，因此具体销毁实现细节取决于具体的注册中心和具体的协议，这里不再展开说明。</p><h4 id="2-6-x的优雅停机"><a href="#2-6-x的优雅停机" class="headerlink" title="2.6.x的优雅停机"></a>2.6.x的优雅停机</h4><p> spring也依赖shutdown hook完成优雅停机，其注册jvm钩子的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register a shutdown hook with the JVM runtime, closing this context</span></span><br><span class="line"><span class="comment"> * on JVM shutdown unless it has already been closed at that time.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Delegates to &#123;<span class="doctag">@code</span> doClose()&#125; for the actual closing procedure.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Runtime#addShutdownHook</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #close()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doClose()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.shutdownHook == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No shutdown hook registered yet.</span></span><br><span class="line"><span class="keyword">this</span>.shutdownHook = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (startupShutdownMonitor) &#123;</span><br><span class="line">doClose();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// 注册jvm钩子</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">this</span>.shutdownHook);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring的shutdownhook具体任务如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Actually performs context closing: publishes a ContextClosedEvent and</span></span><br><span class="line"><span class="comment">  * destroys the singletons in the bean factory of this application context.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;Called by both &#123;<span class="doctag">@code</span> close()&#125; and a JVM shutdown hook, if any.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> org.springframework.context.event.ContextClosedEvent</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #destroyBeans()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #close()</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@see</span> #registerShutdownHook()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.active.get() &amp;&amp; <span class="keyword">this</span>.closed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Closing "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LiveBeansView.unregisterApplicationContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Publish shutdown event   // 注意容器关系事件的发布</span></span><br><span class="line">publishEvent(<span class="keyword">new</span> ContextClosedEvent(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception thrown from ApplicationListener handling ContextClosedEvent"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop all Lifecycle beans, to avoid delays during individual destruction.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleProcessor != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.lifecycleProcessor.onClose();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception thrown from LifecycleProcessor on context close"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy all cached singletons in the context's BeanFactory.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close the state of this context itself.</span></span><br><span class="line">closeBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let subclasses do some final clean-up if they wish...</span></span><br><span class="line">onClose();</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.active.set(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dubbo2.6.x支持使用spring构建dubbo应用时，能够安全使用优雅停机。由于dubbo注册了jvm停止的钩子，<font color="#c7254e"> spring可能 </font> 也注册了jvm停机的钩子，这种情况下两个并发执行的线程可能引用已经销毁的资源，导致优雅停机失效。比如，dubbo正在执行的任务需要引用spring中的bean，但此时spring钩子已经关闭spring上下文，导致访问spring资源都会报错。因此对于这种情况，dubbo在2.6.3中新增ShutdownHookListener 类用来解决并发问题，该类实现了ApplicationListener接口，当进程退出时jvm钩子会被触发，此时spring和dubbo注册的jvm钩子都会被回调，spring注册的jvm钩子程序中spring发出容器关闭事件，ShutdownHookListener接收到关闭事件后执行dubbo的jvm钩子程序进行资源的释放，这样就避免使用无效spring bean的问题，从而完成优雅停机。</p><p><font color="#c7254e"> ShutdownHookListener </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHookListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            <span class="comment">// 使用spring框架时也不应该删除dubbo shutdown hook，因为spring可能没有注册ContextClosed 事件</span></span><br><span class="line">            DubboShutdownHook shutdownHook = DubboShutdownHook.getDubboShutdownHook();</span><br><span class="line">            shutdownHook.destroyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#c7254e"> AbstractConfig中依然保留JVM停止钩子 </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 省略无关代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.name"</span>, <span class="string">"dubbo.service.protocol"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.host"</span>, <span class="string">"dubbo.service.server.host"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.port"</span>, <span class="string">"dubbo.service.server.port"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.protocol.threads"</span>, <span class="string">"dubbo.service.max.thread.pool.size"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.consumer.timeout"</span>, <span class="string">"dubbo.service.invoke.timeout"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.consumer.retries"</span>, <span class="string">"dubbo.service.max.retry.providers"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.consumer.check"</span>, <span class="string">"dubbo.service.allow.no.provider"</span>);</span><br><span class="line">        legacyProperties.put(<span class="string">"dubbo.service.url"</span>, <span class="string">"dubbo.service.address"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this is only for compatibility</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Dubbo 的优雅停机 ShutdownHook 在 AstractConfig 的静态代码块中，这保证了ShutdownHook能够给被初始化。</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 1 Dubbo 是 通过 JDK的ShutdownHook来完成优雅停机的</span></span><br><span class="line"><span class="comment">         * 2 ShutdownHook本质上是一个线程，任务体在对应的run方法中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(DubboShutdownHook.getDubboShutdownHook());</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><font color="#c7254e">DubboShutdownHook </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboShutdownHook</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DubboShutdownHook<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShutdownHook,类属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DubboShutdownHook dubboShutdownHook = <span class="keyword">new</span> DubboShutdownHook(<span class="string">"DubboShutdownHook"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DubboShutdownHook <span class="title">getDubboShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dubboShutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Has it already been destroyed or not?</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 是否已经被销毁标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean destroyed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DubboShutdownHook</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShutdownHook的任务体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Run shutdown hook now."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        destroyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Destroy all the resources, including registries and protocols.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 销毁所有的资源，包括 Registry相关 和 Protocol相关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果已经销毁则忽略</span></span><br><span class="line">        <span class="keyword">if</span> (!destroyed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁所有的 Registry,取消应用程序中的服务提供者和消费者的订阅与注册</span></span><br><span class="line">        AbstractRegistryFactory.destroyAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 销毁所有的 Protocol</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 这里的Protocol比较多，大体上可以分两类：</span></span><br><span class="line"><span class="comment">         * 1 和Registry相关的Protocol，RegistryProtocol关注服务的注册</span></span><br><span class="line"><span class="comment">         * 2 具体协议，如 DubboProtocol、httpProtocol等,关注服务的暴露和引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (String protocolName : loader.getLoadedExtensions()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Protocol protocol = loader.getLoadedExtension(protocolName);</span><br><span class="line">                <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    protocol.destroy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#c7254e">DubboShutdownHook与protocol、registry的关系图 </font></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/shutdownhook-process.jpg" alt></p><p><font color="#c7254e"> 图解(以dubbo协议和zookeeper注册中心为例) <font></font></font></p><p><font color="#c7254e"> Registry相关 <font></font></font></p><ul><li>AbstractRegistryFactory#destroyAll方法，遍历所有的Registry并调用Registry#destroy方法。然后清空Registry缓存集合。</li><li>AbstractRegistry 实现了公用的销毁逻辑：取消注册和订阅。服务提供者和消费者都会执行注册和订阅，因此都需要进行取消。</li><li>FailbackRegistry实现销毁公用的重试任务</li><li>ZookeeperRegistry销毁其对应的客户端连接</li></ul><p><font color="#c7254e"> Protocol相关 <font></font></font></p><ul><li>AbstractProtocol#destroy方法，销毁协议对应的服务消费者拥有的Invoker， 销毁协议对应的服务提供者的所有Exporter。</li><li>DubboProtocol销毁所有通信 ExchangeClient 和 ExchangeServer</li></ul><p><strong>小结</strong></p><ul><li>dubbo2.6.3在spring环境中注册两个钩子的情况，ShutdownHookListener解决了并发执行问题</li><li>使用ShutdownHookListener也不能移除调dubbo注册的jvm钩子，因为不能保证应用中一定会注册spring的shutdown hook</li></ul><h4 id="2-7-x优雅停机"><a href="#2-7-x优雅停机" class="headerlink" title="2.7.x优雅停机"></a>2.7.x优雅停机</h4><p>从dubbo的2.6.3版本开始，解决了使用spring构建的dubbo可能发生优雅停机并发执行shutdown hook的问题。但是还是存在一个问题，那就是如果在spring环境下没有注册spring的jvm钩子，虽然没有大问题，但是还是有不完整的。dubbo2.7.x进行显示地注册spring的jvm钩子，并且移除dubbo的jvm钩子，解决了当前问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 省略其它代码...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;ApplicationContext&gt; CONTEXTS = <span class="keyword">new</span> ConcurrentHashSet&lt;ApplicationContext&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ApplicationListener SHUTDOWN_HOOK_LISTENER = <span class="keyword">new</span> ShutdownHookListener();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addApplicationContext</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">        CONTEXTS.add(context);</span><br><span class="line">        <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ConfigurableApplicationContext) &#123;</span><br><span class="line">            <span class="comment">// 显示注册spring的jvm钩子</span></span><br><span class="line">            ((ConfigurableApplicationContext) context).registerShutdownHook();</span><br><span class="line">            <span class="comment">// 显示移除dubbo的jvm钩子</span></span><br><span class="line">            DubboShutdownHook.getDubboShutdownHook().unregister();</span><br><span class="line">        &#125;</span><br><span class="line">        BeanFactoryUtils.addApplicationListener(context, SHUTDOWN_HOOK_LISTENER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHookListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">                DubboShutdownHook shutdownHook = DubboShutdownHook.getDubboShutdownHook();</span><br><span class="line">                shutdownHook.doDestroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><p>dubbo2.7.x优雅停机的实现，解决了spring环境下两个钩子并发的问题，并且显示注册spring的jvm钩子。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>优雅停机并不是java中的概念，也不是只有dubbo框架进行了扩展实现，springboot、docker等都有涉及到优雅停机。dubbo中的优雅停机是不断优化的，2.5.x中的存在一定的问题，2.6.x在一般场景下是没有问题的，2.7.x是对之前版本的完善和优化。如果 ShutdownHook 不能生效，可以在需要的时机自行调用DubboShutdownHook.destroyAll()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;优雅停机仅存在于服务重启、下线这样的部署阶段，优雅停机是一个应用生命周期的一部分，它保障了应用的健壮性。dubbo是通过jdk的Shutdo
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/tags/JDK/"/>
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Spring" scheme="https://gentryhuang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 远程通信模块总览</title>
    <link href="https://gentryhuang.com/posts/95ab077/"/>
    <id>https://gentryhuang.com/posts/95ab077/</id>
    <published>2020-05-09T16:00:00.000Z</published>
    <updated>2020-11-20T07:21:29.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面的几篇文章对 Dubbo 的 <strong>Serialize</strong> 层进行了介绍，它属于 Remoting 层的一部分，相比较同属于 Remoting 层的 <strong>Transport</strong> 层 和 <strong>Exchange</strong> 层，<strong>Serialize</strong> 层在单独的一个模块中，<strong>Transport</strong> 层 和 <strong>Exchange</strong> 层在 dubbo-remoting 模块中， 接下来我们对该模块进行总体说明。需要说明的是，整个 Remoting 层实现是 Dubbo 协议的实现，如果选择 RMI 协议，那整个 Remoting 层都不会用上。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>dubbo-remoting 模块提供了多种客户端和服务端通信的功能，该模块内部可以再划分为  Transport 传输层和 Exchange 信息交换层，Transport 层只负责单向消息传输，是对 Mina, Netty 等网络传输组件的抽象，它也可以扩展 UDP 传输，而 Exchange 层是在传输层之上封装了 Request-Response 语义。</p><p><img src="/posts/95ab077/dubbo-remoting-remote.png" alt></p><p>dubbo-remoting 模块结构如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-source-remoting.jpg" alt></p><p>Dubbo 框架并没有自己实现一套完整的网络库，而是使用第三方开源网络库。dubbo-remoting-api 子模块中定义了远程通信的抽象概念，具体通信功能需要 dubbo-remoting-* 模块来实现，它们依赖第三方 NIO 库实现 dubbo-remoting-api 模块。如 dubbo-remoting-netty 模块依赖 Netty 3 实现 Dubbo 的远程通信。需要说明的是，dubbo-remoting-zookeeper 模块是实现注册中心功能的模块。</p><h2 id="远程通信的抽象"><a href="#远程通信的抽象" class="headerlink" title="远程通信的抽象"></a>远程通信的抽象</h2><p>dubbo-remoting-api 模块是对远程通信的抽象，结构如下图所示：</p><p><img src="/posts/95ab077/dubbo-remoting-remote-api.jpg" alt></p><p>下面对各个包进行简单说明：</p><ul><li>buffer 包<br>定义了缓冲区相关的接口、抽象类以及实现。缓存区对于通信框架是一个不可或缺的功能，几乎每个通信框架都有自己的缓存区实现。Dubbo 中的该包是对各个通信框架的缓存区进行了统一的抽象，同时实现了一些基础能力。</li><li>exchange 包<br>建立Request-Response模型，封装请求响应模式，以 Request, Response 为中心。</li><li>telnet 包<br>Dubbo 支持通过 telnet 命令进行服务治理。</li><li>transport 包<br>将网络传输抽象为统一接口，屏蔽了不同网络库的差异，只负责抽象单向消息的传输，以 Message 为中心。即请求消息由 Client 端发出，Server 端接收；响应消息由 Server 端发出，Client端接收。</li><li>其它接口<br>顶层接口放到了 remoting 包下，这些接口是 Dubbo Remoting 的核心接口。</li></ul><p>远程通信抽象相关UML图如下：</p><p><img src="/posts/95ab077/dubbo-remoting-remote-api-uml.jpg" alt></p><h3 id="端点-Endpoint"><a href="#端点-Endpoint" class="headerlink" title="端点 Endpoint"></a>端点 Endpoint</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Endpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关联的 URL 信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 底层 Channel 关联的 ChannelHandler</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ChannelHandler <span class="title">getChannelHandler</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取本地地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> local address.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">getLocalAddress</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sent    true: 会等待消息发出，消息发送失败会抛出异常；  false: 不等待消息发出，将消息放入IO队列，即可返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭底层Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优雅关闭底层Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startClose</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测底层Channel是否已经关闭</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> closed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo 中抽象了端点（Endpoint)的概念，通过 <strong>ip + port</strong> 能够唯一确定一个端点，两个端点之间可以建立 TCP 连接，用于双向传输数据。Dubbo 将 Endpoint 之间的 TCP 连接抽象为通道（Channel），将发起请求的 Endpoint 抽象为客户端（Client），将接收请求的 Endpoint 抽象为服务端（Server）。本质上 Client 和 Server 都是一个端点。</p><h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道 Channel"></a>通道 Channel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> <span class="keyword">extends</span> <span class="title">Endpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取远程地址 (注意，父类中是获取本地地址)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> remote address.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">getRemoteAddress</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经链接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> connected</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------- Channel 中属性相关接口，可以对Channel 中属性进行操作 -----------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * has attribute.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> has or has not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasAttribute</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get attribute.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getAttribute</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set attribute.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   key.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * remove attribute.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Channel 是对两个 Endpoint 连接的抽象，消息发送端会往 Channel 写入消息，而接收端会从 Channel 读取消息。Channel 接口继承了 Endpoint 接口，具备开关 Channel 以及发送数据的能力。此外，Channel 支持附加键值对属性。Dubbo 的 Channel 和 Netty 中的 Channel 一致，是通信的载体，Dubbo 的 Channel 的工作最终是要委托给 Netty 的 Channel 来完成的。</p><h3 id="通道处理器-ChannelHandler"><a href="#通道处理器-ChannelHandler" class="headerlink" title="通道处理器 ChannelHandler"></a>通道处理器 ChannelHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 Channel 的连接建立事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel channel.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理 Channel 的连接断开事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel channel.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理发送的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel channel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sent</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理读取到的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel channel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理捕获到的异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel   channel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exception exception.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChannelHandler 是注册在 Channel 上的消息处理器，和 Netty 的 ChannelHandler 一致，负责 Channel 中的逻辑处理。需要说明的是，ChannelHandler 被 @SPI注解标注，表示是一个 Dubbo 扩展点。</p><h3 id="语义端点"><a href="#语义端点" class="headerlink" title="语义端点"></a>语义端点</h3><p>Dubbo 中抽象了端点 Endpoint 的概念，将发起请求的 Endpoint 抽象为客户端（Client），将接收请求的 Endpoint 抽象为服务端（Server），Client 和 Server 本身都是 Endpoint，只不过在语义上区分了请求和响应的职责，两者都具备发送的能力，所以都继承了 Endpoint 接口。UML 图如下：</p><p><img src="/posts/95ab077/dubbo-remoting-endpoint-uml.jpg" alt></p><h4 id="客户端-Client"><a href="#客户端-Client" class="headerlink" title="客户端 Client"></a>客户端 Client</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">Endpoint</span>, <span class="title">Channel</span>, <span class="title">Resetable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重连</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reconnect</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameters</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(com.alibaba.dubbo.common.Parameters parameters)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务端-Server"><a href="#服务端-Server" class="headerlink" title="服务端 Server"></a>服务端 Server</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">Endpoint</span>, <span class="title">Resetable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  是否绑定本地端口，即是否启动成功，可连接、接收消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bound</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBound</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接上服务器的通道列表 【客户端列表】</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channels</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据地址获取连接上服务器的通道 【客户端】</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remoteAddress</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Channel <span class="title">getChannel</span><span class="params">(InetSocketAddress remoteAddress)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重置，已废弃</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameters</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(com.alibaba.dubbo.common.Parameters parameters)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比 Client 和 Server 可以发现，Client 和 Server 的主要区别是 Client 只能关联一个 Channel，而 Server 可以接收多个 Client 发起的 Channel 连接。</p><h3 id="网络传输-Transporter"><a href="#网络传输-Transporter" class="headerlink" title="网络传输 Transporter"></a>网络传输 Transporter</h3><p>由远程通信抽象相关UML图可知，网络传输 Transporter 是在 Client 和 Server 之上封装的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"netty"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个服务器。根据 'server'，'transporter' 确定 Server 扩展实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> server 返回服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.remoting.Transporters#bind(URL, ChannelHandler...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    <span class="function">Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接一个服务器，即创建一个客户端。根据 'client','transporter' 确定 Client 扩展实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     服务器地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> client 客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.remoting.Transporters#connect(URL, ChannelHandler...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    <span class="function">Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transporter 接口上标注 @SPI 注解，它是一个扩展点，默认扩展名为 <em>netty</em> ，<strong>bind 方法</strong> 和 <strong>connect 方法</strong> 都使用 @Adaptive 主机标注，表示会生成自适应扩展实现。</p><h3 id="网络传输门面-Transporters"><a href="#网络传输门面-Transporters" class="headerlink" title="网络传输门面 Transporters"></a>网络传输门面 Transporters</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transporters</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// check duplicate jar package</span></span><br><span class="line">        Version.checkDuplicate(Transporters<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Version.checkDuplicate(RemotingException<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Transporters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法，创建一个服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title">bind</span><span class="params">(String url, ChannelHandler... handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bind(URL.valueOf(url), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handlers == <span class="keyword">null</span> || handlers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handlers == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建handler</span></span><br><span class="line">        ChannelHandler handler;</span><br><span class="line">        <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">            handler = handlers[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果handlers 元素数量大于1，则创建分发器 ChannelHandlerDispatcher【分发器会循环调用handlers，对应的方法】</span></span><br><span class="line">            handler = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取自适应 Transporter 实例，由具体的Transporter 来创建Server 。默认是NettyTransporter创建NettyServer</span></span><br><span class="line">        <span class="keyword">return</span> getTransporter().bind(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法，连接一个服务器，即创建一个客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Client <span class="title">connect</span><span class="params">(String url, ChannelHandler... handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connect(URL.valueOf(url), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ChannelHandler handler;</span><br><span class="line">        <span class="comment">// 没有传入通道处理器 ChannelHandler，则会创建ChannelHandlerAdapter 作为通道处理器</span></span><br><span class="line">        <span class="keyword">if</span> (handlers == <span class="keyword">null</span> || handlers.length == <span class="number">0</span>) &#123;</span><br><span class="line">            handler = <span class="keyword">new</span> ChannelHandlerAdapter();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">            handler = handlers[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 传入多个 ChanenlHandler，则会创建分发器 ChannelHandlerDispatcher【分发器会循环调用handlers，对应的方法】</span></span><br><span class="line">            handler = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取自适应 Transporter 实例，由具体的Transporter 来创建 Client 。默认是NettyTransporter创建 NettyClient</span></span><br><span class="line">        <span class="keyword">return</span> getTransporter().connect(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取自适应 Transporter 实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transporter <span class="title">getTransporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Transporter<span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transporters 是一个门面类，其中封装了通过 Dubbo SPI 获取 Transporter 对象、ChannelHandler 的处理、服务器 Sever 的创建以及客户端 Client 的创建。属于外观模式。</p><h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p>Codec2相比较Codec的变化是，将OutputStream和InputStream，替换成了ChannelBuffer，更好的以 ChannelBuffer 为核心，与其他框架整合。</p><h4 id="Codec2"><a href="#Codec2" class="headerlink" title="Codec2"></a>Codec2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Codec2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer  Buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CODEC_KEY&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(Channel channel, ChannelBuffer buffer, Object message)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer  Buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CODEC_KEY&#125;)</span><br><span class="line">    <span class="function">Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码过程中，需要解决TCP拆包，粘包的场景。解码结果如下：</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">enum</span> DecodeResult &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 需要更多输入</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEED_MORE_INPUT,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 忽略一些输入</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SKIP_SOME_INPUT</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Codec"><a href="#Codec" class="headerlink" title="Codec"></a>Codec</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Need more input poison.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #decode(Channel, InputStream)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object NEED_MORE_INPUT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Encode message.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel channel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> output  output stream.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message message.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CODEC_KEY&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(Channel channel, OutputStream output, Object message)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Decode message.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel channel.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input   input stream.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message or &lt;code&gt;NEED_MORE_INPUT&lt;/code&gt; poison.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #NEED_MORE_INPUT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CODEC_KEY&#125;)</span><br><span class="line">    <span class="function">Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老的编解码器接口，目前已经被Codec2取代，可以通过CodecAdapter将Codec适配成Codec2。</p><h3 id="可解码接口-Decodeable"><a href="#可解码接口-Decodeable" class="headerlink" title="可解码接口 Decodeable"></a>可解码接口 Decodeable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Decodeable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口在消息解码的过程中扮演重要角色，是对 Dubbo 协议下的请求和响应消息解码的支持。在后面的文章中会详细说明其作用。</p><h3 id="派发器-Dispatcher"><a href="#派发器-Dispatcher" class="headerlink" title="派发器 Dispatcher"></a>派发器 Dispatcher</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ChannelHandlerWrapper (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * &lt;span&gt;说明：&lt;/span&gt;</span></span><br><span class="line"><span class="comment"> * 1 调度器接口，被 <span class="doctag">@SPI</span>(AllDispatcher.NAME)注解标注，是Dubbo 的拓展点，默认扩展名为 'all'</span></span><br><span class="line"><span class="comment"> * 2 如果事件处理的逻辑能迅速完成，并且不会发起新的 IO 请求，比如只是在内存中记个标识，则直接在 IO 线程上处理更快，因为减少了线程池调度。</span></span><br><span class="line"><span class="comment"> *   如果事件处理逻辑较慢，或者需要发起新的 IO 请求，比如需要查询数据库，则必须派发到线程池，否则 IO 线程阻塞，将导致不能接收其它请求。</span></span><br><span class="line"><span class="comment"> * 3 通过不同的派发策略和不同的线程池配置的组合来应对不同的场景。注意，派发策略和线程池的联系</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;span&gt;在dubbo 中，有多种Dispatcher的实现&lt;/span&gt;</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;all: 所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;direct: 所有消息都不派发到线程池，全部在IO线程上直接执行&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;message: 只有请求/响应消息派发到线程池，其他的消息直接在IO线程上执行&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;execution: 只有请求消息派发到线程池，其他的消息直接在IO线程上执行&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;connection: 在IO线程上，将连接/断开事件放入队列，有序逐个执行。其他消息派发到线程池&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * 注意：每个Dispatcher实现类，都对应一个ChannelHandler实现类。默认情况下，使用AllDispatcher调度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span>(AllDispatcher.NAME)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 派发消息到线程池处理还是IO线程直接处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler 通道处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel handler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.DISPATCHER_KEY, <span class="string">"dispather"</span>, <span class="string">"channel.handler"</span>&#125;)</span><br><span class="line">    <span class="function">ChannelHandler <span class="title">dispatch</span><span class="params">(ChannelHandler handler, URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dispatcher 主要支持了 Dubbo 的线程模型，在不同的场景中我们可以选择不同的派发策略实现消息的处理。</p><h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p><img src="/posts/95ab077/dubbo-remoting-exception-uml.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章主要介绍了 dubbo-remoting-api 中核心接口以及类，重点介绍了 <strong>端点 Endpoint</strong>、<strong>通道 Channel</strong>、<strong>通道处理器 ChannelHandler</strong> 、以及<strong>编解码器</strong> 。在语义上将端点 Endpoint 区分为 <strong>Client</strong> 和 <strong>Server</strong>。接着又介绍了 Server 和 Client 之上的 <strong>网络传输层Transporter</strong> 以及其<strong>门面类 Transporters</strong> 。</p><p>总结起来，上层使用方通过 Transporters 门面获取适合的 Transporter 实现，然后创建 Server 和 Client 实现，接着 Client 和 Server 之间建立连接即通道 Channel，并使用 ChannelHandler 处理 Channel相关事件和消息，这个过程还会涉及到编解码的处理，Codec2 正是用来解决编解码问题的。需要注意的是，该过程还缺少了信息交互层 Exchange ，我们会在之后的文章中介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面的几篇文章对 Dubbo 的 &lt;strong&gt;Serialize&lt;/strong&gt; 层进行了介绍，它属于 Remoting 层的一部分，
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - FST序列化</title>
    <link href="https://gentryhuang.com/posts/cfaae53/"/>
    <id>https://gentryhuang.com/posts/cfaae53/</id>
    <published>2020-05-04T16:00:00.000Z</published>
    <updated>2020-11-07T16:20:28.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 <a href="https://gentryhuang.com/posts/16132b67/">序列化总览</a> 中介绍了 Dubbo 序列化抽象API相关接口，本篇文章将介绍 Dubbo 的 FST 序列化实现。</p><p>相关的代码结构如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-serialize-fst.jpg" alt></p><h2 id="FST-工厂"><a href="#FST-工厂" class="headerlink" title="FST 工厂"></a>FST 工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FstFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FstFactory factory = <span class="keyword">new</span> FstFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FST 配置对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态方法，获取FST默认工厂</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FstFactory <span class="title">getDefaultFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FstFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将要序列化优化的类 注册到 FSTConfiguration 配置对象中</span></span><br><span class="line">        <span class="keyword">for</span> (Class clazz : SerializableClassRegistry.getRegisteredClasses()) &#123;</span><br><span class="line">            conf.registerClass(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得 FSTObjectOutput 对象，被 FstObjectOutput 调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FSTObjectOutput <span class="title">getObjectOutput</span><span class="params">(OutputStream outputStream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> conf.getObjectOutput(outputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得 FSTObjectInput 对象，被 FstObjectInput 调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FSTObjectInput <span class="title">getObjectInput</span><span class="params">(InputStream inputStream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> conf.getObjectInput(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，FST 工厂的构造方法中会将 SerializableClassRegistry 注册表中的待序列化优化类，注册到 FSTConfiguration 中。</p><h2 id="FstSerialization"><a href="#FstSerialization" class="headerlink" title="FstSerialization"></a>FstSerialization</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FstSerialization</span> <span class="keyword">implements</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getContentTypeId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内容类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x-application/fst"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectOutput <span class="title">serialize</span><span class="params">(URL url, OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FstObjectOutput(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectInput <span class="title">deserialize</span><span class="params">(URL url, InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FstObjectInput(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 Serialization 接口，FST 序列化实现类，将序列化任务交给 FstObjectOutput 对象完成，将反序列化任务交给 FstObjectInput 对象完成。</p><h2 id="FstObjectOutput"><a href="#FstObjectOutput" class="headerlink" title="FstObjectOutput"></a>FstObjectOutput</h2><p>FstObjectOutput 实现序列化抽象API模块的 ObjectOutput 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FstObjectOutput</span> <span class="keyword">implements</span> <span class="title">ObjectOutput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FSTObjectOutput output;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FstObjectOutput</span><span class="params">(OutputStream outputStream)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过工厂创建 FSTObjectOutput 对象</span></span><br><span class="line">        output = FstFactory.getDefaultFactory().getObjectOutput(outputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------------- 序列化方法直接委托给 FSTObjectOutput 对应的方法 ---------- /</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeBoolean(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeByte(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeShort</span><span class="params">(<span class="keyword">short</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeShort(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeInt(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLong</span><span class="params">(<span class="keyword">long</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeLong(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFloat</span><span class="params">(<span class="keyword">float</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeFloat(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeDouble(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            output.writeInt(-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writeBytes(v, <span class="number">0</span>, v.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] v, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            output.writeInt(-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            output.writeInt(len);</span><br><span class="line">            output.write(v, off, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeUTF(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.writeObject(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        output.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FstObjectOutput 中的序列化方法直接委托给 FSTObjectOutput 中对应的方法。</p><h2 id="FstObjectInput"><a href="#FstObjectInput" class="headerlink" title="FstObjectInput"></a>FstObjectInput</h2><p>FstObjectInput 实现序列化抽象API模块的 ObjectInput 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FstObjectInput</span> <span class="keyword">implements</span> <span class="title">ObjectInput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FSTObjectInput input;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FstObjectInput</span><span class="params">(InputStream inputStream)</span> </span>&#123;</span><br><span class="line">        input = FstFactory.getDefaultFactory().getObjectInput(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----------  所有的实现方法委托给 FSTObjectInput 对应的方法 ---------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readBoolean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readByte();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readShort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readFloat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readDouble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readUTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) input.readObject(clazz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; clazz, Type type)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) input.readObject(clazz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readBytes() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">int</span> len = input.readInt();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            input.readFully(b);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个实现方法，直接委托给 FSTObjectInput 对应的方法。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Dubbo 的 FST 序列化方式特殊点在于可以指定要序列化优化的类，然注册到 FSTConfiguration 配置对象中，用以发挥出 FST 的高性能。其中 Kryo 序列化方式和 FST 类似。其它没有分析到的序列化方式套路都是一样的。Dubbo 的序列化到此结束。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/16132b67/&quot;&gt;序列化总览&lt;/a&gt; 中介绍了 Dub
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - Hessian序列化</title>
    <link href="https://gentryhuang.com/posts/4fd38523/"/>
    <id>https://gentryhuang.com/posts/4fd38523/</id>
    <published>2020-05-03T16:00:00.000Z</published>
    <updated>2020-11-07T16:00:54.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 <a href="https://gentryhuang.com/posts/16132b67/">序列化总览</a> 中介绍了 Dubbo 序列化抽象API相关接口，本篇文章将介绍 Dubbo 的 Hessian 序列化实现，它是 Dubbo 的默认序列化实现。</p><p>相关的代码结构如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-serialize-hessian.jpg" alt></p><p>Hessian 有自己的序列化实现，Dubbo 对 Hessian2 进行了改进，形成了一套自己的序列化方式。</p><h2 id="Hessian2Serialization"><a href="#Hessian2Serialization" class="headerlink" title="Hessian2Serialization"></a>Hessian2Serialization</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hessian2Serialization</span> <span class="keyword">implements</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> ID = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getContentTypeId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x-application/hessian2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectOutput <span class="title">serialize</span><span class="params">(URL url, OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hessian2ObjectOutput(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectInput <span class="title">deserialize</span><span class="params">(URL url, InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hessian2ObjectInput(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hessian2Serialization 实现并没有什么不同，同样是使用 <code>serialize</code> 方法创建 ObjectOutput 对象，该对象类型为 Hessian2ObjectOutput，负责序列化工作。使用 <code>deserialize</code> 方法创建 ObjectInput 对象，该对象类型为 Hessian2ObjectInput，负责反序列化工作。</p><h2 id="Hessian2ObjectOutput"><a href="#Hessian2ObjectOutput" class="headerlink" title="Hessian2ObjectOutput"></a>Hessian2ObjectOutput</h2><p>Hessian2ObjectOutput 实现了抽象API模块中的 ObjectOutput 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hessian2ObjectOutput</span> <span class="keyword">implements</span> <span class="title">ObjectOutput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Hessian2Output mH2o;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hessian2ObjectOutput</span><span class="params">(OutputStream os)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Hessian2Output 对象</span></span><br><span class="line">        mH2o = <span class="keyword">new</span> Hessian2Output(os);</span><br><span class="line">        <span class="comment">// 设置对应的工厂</span></span><br><span class="line">        mH2o.setSerializerFactory(Hessian2SerializerFactory.SERIALIZER_FACTORY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------- 最终序列化任务都委托给 Hessian2Output 对象来完成 ------------/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeBoolean(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeInt(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeShort</span><span class="params">(<span class="keyword">short</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeInt(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeInt(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLong</span><span class="params">(<span class="keyword">long</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeLong(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFloat</span><span class="params">(<span class="keyword">float</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeDouble(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeDouble(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeBytes(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeBytes(b, off, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeString(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mH2o.flushBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hessian2ObjectOutput 中封装一个 Hessian2Output 对象，由上面代码可知，Hessian2Output 对 java.io.OutputStream 进行了封装，并且序列化各类数据的方法都会委托给 Hessian2Output 对象的相应方法完成。需要注意的是，对于基本类型数据的序列化，Hessian2Output 使用字节数组来处理的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hessian2Output</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractHessianOutput</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Hessian2Constants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SIZE = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">// 字节数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] _buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[SIZE];</span><br><span class="line">    <span class="comment">// the output stream/</span></span><br><span class="line">    <span class="keyword">protected</span> OutputStream _os;</span><br><span class="line">    <span class="comment">// map of references</span></span><br><span class="line">    <span class="keyword">private</span> IdentityIntMap _refs = <span class="keyword">new</span> IdentityIntMap();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> _isCloseStreamOnClose;</span><br><span class="line">    <span class="comment">// map of classes</span></span><br><span class="line">    <span class="keyword">private</span> HashMap _classRefs;</span><br><span class="line">    <span class="comment">// map of types</span></span><br><span class="line">    <span class="keyword">private</span> HashMap _typeRefs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> _offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> _isStreaming;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new Hessian output stream, initialized with an</span></span><br><span class="line"><span class="comment">     * underlying output stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> os the underlying output stream.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hessian2Output</span><span class="params">(OutputStream os)</span> </span>&#123;</span><br><span class="line">        _os = os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ... 省略其它代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hessian2ObjectInput"><a href="#Hessian2ObjectInput" class="headerlink" title="Hessian2ObjectInput"></a>Hessian2ObjectInput</h2><p>Hessian2ObjectInput 实现了抽象API模块中的 ObjectInput 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hessian2ObjectInput</span> <span class="keyword">implements</span> <span class="title">ObjectInput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Hessian2Input mH2i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hessian2ObjectInput</span><span class="params">(InputStream is)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 Hessian2Input 对象</span></span><br><span class="line">        mH2i = <span class="keyword">new</span> Hessian2Input(is);</span><br><span class="line">        <span class="comment">// 设置序列化工厂</span></span><br><span class="line">        mH2i.setSerializerFactory(Hessian2SerializerFactory.SERIALIZER_FACTORY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mH2i.readBoolean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>) mH2i.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">short</span>) mH2i.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mH2i.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mH2i.readLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>) mH2i.readDouble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mH2i.readDouble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readBytes() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> mH2i.readBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mH2i.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mH2i.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">            ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) mH2i.readObject(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls, Type type)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readObject(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hessian2ObjectInput 中封装一个 Hessian2Input 对象，由上面代码可知，Hessian2Input 对 java.io.InputStream 进行了封装，并且将所有反序列化的实现都委托给 Hessian2Input 对象。同样的，Hessian2Input 对基本数据类型的数据进行反序列化是读取字节数组内容。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Dubbo 的 Hessian 序列化也是同样的套路，Hessian2Serialization 要进行序列化操作就把任务交给创建的 Hessian2ObjectOutput 对象去完成，要进行反序列化操作就把任务交给 Hessian2ObjectInput 对象去完成。只不过，Hessian2ObjectOutput 和 Hessian2ObjectInput 又会把任务委托给 Hessian类的Hessian2Output对象和Hessian2Input对象去完成。下一篇文章中分析 Dubbo 的 FST 序列化实现，它代表了一种类型，支持将那些需要被序列化的类注册到dubbo系统中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/16132b67/&quot;&gt;序列化总览&lt;/a&gt; 中介绍了 Dub
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - JDK序列化</title>
    <link href="https://gentryhuang.com/posts/5898e8ff/"/>
    <id>https://gentryhuang.com/posts/5898e8ff/</id>
    <published>2020-05-02T16:00:00.000Z</published>
    <updated>2020-11-07T10:49:32.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 <a href="https://gentryhuang.com/posts/16132b67/">序列化总览</a> 中介绍了 Dubbo 序列化抽象API相关接口，本篇文章将介绍JDK的序列化实现。</p><p>相关的代码结构如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-serialize-jdk.jpg" alt></p><p>JDK 序列化是基于Java原生的序列化实现，从不同的方面考虑，具体有三种实现方式：</p><blockquote><p>java=com.alibaba.dubbo.common.serialize.java.JavaSerialization<br>compactedjava=com.alibaba.dubbo.common.serialize.java.CompactedJavaSerialization<br>nativejava=com.alibaba.dubbo.common.serialize.nativejava.NativeJavaSerialization</p></blockquote><p>NativeJavaSerialization 是原生的 Java 序列化的实现方式。CompactedJavaSerialization 是在原生的 Java 序列化的基础上做了压缩，实现了自定义的类描述符的写入和读取，在序列化时只需写入类名而不是完整的类信息，可以有效压缩体积。JavaSerialization 是对原生 Java 序列化和压缩的组合实现，并且支持对空字符串及空对象的处理。三者的UML图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-serialize-jdk-outline.jpg" alt></p><h3 id="Java-原生序列化"><a href="#Java-原生序列化" class="headerlink" title="Java 原生序列化"></a>Java 原生序列化</h3><h3 id="NativeJavaSerialization"><a href="#NativeJavaSerialization" class="headerlink" title="NativeJavaSerialization"></a>NativeJavaSerialization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeJavaSerialization</span> <span class="keyword">implements</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"nativejava"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getContentTypeId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x-application/nativejava"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectOutput <span class="title">serialize</span><span class="params">(URL url, OutputStream output)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NativeJavaObjectOutput(output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectInput <span class="title">deserialize</span><span class="params">(URL url, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NativeJavaObjectInput(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于原生的Java序列化实现，即使用 java.io.ObjectOutputSteam 进行序列化，使用 java.io.ObjectInputStream 进行反序列化。在 NativeJavaObjectOutput 和 NativeJavaObjectInput 会分别对传入的流进行包装。</p><h3 id="NativeJavaObjectOutput"><a href="#NativeJavaObjectOutput" class="headerlink" title="NativeJavaObjectOutput"></a>NativeJavaObjectOutput</h3><p>NativeJavaObjectOutput 实现了抽象API模块中的 ObjectOutput 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeJavaObjectOutput</span> <span class="keyword">implements</span> <span class="title">ObjectOutput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * java原生的 输出流对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectOutputStream outputStream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NativeJavaObjectOutput</span><span class="params">(OutputStream os)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> ObjectOutputStream(os));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">NativeJavaObjectOutput</span><span class="params">(ObjectOutputStream out)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(out, <span class="string">"output == null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.outputStream = out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ObjectOutputStream <span class="title">getObjectOutputStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> outputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeBoolean(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeByte(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeShort</span><span class="params">(<span class="keyword">short</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeShort(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeInt(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLong</span><span class="params">(<span class="keyword">long</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeLong(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeFloat</span><span class="params">(<span class="keyword">float</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeFloat(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeDouble(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.writeUTF(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            outputStream.writeInt(-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writeBytes(v, <span class="number">0</span>, v.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] v, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            outputStream.writeInt(-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outputStream.writeInt(len);</span><br><span class="line">            outputStream.write(v, off, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 原生的序列化，无论是基本数据类型还是引用数据类型，进行序列化时都直接使用 java.io.ObjectOutputStream API来完成。</p><h3 id="NativeJavaObjectInput"><a href="#NativeJavaObjectInput" class="headerlink" title="NativeJavaObjectInput"></a>NativeJavaObjectInput</h3><p>NativeJavaObjectInput 实现了抽象API模块中的 ObjectInput接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NativeJavaObjectInput</span> <span class="keyword">implements</span> <span class="title">ObjectInput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java原生的 ObjectInputStream 输入流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectInputStream inputStream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NativeJavaObjectInput</span><span class="params">(InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> ObjectInputStream(is));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">NativeJavaObjectInput</span><span class="params">(ObjectInputStream is)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(is, <span class="string">"input == null"</span>);</span><br><span class="line">        inputStream = is;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ObjectInputStream <span class="title">getObjectInputStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls, Type type)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readBoolean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readByte();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readShort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readLong();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readFloat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readDouble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStream.readUTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readBytes() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">int</span> len = inputStream.readInt();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">            inputStream.readFully(result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 原生的反序列化，无论是基本数据类型还是引用数据类型，进行反序列化时都直接使用 java.io.ObjectInputStream API来完成。</p><h2 id="压缩能力的序列化"><a href="#压缩能力的序列化" class="headerlink" title="压缩能力的序列化"></a>压缩能力的序列化</h2><h3 id="CompactedJava"><a href="#CompactedJava" class="headerlink" title="CompactedJava"></a>CompactedJava</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompactedJavaSerialization</span> <span class="keyword">implements</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getContentTypeId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x-application/compactedjava"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在创建 JavaObjectOutput 时，根据 compact = true 时，使用 CompactedObjectOutputStream 输出流</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectOutput <span class="title">serialize</span><span class="params">(URL url, OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JavaObjectOutput(out, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectInput <span class="title">deserialize</span><span class="params">(URL url, InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JavaObjectInput(is, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原生的 Java 序列化的基础上做了压缩，实现了自定义的类描述符的写入和读取，在序列化时只需写入类名而不是完整的类信息，可以有效压缩体积。功能由 CompactedObjectOutputStream 和 CompactedObjectInputStream 实现。</p><h3 id="CompactedObjectOutputStream"><a href="#CompactedObjectOutputStream" class="headerlink" title="CompactedObjectOutputStream"></a>CompactedObjectOutputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompactedObjectOutputStream</span> <span class="keyword">extends</span> <span class="title">ObjectOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompactedObjectOutputStream</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">writeClassDescriptor</span><span class="params">(ObjectStreamClass desc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = desc.forClass();</span><br><span class="line">        <span class="keyword">if</span> (clazz.isPrimitive() || clazz.isArray()) &#123;</span><br><span class="line">            write(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">super</span>.writeClassDescriptor(desc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            write(<span class="number">1</span>);</span><br><span class="line">            writeUTF(desc.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承了 ObjectOutputStream 类，重写了 writeClassDescriptor 方法，实现了对 ClassDescriptor 的写入。</p><h3 id="CompactedObjectInputStream"><a href="#CompactedObjectInputStream" class="headerlink" title="CompactedObjectInputStream"></a>CompactedObjectInputStream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompactedObjectInputStream</span> <span class="keyword">extends</span> <span class="title">ObjectInputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader mClassLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompactedObjectInputStream</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(in, Thread.currentThread().getContextClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompactedObjectInputStream</span><span class="params">(InputStream in, ClassLoader cl)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">        mClassLoader = cl == <span class="keyword">null</span> ? ClassHelper.getClassLoader() : cl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ObjectStreamClass <span class="title">readClassDescriptor</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> type = read();</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.readClassDescriptor();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                Class&lt;?&gt; clazz = loadClass(readUTF());</span><br><span class="line">                <span class="keyword">return</span> ObjectStreamClass.lookup(clazz);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> StreamCorruptedException(<span class="string">"Unexpected class descriptor type: "</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; loadClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> mClassLoader.loadClass(className);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承了 ObjectInputStream 类，重写了 readClassDescriptor 方法，实现了对 ClassDescriptor 读取。</p><h2 id="组合原生和压缩序列化"><a href="#组合原生和压缩序列化" class="headerlink" title="组合原生和压缩序列化"></a>组合原生和压缩序列化</h2><h3 id="JavaSerialization"><a href="#JavaSerialization" class="headerlink" title="JavaSerialization"></a>JavaSerialization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaSerialization</span> <span class="keyword">implements</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getContentTypeId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x-application/java"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectOutput <span class="title">serialize</span><span class="params">(URL url, OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JavaObjectOutput(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectInput <span class="title">deserialize</span><span class="params">(URL url, InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JavaObjectInput(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JavaObjectOutput"><a href="#JavaObjectOutput" class="headerlink" title="JavaObjectOutput"></a>JavaObjectOutput</h3><p>JavaObjectOutput 继承了 Java 原生序列化的 NativeJavaObjectOutput 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaObjectOutput</span> <span class="keyword">extends</span> <span class="title">NativeJavaObjectOutput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaObjectOutput</span><span class="params">(OutputStream os)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> ObjectOutputStream(os));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意 compact 为true的情况  &#123;<span class="doctag">@link</span> CompactedJavaSerialization#serialize(URL, OutputStream)&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> os</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> compact</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaObjectOutput</span><span class="params">(OutputStream os, <span class="keyword">boolean</span> compact)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(compact ? <span class="keyword">new</span> CompactedObjectOutputStream(os) : <span class="keyword">new</span> ObjectOutputStream(os));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对空字符串的处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String v)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">            getObjectOutputStream().writeInt(-<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getObjectOutputStream().writeInt(v.length());</span><br><span class="line">            getObjectOutputStream().writeUTF(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对空对象的处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            getObjectOutputStream().writeByte(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            getObjectOutputStream().writeByte(<span class="number">1</span>);</span><br><span class="line">            getObjectOutputStream().writeObject(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        getObjectOutputStream().flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaObjectOutput 构造方法可以根据 <strong>compact</strong> 参数创建不同的实现序列化功能对象。</p><h3 id="JavaObjectInput"><a href="#JavaObjectInput" class="headerlink" title="JavaObjectInput"></a>JavaObjectInput</h3><p>JavaObjectInput 继承了 Java 原生序列化的 NativeJavaObjectInput 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaObjectInput</span> <span class="keyword">extends</span> <span class="title">NativeJavaObjectInput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_BYTE_ARRAY_LENGTH = <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaObjectInput</span><span class="params">(InputStream is)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> ObjectInputStream(is));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaObjectInput</span><span class="params">(InputStream is, <span class="keyword">boolean</span> compacted)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(compacted ? <span class="keyword">new</span> CompactedObjectInputStream(is) : <span class="keyword">new</span> ObjectInputStream(is));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] readBytes() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">int</span> len = getObjectInputStream().readInt();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (len &gt; MAX_BYTE_ARRAY_LENGTH)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Byte array length too large. "</span> + len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        getObjectInputStream().readFully(b);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = getObjectInputStream().readInt();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getObjectInputStream().readUTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> b = getObjectInputStream().readByte();</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getObjectInputStream().readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">            ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls, Type type)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaObjectOutput 构造方法可以根据 <strong>compact</strong> 参数创建不同的实现反序列化功能对象。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本篇文章加单介绍了 Dubbo 原生的 Java 序列化实现方式，即直接使用 java.io.ObjectOutputSteam 进行序列化，使用 java.io.ObjectInputStream 进行反序列化，并没有进行过多的其它处理，不依赖其它组件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/16132b67/&quot;&gt;序列化总览&lt;/a&gt; 中介绍了 Dub
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/tags/JDK/"/>
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 序列化总览</title>
    <link href="https://gentryhuang.com/posts/16132b67/"/>
    <id>https://gentryhuang.com/posts/16132b67/</id>
    <published>2020-05-02T16:00:00.000Z</published>
    <updated>2020-11-07T15:50:56.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Dubbo 的服务暴露、服务引用以及服务调用除了需要之前介绍的配置、代理、注册中心，还需要协议、网络通信、集群容错、序列化等。因此，从本文开始会由底向上分析 Dubbo 架构中的模块。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RPC框架需要网络通信实现信息的发送和接收，既然是网络通信就一定会使用到序列化和反序列化技术。Dubbo 对序列化的定义是，将对象（基本数据类型和引用类型）转成字节流用于<strong>网络传输</strong>；以及将字节流转为对象（基本数据类型和引用类型），用于在收到字节流数据后进行还原。</p><p>提起序列化就不得不提到<strong>协议</strong>这个概念，两者是不同的东西，它们之间属于组合关系，协议需要用到序列化技术，而序列化技术可以服务于不同的协议。序列化层在 Dubbo 的架构图中的位置如下，它处于最低层，属于 Remoting 层的一部分。在 Dubbo 中还有一个和序列化相关的扩展接口 Codec2，是基于序列化之上封装的组件，主要用于实现对数据的编码和解码，即解决粘包和拆包等问题，序列化和反序列化功能是使用序列化层来完成的。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-serialize.jpg" alt></p><p>Dubbo 为了支持多种序列化算法，单独抽象了 Serialize 层，对应的模块结构如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-source-serialization.jpg" alt></p><h2 id="Dubbo-序列化抽象-API"><a href="#Dubbo-序列化抽象-API" class="headerlink" title="Dubbo 序列化抽象 API"></a>Dubbo 序列化抽象 API</h2><p>dubbo-serialization-api 模块中定义了 Dubbo 序列化层的核心接口以及类，关系如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-serialize-api.jpg" alt></p><h3 id="Serialization-接口"><a href="#Serialization-接口" class="headerlink" title="Serialization 接口"></a>Serialization 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"hessian2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化类型编号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> content type id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">byte</span> <span class="title">getContentTypeId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得序列化对应的类型，每一种序列化算法都对应一个类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> content type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getContentType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create serializer</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 创建ObjectOutput对象，实现序列化功能，序列化输出到 OutputStream</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url    URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> output 输出流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> serializer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    <span class="function">ObjectOutput <span class="title">serialize</span><span class="params">(URL url, OutputStream output)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create deserializer</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 创建 ObjectInput 对象，实现反序列化，从 InputStream 反序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url   URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input 输入流</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> deserializer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    <span class="function">ObjectInput <span class="title">deserialize</span><span class="params">(URL url, InputStream input)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Serialization 接口是一个扩展点，默认扩展实现是 Hessian2Serialization 。它是序列化最核心的接口，<strong>serialize</strong>方法用来创建实现序列化功能的 ObjectOutput 对象，<strong>deserialize</strong>方法用来创建实现反序列化功能的 ObjectInput。不同的 Serialization 扩展实现对应不同的 ObjectOutput 和 ObjectInput 对象，但是本质上都是对 JDK的 OutputStream 和 InputStream 的封装。不同的 Serialization 扩展实现会有所差异，除了效率外还体现在API上，对于引用类型的序列化一般最底层都是使用JDK的OutputStream 和 InputStream的API，上层因不同特性的 Serialization 会有不同，对于基本类型数据的序列化有的 Serialization 会使用自身维护的字节数组来实现，有的直接使用传入的输入/输出流实现。</p><p>Dubbo 提供了多个 Serialization 实现 ，如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-remoting-serialize-hierarchy.jpg" alt></p><h3 id="DataOutput-接口"><a href="#DataOutput-接口" class="headerlink" title="DataOutput 接口"></a>DataOutput 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataOutput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write boolean.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeBool</span><span class="params">(<span class="keyword">boolean</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write byte.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeByte</span><span class="params">(<span class="keyword">byte</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write short.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeShort</span><span class="params">(<span class="keyword">short</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write integer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write long.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeLong</span><span class="params">(<span class="keyword">long</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write float.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeFloat</span><span class="params">(<span class="keyword">float</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write double.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeDouble</span><span class="params">(<span class="keyword">double</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write string.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write byte array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Write byte array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v   value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> off offset.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len length.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] v, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flush buffer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DataOutput 接口中定义了用于序列化 Java 中各种基本数据类型的方法。</p><h3 id="ObjectOutput-接口"><a href="#ObjectOutput-接口" class="headerlink" title="ObjectOutput 接口"></a>ObjectOutput 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectOutput</span> <span class="keyword">extends</span> <span class="title">DataOutput</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * write object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承 DataOutput 接口，在DataOutput 的基础上增加序列化对象的能力。</p><h3 id="InputStream-接口"><a href="#InputStream-接口" class="headerlink" title="InputStream 接口"></a>InputStream 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataInput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read boolean.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">readBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read byte.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read short integer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> short.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read integer.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> integer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read long.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read float.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> float.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read double.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> double.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read UTF-8 string.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Read byte array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> byte array.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">byte</span>[] readBytes() <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputStream 接口中定义了反序列化 Java 中各种化基本类型的数据。</p><h3 id="ObjectInput-接口"><a href="#ObjectInput-接口" class="headerlink" title="ObjectInput 接口"></a>ObjectInput 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectInput</span> <span class="keyword">extends</span> <span class="title">DataInput</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * read object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * read object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cls object type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * read object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cls object type.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">readObject</span><span class="params">(Class&lt;T&gt; cls, Type type)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承 DataInput 接口，在DataInput 的基础上增加了反序列化对象的能力。</p><h3 id="Cleanable"><a href="#Cleanable" class="headerlink" title="Cleanable"></a>Cleanable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cleanable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成序列化或反序列化需要做清理工作，通过实现该接口释放资源，目前 Kryo 实现。</p><h3 id="序列化优化器"><a href="#序列化优化器" class="headerlink" title="序列化优化器"></a>序列化优化器</h3><h4 id="SerializationOptimizer-接口"><a href="#SerializationOptimizer-接口" class="headerlink" title="SerializationOptimizer 接口"></a>SerializationOptimizer 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用文件也是一个选择，这个类可以替换为配置文件中的内容，但是类的方式更容易编写</span></span><br><span class="line"><span class="comment"> * This class can be replaced with the contents in config file, but for now I think the class is easier to write</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SerializationOptimizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回需要使用优化的类的集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Collection&lt;Class&gt; <span class="title">getSerializableClasses</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Kryo、FST 序列化实现中，支持配置需要优化的类。可以实现自定义的SerializationOptimizer实现，配置需要优化的类，让Kryo和FST完全发挥出高性能。序列化优化器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationOptimizerImpl</span> <span class="keyword">implements</span> <span class="title">SerializationOptimizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;Class&gt; <span class="title">getSerializableClasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Class&gt; classes = <span class="keyword">new</span> LinkedList&lt;Class&gt;();</span><br><span class="line">        classes.add(BidRequest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        classes.add(BidResponse<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        classes.add(Device<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        classes.add(Geo<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        classes.add(Impression<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        classes.add(SeatBid<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo 已经自动将 JDK 中常用的类进行了注册，不要重复注册，即使重复注册也没又任何影响。由于注册被序列化的类仅仅是出于性能优化的目的，所以即使忘记注册某些类也没有关系。事实上，即使不注册任何类，Kryo和FST的性能依然普遍优于hessian和dubbo序列化。</p><h4 id="序列化类的注册表"><a href="#序列化类的注册表" class="headerlink" title="序列化类的注册表"></a>序列化类的注册表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableClassRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要序列化优化的类的注册表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Class&gt; registrations = <span class="keyword">new</span> LinkedHashSet&lt;Class&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * only supposed to be called at startup time</span></span><br><span class="line"><span class="comment">     * 在 &#123;<span class="doctag">@link</span> SerializationOptimizer#getSerializableClasses()&#125; 方法获得的类集合，会注册到这里。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerClass</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        registrations.add(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得序列化优化类集合。在 Kryo,FST中调用该方法会获得需要优化的类的集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&gt; <span class="title">getRegisteredClasses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registrations;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要序列化优化的类都会注册到该类中进行缓存。</p><h4 id="序列化优化器的使用"><a href="#序列化优化器的使用" class="headerlink" title="序列化优化器的使用"></a>序列化优化器的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">--- DubboProtocol</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">optimizeSerialization</span><span class="params">(URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 获得 optimizer 序列化优化器 配置项</span></span><br><span class="line">        String className = url.getParameter(Constants.OPTIMIZER_KEY, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果系统中没有序列化优化器就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(className) || optimizers.contains(className)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"Optimizing the serialization process for Kryo, FST, etc..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据 序列化优化器名 加载 SerializationOptimizer 实现类</span></span><br><span class="line">            Class clazz = Thread.currentThread().getContextClassLoader().loadClass(className);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 是否是SerializationOptimizer的子</span></span><br><span class="line">            <span class="keyword">if</span> (!SerializationOptimizer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">clazz</span>)) </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"The serialization optimizer "</span> + className + <span class="string">" isn't an instance of "</span> + SerializationOptimizer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反射创建 SerializationOptimizer 对象</span></span><br><span class="line">            SerializationOptimizer optimizer = (SerializationOptimizer) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有要优化的类直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (optimizer.getSerializableClasses() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将要优化的类注册到 SerializableClassRegistry 注册表中</span></span><br><span class="line">            <span class="keyword">for</span> (Class c : optimizer.getSerializableClasses()) &#123;</span><br><span class="line">                SerializableClassRegistry.registerClass(c);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 序列化优化器实现类名 加入到缓存中</span></span><br><span class="line">            optimizers.add(className);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Cannot find the serialization optimizer class: "</span> + className, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Cannot instantiate the serialization optimizer class: "</span> + className, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Cannot instantiate the serialization optimizer class: "</span> + className, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章主要介绍了序列化层的抽象API，序列化实现具体的职能是由其 serialize 方法创建的<strong>ObjectOutput</strong>和 deserialize 方法创建的<strong>ObjectInput</strong>来完成的，而这两个对象又是对 OutputStream 和 InputStream 的封装。还介绍了序列化优化器，它是用来支持序列化实现对指定的序列化类进行序列化优化处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Dubbo 的服务暴露、服务引用以及服务调用除了需要之前介绍的配置、代理、注册中心，还需要协议、网络通信、集群容错、序列化等。因此，从本文开
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 动态代理本地存根</title>
    <link href="https://gentryhuang.com/posts/1663a5dc/"/>
    <id>https://gentryhuang.com/posts/1663a5dc/</id>
    <published>2020-05-01T16:00:00.000Z</published>
    <updated>2020-10-01T15:06:29.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="http://localhost:4000/posts/1d1e42a8/" target="_blank" rel="noopener">动态代理总览</a> 中已经介绍了抽象层及使用方式，本篇文章介绍动态代理Wrapper StubProxyFactoryWrapper 。</p><h2 id="Wrapper-类"><a href="#Wrapper-类" class="headerlink" title="Wrapper 类"></a>Wrapper 类</h2><p>在 <a href="https://gentryhuang.com/posts/5d81f464/">Dubbo SPI</a> 中已经详细介绍了什么是 Wrapper 类以及 Wrapper 类的作用和用法。StubProxyFactoryWrapper 会在 ProxyFactory 实现执行前先执行。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StubProxyFactoryWrapper</span> <span class="keyword">implements</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(StubProxyFactoryWrapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ProxyFactory$Adaptive 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProxyFactory proxyFactory;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Protocol$Adaptive 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Protocol protocol;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * StubProxyFactoryWrapper 基于 Dubbo SPI Wrapper 机制，根据URL配置，使用具体的实现【JavassistProxyFactory/JdkProxyFactory】</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxyFactory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StubProxyFactoryWrapper</span><span class="params">(ProxyFactory proxyFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxyFactory = proxyFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StubProxyFactoryWrapper 是 ProxyFactory 的 Wrapper 类，同时它又是实现 Dubbo 动态代理本地存根的类，我们继续往下看。</p><h2 id="动态代理本地存根"><a href="#动态代理本地存根" class="headerlink" title="动态代理本地存根"></a>动态代理本地存根</h2><h3 id="获取代理"><a href="#获取代理" class="headerlink" title="获取代理"></a>获取代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StubProxyFactoryWrapper</span> <span class="keyword">implements</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取代理对象【使用JavassistProxyFactory/JdkProxyFactory】</span></span><br><span class="line">        T proxy = proxyFactory.getProxy(invoker);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非泛化 【泛化不支持使用本地存根】</span></span><br><span class="line">        <span class="keyword">if</span> (GenericService<span class="class">.<span class="keyword">class</span> !</span>= invoker.getInterface()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得 `stub` 配置项 ，注意，local 配置项，和 stub 配置项是等价的，目前使用 stub 而不使用 local 。</span></span><br><span class="line">            String stub = invoker.getUrl().getParameter(Constants.STUB_KEY, invoker.getUrl().getParameter(Constants.LOCAL_KEY));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 服务引用有配置本地存根</span></span><br><span class="line">            <span class="keyword">if</span> (ConfigUtils.isNotEmpty(stub)) &#123;</span><br><span class="line">                Class&lt;?&gt; serviceType = invoker.getInterface();</span><br><span class="line">                <span class="comment">// `stub = true` 的时，使用 接口 + `Stub` 作为存根类的类名</span></span><br><span class="line">                <span class="keyword">if</span> (ConfigUtils.isDefault(stub)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (invoker.getUrl().hasParameter(Constants.STUB_KEY)) &#123;</span><br><span class="line">                        stub = serviceType.getName() + <span class="string">"Stub"</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        stub = serviceType.getName() + <span class="string">"Local"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 反射获取本地存根类</span></span><br><span class="line">                    Class&lt;?&gt; stubClass = ReflectUtils.forName(stub);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 本地存根类必须是实现服务接口</span></span><br><span class="line">                    <span class="keyword">if</span> (!serviceType.isAssignableFrom(stubClass)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The stub implementation class "</span> + stubClass.getName() + <span class="string">" not implement interface "</span> + serviceType.getName());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 反射获取 Stub 的有参构造方法，参数类型是服务类型</span></span><br><span class="line">                        Constructor&lt;?&gt; constructor = ReflectUtils.findConstructor(stubClass, serviceType);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 反射创建本地对象，构造参数需要是服务接口类型对象</span></span><br><span class="line">                        proxy = (T) constructor.newInstance(<span class="keyword">new</span> Object[]&#123;proxy&#125;);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//设置了 Stub 参数回调就需要暴露 Stub 服务 </span></span><br><span class="line">                        URL url = invoker.getUrl();</span><br><span class="line">                        <span class="keyword">if</span> (url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT)) &#123;</span><br><span class="line">                            url = url.addParameter(Constants.STUB_EVENT_METHODS_KEY, StringUtils.join(Wrapper.getWrapper(proxy.getClass()).getDeclaredMethodNames(), <span class="string">","</span>));</span><br><span class="line">                            url = url.addParameter(Constants.IS_SERVER_KEY, Boolean.FALSE.toString());</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 暴露 Stub 服务</span></span><br><span class="line">                                export(proxy, (Class) invoker.getInterface(), url);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                LOGGER.error(<span class="string">"export a stub service error."</span>, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such constructor \"public "</span> + stubClass.getSimpleName() + <span class="string">"("</span> + serviceType.getName() + <span class="string">")\" in stub implementation class "</span> + stubClass.getName(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    LOGGER.error(<span class="string">"Failed to create stub implementation class "</span> + stub + <span class="string">" in consumer "</span> + NetUtils.getLocalHost() + <span class="string">" use dubbo version "</span> + Version.getVersion() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">                    <span class="comment">// ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取-Invoker"><a href="#获取-Invoker" class="headerlink" title="获取 Invoker"></a>获取 Invoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StubProxyFactoryWrapper</span> <span class="keyword">implements</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 服务对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 服务接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getInvoker(proxy, type, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，服务提供方不支持 Stub 本地存根，即使 &lt;dubbo:service /&gt; 有 stub 配置项，实际是不起作用的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>StubProxyFactoryWrapper 功能比较简单，基本流程如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-proxy-wrapper.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;http://localhost:4000/posts/1d1e42a8/&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - JDK动态代理</title>
    <link href="https://gentryhuang.com/posts/faa2b4a3/"/>
    <id>https://gentryhuang.com/posts/faa2b4a3/</id>
    <published>2020-04-30T16:00:00.000Z</published>
    <updated>2020-10-01T15:09:02.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="http://localhost:4000/posts/1d1e42a8/" target="_blank" rel="noopener">动态代理总览</a> 中已经介绍了抽象层，本篇文章介绍 JdkProxyFactory 。</p><h2 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">proxy</span>=<span class="string">"jdk"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">proxy</span>=<span class="string">"jdk"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JDK-代理工厂"><a href="#JDK-代理工厂" class="headerlink" title="JDK 代理工厂"></a>JDK 代理工厂</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker    invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces 服务实现的接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                interfaces,</span><br><span class="line">                <span class="keyword">new</span> InvokerInvocationHandler(invoker)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 服务对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type  服务接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url   URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 调用 Class#getMethod(String name, Class&lt;?&gt;... parameterTypes) 方法，反射获得方法。</span></span><br><span class="line">                Method method = proxy.getClass().getMethod(methodName, parameterTypes);</span><br><span class="line">                <span class="comment">// 调用 Method#invoke(proxy, arguments) 方法，执行方法</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(proxy, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取代理对象"><a href="#获取代理对象" class="headerlink" title="获取代理对象"></a>获取代理对象</h3><p>JDK 获取代理的方式很简单，不依赖三方依赖，直接使用 JDK 的动态代理为服务接口创建一个代理对象，其中 InvokerInvocationHandler 同 JavassistProxyFactory 。</p><h3 id="获取-Invoker"><a href="#获取-Invoker" class="headerlink" title="获取 Invoker"></a>获取 Invoker</h3><p>JDK 获取 Invoker 同样是创建 AbstractProxyInvoker 的匿名对象，不过在 doInvoke 方法中是直接通过反射拿到实现类的Method对象，然后执行对应的方法，非常清爽。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Dubbo 使用 JDK 实现动态非常简单，并且不需要依赖三个依赖，直接一个反射就解决了所有问题，就是性能上有所不足。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;http://localhost:4000/posts/1d1e42a8/&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/tags/JDK/"/>
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - Javassist动态代理</title>
    <link href="https://gentryhuang.com/posts/c2df2fc6/"/>
    <id>https://gentryhuang.com/posts/c2df2fc6/</id>
    <published>2020-04-29T16:00:00.000Z</published>
    <updated>2020-10-01T14:05:11.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="http://localhost:4000/posts/1d1e42a8/" target="_blank" rel="noopener">动态代理总览</a> 中已经详细介绍了抽象层，本篇文章介绍 JavassistProxyFactory 。</p><h2 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">proxy</span>=<span class="string">"javassist"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">proxy</span>=<span class="string">"javassist"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>注意，默认情况就是 javassist。</p><h2 id="JavassistProxyFactory"><a href="#JavassistProxyFactory" class="headerlink" title="JavassistProxyFactory"></a>JavassistProxyFactory</h2><p>实现 AbstractProxyFactory 抽象类，基于 Javassist 代理工厂实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistProxyFactory</span> <span class="keyword">extends</span> <span class="title">AbstractProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces 服务实现的接口(包括 EchoService)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy Service对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type  Service接口类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url   Service对应的Dubbo URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取服务类的包装对象，注意 Wrapper类不能正确处理类名包含$的类</span></span><br><span class="line">        <span class="keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="string">'$'</span>) &lt; <span class="number">0</span> ? proxy.getClass() : type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] parameterTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Object[] arguments)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 调用 Wrapper 的 invokeMethod 方法，invokeMethod 最终会调用目标方法</span></span><br><span class="line">                <span class="keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavassistProxyFactory 代理工厂有两个方法，通过方法名很容易看出一个是获取代理对象的，另一个是获取 Invoker 的，前者一般是在引用服务的过程会调用该方法，后者是在暴露服务时会调用。我们下面分别分析这两个方法。</p><h2 id="获取代理"><a href="#获取代理" class="headerlink" title="获取代理"></a>获取代理</h2><blockquote><p>Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker))</p></blockquote><p>上面这段代码信息量还是很大的，总体上做了三件事：</p><ol><li>Proxy.getProxy(interfaces) 用于构建服务接口代理类并放入内存，接着获取 Proxy 的子类并创建对象，</li><li>调用子类对象的 newInstance 方法创建服务接口的代理类的实例，需要 InvokerInvocationHandler </li><li>基于 Invoker 创建 InvocationHandler 对象</li></ol><p>其中 1、2 两步操作的原理在动态代理总览已经介绍过了，下面我们主要分析第 3 步实现的原理。</p><h3 id="实现-InvocationHandler"><a href="#实现-InvocationHandler" class="headerlink" title="实现 InvocationHandler"></a>实现 InvocationHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.rpc.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.rpc.Invoker;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.rpc.RpcInvocation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * InvokerInvocationHandler，实现了JDK的InvocationHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoker对象，用于 #invoke方法调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Invoker&lt;?&gt; invoker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvokerInvocationHandler</span><span class="params">(Invoker&lt;?&gt; handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.invoker = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理对象【Proxy创建的】发出请求，会执行到这里。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory#getProxy(com.alibaba.dubbo.rpc.Invoker, java.lang.Class[])</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        <span class="comment">// 处理wait(),notify()等方法，直接进行反射调用</span></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(invoker, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基础方法，不使用RPC调用</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(methodName) &amp;&amp; parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invoker.equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// RPC 调用</span></span><br><span class="line">        <span class="keyword">return</span> invoker.invoke(<span class="keyword">new</span> RpcInvocation(method, args)).recreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第 2 步中，服务接口代理对象所需要的是 Jdk 的 InvocationHandler，我们再把生成的代理拿过来便于对比分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 官方Demo服务接口</span></span><br><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.common.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.rpc.service.EchoService;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxy0</span> <span class="keyword">implements</span> <span class="title">EchoService</span>, <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method[] methods;</span><br><span class="line">    <span class="keyword">private</span> InvocationHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务接口方法，由代理类来执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String paramString)</span> </span>&#123;</span><br><span class="line">        Object[] arrayOfObject = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        arrayOfObject[<span class="number">0</span>] = paramString;</span><br><span class="line">        <span class="comment">// proxy.method =&gt;  InvocationHandler.invoke</span></span><br><span class="line">        Object localObject = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], arrayOfObject);</span><br><span class="line">        <span class="keyword">return</span> (String) localObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 回声探测方法</span></span><br><span class="line">    <span class="keyword">public</span> Object $echo(Object paramObject) &#123;</span><br><span class="line">        Object[] arrayOfObject = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        arrayOfObject[<span class="number">0</span>] = paramObject;</span><br><span class="line">        Object localObject = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">1</span>], arrayOfObject);</span><br><span class="line">        <span class="keyword">return</span> (Object) localObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参数构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">(InvocationHandler paramInvocationHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = paramInvocationHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码我们很容易总结出调用关系：</p><blockquote><p>client -&gt; proxy.method -&gt; InvocationHandler.invoke -&gt; Invoker.invoke</p></blockquote><p>一般消费者在调用服务的时候，会先获取服务接口代理对象，代理对象（Proxy 生成的）发起服务调用会经过 Jdk 的 InvocationHandler 进行路由，如果属于远程调用，则执行 Invoker#invoke 方法进行远程调用。</p><h2 id="获取-Invoker"><a href="#获取-Invoker" class="headerlink" title="获取 Invoker"></a>获取 Invoker</h2><blockquote><p>Wrapper.getWrapper(proxy.getClass().getName().indexOf(‘$’) &lt; 0 ? proxy.getClass() : type);<br>return new AbstractProxyInvoker<T>(proxy, type, url)</T></p></blockquote><p>获取 Invoker 做了 2 个工作：</p><blockquote><p>1 获取服务类的包装类 Wrapper<br>2 创建 AbstractProxyInvoker 匿名对象</p></blockquote><p>其中第 1 步在上一篇文章中已经详细说明，下面我们分析下 AbstractProxyInvoker 。</p><h3 id="AbstractProxyInvoker"><a href="#AbstractProxyInvoker" class="headerlink" title="AbstractProxyInvoker"></a>AbstractProxyInvoker</h3><p>在介绍 AbstractProxyInvoker 前我们先看 Invoker 接口，它是 Dubbo 中很重要的模型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoker. (API/SPI, Prototype, ThreadSafe)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.Protocol#refer(Class, com.alibaba.dubbo.common.URL)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.InvokerListener</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.rpc.protocol.AbstractInvoker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取服务接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> service interface.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RPC 调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Invoker 接口很简单，它就有两个方法，获取服务接口和进行RPC调用。它的实现类很多，先不展开说明遇到了再分析。这里我们分析 AbstractProxyInvoker 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProxyInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理的对象，一般是服务接口的实现对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T proxy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * URL对象，一般是暴露服务的URL对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractProxyInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (proxy == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"proxy == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!type.isInstance(proxy)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(proxy.getClass().getName() + <span class="string">" not implement interface "</span> + type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.proxy = proxy;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁</span></span><br><span class="line"><span class="comment">     * 说明：在通过JavassistProxyFactory工厂创建Invoker时，就是创建了AbstractProxyInvoker抽象匿名对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主要逻辑在doInvoke模版方法中实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 doInvoke 执行后续的调用，并将调用结果封装到 RpcResult 中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            <span class="comment">// 发生InvocationTargetException 异常，创建RpcResult对象包装</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(e.getTargetException());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to invoke remote proxy method "</span> + invocation.getMethodName() + <span class="string">" to "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由具体子类覆写 【默认情况使用 JavassistProxyFactory 创建的一个匿名类对象】</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy          服务实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName     方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameterTypes 方法参数类型数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arguments      方法参数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 调用结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable 发生异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">doInvoke</span><span class="params">(T proxy, String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInterface() + <span class="string">" -&gt; "</span> + (getUrl() == <span class="keyword">null</span> ? <span class="string">" "</span> : getUrl().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务暴露的时候会创建该类的匿名对象作为 Invoker，该 Invoker 封装了服务对象及服务相关信息（如服务接口、服务URL等），经过层层包装最终成为 Exporter 对象，更详细的流程会在服务暴露章节详细说明。</p><p>结合 getInvoker 方法整体说明 Invoker 创建与调用的过程，忽略容错、路由等细节：</p><ol><li>为服务类构建 Wrapper 的实现类，该实现类拥有服务类的属性、方法等信息，其中 invokeMethod 方法会为服务方法做方法名和方法参数匹配，然后创建实现类的对象</li><li>创建 AbstractProxyInvoker 匿名对象，其中实现的 doInvoke 方法会调用 Wrapper 实现类对象的 invokeMethod 方法</li><li>一个服务对应一个 Wrapper </li><li>消费方在调用Invoker.invoke 时，会先触发 doInvoke 方法， Wrapper的实现的invokeMethod方法做了一次转发，然后才会真正调用Invoker（AbstractProxyInvoker）中的服务对象的方法（Invoker封装了服务对象ref）</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>JavassistProxyFactory 在创建服务代理对象和 Invoker 的过程，都使用了字节码技术，尽可能地规避反射操作。下一篇分析 Jdk 的动态代理实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;http://localhost:4000/posts/1d1e42a8/&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Javassist" scheme="https://gentryhuang.com/tags/Javassist/"/>
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 动态代理总览</title>
    <link href="https://gentryhuang.com/posts/1d1e42a8/"/>
    <id>https://gentryhuang.com/posts/1d1e42a8/</id>
    <published>2020-04-27T16:00:00.000Z</published>
    <updated>2020-11-19T13:29:54.533Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面的一系列文章主要探讨了 <a href="https://gentryhuang.com/posts/e2577ca1/">框架设计</a> 中的业务层（service）、配置层（config）以及注册中心层（registry）。虽然代理层（proxy）位于配置层和注册中心层之间，但是它是业务层连接 Dubbo 内部的桥梁，因为业务层无法直接使用 Dubbo 内部概念。需要注意的是，代理层具体实现位于 dubbo-rpc-api模块中。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-frame-proxy.jpg" alt></p><p>服务暴露时，需要通过代理层将业务接口实现对象转为 Invoker 。服务引用时，需要通过代理层将业务接口实现对象的 Invoker 转为 Dubbo 的 Proxy 。具体过程下面会详细说明。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Dubbo 支持 Javassist 和 JDK 的方式生成代理，默认使用 Javassist 生成代理，配置方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">proxy</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">proxy</span>=<span class="string">"xxx"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-proxy-module.jpg" alt></p><p>Dubbo 代理相关的 UML 图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-proxy-overview.jpg" alt></p><p>现在看这个 UML 图可能会不理解，等分析完后再回来看就很清晰了。需要说明的是，分析的过程中会涉及到 Invoker 模型，可以简单理解成一个真实的服务对象，它是 Dubbo 框架实体域，所有模型都会向它靠拢，可向它发起 invoke 调用。</p><h2 id="代理工厂-ProxyFactory"><a href="#代理工厂-ProxyFactory" class="headerlink" title="代理工厂 ProxyFactory"></a>代理工厂 ProxyFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ProxyFactory. (API/SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span>(<span class="string">"javassist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象（为Invoker对象创建代理对象），在引用服务的过程会调用该方法。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * create proxy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker 消费者对提供者调用的Invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * create proxy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> proxy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, <span class="keyword">boolean</span> generic)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Invoker（将代理对象反向封装成Invoker对象），在暴露服务时会调用。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * create invoker.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy Service对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type  Service接口类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url   Service对应的Dubbo URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> invoker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">getInvoker</span><span class="params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理工厂接口是个扩展点，用于获取代理对象和Invoker，默认扩展实现是 <code>javassist</code>，它的三个方法都标注有 <code>@Adaptive({Constants.PROXY_KEY})</code> 注解信息，表明会自动生成自适应扩展实现，关于自适应扩展在之前的文章中已经详细介绍过了。代理工厂的扩展点配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stub&#x3D;com.alibaba.dubbo.rpc.proxy.wrapper.StubProxyFactoryWrapper</span><br><span class="line">jdk&#x3D;com.alibaba.dubbo.rpc.proxy.jdk.JdkProxyFactory</span><br><span class="line">javassist&#x3D;com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory</span><br></pre></td></tr></table></figure><h2 id="代理工厂抽象实现类"><a href="#代理工厂抽象实现类" class="headerlink" title="代理工厂抽象实现类"></a>代理工厂抽象实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProxyFactory</span> <span class="keyword">implements</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker 消费者对提供者调用的Invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 调用重载方法获取代理对象</span></span><br><span class="line">        <span class="keyword">return</span> getProxy(invoker, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意：这里会在原有Invoker关联的接口之上增加EchoService接口，作用是回声测试，每个服务都会自动实现EchoService接口。</span></span><br><span class="line"><span class="comment">     * 如果要使用回声测试，只需要将任意服务引用强制转型为EchoService即可使用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> generic 是否泛化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, <span class="keyword">boolean</span> generic)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// 记录要代理的接口</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从Invoker的URL中获取接口列表</span></span><br><span class="line">        String config = invoker.getUrl().getParameter(<span class="string">"interfaces"</span>);</span><br><span class="line">        <span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; config.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 切分接口列表</span></span><br><span class="line">            String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);</span><br><span class="line">            <span class="keyword">if</span> (types != <span class="keyword">null</span> &amp;&amp; types.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                interfaces = <span class="keyword">new</span> Class&lt;?&gt;[types.length + <span class="number">2</span>];</span><br><span class="line">                <span class="comment">// 设置服务接口类和EchoService.class 到 interfaces 中，这里就是增加EchoService接口的入口，让服务实现它。</span></span><br><span class="line">                interfaces[<span class="number">0</span>] = invoker.getInterface();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回声测试接口</span></span><br><span class="line">                interfaces[<span class="number">1</span>] = EchoService<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">                    <span class="comment">// 加载接口类</span></span><br><span class="line">                    interfaces[i + <span class="number">1</span>] = ReflectUtils.forName(types[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果interfaces为空，增加EchoService接口，用于回声测试</span></span><br><span class="line">        <span class="keyword">if</span> (interfaces == <span class="keyword">null</span>) &#123;</span><br><span class="line">            interfaces = <span class="keyword">new</span> Class&lt;?&gt;[]&#123;invoker.getInterface(), EchoService<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为http和hessian 协议提供泛化调用支持</span></span><br><span class="line">        <span class="keyword">if</span> (!invoker.getInterface().equals(GenericService<span class="class">.<span class="keyword">class</span>) &amp;&amp; <span class="title">generic</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> len = interfaces.length;</span><br><span class="line">            Class&lt;?&gt;[] temp = interfaces;</span><br><span class="line">            <span class="comment">// 创建新的interfaces数组</span></span><br><span class="line">            interfaces = <span class="keyword">new</span> Class&lt;?&gt;[len + <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(temp, <span class="number">0</span>, interfaces, <span class="number">0</span>, len);</span><br><span class="line">            <span class="comment">// 设置GenericService.class 到数组中</span></span><br><span class="line">            interfaces[len] = GenericService<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用重载方法</span></span><br><span class="line">        <span class="keyword">return</span> getProxy(invoker, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类需要实现真正获取Proxy对象的逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invoker</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> types</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] types)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该抽象类主要为服务自动增加一个实现接口 EchoService，用于回声测试，获取代理的工作交给了具体子类来完成。我们前面也说了子类有两个，具体获取哪一个可以通过配置决定，没有配置默认使用 JavassistProxyFactory 。</p><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>该类位于 <em>dubbo-common</em> 模块下，是 Dubbo 框架自定义的类，用于构建 Proxy 的实现类及创建其对象，为什说是构建 Proxy 的实现类呢？因为 Proxy 是一个抽象类，它的 <code>getProxy</code> 方法利用 Javassist API 构建 Proxy 的子类并通过反射创建其对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.common.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Proxy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的 InvocationHandler 对象，返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> InvocationHandler RETURN_NULL_INVOKER = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认的 InvocationHandler 对象，直接抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> InvocationHandler THROW_UNSUPPORTED_INVOKER = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Method ["</span> + ReflectUtils.getName(method) + <span class="string">"] unimplemented."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原子对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong PROXY_CLASS_COUNTER = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Proxy类所在的包名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PACKAGE_NAME = Proxy<span class="class">.<span class="keyword">class</span>.<span class="title">getPackage</span>().<span class="title">getName</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Proxy 实例的缓存</span></span><br><span class="line"><span class="comment">     * key1: Classloader</span></span><br><span class="line"><span class="comment">     * key2: 服务实现的接口串</span></span><br><span class="line"><span class="comment">     * value:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;ClassLoader, Map&lt;String, Object&gt;&gt; ProxyCacheMap = <span class="keyword">new</span> WeakHashMap&lt;ClassLoader, Map&lt;String, Object&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PendingGenerationMarker = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get proxy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ics interface class array.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Proxy instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Proxy <span class="title">getProxy</span><span class="params">(Class&lt;?&gt;... ics)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getProxy(ClassHelper.getClassLoader(Proxy<span class="class">.<span class="keyword">class</span>), <span class="title">ics</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl  类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ics 服务实现的接口数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Proxy 接口代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Proxy <span class="title">getProxy</span><span class="params">(ClassLoader cl, Class&lt;?&gt;... ics)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//----------------------------------- 1 校验、访问缓存、并发控制 ------------------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ics.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历接口列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ics.length; i++) &#123;</span><br><span class="line">            String itf = ics[i].getName();</span><br><span class="line">            <span class="comment">// 检测类型是否为接口</span></span><br><span class="line">            <span class="keyword">if</span> (!ics[i].isInterface()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(itf + <span class="string">" is not a interface."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; tmp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 反射获取接口对应的Class</span></span><br><span class="line">                tmp = Class.forName(itf, <span class="keyword">false</span>, cl);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测接口是否相同，这里tmp有可能为空</span></span><br><span class="line">            <span class="keyword">if</span> (tmp != ics[i]) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ics[i] + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拼接接口全限定性名，分隔符为 `;`</span></span><br><span class="line">            sb.append(itf).append(<span class="string">';'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用拼接后的接口名作为 key</span></span><br><span class="line">        String key = sb.toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get cache by class loader.</span></span><br><span class="line">        Map&lt;String, Object&gt; cache;</span><br><span class="line">        <span class="keyword">synchronized</span> (ProxyCacheMap) &#123;</span><br><span class="line">            <span class="comment">// cl 类加载器是否有对应的值，没有则创建一个新的值</span></span><br><span class="line">            cache = ProxyCacheMap.get(cl);</span><br><span class="line">            <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cache = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">                ProxyCacheMap.put(cl, cache);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Proxy proxy = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 从缓存中获取 key 对应的值，可能是标志未</span></span><br><span class="line">                Object value = cache.get(key);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Reference&lt;?&gt;) &#123;</span><br><span class="line">                    proxy = (Proxy) ((Reference&lt;?&gt;) value).get();</span><br><span class="line">                    <span class="keyword">if</span> (proxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> proxy;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 多线程控制，保证只有一个线程可以进行后续操作，即如果已经是标志位说明已经有线程在获取了，当前线程要等待</span></span><br><span class="line">                <span class="keyword">if</span> (value == PendingGenerationMarker) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 线程要等待</span></span><br><span class="line">                        cache.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置标志位到缓存中，并跳出while循环进行后续操作</span></span><br><span class="line">                    cache.put(key, PendingGenerationMarker);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> id = PROXY_CLASS_COUNTER.getAndIncrement();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String pkg = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于为服务接口生成代理类</span></span><br><span class="line">        ClassGenerator ccp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 为 org.apache.dubbo.common.bytecode.Proxy 抽象类生成子类，主要是实现 Proxy 类的抽象方法</span></span><br><span class="line">        ClassGenerator ccm = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//----------------------------------------- 2 构建接口代理类 -----------------------------------------/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 javassist 工具对象 （ClassGenerator对 javassist进行了封装）</span></span><br><span class="line">            ccp = ClassGenerator.newInstance(cl);</span><br><span class="line"></span><br><span class="line">            Set&lt;String&gt; worked = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">            List&lt;Method&gt; methods = <span class="keyword">new</span> ArrayList&lt;Method&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历 服务实现的接口数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ics.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 检测接口访问级别是否为protected或private</span></span><br><span class="line">                <span class="keyword">if</span> (!Modifier.isPublic(ics[i].getModifiers())) &#123;</span><br><span class="line">                    <span class="comment">// 获取接口包名</span></span><br><span class="line">                    String npkg = ics[i].getPackage().getName();</span><br><span class="line">                    <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        pkg = npkg;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!pkg.equals(npkg)) &#123;</span><br><span class="line">                            <span class="comment">// 非public 级别的接口必须在同一个包下，否则报错</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 添加接口到 ClassGenerator 工具类的属性中</span></span><br><span class="line">                ccp.addInterface(ics[i]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历接口方法</span></span><br><span class="line">                <span class="keyword">for</span> (Method method : ics[i].getMethods()) &#123;</span><br><span class="line">                    <span class="comment">// 获取方法签名</span></span><br><span class="line">                    String desc = ReflectUtils.getDesc(method);</span><br><span class="line">                    <span class="comment">// 如果已经包含在worked中，则忽略。可能会出现，A接口和B接口中包含一个完全相同的方法</span></span><br><span class="line">                    <span class="keyword">if</span> (worked.contains(desc)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    worked.add(desc);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> ix = methods.size();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取方法返回值类型</span></span><br><span class="line">                    Class&lt;?&gt; rt = method.getReturnType();</span><br><span class="line">                    <span class="comment">// 获取参数列表</span></span><br><span class="line">                    Class&lt;?&gt;[] pts = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 生成 Object[] args = new Object[1...N]</span></span><br><span class="line">                    StringBuilder code = <span class="keyword">new</span> StringBuilder(<span class="string">"Object[] args = new Object["</span>).append(pts.length).append(<span class="string">"];"</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pts.length; j++) &#123;</span><br><span class="line">                        code.append(<span class="string">" args["</span>).append(j).append(<span class="string">"] = ($w)$"</span>).append(j + <span class="number">1</span>).append(<span class="string">";"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 生成InvokerHandler接口的invoker 方法调用语句，如： Object ret = handler.invoke(this,methods[1...N],args);</span></span><br><span class="line">                    code.append(<span class="string">" Object ret = handler.invoke(this, methods["</span> + ix + <span class="string">"], args);"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 返回值不为void</span></span><br><span class="line">                    <span class="keyword">if</span> (!Void.TYPE.equals(rt)) &#123;</span><br><span class="line">                        <span class="comment">// 生成返回语句，形如 return (java.lang.String) ret;</span></span><br><span class="line">                        code.append(<span class="string">" return "</span>).append(asArgument(rt, <span class="string">"ret"</span>)).append(<span class="string">";"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    methods.add(method);</span><br><span class="line">                    <span class="comment">// 添加方法名、访问控制符、参数列表、方法代码等信息到 ClassGenerator 中</span></span><br><span class="line">                    ccp.addMethod(method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pkg = PACKAGE_NAME;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拼接接口代理类名称：pkg + ".proxy" + id，比如 org.apache.dubbo.proxy0</span></span><br><span class="line">            String pcn = pkg + <span class="string">".proxy"</span> + id;</span><br><span class="line">            ccp.setClassName(pcn);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明方法数组</span></span><br><span class="line">            ccp.addField(<span class="string">"public static java.lang.reflect.Method[] methods;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明 private java.lang.reflect.InvocationHandler handler;</span></span><br><span class="line">            ccp.addField("private " + InvocationHandler.class.getName() + " handler;");</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 为接口代理类添加带有 InvocationHandler 参数的构造方法，比如：</span></span><br><span class="line"><span class="comment">             *       porxy0(java.lang.reflect.InvocationHandler arg0) &#123;</span></span><br><span class="line"><span class="comment">             *           handler=$1;</span></span><br><span class="line"><span class="comment">             *      &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ccp.addConstructor(Modifier.PUBLIC, new Class&lt;?&gt;[]&#123;InvocationHandler.class&#125;, new Class&lt;?&gt;[0], "handler=$1;");</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为接口代理类添加默认构造方法，如： public proxy0() &#123;&#125;</span></span><br><span class="line">            ccp.addDefaultConstructor();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成接口代理。需要注意的是，下面构建并创建的 Proxy 的子类对象会调用它的 newInstance 方法，进而创建接口代理对象</span></span><br><span class="line">            Class&lt;?&gt; clazz = ccp.toClass();</span><br><span class="line">            clazz.getField(<span class="string">"methods"</span>).set(<span class="keyword">null</span>, methods.toArray(<span class="keyword">new</span> Method[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//----------------------------------------- 3 构建 Proxy抽象类的子类并创建对象 -----------------------------------------/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构建Proxy子类名称，比如：Proxy1</span></span><br><span class="line">            String fcn = Proxy<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>() + <span class="title">id</span></span>;</span><br><span class="line">            <span class="comment">// 创建 javassist 工具对象 （ClassGenerator对 javassist进行了封装）</span></span><br><span class="line">            ccm = ClassGenerator.newInstance(cl);</span><br><span class="line">            <span class="comment">// 类名</span></span><br><span class="line">            ccm.setClassName(fcn);</span><br><span class="line">            <span class="comment">// 默认构造方法</span></span><br><span class="line">            ccm.addDefaultConstructor();</span><br><span class="line">            <span class="comment">// 设置父类 Proxy</span></span><br><span class="line">            ccm.setSuperClass(Proxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 为 Proxy 的抽象方法 newInstance 生成实现代码，这里会调用前面生成的接口代理类的有参构造方法。形如：</span></span><br><span class="line"><span class="comment">             *     public Object newInstance(java.lang.reflect.InvocationHandler h) &#123;</span></span><br><span class="line"><span class="comment">             *          return new com.alibaba.demo.proxy0($1);</span></span><br><span class="line"><span class="comment">             *      &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ccm.addMethod("public Object newInstance(" + InvocationHandler.class.getName() + " h)&#123; return new " + pcn + "($1); &#125;");</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成Proxy实现类</span></span><br><span class="line">            Class&lt;?&gt; pc = ccm.toClass();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 通过反射创建Proxy子类的对象</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            proxy = (Proxy) pc.newInstance();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// release ClassGenerator</span></span><br><span class="line">            <span class="keyword">if</span> (ccp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 释放资源</span></span><br><span class="line">                ccp.release();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ccm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ccm.release();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">                <span class="keyword">if</span> (proxy == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cache.remove(key);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 缓存，注意弱引用</span></span><br><span class="line">                    cache.put(key, <span class="keyword">new</span> WeakReference&lt;Proxy&gt;(proxy));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒其他等待线程</span></span><br><span class="line">                cache.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成返回语句</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">asArgument</span><span class="params">(Class&lt;?&gt; cl, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cl.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TYPE == cl) &#123;</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?false:((Boolean)"</span> + name + <span class="string">").booleanValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Byte.TYPE == cl) &#123;</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?(byte)0:((Byte)"</span> + name + <span class="string">").byteValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Character.TYPE == cl) &#123;</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?(char)0:((Character)"</span> + name + <span class="string">").charValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Double.TYPE == cl) &#123;</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?(double)0:((Double)"</span> + name + <span class="string">").doubleValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Float.TYPE == cl) &#123;</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?(float)0:((Float)"</span> + name + <span class="string">").floatValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Integer.TYPE == cl) &#123;</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?(int)0:((Integer)"</span> + name + <span class="string">").intValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Long.TYPE == cl) &#123;</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?(long)0:((Long)"</span> + name + <span class="string">").longValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Short.TYPE == cl) &#123;</span><br><span class="line">                <span class="keyword">return</span> name + <span class="string">"==null?(short)0:((Short)"</span> + name + <span class="string">").shortValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(name + <span class="string">" is unknown primitive type."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + ReflectUtils.getName(cl) + <span class="string">")"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get instance with default handler.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newInstance(THROW_UNSUPPORTED_INVOKER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get instance with special handler.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(InvocationHandler handler)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy 类是一个抽象类，其逻辑操作主要是使用 Javassist API ，已参考官方文档进行详细注释。该类主要做了两件事，也即构建了两个类：</p><blockquote><p>1 为服务接口创建代理类，这个代理类构建完成后先放入内存中<br>2 构建 Proxy 的实现类并创建该实现类的对象，创建的服务接口代理类的初始化就是在 Proxy 实现类的 newInstance 方法中进行的</p></blockquote><p><strong>服务接口代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 官方Demo服务接口生成的代理类</span></span><br><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.common.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.rpc.service.EchoService;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxy0</span> <span class="keyword">implements</span> <span class="title">EchoService</span>, <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method[] methods;</span><br><span class="line">    <span class="keyword">private</span> InvocationHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务接口方法，由代理类来执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String paramString)</span> </span>&#123;</span><br><span class="line">        Object[] arrayOfObject = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        arrayOfObject[<span class="number">0</span>] = paramString;</span><br><span class="line">        <span class="comment">// proxy.method =&gt;  InvocationHandler.invoke  【这里是调用目标方法的入口，即通过 InvocationHandler.invoke() 方法调用目标方法 】</span></span><br><span class="line">        Object localObject = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">0</span>], arrayOfObject);</span><br><span class="line">        <span class="keyword">return</span> (String) localObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 回声探测方法</span></span><br><span class="line">    <span class="keyword">public</span> Object $echo(Object paramObject) &#123;</span><br><span class="line">        Object[] arrayOfObject = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        arrayOfObject[<span class="number">0</span>] = paramObject;</span><br><span class="line">        Object localObject = <span class="keyword">this</span>.handler.invoke(<span class="keyword">this</span>, methods[<span class="number">1</span>], arrayOfObject);</span><br><span class="line">        <span class="keyword">return</span> (Object) localObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参数构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy0</span><span class="params">(InvocationHandler paramInvocationHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = paramInvocationHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Proxy 的子类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.common.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现 Proxy 的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(InvocationHandler paramInvocationHandler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建服务接口的代理对象，构造参数为 InvocationHandler</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> proxy0(paramInvocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：Proxy 实例对象和服务没有直接关系的，Proxy 实例对象是用来创建服务的代理对象的。在下一篇文章 <code>Javassist动态代理</code> 中会使用到Proxy实例对象，这里先分析其生成原理及其作用。</p><h2 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h2><p>该类位于 <em>dubbo-common</em> 模块下，是 Dubbo 框架自定义的类，用于包裹目标类，以避免反射调用提高性能。Wrapper同样是基于 Javassit API 进行代码生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.common.bytecode;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wrapper缓存对象</span></span><br><span class="line"><span class="comment">     * key: Wrapper 包装的类</span></span><br><span class="line"><span class="comment">     * value: Wrapper对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Wrapper&gt; WRAPPER_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Wrapper&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] EMPTY_STRING_ARRAY = <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Object 中的部分方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] OBJECT_METHODS = <span class="keyword">new</span> String[]&#123;<span class="string">"getClass"</span>, <span class="string">"hashCode"</span>, <span class="string">"toString"</span>, <span class="string">"equals"</span>&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建匿名对象，这个仅仅针对目标类是Object 的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Wrapper OBJECT_WRAPPER = <span class="keyword">new</span> Wrapper() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String[] getMethodNames() &#123;</span><br><span class="line">            <span class="keyword">return</span> OBJECT_METHODS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String[] getDeclaredMethodNames() &#123;</span><br><span class="line">            <span class="keyword">return</span> OBJECT_METHODS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String[] getPropertyNames() &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_STRING_ARRAY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; getPropertyType(String pn) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getPropertyValue</span><span class="params">(Object instance, String pn)</span> <span class="keyword">throws</span> NoSuchPropertyException </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchPropertyException(<span class="string">"Property ["</span> + pn + <span class="string">"] not found."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(Object instance, String pn, Object pv)</span> <span class="keyword">throws</span> NoSuchPropertyException </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchPropertyException(<span class="string">"Property ["</span> + pn + <span class="string">"] not found."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invokeMethod</span><span class="params">(Object instance, String mn, Class&lt;?&gt;[] types, Object[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"getClass"</span>.equals(mn)) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance.getClass();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"hashCode"</span>.equals(mn)) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance.hashCode();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"toString"</span>.equals(mn)) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"equals"</span>.equals(mn)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> instance.equals(args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invoke method ["</span> + mn + <span class="string">"] argument number error."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(<span class="string">"Method ["</span> + mn + <span class="string">"] not found."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicLong WRAPPER_CLASS_COUNTER = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关键一点： 实现的invokeMethod方法封装了传入的Class的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c Class instance.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Wrapper instance(not null).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Wrapper <span class="title">getWrapper</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// can not wrapper on dynamic class.</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 ClassGenerator是类生成器，基于Javassist实现。</span></span><br><span class="line"><span class="comment">         * 2 判断是否继承ClassGenerator.DC.class，如果是就拿到父类，避免重复包装</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (ClassGenerator.isDynamicClass(c)) &#123;</span><br><span class="line">            c = c.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是Object.class就直接返回创建的匿名Wrapper</span></span><br><span class="line">        <span class="keyword">if</span> (c == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> OBJECT_WRAPPER;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从缓存中获得Wrapper</span></span><br><span class="line">        Wrapper ret = WRAPPER_MAP.get(c);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 缓存未命中，创建Wrapper</span></span><br><span class="line">            ret = makeWrapper(c);</span><br><span class="line">            <span class="comment">// 写入缓存</span></span><br><span class="line">            WRAPPER_MAP.put(c, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Wrapper</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Wrapper <span class="title">makeWrapper</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// -------------------------------------------------- 1 组装、创建Wrapper实例的准备工作 ----------------------------------------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测 c 是否为基本类型，若是则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (c.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can not create wrapper for primitive type: "</span> + c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类名</span></span><br><span class="line">        String name = c.getName();</span><br><span class="line">        <span class="comment">// 类加载器</span></span><br><span class="line">        ClassLoader cl = ClassHelper.getClassLoader(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * c1 用于存储 setPropertyValue 方法代码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        StringBuilder c1 = <span class="keyword">new</span> StringBuilder(<span class="string">"public void setPropertyValue(Object o, String n, Object v)&#123; "</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * c2 用于存储getPropertyValue 方法代码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        StringBuilder c2 = <span class="keyword">new</span> StringBuilder(<span class="string">"public Object getPropertyValue(Object o, String n)&#123; "</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * c3 用于存储 invokeMethod 方法代码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        StringBuilder c3 = new StringBuilder("public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws " + InvocationTargetException.class.getName() + "&#123; ");</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加每个方法的被调用对象的类型转换的代码。即生成类型转换代码及异常捕捉代码，如：  DemoService w; try &#123; w = ((DemoServcie) $1); &#125;&#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c1.append(name).append(<span class="string">" w; try&#123; w = (("</span>).append(name).append(<span class="string">")$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;"</span>);</span><br><span class="line">        c2.append(name).append(<span class="string">" w; try&#123; w = (("</span>).append(name).append(<span class="string">")$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;"</span>);</span><br><span class="line">        c3.append(name).append(<span class="string">" w; try&#123; w = (("</span>).append(name).append(<span class="string">")$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * pts 用于存储成员变量名和类型</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; pts = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;(); <span class="comment">// &lt;property name, property types&gt;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ms 用于存储方法签名 及 Method 实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, Method&gt; ms = <span class="keyword">new</span> LinkedHashMap&lt;String, Method&gt;(); <span class="comment">// &lt;method desc, Method instance&gt;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * mns 为方法名列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;String&gt; mns = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// method names.</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * dmns 用于存储定义在当前类中的方法的名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;String&gt; dmns = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// declaring method names.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// -------------------------------------------------- 2 解析目标类的属性 ----------------------------------------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取public 访问级别的字段，并为所有字段生成条件判断语句</span></span><br><span class="line">        <span class="keyword">for</span> (Field f : c.getFields()) &#123;</span><br><span class="line">            String fn = f.getName();</span><br><span class="line">            Class&lt;?&gt; ft = f.getType();</span><br><span class="line">            <span class="comment">// 忽略关键字 static 或 transient 修饰的变量</span></span><br><span class="line">            <span class="keyword">if</span> (Modifier.isStatic(f.getModifiers()) || Modifier.isTransient(f.getModifiers())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成条件判断及赋值语句，如：if($2.equals("name"))&#123;w.name = (java.lang.String)$3;return;&#125;</span></span><br><span class="line">            c1.append(<span class="string">" if( $2.equals(\""</span>).append(fn).append(<span class="string">"\") )&#123; w."</span>).append(fn).append(<span class="string">"="</span>).append(arg(ft, <span class="string">"$3"</span>)).append(<span class="string">"; return; &#125;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成条件判断及返回语句，如: if($2.equals("name"))&#123;return ($w)w.name;&#125;</span></span><br><span class="line">            c2.append(<span class="string">" if( $2.equals(\""</span>).append(fn).append(<span class="string">"\") )&#123; return ($w)w."</span>).append(fn).append(<span class="string">"; &#125;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储 &lt;字段名，字段类型&gt; 赋值对到pts中</span></span><br><span class="line">            pts.put(fn, ft);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// -------------------------------------------------- 3 解析目标类的方法 ---------------------------------------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取目标类中的方法列表</span></span><br><span class="line">        Method[] methods = c.getMethods();</span><br><span class="line">        <span class="comment">// get all public method. // 检测目标类中是否包含在当前类中声明的方法</span></span><br><span class="line">        <span class="keyword">boolean</span> hasMethod = hasMethods(methods);</span><br><span class="line">        <span class="keyword">if</span> (hasMethod) &#123;</span><br><span class="line">            c3.append(<span class="string">" try&#123;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            <span class="comment">// 忽略Ojbect 中定义的方法</span></span><br><span class="line">            <span class="keyword">if</span> (m.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String mn = m.getName();</span><br><span class="line">            <span class="comment">// 生成方法名判断语句，如：if ( "sayHello".equals( $2 )</span></span><br><span class="line">            c3.append(<span class="string">" if( \""</span>).append(mn).append(<span class="string">"\".equals( $2 ) "</span>);</span><br><span class="line">            <span class="keyword">int</span> len = m.getParameterTypes().length;</span><br><span class="line">            <span class="comment">// 生成运行时传入参数的数量与方法的参数列表长度判读语句，如：&amp;&amp; $3.length == 2</span></span><br><span class="line">            c3.append(<span class="string">" &amp;&amp; "</span>).append(<span class="string">" $3.length == "</span>).append(len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若相同方法名存在多个，增加参数类型数组的比较判断</span></span><br><span class="line">            <span class="keyword">boolean</span> override = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (Method m2 : methods) &#123;</span><br><span class="line">                <span class="comment">// 检测方法是否存在重载情况，条件为：方法对象不同 &amp;&amp; 方法名相同</span></span><br><span class="line">                <span class="keyword">if</span> (m != m2 &amp;&amp; m.getName().equals(m2.getName())) &#123;</span><br><span class="line">                    override = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 对重载方法进行处理，考虑下面的方法：</span></span><br><span class="line"><span class="comment">             * 1 void sayHello(Integer,String)</span></span><br><span class="line"><span class="comment">             * 2 void sayHello(Integer,Integer)</span></span><br><span class="line"><span class="comment">             * 方法名相同，参数列表长度也相同，因此不能仅通过上面两个条件判断两个方法是否相等，需要进一步判断方法的参数类型</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (override) &#123;</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; len; l++) &#123;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * &amp;&amp; $3[0].getName().equals("java.lang.Integer") &amp;&amp; $3[1].getName().equals("java.lang.String")</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        c3.append(<span class="string">" &amp;&amp; "</span>).append(<span class="string">" $3["</span>).append(l).append(<span class="string">"].getName().equals(\""</span>)</span><br><span class="line">                                .append(m.getParameterTypes()[l].getName()).append(<span class="string">"\")"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 添加 )&#123;,完成方法判断语句，此时生成的方法可能如下：</span></span><br><span class="line"><span class="comment">             * if("sayHello".equals($2) &amp;&amp; $3.length == 2 &amp;&amp; $3[0].getName().equals("java.lang.Integer") &amp;&amp; $3[1].getName().equals("java.lang.String")</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            c3.append(<span class="string">" ) &#123; "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据返回值类型生成目标方法调用语句</span></span><br><span class="line">            <span class="keyword">if</span> (m.getReturnType() == Void.TYPE) &#123;</span><br><span class="line">                <span class="comment">// w.sayHello((java.lang.Integer)$4[0],(java.lang.String)$4[1]); return null;</span></span><br><span class="line">                c3.append(<span class="string">" w."</span>).append(mn).append(<span class="string">'('</span>).append(args(m.getParameterTypes(), <span class="string">"$4"</span>)).append(<span class="string">");"</span>).append(<span class="string">" return null;"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// return w.sayHello((java.lang.Integer)$4[0],(java.lang.String)$4[1])</span></span><br><span class="line">                c3.append(<span class="string">" return ($w)w."</span>).append(mn).append(<span class="string">'('</span>).append(args(m.getParameterTypes(), <span class="string">"$4"</span>)).append(<span class="string">");"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 添加 &#125; ，目标方法调用语句生成完毕，如下：</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * if("sayHello".equals($2) &amp;&amp; $3.length == 2 &amp;&amp; $3[0].getName().equals("java.lang.Integer") &amp;&amp; $3[1].getName().equals("java.lang.String")</span></span><br><span class="line"><span class="comment">             *     w.sayHello((java.lang.Integer)$4[0],(java.lang.String)$4[1]); return null;</span></span><br><span class="line"><span class="comment">             *     return null;</span></span><br><span class="line"><span class="comment">             *     &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            c3.append(<span class="string">" &#125;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加方法名到mns集合中</span></span><br><span class="line">            mns.add(mn);</span><br><span class="line">            <span class="comment">// 检测当前方法是否在c中被声明</span></span><br><span class="line">            <span class="keyword">if</span> (m.getDeclaringClass() == c) &#123;</span><br><span class="line">                <span class="comment">// 若是，则将当前方法名添加到dmns中</span></span><br><span class="line">                dmns.add(mn);</span><br><span class="line">            &#125;</span><br><span class="line">            ms.put(ReflectUtils.getDesc(m), m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有方法，就添加 invokeMethod(o,n,p,v) 的 catch 的代码</span></span><br><span class="line">        <span class="keyword">if</span> (hasMethod) &#123;</span><br><span class="line">            <span class="comment">// 添加异常捕获语句</span></span><br><span class="line">            c3.append(<span class="string">" &#125; catch(Throwable e) &#123; "</span>);</span><br><span class="line">            c3.append(<span class="string">"     throw new java.lang.reflect.InvocationTargetException(e); "</span>);</span><br><span class="line">            c3.append(<span class="string">" &#125;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加 invokeMethod(o,n,p,v) 的未匹配到方法的代码。即添加NoSuchMethodException 异常抛出代码</span></span><br><span class="line">        c3.append(" throw new " + NoSuchMethodException.class.getName() + "(\"Not found method \\\"\"+$2+\"\\\" in class " + c.getName() + ".\"); &#125;");</span><br><span class="line"></span><br><span class="line">        <span class="comment">//----------------------------------------------4 解析目标类属性操作方法，setter/getter ----------------------------------------------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环 setting/getting 方法，添加每个属性的设置和获得分别到 `#setPropertyValue(o, n, v)` 和 `#getPropertyValue(o, n)` 的代码</span></span><br><span class="line">        Matcher matcher;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理get/set方法</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Method&gt; entry : ms.entrySet()) &#123;</span><br><span class="line">            String md = entry.getKey();</span><br><span class="line">            Method method = entry.getValue();</span><br><span class="line">            <span class="comment">// 匹配以get开头的方法</span></span><br><span class="line">            <span class="keyword">if</span> ((matcher = ReflectUtils.GETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) &#123;</span><br><span class="line">                <span class="comment">// 获取属性名</span></span><br><span class="line">                String pn = propertyName(matcher.group(<span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 生成属性判断以及返回语句，示例如： if($2.equals("name")) &#123; return ($w).w.getName()&#125;</span></span><br><span class="line">                c2.append(<span class="string">" if( $2.equals(\""</span>).append(pn).append(<span class="string">"\") )&#123; return ($w)w."</span>).append(method.getName()).append(<span class="string">"(); &#125;"</span>);</span><br><span class="line">                pts.put(pn, method.getReturnType());</span><br><span class="line">                <span class="comment">// 匹配以is/has/can 开头的方法</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((matcher = ReflectUtils.IS_HAS_CAN_METHOD_DESC_PATTERN.matcher(md)).matches()) &#123;</span><br><span class="line">                String pn = propertyName(matcher.group(<span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 生成属性判断以及 返回语句，如： if($2.equals("dream"))&#123;return ($w)w.hasDream();&#125;</span></span><br><span class="line">                c2.append(<span class="string">" if( $2.equals(\""</span>).append(pn).append(<span class="string">"\") )&#123; return ($w)w."</span>).append(method.getName()).append(<span class="string">"(); &#125;"</span>);</span><br><span class="line">                pts.put(pn, method.getReturnType());</span><br><span class="line">                <span class="comment">// 匹配以set 开头的方法</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((matcher = ReflectUtils.SETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) &#123;</span><br><span class="line">                Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                String pn = propertyName(matcher.group(<span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 生成属性判断以及setter 调用语句，如： if($2.equals("name"))&#123;w.setName(java.lang.String)$3);return;&#125;</span></span><br><span class="line">                c1.append(<span class="string">" if( $2.equals(\""</span>).append(pn).append(<span class="string">"\") )&#123; w."</span>).append(method.getName()).append(<span class="string">"("</span>).append(arg(pt, <span class="string">"$3"</span>)).append(<span class="string">"); return; &#125;"</span>);</span><br><span class="line">                pts.put(pn, pt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加 NoSuchPropertyException 异常抛出语句</span></span><br><span class="line">        c1.append(" throw new " + NoSuchPropertyException.class.getName() + "(\"Not found property \\\"\"+$2+\"\\\" filed or setter method in class " + c.getName() + ".\"); &#125;");</span><br><span class="line">        c2.append(" throw new " + NoSuchPropertyException.class.getName() + "(\"Not found property \\\"\"+$2+\"\\\" filed or setter method in class " + c.getName() + ".\"); &#125;");</span><br><span class="line"></span><br><span class="line">        <span class="comment">//--------------------------------------------------- 5 为上面生成的代码构建 Class 类并组、射创建 Wrapper 实例 ---------------------------------------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// make class</span></span><br><span class="line">        <span class="keyword">long</span> id = WRAPPER_CLASS_COUNTER.getAndIncrement();</span><br><span class="line">        <span class="comment">// 创建类生成器</span></span><br><span class="line">        ClassGenerator cc = ClassGenerator.newInstance(cl);</span><br><span class="line">        <span class="comment">// 设置类名</span></span><br><span class="line">        cc.setClassName((Modifier.isPublic(c.getModifiers()) ? Wrapper.class.getName() : c.getName() + "$sw") + id);</span><br><span class="line">        <span class="comment">// 设置父类为 Wrapper.class</span></span><br><span class="line">        cc.setSuperClass(Wrapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加默认构造方法</span></span><br><span class="line">        cc.addDefaultConstructor();</span><br><span class="line">        <span class="comment">// 添加静态属性 `pns` 的代码</span></span><br><span class="line">        cc.addField(<span class="string">"public static String[] pns;"</span>); <span class="comment">// property name array.</span></span><br><span class="line">        <span class="comment">// 添加静态属性 `pts` 的代码</span></span><br><span class="line">        cc.addField("public static " + Map.class.getName() + " pts;"); // property type map.</span><br><span class="line">        <span class="comment">// 添加静态属性 `mns` 的代码</span></span><br><span class="line">        cc.addField(<span class="string">"public static String[] mns;"</span>); <span class="comment">// all method name array.</span></span><br><span class="line">        <span class="comment">// 添加静态属性 `dmns` 的代码</span></span><br><span class="line">        cc.addField(<span class="string">"public static String[] dmns;"</span>); <span class="comment">// declared method name array.</span></span><br><span class="line">        <span class="comment">// 添加静态属性 `mts` 的代码。每个方法的参数数组。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = ms.size(); i &lt; len; i++) &#123;</span><br><span class="line">            cc.addField(<span class="string">"public static Class[] mts"</span> + i + <span class="string">";"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ======= 添加抽象方法的实现，到 `cc` 中</span></span><br><span class="line">        <span class="comment">// 添加 `#getPropertyNames()` 的代码到 `cc`</span></span><br><span class="line">        cc.addMethod(<span class="string">"public String[] getPropertyNames()&#123; return pns; &#125;"</span>);</span><br><span class="line">        <span class="comment">// 添加 `#hasProperty(n)` 的代码到 `cc`</span></span><br><span class="line">        cc.addMethod(<span class="string">"public boolean hasProperty(String n)&#123; return pts.containsKey($1); &#125;"</span>);</span><br><span class="line">        <span class="comment">// 添加 `#getPropertyType(n)` 的代码到 `cc`</span></span><br><span class="line">        cc.addMethod(<span class="string">"public Class getPropertyType(String n)&#123; return (Class)pts.get($1); &#125;"</span>);</span><br><span class="line">        <span class="comment">// 添加 `#getMethodNames()` 的代码到 `cc`</span></span><br><span class="line">        cc.addMethod(<span class="string">"public String[] getMethodNames()&#123; return mns; &#125;"</span>);</span><br><span class="line">        <span class="comment">// 添加 `#getDeclaredMethodNames()` 的代码到 `cc`</span></span><br><span class="line">        cc.addMethod(<span class="string">"public String[] getDeclaredMethodNames()&#123; return dmns; &#125;"</span>);</span><br><span class="line">        <span class="comment">// 添加 `#setPropertyValue(o, n, v)` 的代码到 `cc`</span></span><br><span class="line">        cc.addMethod(c1.toString());</span><br><span class="line">        <span class="comment">// 添加 `#getPropertyValue(o, n)` 的代码到 `cc`</span></span><br><span class="line">        cc.addMethod(c2.toString());</span><br><span class="line">        <span class="comment">// 添加 `#invokeMethod(o, n, p, v)` 的代码到 `cc`</span></span><br><span class="line">        cc.addMethod(c3.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 生成类，通过javassist构建</span></span><br><span class="line">            Class&lt;?&gt; wc = cc.toClass();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反射，设置静态变量的值</span></span><br><span class="line">            wc.getField(<span class="string">"pts"</span>).set(<span class="keyword">null</span>, pts);</span><br><span class="line">            wc.getField(<span class="string">"pns"</span>).set(<span class="keyword">null</span>, pts.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">            wc.getField(<span class="string">"mns"</span>).set(<span class="keyword">null</span>, mns.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">            wc.getField(<span class="string">"dmns"</span>).set(<span class="keyword">null</span>, dmns.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">            <span class="keyword">int</span> ix = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Method m : ms.values()) &#123;</span><br><span class="line">                wc.getField(<span class="string">"mts"</span> + ix++).set(<span class="keyword">null</span>, m.getParameterTypes());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过反射创建对象 创建Wrapper 实例</span></span><br><span class="line">            <span class="keyword">return</span> (Wrapper) wc.newInstance();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            cc.release();</span><br><span class="line">            ms.clear();</span><br><span class="line">            mns.clear();</span><br><span class="line">            dmns.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法返回语句</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">arg</span><span class="params">(Class&lt;?&gt; cl, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cl.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cl == Boolean.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"((Boolean)"</span> + name + <span class="string">").booleanValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cl == Byte.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"((Byte)"</span> + name + <span class="string">").byteValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cl == Character.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"((Character)"</span> + name + <span class="string">").charValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cl == Double.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"((Number)"</span> + name + <span class="string">").doubleValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cl == Float.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"((Number)"</span> + name + <span class="string">").floatValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cl == Integer.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"((Number)"</span> + name + <span class="string">").intValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cl == Long.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"((Number)"</span> + name + <span class="string">").longValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cl == Short.TYPE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"((Number)"</span> + name + <span class="string">").shortValue()"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unknown primitive type: "</span> + cl.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"("</span> + ReflectUtils.getName(cl) + <span class="string">")"</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">args</span><span class="params">(Class&lt;?&gt;[] cs, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = cs.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">','</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(arg(cs[i], name + <span class="string">"["</span> + i + <span class="string">"]"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">propertyName</span><span class="params">(String pn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pn.length() == <span class="number">1</span> || Character.isLowerCase(pn.charAt(<span class="number">1</span>)) ? Character.toLowerCase(pn.charAt(<span class="number">0</span>)) + pn.substring(<span class="number">1</span>) : pn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否是有效的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasMethods</span><span class="params">(Method[] methods)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (methods == <span class="keyword">null</span> || methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            <span class="comment">// 有一个不是Object中定义的方法就说明符合条件</span></span><br><span class="line">            <span class="keyword">if</span> (m.getDeclaringClass() != Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get property name array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> property name array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> String[] getPropertyNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get property type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pn property name.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Property type or nul.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> Class&lt;?&gt; getPropertyType(String pn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * has property.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name property name.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> has or has not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasProperty</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get property value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> instance instance.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pn       property name.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Object <span class="title">getPropertyValue</span><span class="params">(Object instance, String pn)</span> <span class="keyword">throws</span> NoSuchPropertyException, IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set property value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> instance instance.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pn       property name.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pv       property value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(Object instance, String pn, Object pv)</span> <span class="keyword">throws</span> NoSuchPropertyException, IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get property value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> instance instance.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pns      property name array.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> value array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] getPropertyValues(Object instance, String[] pns) <span class="keyword">throws</span> NoSuchPropertyException, IllegalArgumentException &#123;</span><br><span class="line">        Object[] ret = <span class="keyword">new</span> Object[pns.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret.length; i++) &#123;</span><br><span class="line">            ret[i] = getPropertyValue(instance, pns[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * set property value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> instance instance.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pns      property name array.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pvs      property value array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(Object instance, String[] pns, Object[] pvs)</span> <span class="keyword">throws</span> NoSuchPropertyException, IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pns.length != pvs.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"pns.length != pvs.length"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pns.length; i++) &#123;</span><br><span class="line">            setPropertyValue(instance, pns[i], pvs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get method name array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> method name array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> String[] getMethodNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get method name array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> method name array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> String[] getDeclaredMethodNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * has method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name method name.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> has or has not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMethod</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String mn : getMethodNames()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mn.equals(name)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法，Dubbo在运行时会通过 Javassist 框架 为 Wrapper生成实现类，并实现该方法，该方法会根据调用信息调用具体的服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> instance 被调用的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mn       方法名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> types    参数类型数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args     参数数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Object <span class="title">invokeMethod</span><span class="params">(Object instance, String mn, Class&lt;?&gt;[] types, Object[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Wrapper 类的代码很多，但是就做一件事，对方法调用的包装，为什么能包装？ 为什么要包装？怎么执行目标对象方法？</p><blockquote><p>1 Wrapper 是一个抽象类，仅可通过 getWrapper(Class) 方法创建子类然后反射创建对象。在创建 Wrapper 子类的过程中，子类代码生成逻辑会对 getWrapper 方法传入的 Class 进行解析，拿到其方法，类成员变量等信息，以及生成 invokeMethod 方法代码等。<br>2 包装的目的是避免反射调用，提高性能。需要注意的是，创建 Wrapper 实例还是要通过反射的。<br>3 包装后，只需把包装类的对象、方法及参数传入invokeMethod方法中，无需通过反射就能匹配到方法并执行</p></blockquote><p>可以发现 Wrapper 逻辑的套路和 Proxy 差不多，都是通过 Javassist API 生成类并反射创建对象。以 Dubbo 的官方Demo服务接口为例，生成的 Wrapper 实现类整理后如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.common.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper0</span> <span class="keyword">extends</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] pns;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> java.util.Map pts;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] mns;,</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] dmns;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class[] mts0;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrapper0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getPropertyNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> pns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasProperty</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pts.containsKey($<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">getPropertyType</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Class) pts.get($<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getMethodNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> mns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getDeclaredMethodNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> dmns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValue</span><span class="params">(Object o, String n, Object v)</span> </span>&#123;</span><br><span class="line">        com.alibaba.dubbo.demo.DemoService w;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = ((com.alibaba.dubbo.demo.DemoService) $<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(<span class="string">"Not found property \""</span> + $<span class="number">2</span> + <span class="string">"\" filed or setter method in class com.alibaba.dubbo.demo.DemoService."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getPropertyValue</span><span class="params">(Object o, String n)</span> </span>&#123;</span><br><span class="line">        com.alibaba.dubbo.demo.DemoService w;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = ((com.alibaba.dubbo.demo.DemoService) $<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(<span class="string">"Not found property \""</span> + $<span class="number">2</span> + <span class="string">"\" filed or setter method in class com.alibaba.dubbo.demo.DemoService."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 目标类对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 方名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p 参数类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v 参数值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> java.lang.reflect.InvocationTargetException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invokeMethod</span><span class="params">(Object o, String n, Class[] p, Object[] v)</span> <span class="keyword">throws</span> java.lang.reflect.InvocationTargetException </span>&#123;</span><br><span class="line">        com.alibaba.dubbo.demo.DemoService w;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            w = ((com.alibaba.dubbo.demo.DemoService) $<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"sayHello"</span>.equals($<span class="number">2</span>) &amp;&amp; $<span class="number">3</span>.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ($w) w.sayHello((java.lang.String) $<span class="number">4</span>[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.reflect.InvocationTargetException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> com.alibaba.dubbo.common.bytecode.NoSuchMethodException(<span class="string">"Not found method \""</span> + $<span class="number">2</span> + <span class="string">"\" in class com.alibaba.dubbo.demo.DemoService."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章主要分析了 Dubbo 动态代理的抽象层，具体的实现是通过 Dubbo SPI 来决策的。此外，重点介绍了 <code>Proxy</code> 和 <code>Wrapper</code> 这两个类，<code>Proxy</code> 类用来创建服务接口代理类的实例，<code>Wrapper</code> 类是对服务类进行拆解、包装，对服务方法进行映射处理，避免反射调用。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-proxy-model.jpg" alt></p><p>服务消费者使用Proxy创建的服务代理对象屏蔽了网络通信等细节，服务提供者使用Wrapper将个性化的服务接口实现统一转成Invoker， <code>Proxy</code> 和 <code>Wrapper</code> 实现了 Dubbo 内部和业务接口之间的无缝转换。在之后的服务暴露、服务引用以及服务调用环节中可以看到它们的必要性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面的一系列文章主要探讨了 &lt;a href=&quot;https://gentryhuang.com/posts/e2577ca1/&quot;&gt;框架设计&lt;/
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Javassist" scheme="https://gentryhuang.com/tags/Javassist/"/>
    
      <category term="JDK" scheme="https://gentryhuang.com/tags/JDK/"/>
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="RPC" scheme="https://gentryhuang.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - Redis注册中心</title>
    <link href="https://gentryhuang.com/posts/b2453481/"/>
    <id>https://gentryhuang.com/posts/b2453481/</id>
    <published>2020-04-25T16:00:00.000Z</published>
    <updated>2020-10-13T11:46:23.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://gentryhuang.com/posts/dafcd048/">注册中心总览</a> 中介绍了 Dubbo 的注册中心抽象层，包括注册中心及其工厂。本篇文章将介绍 Dubbo 的 Redis 注册中心及其工厂。<br><br></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-redis-registry.png" alt></p><p>UML 图中的 RedisRegistry 类中实现了 Redis 作为注册中心的逻辑，其中 Redis 的客户端使用的是 Jedis 。</p><h2 id="Dubbo-中的-Redis-注册中心"><a href="#Dubbo-中的-Redis-注册中心" class="headerlink" title="Dubbo 中的 Redis 注册中心"></a>Dubbo 中的 Redis 注册中心</h2><br><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubb-redis-meta.jpg" alt></p><p>Redis 注册中心也沿用了 Dubbo 抽象的 Root、Service、Type、URL 四层结构。在 Redis 中数据都是以键值对的形式保存的，并不能像 Zookeeper 一样直接实现树形目录结构。因此，Redis 使用了 <code>key/Map</code> 结构存储数据：</p><blockquote><p>主key：Root、Service、Type 组合成的值，即服务名和类型，对应图中 /dubbo/com.foo.BarService/providers<br>主key的值Map中的key：URL串，对应图中 dubbo://10.20.153.10:123/barService=13658…<br>主key的值Map中的value: 过期时间</p></blockquote><p>Zookeeper 是基于监听器来感知数据的变化，而 Redis 使用基于 Publish/Subscribe 事件通知数据变更：</p><blockquote><p>通过事件的值区分事件消息类型：register,unregister<br>普通消费者订阅指定的服务提供者的Key，只会收到指定服务的 register,unregister 事件<br>监控中心订阅 /dubbo/*，会收到所有服务的所有变更事件</p></blockquote><p>注意事项：</p><ul><li>当前 Dubbo 版本的 Redis注册中心只会发送两种事件，分别对应服务提供者、服务消费者、动态配置、路由配置的注册与反注册，发送这两个事件的通道Channel是由服务接口决定的。</li><li>服务实例的启动或关闭，会写入或删除对应的数据，并通过通道发布对应的 <code>register</code>，<code>unregister</code> 事件消息，从而保证实时性。</li><li>如果使用监控中心（会订阅/dubbo/*）,Redis 注册中心会定时调度触发清理逻辑，保证未正常关闭的服务实例的 URL 的删除，并发起对应的 <code>unregister</code> 事件消息，从而保证数据的最终一致性。</li><li>不使用 Redis 的自动过期机制，而是通过监控中心实现过期机制，因为 Redis 的key自动过期不存在相应的事件消息通知。</li></ul><br><p>选项</p><ul><li>可通过 &lt;dubbo:registry group=”dubbo” /&gt; 设置 redis 中 key 的前缀，缺省为 dubbo。</li><li>可通过 &lt;dubbo:registry cluster=”replicate” /&gt; 设置 redis 集群策略，缺省为 failover。failover: 只写入和读取任意一台，失败时重试另一台，需要服务器端自行配置数据同步，replicate: 在客户端同时写入所有服务器，只读取单台，服务器端不需要同步，注册中心集群增大，性能压力也会更大。</li></ul><h2 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h2><p>订阅与通知是注册中心非常重要的功能，使用 Redis 作为注册中心，其订阅与通知实现方式与 Zookeeper 不同。Redis 订阅通知机制使用的是 <code>过期机制</code> 和 <code>Publish/Subscribe</code> 机制。</p><h3 id="服务提供者启动"><a href="#服务提供者启动" class="headerlink" title="服务提供者启动"></a>服务提供者启动</h3><p>服务提供者启动时，首先会在 Redis 中创建约定的k-v键值对，然后在通道（Root + Service + Type）中发布一条 <code>register</code> 事件消息。接着服务提供者会订阅动态配置信息，也就是在订阅URL中设置 <code>category=configurators</code> 。但是需要说明的是，Redis 的订阅实现方式不同 Zookeeper ，Zookeeper 可以直接注册子节点监听器直接监听 <code>.../configurators</code> 下的子节点变化，并且首次订阅就可以返回全量数据。而 Redis 每次订阅并没有订阅详细的Channel，如 <code>/dubbo/com.foo.BarService/configurators</code>，而是统一订阅 <code>Root + Service + *</code>，如 <code>Channel:/dubbo/com.alibaba.dubbo.demo.DemoService/*</code> ,这样一来任何只要是 <code>Root + Service</code> 匹配到的通道有消息都可以被订阅通知对象感知到。除此以外，使用 Redis 作为注册中心进行首次订阅的时候，当前订阅URL的 <code>Root + Service</code> 没有对应的通知器时会为其创建通知器，这个通知器就是用来订阅通道的， 由于 Redis 没有像 Zookeeper 那样绑定监听器，因此首次订阅需要主动使用 Redis 客户端获取 <code>Root + Service</code> 下的所有分类即 <code>Type</code>，然后再根据每个具体的分类获取其对应的 <code>URL</code> 列表，最后就是 Dubbo 的通知逻辑了。</p><h3 id="服务消费者启动"><a href="#服务消费者启动" class="headerlink" title="服务消费者启动"></a>服务消费者启动</h3><p>服务消费者启动的流程和服务提供者几乎一致，不同的是，在 Redis 中创建的k-v队是消费者的，消费者订阅的信息除了动态配置信息，还包括服务提供者信息和路由信息。</p><h3 id="监控中心启动"><a href="#监控中心启动" class="headerlink" title="监控中心启动"></a>监控中心启动</h3><p>监控中心(dubbo-admin)启动的时候只会进行订阅，而且订阅的是所有服务信息，即订阅的通道为 <code>/dubbo/*</code>，也就是说它会订阅所有服务的 providers、consumers、configurators和routers。通过监控中心进行服务治理时，如 设置配置参数、设置路由规则、调整权重、设置黑白名单等才会涉及注册与反注册操作。当订阅的通道有数据变动时，就会触发回调操作。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="RedisRegistryFactory"><a href="#RedisRegistryFactory" class="headerlink" title="RedisRegistryFactory"></a>RedisRegistryFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRegistryFactory</span> <span class="keyword">extends</span> <span class="title">AbstractRegistryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 注册中心地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 RedisRegistry 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisRegistry(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedisRegistry 工厂比较简单，没有其它逻辑，仅仅创建了一个 RedisRegistry 对象。</p><h3 id="RedisRegistry"><a href="#RedisRegistry" class="headerlink" title="RedisRegistry"></a>RedisRegistry</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RedisRegistry<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_REDIS_PORT = <span class="number">6379</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认redis的key的根据节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_ROOT = <span class="string">"dubbo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis Key 延时过期执行器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService expireExecutor = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboRegistryExpireTimer"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis Key 延时过期任务的Future</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledFuture&lt;?&gt; expireFuture;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Redis 根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JedisPool 集合</span></span><br><span class="line"><span class="comment">     * key: ip:port</span></span><br><span class="line"><span class="comment">     * value: JedisPool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, JedisPool&gt; jedisPools = <span class="keyword">new</span> ConcurrentHashMap&lt;String, JedisPool&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知器集合，用于Redis Publish/Subscribe机制中的订阅，本质是调用 Jedis的psubscribe方法进行订阅通道</span></span><br><span class="line"><span class="comment">     * key: Root + Service,例如： /dubbo/com.alibaba.dubbo.demo.DemoService</span></span><br><span class="line"><span class="comment">     * value: 通知器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Notifier&gt; notifiers = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Notifier&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重连周期，单位：毫秒</span></span><br><span class="line"><span class="comment">     * 订阅发生Redis连接异常时，Notifier sleep，等待重连</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> reconnectPeriod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期周期，单位：毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> expirePeriod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否使用了监控中心，使用了监控中心该属性会被设置 true</span></span><br><span class="line"><span class="comment">     * 用于判断脏数据，脏数据由监控中心删除&#123;<span class="doctag">@link</span> #clean(Jedis)&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> admin = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否复制模式，缺省是failover</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> replicate;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">RedisRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line">        <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"registry address == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建 GenericObjectPoolConfig 对象</span></span><br><span class="line">        GenericObjectPoolConfig config = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">        <span class="comment">// 连接从pool中获取，使用前会被验证，通过ping命令检测</span></span><br><span class="line">        config.setTestOnBorrow(url.getParameter(<span class="string">"test.on.borrow"</span>, <span class="keyword">true</span>));</span><br><span class="line">        <span class="comment">// 连接在被归还给pool前，会验证连接的有效性，通过ping命令来检测</span></span><br><span class="line">        config.setTestOnReturn(url.getParameter(<span class="string">"test.on.return"</span>, <span class="keyword">false</span>));</span><br><span class="line">        <span class="comment">// 打开空闲连接存活和回收，周期性检测</span></span><br><span class="line">        config.setTestWhileIdle(url.getParameter(<span class="string">"test.while.idle"</span>, <span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pool中最大的空闲连接数；达到后pool会开始回收空闲连接，直到空闲连接数达到Mindle个数。 主要避免空连接占用，资源浪费</span></span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"max.idle"</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setMaxIdle(url.getParameter(<span class="string">"max.idle"</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  pool中保持最小的空闲可用连接数，这部分不被回收。可防止流量增量时，连接创建不及时</span></span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"min.idle"</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setMinIdle(url.getParameter(<span class="string">"min.idle"</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pool可分配的连接数</span></span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"max.active"</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setMaxTotal(url.getParameter(<span class="string">"max.active"</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前pool可并发的最大连接数</span></span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"max.total"</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setMaxTotal(url.getParameter(<span class="string">"max.total"</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取连接的最大等待时间</span></span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"max.wait"</span>, url.getParameter(<span class="string">"timeout"</span>, <span class="number">0</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setMaxWaitMillis(url.getParameter(<span class="string">"max.wait"</span>, url.getParameter(<span class="string">"timeout"</span>, <span class="number">0</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"num.tests.per.eviction.run"</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setNumTestsPerEvictionRun(url.getParameter(<span class="string">"num.tests.per.eviction.run"</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"time.between.eviction.runs.millis"</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setTimeBetweenEvictionRunsMillis(url.getParameter(<span class="string">"time.between.eviction.runs.millis"</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(<span class="string">"min.evictable.idle.time.millis"</span>, <span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            config.setMinEvictableIdleTimeMillis(url.getParameter(<span class="string">"min.evictable.idle.time.millis"</span>, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否复制模式</span></span><br><span class="line">        String cluster = url.getParameter(<span class="string">"cluster"</span>, <span class="string">"failover"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"failover"</span>.equals(cluster) &amp;&amp; !<span class="string">"replicate"</span>.equals(cluster)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported redis cluster: "</span> + cluster + <span class="string">". The redis cluster only supported failover or replicate."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        replicate = <span class="string">"replicate"</span>.equals(cluster);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析</span></span><br><span class="line">        List&lt;String&gt; addresses = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        addresses.add(url.getAddress());</span><br><span class="line">        <span class="comment">// ULR中设置了从库地址</span></span><br><span class="line">        String[] backups = url.getParameter(Constants.BACKUP_KEY, <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (backups != <span class="keyword">null</span> &amp;&amp; backups.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            addresses.addAll(Arrays.asList(backups));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建JedisPool对象</span></span><br><span class="line">        <span class="keyword">for</span> (String address : addresses) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = address.indexOf(<span class="string">':'</span>);</span><br><span class="line">            String host;</span><br><span class="line">            <span class="keyword">int</span> port;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                host = address.substring(<span class="number">0</span>, i);</span><br><span class="line">                port = Integer.parseInt(address.substring(i + <span class="number">1</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                host = address;</span><br><span class="line">                port = DEFAULT_REDIS_PORT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.jedisPools.put(address, <span class="keyword">new</span> JedisPool(config, host, port,</span><br><span class="line">                    url.getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT), StringUtils.isEmpty(url.getPassword()) ? <span class="keyword">null</span> : url.getPassword(),</span><br><span class="line">                    url.getParameter(<span class="string">"db.index"</span>, <span class="number">0</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析重连周期</span></span><br><span class="line">        <span class="keyword">this</span>.reconnectPeriod = url.getParameter(Constants.REGISTRY_RECONNECT_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RECONNECT_PERIOD);</span><br><span class="line">        <span class="comment">// 获得Redis 根节点</span></span><br><span class="line">        String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">        <span class="keyword">if</span> (!group.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">            group = Constants.PATH_SEPARATOR + group;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!group.endsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">            group = group + Constants.PATH_SEPARATOR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = group;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析会话过期时间</span></span><br><span class="line">        <span class="keyword">this</span>.expirePeriod = url.getParameter(Constants.SESSION_TIMEOUT_KEY, Constants.DEFAULT_SESSION_TIMEOUT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建实现Redis Key 过期机制的任务</span></span><br><span class="line">        <span class="keyword">this</span>.expireFuture = expireExecutor.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 延时过期时间</span></span><br><span class="line">                    deferExpired();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Defensive fault tolerance</span></span><br><span class="line">                    logger.error(<span class="string">"Unexpected exception occur at defer expire time, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, expirePeriod / <span class="number">2</span>, expirePeriod / <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RedisRegistry 构造方法做了两件事，初始化 JedisPool 和 创建 Redis key的延迟过期的任务。初始化 JedisPool 没有什么好说的，主要是设置一些参数，下面我们来看 deferExpired 方法是怎么做到延时key过期的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 被Key过期机制执行器expireExecutor定时调用，用来延时过期时间.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deferExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123;</span><br><span class="line">         JedisPool jedisPool = entry.getValue();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Jedis jedis = jedisPool.getResource();</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">// 循环已注册的URL集合</span></span><br><span class="line">                 <span class="keyword">for</span> (URL url : <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered())) &#123;</span><br><span class="line">                     <span class="comment">// 是否是动态节点，只有动态节点需要延长过期时间</span></span><br><span class="line">                     <span class="keyword">if</span> (url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                         <span class="comment">// 获得分类路径，如：/dubbo/com.foo.BarService/providers</span></span><br><span class="line">                         String key = toCategoryPath(url);</span><br><span class="line">                         <span class="comment">/**</span></span><br><span class="line"><span class="comment">                          * 1 写入Redis Map中，更新过期时间</span></span><br><span class="line"><span class="comment">                          * 2 注意，如果过期时间更新的时候返回值为1，说明key已经被删除了，这次算重新发布，因此需要在通道key 中发布 register 事件消息</span></span><br><span class="line"><span class="comment">                          */</span></span><br><span class="line">                         <span class="keyword">if</span> (jedis.hset(key, url.toFullString(), String.valueOf(System.currentTimeMillis() + expirePeriod)) == <span class="number">1</span>) &#123;</span><br><span class="line">                             <span class="comment">// 发布 register 事件</span></span><br><span class="line">                             jedis.publish(key, Constants.REGISTER);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 如果是监控中心（admin = true），就负责删除过期脏数据。admin默认为false,可能修改的地方在 doSubscribe 方法中</span></span><br><span class="line">                 <span class="keyword">if</span> (admin) &#123;</span><br><span class="line">                     clean(jedis);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 如果Redis集群策略为 failover，则操作一台Redis即可。</span></span><br><span class="line">                 <span class="keyword">if</span> (!replicate) &#123;</span><br><span class="line">                     <span class="keyword">break</span>;<span class="comment">//  If the server side has synchronized data, just write a single machine</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 jedis.close();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">             logger.warn(<span class="string">"Failed to write provider heartbeat to redis registry. registry: "</span> + entry.getKey() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>服务的 key 写入Redis 后，需要周期性地刷新key过期时间，RedisRegistry 构造方法中启动了一个定时调度线程池，不断调用该方法延续key的过期时间。前面也说明了，Redis 的key自动过期不存在相应的事件通知（订阅者无法感知到key已经不存在），如果提供者宕机而非主动下线，则会造成没有发布 <code>unregister</code> 事件，这时订阅方是不知道服务已经下线的，此外，Redis 的 publish/subscribe 并不是绝对可靠的，如果 Redis 的集群策略设置为 <code>failover</code> 模式，消费者订阅了从节点，某一时刻主节点还没有完成数据同步给从节点就宕机了，那么消费者也是不知道服务已经下线的。因此，如果使用 Redis 作为注册中心，会依赖服务治理中心，使用了服务治理中心，Redis 注册中心就会定时触发清理逻辑，下面我们来看下 Redis 注册中心清理脏数据的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 监控中心负责清理过期脏数据</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> jedis</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获得所有的 Root + Service + Type</span></span><br><span class="line">       Set&lt;String&gt; keys = jedis.keys(root + Constants.ANY_VALUE);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; !keys.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">               <span class="comment">// 获得分类下的Map,key-&gt;URL,value-&gt;过期时间</span></span><br><span class="line">               Map&lt;String, String&gt; values = jedis.hgetAll(key);</span><br><span class="line">               <span class="keyword">if</span> (values != <span class="keyword">null</span> &amp;&amp; values.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">boolean</span> delete = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">                   <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : values.entrySet()) &#123;</span><br><span class="line">                       <span class="comment">// 获取URL</span></span><br><span class="line">                       URL url = URL.valueOf(entry.getKey());</span><br><span class="line">                       <span class="comment">// 动态节点</span></span><br><span class="line">                       <span class="keyword">if</span> (url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                           <span class="comment">// 获取URL对应的过期时间</span></span><br><span class="line">                           <span class="keyword">long</span> expire = Long.parseLong(entry.getValue());</span><br><span class="line">                           <span class="comment">// 已经过期</span></span><br><span class="line">                           <span class="keyword">if</span> (expire &lt; now) &#123;</span><br><span class="line">                               jedis.hdel(key, entry.getKey());</span><br><span class="line">                               delete = <span class="keyword">true</span>;</span><br><span class="line">                               <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                                   logger.warn(<span class="string">"Delete expired key: "</span> + key + <span class="string">" -&gt; value: "</span> + entry.getKey() + <span class="string">", expire: "</span> + <span class="keyword">new</span> Date(expire) + <span class="string">", now: "</span> + <span class="keyword">new</span> Date(now));</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 若发生删除行为，说明存在URL过期了，需要向key通道发布 `unregister`事件</span></span><br><span class="line">                   <span class="keyword">if</span> (delete) &#123;</span><br><span class="line">                       jedis.publish(key, Constants.UNREGISTER);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>clean 方法主要做了两件事，把过期的key删除并在通道key中发布 <code>unregister</code> 事件，保证了未正常下线的服务信息的删除，从而保证数据的最终一致性。但这里还有一个问题没有解决，如果 Redis 的集群策略设置为 <code>failover</code> 模式，消费者订阅了从节点，某一时刻提供者下线了，主节点还没有完成数据同步给从节点就宕机了，那么消费者也是不知道服务已经下线的，那这样情况怎么解决呢？问题先抛出来。</p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取分类路径 Root + Service + Type</span></span><br><span class="line">       String key = toCategoryPath(url);</span><br><span class="line">       <span class="comment">// 获得URL字符串作为Value</span></span><br><span class="line">       String value = url.toFullString();</span><br><span class="line">       <span class="comment">// 计算过期时间，这会作为Redis Map的值</span></span><br><span class="line">       String expire = String.valueOf(System.currentTimeMillis() + expirePeriod);</span><br><span class="line">       <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">       RpcException exception = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 向Redis注册</span></span><br><span class="line">       <span class="keyword">for</span> (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123;</span><br><span class="line">           JedisPool jedisPool = entry.getValue();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               Jedis jedis = jedisPool.getResource();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 写入Redis hash 中，注意，过期时间是作为Map的值。</span></span><br><span class="line">                   jedis.hset(key, value, expire);</span><br><span class="line">                   <span class="comment">// 发布Redis 注册事件。 key为通道， Constants.REGISTER-&gt;register为事件消息，订阅该通道的就会实时从Redis读取最新消息</span></span><br><span class="line">                   jedis.publish(key, Constants.REGISTER);</span><br><span class="line">                   success = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="comment">// 如果非replicate模式，只需要写入单台机器，结束循环。否则，就继续循环，向所有的Redis写入</span></span><br><span class="line">                   <span class="keyword">if</span> (!replicate) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   jedis.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               exception = <span class="keyword">new</span> RpcException(<span class="string">"Failed to register service to redis registry. registry: "</span> + entry.getKey() + <span class="string">", service: "</span> + url + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 处理异常</span></span><br><span class="line">       <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (success) &#123;</span><br><span class="line">               logger.warn(exception.getMessage(), exception);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> exception;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>注册方法主要做了两件事，把信息写到 Redis 中，然后发布注册事件。这里注册不仅是服务提供者和消费者，还可能是动态配置，路由规则等。</p><h4 id="反注册"><a href="#反注册" class="headerlink" title="反注册"></a>反注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUnregister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取分类路径 Root + Service + Type</span></span><br><span class="line">    String key = toCategoryPath(url);</span><br><span class="line">    <span class="comment">// 获得URL字符串作为Value</span></span><br><span class="line">    String value = url.toFullString();</span><br><span class="line">    RpcException exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123;</span><br><span class="line">        JedisPool jedisPool = entry.getValue();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Jedis jedis = jedisPool.getResource();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 删除 Redis Map 建</span></span><br><span class="line">                jedis.hdel(key, value);</span><br><span class="line">                <span class="comment">// 发布Redis 取消注册事件 key为通道 ， Constants.UNREGISTER-&gt;unregister 为事件消息</span></span><br><span class="line">                jedis.publish(key, Constants.UNREGISTER);</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 如果非replicate模式，只需操作单台机器，因此结束循环。否则，就继续循环，向所有的Redis写入</span></span><br><span class="line">                <span class="keyword">if</span> (!replicate) &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">//  If the server side has synchronized data, just write a single machine</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            exception = <span class="keyword">new</span> RpcException(<span class="string">"Failed to unregister service to redis registry. registry: "</span> + entry.getKey() + <span class="string">", service: "</span> + url + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            logger.warn(exception.getMessage(), exception);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反注册主要也做了两件事，从Redis 中删除数据，然后发布 unregister 为事件。当服务消费者或服务提供者关闭时，会调用该方法，取消注册，因为正常情况下，无需使用监控中心做脏数据删除的工作。同样，这里反注册不仅是服务提供者和消费者，还可能是动态配置，路由规则等。</p><h4 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得服务路径 Root + Service 如： /dubbo/com.alibaba.dubbo.demo.DemoService</span></span><br><span class="line">    String service = toServicePath(url);</span><br><span class="line">    <span class="comment">// 获得服务路径对应的通知器 Notifier 对象,不存在对应的通知器，则创建Notifier对象</span></span><br><span class="line">    Notifier notifier = notifiers.get(service);</span><br><span class="line">    <span class="keyword">if</span> (notifier == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  创建服务路径对应的通知器Notifier对象，即基于 Root + Service 开启订阅线程，如果服务很多，就意味着有很多此类线程，创建线程是消耗资源的，而且还是那种阻塞不释放的。</span></span><br><span class="line"><span class="comment">         *  说明：</span></span><br><span class="line"><span class="comment">         *  zk是直接调用客户端API绑定监听器实现订阅，redis是使用多个独立的订阅线程，使用pub/sub机制进行处理，因为redis的pub/sub是基于channel进行的长连接通信，因此每个服务只能使用单独的线程。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Notifier newNotifier = <span class="keyword">new</span> Notifier(service);</span><br><span class="line">        notifiers.putIfAbsent(service, newNotifier);</span><br><span class="line">        notifier = notifiers.get(service);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保证并发的情况下，有且仅有一个启动</span></span><br><span class="line">        <span class="keyword">if</span> (notifier == newNotifier) &#123;</span><br><span class="line">            <span class="comment">// 启动线程（订阅了通道，有消息发布就会被通知订阅对象收到，然后进行后续的通知处理），需要注意：Jedis的订阅是阻塞的，因此需要开启线程，不然主线程会阻塞。</span></span><br><span class="line">            notifier.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    RpcException exception = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环 jedisPools,仅从一个Redis获取数据，然后进行通知，直到成功</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123;</span><br><span class="line">        JedisPool jedisPool = entry.getValue();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Jedis jedis = jedisPool.getResource();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理 Root + * 的订阅，一般是监听中心的订阅</span></span><br><span class="line">                <span class="keyword">if</span> (service.endsWith(Constants.ANY_VALUE)) &#123;</span><br><span class="line">                    <span class="comment">// 标记admin = true,监控中心才会清理脏数据</span></span><br><span class="line">                    admin = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">// 调用Jedis#keys(pattern)方法根据`/dubbo/*` 通配符获得分类层集合。始终记住 Redis 作为注册中心时，key是分类，如： /dubbo/com.alibaba.dubbo.demo.DemoService/providers</span></span><br><span class="line">                    Set&lt;String&gt; keys = jedis.keys(service);</span><br><span class="line">                    <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; !keys.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">// key: Root + Service  value: Root + Service + Type</span></span><br><span class="line">                        Map&lt;String, Set&lt;String&gt;&gt; serviceKeys = <span class="keyword">new</span> HashMap&lt;String, Set&lt;String&gt;&gt;();</span><br><span class="line">                        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                            <span class="comment">// 获取Root + Service，如：/dubbo/com.alibaba.dubbo.demo.DemoService</span></span><br><span class="line">                            String serviceKey = toServicePath(key);</span><br><span class="line">                            Set&lt;String&gt; sk = serviceKeys.get(serviceKey);</span><br><span class="line">                            <span class="keyword">if</span> (sk == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                sk = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">                                serviceKeys.put(serviceKey, sk);</span><br><span class="line">                            &#125;</span><br><span class="line">                            sk.add(key);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 循环serviceKeys</span></span><br><span class="line">                        <span class="keyword">for</span> (Set&lt;String&gt; sk : serviceKeys.values()) &#123;</span><br><span class="line">                            <span class="comment">// 通知监听器</span></span><br><span class="line">                            doNotify(jedis, sk, url, Arrays.asList(listener));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 处理指定 Root + Service 的订阅 </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 1 调用Jedis#keys(pattern)方法，获得所有分类，例如：/dubbo/com.alibaba.dubbo.demo.DemoService/providers</span></span><br><span class="line"><span class="comment">                     * 2 通知监听器</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    doNotify(jedis, jedis.keys(service + Constants.PATH_SEPARATOR + Constants.ANY_VALUE), url, Arrays.asList(listener));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 标记成功</span></span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// Just read one server's data</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Try the next server</span></span><br><span class="line">            exception = <span class="keyword">new</span> RpcException(<span class="string">"Failed to subscribe service from redis registry. registry: "</span> + entry.getKey() + <span class="string">", service: "</span> + url + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            logger.warn(exception.getMessage(), exception);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务提供者、服务消费者、和服务治理中心都会使用注册中心的订阅功能。在订阅时，如果是首次订阅，则会先创建一个 Notifier 通知器，它是一个线程类，以异步方式进行通道的订阅。在启动通知器的同时，主线程会继续往下执行，全量拉取注册中心上和本次订阅相关的数据信息。后续注册中心上的信息变更则通过通知器订阅的通道来实现，发生变更订阅器会收到。此外，这里有两个分支，第一个是处理监控中心的订阅即 <code>Root + *</code>，第二个是处理指定<code>Root + Service + *</code> 的订阅，如果是监控中心的订阅会开启脏数据的清理任务。有了订阅，下面我们来看通知器的实现。</p><h4 id="Notifier-通知器"><a href="#Notifier-通知器" class="headerlink" title="Notifier 通知器"></a>Notifier 通知器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知器类，是一个线程对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Notifier</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 服务名 Root + Service</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String service;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 需要忽略连接的次数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger connectSkip = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 已经忽略连接的次数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger connectSkiped = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 随机对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Jedis</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Jedis jedis;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 是否首次</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 是否运行中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 连接次数随机数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> connectRandom;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Notifier</span><span class="params">(String service)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">super</span>.setName(<span class="string">"DubboRedisSubscribe"</span>);</span><br><span class="line">            <span class="keyword">this</span>.service = service;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重置忽略连接的信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetSkip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 重置需要忽略连接的次数</span></span><br><span class="line">            connectSkip.set(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 重置已忽略次数和随机数</span></span><br><span class="line">            connectSkiped.set(<span class="number">0</span>);</span><br><span class="line">            connectRandom = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断是否忽略本次对Redis的连接</span></span><br><span class="line"><span class="comment">         * 原则是：连接失败的次数越多，每一轮加大需要忽略的总次数</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSkip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 获得需要忽略的连接数，如果超过10，则加上一个10以内的随机数</span></span><br><span class="line">            <span class="keyword">int</span> skip = connectSkip.get(); <span class="comment">// Growth of skipping times</span></span><br><span class="line">            <span class="keyword">if</span> (skip &gt;= <span class="number">10</span>) &#123; <span class="comment">// If the number of skipping times increases by more than 10, take the random number</span></span><br><span class="line">                <span class="keyword">if</span> (connectRandom == <span class="number">0</span>) &#123;</span><br><span class="line">                    connectRandom = random.nextInt(<span class="number">10</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                skip = <span class="number">10</span> + connectRandom;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自增忽略次数，若忽略次数不够，则继续忽略</span></span><br><span class="line">            <span class="keyword">if</span> (connectSkiped.getAndIncrement() &lt; skip) &#123; <span class="comment">// Check the number of skipping times</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 增加需要忽略的次数</span></span><br><span class="line">            connectSkip.incrementAndGet();</span><br><span class="line">            <span class="comment">// 重置已忽略次数和随机数</span></span><br><span class="line">            connectSkiped.set(<span class="number">0</span>);</span><br><span class="line">            connectRandom = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 这里的循环处理是为了避免网络等异常的发生，便于重新尝试连接redis 订阅channel</span></span><br><span class="line">            <span class="keyword">while</span> (running) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 是否跳过本次Redis连接 todo</span></span><br><span class="line">                    <span class="keyword">if</span> (!isSkip()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 循环连接池</span></span><br><span class="line">                            <span class="keyword">for</span> (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">                                JedisPool jedisPool = entry.getValue();</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                                    jedis = jedisPool.getResource();</span><br><span class="line">                                    <span class="keyword">try</span> &#123;</span><br><span class="line">                                        <span class="comment">// 如果是监控中心的订阅</span></span><br><span class="line">                                        <span class="keyword">if</span> (service.endsWith(Constants.ANY_VALUE)) &#123;</span><br><span class="line">                                            <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">                                                first = <span class="keyword">false</span>;</span><br><span class="line">                                                <span class="comment">// 获取分类集合</span></span><br><span class="line">                                                Set&lt;String&gt; keys = jedis.keys(service);</span><br><span class="line">                                                <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; !keys.isEmpty()) &#123;</span><br><span class="line">                                                    <span class="keyword">for</span> (String s : keys) &#123;</span><br><span class="line">                                                        doNotify(jedis, s);</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line"></span><br><span class="line">                                              <span class="comment">// 由于连接过程允许一定量的失败，调用该方法重置计数器</span></span><br><span class="line">                                                resetSkip();</span><br><span class="line">                                            &#125;</span><br><span class="line">                                          </span><br><span class="line">                                            <span class="comment">// 订阅给定模式的通道，当订阅的通道有发布消息时，NotifySub对象的回调方法就能接收到。需要注意的是，订阅方法是阻塞的。</span></span><br><span class="line">                                            jedis.psubscribe(<span class="keyword">new</span> NotifySub(jedisPool), service); <span class="comment">// blocking</span></span><br><span class="line"></span><br><span class="line">                                            <span class="comment">// 服务提供者或者消费者</span></span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                            <span class="keyword">if</span> (!first) &#123;</span><br><span class="line">                                                first = <span class="keyword">false</span>;</span><br><span class="line">                                                doNotify(jedis, service);</span><br><span class="line">                                                <span class="comment">// 由于连接过程允许一定量的失败，调用该方法重置计数器</span></span><br><span class="line">                                                resetSkip();</span><br><span class="line">                                            &#125;</span><br><span class="line"></span><br><span class="line">                                            jedis.psubscribe(<span class="keyword">new</span> NotifySub(jedisPool), service + Constants.PATH_SEPARATOR + Constants.ANY_VALUE); <span class="comment">// blocking</span></span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                        jedis.close();</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Retry another server</span></span><br><span class="line"></span><br><span class="line">                                    logger.warn(<span class="string">"Failed to subscribe service from redis registry. registry: "</span> + entry.getKey() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">                                    <span class="comment">// If you only have a single redis, you need to take a rest to avoid overtaking a lot of CPU resources</span></span><br><span class="line">                                    sleep(reconnectPeriod);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                            logger.error(t.getMessage(), t);</span><br><span class="line">                            sleep(reconnectPeriod);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.error(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 停止 Notifier，关闭redis订阅相关工作的关键。它是通过设置停止循环标识，以及关闭redis连接实现的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 设置停止标识</span></span><br><span class="line">                running = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 断开redis连接，它还会停止psubscribe的调用，从而间接中止订阅</span></span><br><span class="line">                jedis.disconnect();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通知器是一个线程，它是 RedisRegistry的内部类，每一个服务（Root + Service）对应一个通知器，如果存在大量订阅请求并且订阅URL都不是同一个服务，那么就要创建大量的线程。不仅如此，由通知器类还可以发现其任务方法中调用了订阅方法 <code>jedis.psubscribe</code> ，这个方法是阻塞的。因此，使用 Redis 注册中心要考虑线程资源。目前为止，Redis 的发布我们已经知道了，主要在注册和反注册的方法中，如果使用了监控中心，还会在脏数据清理方法中。订阅接收对象依然没有出现，请注意，通知器并非是订阅器，但是通知器创建了订阅器 NotifySub，我们继续跟进该类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RedisRegistry 的内部类，继承 redis.clients.jedis.JedisPubSub 抽象类，它是个通知订阅实现类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifySub</span> <span class="keyword">extends</span> <span class="title">JedisPubSub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NotifySub</span><span class="params">(JedisPool jedisPool)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.jedisPool = jedisPool;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 订阅后的通知回调方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key 订阅的key，一般为类目，如：/dubbo/com.alibaba.dubbo.demo.DemoService/providers</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> msg 事件消息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String key, String msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"redis event: "</span> + key + <span class="string">" = "</span> + msg);</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 收到register/unregister事件，调用#doNotify方法，组装目标URL然后通知监听器，从而实现实时更新</span></span><br><span class="line">            <span class="keyword">if</span> (msg.equals(Constants.REGISTER) || msg.equals(Constants.UNREGISTER)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Jedis jedis = jedisPool.getResource();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 进行通知，这里不是真正意义上的通知</span></span><br><span class="line">                        doNotify(jedis, key);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        jedis.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// TODO Notification failure does not restore mechanism guarantee</span></span><br><span class="line">                    logger.error(t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPMessage</span><span class="params">(String pattern, String key, String msg)</span> </span>&#123;</span><br><span class="line">            onMessage(key, msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(String key, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPSubscribe</span><span class="params">(String pattern, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUnsubscribe</span><span class="params">(String key, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPUnsubscribe</span><span class="params">(String pattern, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NotifySub 继承 <code>redis.clients.jedis.JedisPubSub</code> 抽象类，这样它就具有了订阅的功能，它也是 RedisRegistry 的内部类。当 <code>jedis.psubscribe(JedisPubSub,channel)</code> 订阅了通道（支持通配符）后，一旦该通道有事件消息发布 NotifySub 的通知回调方法就会调用，就能拿到具体的通道和在通道中发布的事件消息。至此， Redis 注册中心的两大核心角色就有了，下面我们简单梳理下整个过程。</p><ol><li>服务提供者、消费者在启动过程会进行服务的注册和订阅</li></ol><blockquote><p>1 注册的过程会先把服务信息写入到Redis中，并且通过分类路径 ‘Root + Service + Type’ 这个通道发布注册事件消息 register<br>2 订阅的过程会先创建一个通知器线程并启动，这个通知器线程会订阅服务路径 ‘Root + Service + *’ 这个通道，订阅后就坐等该通道的事件消息，NotifySub 对象就是用来接收通道消息的。然后会主动从Redis注册中心拉取 服务路径 ‘Root + Service + *’ 下的所有分类。</p></blockquote><ol start="2"><li>有服务下线会进行反注册</li></ol><blockquote><p>1 反注册会先把服务信息从Redis中删除，并且通过分类路径 ‘Root + Service + Type’ 这个通道发布反注册事件消息 unregister<br>2 如果通知已经被订阅，那么NotifySub就会接收通道发来的 反注册事件消息 unregister</p></blockquote><ol start="3"><li>监控中心启动会订阅所有服务</li></ol><blockquote><p>订阅的过程会先创建一个通知器线程并启动，这个通知器线程会订阅服务路径 ‘Root + *’ 这个通道，订阅后就坐等该通道的事件消息。然后会从Redis注册中心拉取所有数据并分类存储在缓存中</p></blockquote><ol start="4"><li>监控中心进行服务治理</li></ol><blockquote><p>服务治理涉及到注册和反注册，如：创建提供者、设置动态配置、设置路由规则等，都会向对应的通道发送消息。这些都会触发 NotifySub 通知回调</p></blockquote><p>以上分析主要是针对 注册（反注册）和订阅的分析，我们还少了一步通知，前文订阅的过程会调用通知方法，下面我们就来分析 Redis 注册中心的通知是怎么做的。</p><h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>需要说明的是，Zookeeper 由于可以注册监听器进而直接拿到订阅关注的全量数据，但是 Redis 订阅后得到的通知结果并不是订阅关注的数据而是大Key，需要多做一步查询大Key对应的目标URL集合，即 使用 doNotify 方法将 Redis 中的数据接入到应用中，然后回调监听器的方法完成通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> jedis</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key   分类，NotifySub获取到的，例如： /dubbo/com.alibaba.dubbo.demo.DemoService/providers</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">(Jedis jedis, String key)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 调用getSubscribed()方法，获得所有 订阅 URL 的监听器集合</span></span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed()).entrySet()) &#123;</span><br><span class="line">          doNotify(jedis, Arrays.asList(key), entry.getKey(), <span class="keyword">new</span> HashSet&lt;NotifyListener&gt;(entry.getValue()));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> jedis     Jedis</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> keys      分类数组 ，如 /dubbo/com.alibaba.dubbo.demo.DemoService/providers （首次会拉取某个Service层下的所有分类）</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> url       订阅URL</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> listeners 订阅URL对应的监听器集合</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">(Jedis jedis, Collection&lt;String&gt; keys, URL url, Collection&lt;NotifyListener&gt; listeners)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (keys == <span class="keyword">null</span> || keys.isEmpty() || listeners == <span class="keyword">null</span> || listeners.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 当前时间</span></span><br><span class="line">      <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 目标URL集合</span></span><br><span class="line">      List&lt;URL&gt; result = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 获得订阅URL的分类，不同的角色关注不同的分类数据【zookeeper也是如此】</span></span><br><span class="line"><span class="comment">       * 1 服务提供者，关注configurators</span></span><br><span class="line"><span class="comment">       * 2 服务消费者，关注providers,configurators.routers</span></span><br><span class="line"><span class="comment">       * 3 监控中心关注所有</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      List&lt;String&gt; categories = Arrays.asList(url.getParameter(Constants.CATEGORY_KEY, <span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 订阅URL映射的服务接口名 ，Root + Service</span></span><br><span class="line">      String consumerService = url.getServiceInterface();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 循环分类数组，如： /dubbo/com.alibaba.dubbo.demo.DemoService/providers</span></span><br><span class="line">      <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (!Constants.ANY_VALUE.equals(consumerService)) &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 获取分类对应的服务接口名 ，Root + Service</span></span><br><span class="line">              String prvoiderService = toServiceName(key);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 分离对应的服务接口名是否匹配订阅URL映射的服务接口名,不匹配直接返回，说明不是订阅URl关注的分类</span></span><br><span class="line">              <span class="keyword">if</span> (!prvoiderService.equals(consumerService)) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果订阅URL不关注该分类，则直接返回</span></span><br><span class="line">          String category = toCategoryName(key);</span><br><span class="line">          <span class="keyword">if</span> (!categories.contains(Constants.ANY_VALUE) &amp;&amp; !categories.contains(category)) &#123;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">         </span><br><span class="line">          List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 获得分类下所有URL数组，如： /dubbo/com.alibaba.dubbo.demo.DemoService/providers 下的所有提供者URL及其过期时间</span></span><br><span class="line">          Map&lt;String, String&gt; values = jedis.hgetAll(key);</span><br><span class="line">          <span class="keyword">if</span> (values != <span class="keyword">null</span> &amp;&amp; values.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : values.entrySet()) &#123;</span><br><span class="line">                  URL u = URL.valueOf(entry.getKey());</span><br><span class="line">                  <span class="comment">// 过滤掉已过期的动态节点 [动态节点才可能会变化，把动态节点收集起来，去和原来的节点对比，看是否有变化，有变化就需要做些操作，如 服务重新暴露]</span></span><br><span class="line">                  <span class="keyword">if</span> (!u.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>) || Long.parseLong(entry.getValue()) &gt;= now) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">                          urls.add(u);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 若不存在匹配，则创建 `empty://` 的 URL</span></span><br><span class="line">          <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">              urls.add(url.setProtocol(Constants.EMPTY_PROTOCOL)</span><br><span class="line">                      .setAddress(Constants.ANYHOST_VALUE)</span><br><span class="line">                      .setPath(toServiceName(key))</span><br><span class="line">                      .addParameter(Constants.CATEGORY_KEY, category));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          result.addAll(urls);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">              logger.info(<span class="string">"redis notify: "</span> + key + <span class="string">" = "</span> + urls);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span> || result.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 回调父类的notify方法，进行通知，这里才是真正通知监听器的入口。接下来的流程和 Zookeeper 一致</span></span><br><span class="line">      <span class="keyword">for</span> (NotifyListener listener : listeners) &#123;</span><br><span class="line">          notify(url, listener, result);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>该方法需要注意一个点，分类不一定能够匹配上订阅URL，因此需要过滤。造成原因就一个，Redis 是使用Root + Service 获取分类的，主动获取和订阅都是这样。该方法看着逻辑不少，不过主要做了三个工作：</p><ol><li>根据订阅URL选出匹配的分类，因为 Redis 是根据订阅URL的Root + Service 获取其下的所有分类，但是订阅URL中也许没有指定那么多，就是订阅URL的category参数的值。</li><li>选出匹配的分类后，获取分类下的URL集合，然后筛选出没有过期的URL。如果没有预期的URL，就创建一个 empty://… </li><li>回调NotifyListener，进行通知。如 服务重新暴露，服务目录更新等</li></ol><p>至此，Redis 注册中心的 注册（反注册）、订阅、通知分析完毕，值得一说的是 Redis 的取消订阅什么都没有做是个空方法，在ZookeeperRegistry的该方法中，是移除了对应的监听器，这里理论上 Redis 应该解除订阅，不过 Redis 把这个收尾操作放到了 destroy 方法中了，我们一起来看看这个收尾方法。</p><h4 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 父类关闭</span></span><br><span class="line">    <span class="keyword">super</span>.destroy();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 取消定时任务，过期时间不会更新</span></span><br><span class="line">        expireFuture.cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭通知器，依次调用 shutdown方法，停止订阅工作。</span></span><br><span class="line">        <span class="keyword">for</span> (Notifier notifier : notifiers.values()) &#123;</span><br><span class="line">            notifier.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭连接池</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123;</span><br><span class="line">        JedisPool jedisPool = entry.getValue();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedisPool.destroy();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Failed to destroy the redis registry client. registry: "</span> + entry.getKey() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后优雅关闭过期扫描定时任务线程池，即 shutdown()..awaitTermination()的应用。</span></span><br><span class="line">    ExecutorUtil.gracefulShutdown(expireExecutor, expirePeriod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>销毁方法主要做了以下工作：</p><ol><li>调用父类FailbackRegistry的 destroy 方法</li><li>取消延时key过期的任务</li><li>关闭通知器线程，停止订阅工作</li><li>关闭JedisPool，释放资源</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Redis 作为注册中心与 Zookeeper 作为注册的前置操作都是一样的，其核心是基于 Redis 的 Publish/Subscribe 。和 Zookeeper 相比较，Redis 功能实现会相对繁琐一些，并且其可靠性依赖于 Redis 本身的可靠性，相比较 Redis 一般更常用 Zookeeper 。Redis 作为注册中心的原理还是非常值得学习的，毕竟 Redis 那么流行。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/dafcd048/&quot;&gt;注册中心总览&lt;/a&gt; 中介绍了 Du
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Redis" scheme="https://gentryhuang.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - Zookeeper客户端</title>
    <link href="https://gentryhuang.com/posts/817d6a19/"/>
    <id>https://gentryhuang.com/posts/817d6a19/</id>
    <published>2020-04-19T16:00:00.000Z</published>
    <updated>2020-10-25T04:00:29.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://gentryhuang.com/posts/f70c2f2e/">Dubbo源码分析 - Zookeeper注册中心</a> 中介绍的是 Dubbo 的 Zookeeper 注册中心实现，但是并没有涉及到 Zookeeper 客户端的操作，下面我们介绍 Zookeeper 在 Dubbo 框架中具体实现。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-zookeeper-client.png" alt></p><p>上图的 UML 描述了 Dubbo 封装的 Zookeeper 注册中心和 Zookeeper 相关实现的关系。</p><p>Dubbo 对 Zookeeper 客户端的封装是在 dubbo-remoting-zookeeper 模块中，该模块对 Zookeeper 客户端接口进行了抽象。在 <a href="https://gentryhuang.com/posts/f70c2f2e/">Zookeeper注册中心</a> 中也提到 dubbo-remoting-zookeeper 模块是 dubbo-remoting 模块的子模块，但它并不依赖 dubbo-remoting 中的其他模块，是相对独立的。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubb-zookeeper-module.jpg" alt></p><p>目前支持 ZkClient 和 Curator 两种 Zookeeper 客户端实现：</p><ul><li><p>Curator 实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">...</span> <span class="attr">client</span>=<span class="string">"curator"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>ZkClient 实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">...</span> <span class="attr">client</span>=<span class="string">"zkclient"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>注意:</strong>  </p><ul><li>在2.7.x的版本中已经移除了zkclient的实现,如果要使用zkclient客户端,需要显示配置。下面分析上图的 UML 中涉及的接口和实现类。</li><li>无论服务提供者还是消费者，或者服务治理中心，任何一个节点连接到 Zookeeper 注册中心都需要使用一个客户端。从 Zookeeper 架构的角度来看，使用 Dubbo 的业务节点也只是一个 Zookeeper 客户端。</li></ul><h2 id="ZookeeperTransporter"><a href="#ZookeeperTransporter" class="headerlink" title="ZookeeperTransporter"></a>ZookeeperTransporter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"curator"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ZookeeperTransporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 ZookeeperClient 对象。该方法被 <span class="doctag">@Adaptive</span> 注解修饰，可通过 URL 参数中的 client 或 transporter 参数覆盖 <span class="doctag">@SPI</span> 注解指定的默认扩展名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 注册中心地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ZookeeperClient 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    <span class="function">ZookeeperClient <span class="title">connect</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口是 Dubbo 的扩展点，是 Zookeeper 客户端工厂，就是用来创建 ZookeeperClient 对象的。 默认是使用 CuratorZookeeperTransporter 创建 ZookeeperClient ，后面会详细分析 ZookeeperClient 继承体系。下图是两者 UML 关系图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-zookeeper-transporter.jpg" alt></p><h2 id="StateListener"><a href="#StateListener" class="headerlink" title="StateListener"></a>StateListener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StateListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已断开</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> DISCONNECTED = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> CONNECTED = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已重连</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> RECONNECTED = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态变更回调方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connected 状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">int</span> connected)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口不是真正意义上的监听器，它的实现是一个匿名内部类，在 ZookeeperRegistry 的构造方法中，作为 ZookeeperClient 的状态变化（会话）的回调，具体调用入口是 <code>AbstractZookeeperClient#stateChanged(int)</code> ，主要负责监听 Dubbo 与 Zookeeper 集群的连接状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter，由SPI确定具体的实例。创建好Zookeeper客户端，意味着注册中心的创建完成【Zookeeper服务端必需先启动，Dubbo应用作为Zookeeper的客户端进行连接，然后操作Zookeeper】</span></span><br><span class="line">        zkClient = zookeeperTransporter.connect(url);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加 StateListener 状态监听器，该监听器在重连时，调用恢复方法 recover()，重新发起注册和订阅【将之前已经注册和订阅的数据进行重试】</span></span><br><span class="line"><span class="comment">         * 注意：</span></span><br><span class="line"><span class="comment">         *  StateListener 不是真正意义上的监听器，这里就是创建了一个匿名对象，其中的 #stateChanged 方法触发需要主动调用该匿名对象的该方法 &#123;<span class="doctag">@link</span> AbstractZookeeperClient#stateChanged(int)&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        zkClient.addStateListener(<span class="keyword">new</span> StateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (state == RECONNECTED) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        recover();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ChildListener"><a href="#ChildListener" class="headerlink" title="ChildListener"></a>ChildListener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChildListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子节点发生变化的回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> children 最新的子节点列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">childChanged</span><span class="params">(String path, List&lt;String&gt; children)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口只是一个普通的接口，具体实现是一个匿名内部类，主要监听某个 ZNode 节点下的子节点变化。入口在 ZookeeperRegistry 实现类的 doSubscribe 方法中，该接口的对象最终会用于 Zookeeper 客户端的某个节点下子节点变化的回调方法中，下面我们再分析两种客户端的不同实现。</p><h2 id="ZookeeperClient"><a href="#ZookeeperClient" class="headerlink" title="ZookeeperClient"></a>ZookeeperClient</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ZookeeperClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 节点路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ephemeral 是否临时节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(String path, <span class="keyword">boolean</span> ephemeral)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 节点路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(String path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定节点的子节点集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">getChildren</span><span class="params">(String path)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加 ChildListener</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 节点路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 子节点列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">addChildListener</span><span class="params">(String path, ChildListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除 ChildListener</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 节点路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeChildListener</span><span class="params">(String path, ChildListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加 StateListener</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStateListener</span><span class="params">(StateListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除 StateListener</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeStateListener</span><span class="params">(StateListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获得注册中心 URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZookeeperClient 接口是 Dubbo 对 Zookeeper 客户端接口的抽象，定义了一系列的操作方法，都是用来和 Zookeeper 进行交互的，它的具体子类中封装了 Zookeeper 的客户端对象。</p><h3 id="AbstractZookeeperClient"><a href="#AbstractZookeeperClient" class="headerlink" title="AbstractZookeeperClient"></a>AbstractZookeeperClient</h3><p>ZookeeperClient 接口的抽象类，主要实现了通用的逻辑，如，创建节点，管理 ZookeeperClient 对象添加的监听器，管理 ZookeeperClient 的运行状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 ZookeeperClient 接口，Zookeeper 客户端抽象类，实现通用的逻辑。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;TargetChildListener&gt; 泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">TargetChildListener</span>&gt; <span class="keyword">implements</span> <span class="title">ZookeeperClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractZookeeperClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心 URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * StateListener 状态监听器集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;StateListener&gt; stateListeners = <span class="keyword">new</span> CopyOnWriteArraySet&lt;StateListener&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ChildListener 集合</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * key1：节点路径</span></span><br><span class="line"><span class="comment">     * key2：ChildListener 对象</span></span><br><span class="line"><span class="comment">     * value ：监听器具体对象，不同 Zookeeper 客户端，实现会不同。CuratorZookeeperClient的是CuratorWatcher;ZkclientZookeeperClient 的是 IZkChildListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConcurrentMap&lt;ChildListener, TargetChildListener&gt;&gt; childListeners = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;ChildListener, TargetChildListener&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractZookeeperClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该抽象类中的属性主要四个，stateListeners 和 childListeners 属性用于分别管理 StateListener 和 ChildListener 监听器。其中 stateListeners 属性是当 Zookeeper的状态变化时要通知的对象，childListeners 属性比较关键，是节点路径到其子节点监听器的映射。</p><h3 id="create-创建节点"><a href="#create-创建节点" class="headerlink" title="create 创建节点"></a>create 创建节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">TargetChildListener</span>&gt; <span class="keyword">implements</span> <span class="title">ZookeeperClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String path, <span class="keyword">boolean</span> ephemeral)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!ephemeral) &#123;</span><br><span class="line">            <span class="comment">// 如果要创建的节点类型非临时节点，那么这里要检测节点是否存在。临时节点有序号，不需要考虑覆盖问题</span></span><br><span class="line">            <span class="keyword">if</span> (checkExists(path)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = path.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 递归创建上一级路径</span></span><br><span class="line">            create(path.substring(<span class="number">0</span>, i), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据 ephemeral 的值创建临时或持久节点</span></span><br><span class="line">        <span class="keyword">if</span> (ephemeral) &#123;</span><br><span class="line">            createEphemeral(path);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            createPersistent(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StateListener-操作方法"><a href="#StateListener-操作方法" class="headerlink" title="StateListener 操作方法"></a>StateListener 操作方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">TargetChildListener</span>&gt; <span class="keyword">implements</span> <span class="title">ZookeeperClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入 StateListener 到缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener StateListener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStateListener</span><span class="params">(StateListener listener)</span> </span>&#123;</span><br><span class="line">        stateListeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除缓存中的 StateListener</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeStateListener</span><span class="params">(StateListener listener)</span> </span>&#123;</span><br><span class="line">        stateListeners.remove(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存中的 StateListener </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;StateListener&gt; <span class="title">getSessionListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stateListeners;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历StateListener 数组，回调</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state 状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (StateListener sessionListener : getSessionListeners()) &#123;</span><br><span class="line">            sessionListener.stateChanged(state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StateListener 操作方法很简单，需要注意的是 addStateListener 和 stateChanged 方法，前者是在 ZookeeperRegistry 构造方法中被调用，前文已经说明。后者是当 Zookeeper 客户端的会话变化时会主动调用，下文会说明。</p><h3 id="addChildListener"><a href="#addChildListener" class="headerlink" title="addChildListener"></a>addChildListener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">TargetChildListener</span>&gt; <span class="keyword">implements</span> <span class="title">ZookeeperClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path     订阅url 映射的目录，如 .../providers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 订阅url 映射的目录下子节点变化时执行回调的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addChildListener</span><span class="params">(String path, <span class="keyword">final</span> ChildListener listener)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取/创建：ConcurrentMap&lt;categorypath, ConcurrentMap&lt;ZookeeperRegistry的内部类ChildListener实例, TargetChildListener&gt;&gt; childListeners，这里主要是创建TargetChildListener</span></span><br><span class="line">        ConcurrentMap&lt;ChildListener, TargetChildListener&gt; listeners = childListeners.get(path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">            childListeners.putIfAbsent(path, <span class="keyword">new</span> ConcurrentHashMap&lt;ChildListener, TargetChildListener&gt;());</span><br><span class="line">            listeners = childListeners.get(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得是否已经有该监听器</span></span><br><span class="line">        TargetChildListener targetListener = listeners.get(listener);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// zk监听器对象不存在，进行创建</span></span><br><span class="line">        <span class="keyword">if</span> (targetListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1 创建一个监听path下子节点的watcher【CuratorZookeeperClient实现】或 IZkChildListener 【ZkclientZookeeperClient实现】</span></span><br><span class="line"><span class="comment">             * 2 当path下有子节点变化时，调用listener（即传入的ZookeeperRegistry的内部类ChildListener实例的childChanged(String parentPath, List&lt;String&gt; currentChilds)方法）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            listeners.putIfAbsent(listener, createTargetChildListener(path, listener));</span><br><span class="line">            targetListener = listeners.get(listener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向 Zookeeper ，真正发起订阅，即为 path添加TargetChildListener监听器实例</span></span><br><span class="line">        <span class="keyword">return</span> addTargetChildListener(path, targetListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法，创建真正的 ChildListener 对象。因为，每个 Zookeeper 的库，实现不同。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> TargetChildListener <span class="title">createTargetChildListener</span><span class="params">(String path, ChildListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向 Zookeeper ，真正发起订阅</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;String&gt; <span class="title">addTargetChildListener</span><span class="params">(String path, TargetChildListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向 Zookeeper ，真正发起取消订阅</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeTargetChildListener</span><span class="params">(String path, TargetChildListener listener)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>createTargetChildListener(path, listener)</code> 方法和 <code>addTargetChildListener(path, targetListener)</code> 方法都是抽象方法，由 AbstractZookeeperClient 的子类实现，TargetChildListener 是 AbstractZookeeperClient 中标记的一个泛型。因为 ZookeeperClient 实现可能依赖不同的 Zookeeper 客户端组件，不同的 Zookeeper 客户端组件的监听器实现是不同的，而整个 dubbo-remoting-zookeeper 模块进行了抽象，对外暴露的监听器是统一的，使用泛型进行了转换，原则上抽象一个接口也是可以的。该方法的核心就是为订阅 URL 映射的节点绑定一个子节点监听器，子节点发生变化时会被子节点监听器捕捉到，然后将变化的数据信息通过 ChildListener 匿名对象的方法传递出去，下面会结合具体的 Zookeeper 客户端说明。</p><h3 id="removeChildListener"><a href="#removeChildListener" class="headerlink" title="removeChildListener"></a>removeChildListener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">TargetChildListener</span>&gt; <span class="keyword">implements</span> <span class="title">ZookeeperClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeChildListener</span><span class="params">(String path, ChildListener listener)</span> </span>&#123;</span><br><span class="line">        ConcurrentMap&lt;ChildListener, TargetChildListener&gt; listeners = childListeners.get(path);</span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TargetChildListener targetListener = listeners.remove(listener);</span><br><span class="line">            <span class="keyword">if</span> (targetListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 向 Zookeeper ，真正发起取消订阅</span></span><br><span class="line">                removeTargetChildListener(path, targetListener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用于解除 path 目录的子节点变化监听器。</p><h3 id="目录的子节点变化监听器操作"><a href="#目录的子节点变化监听器操作" class="headerlink" title="目录的子节点变化监听器操作"></a>目录的子节点变化监听器操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">TargetChildListener</span>&gt; <span class="keyword">implements</span> <span class="title">ZookeeperClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 抽象方法，创建真正的 ChildListener 对象。因为，每个 Zookeeper 的库，实现不同。</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> TargetChildListener <span class="title">createTargetChildListener</span><span class="params">(String path, ChildListener listener)</span></span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 向 Zookeeper ，真正发起订阅</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;String&gt; <span class="title">addTargetChildListener</span><span class="params">(String path, TargetChildListener listener)</span></span>;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 向 Zookeeper ，真正发起取消订阅</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeTargetChildListener</span><span class="params">(String path, TargetChildListener listener)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三个方法是用来对 path 目录下的子节点的监听器进行操作的，具体逻辑交给子类实现。下面我们详细分析 AbstractZookeeperClient 的两个具体实现类。</p><h3 id="CuratorZookeeperClient"><a href="#CuratorZookeeperClient" class="headerlink" title="CuratorZookeeperClient"></a>CuratorZookeeperClient</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorZookeeperClient</span> <span class="keyword">extends</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">CuratorWatcher</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Zookeeper 的 Curator 客户端对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CuratorZookeeperClient 构造方法主要用于创建和启动 CuratorFramework 实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CuratorZookeeperClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 CuratorFramework 构造器</span></span><br><span class="line">            CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()</span><br><span class="line">                    <span class="comment">// 连接地址</span></span><br><span class="line">                    .connectString(url.getBackupAddress())</span><br><span class="line">                    <span class="comment">// 重试策略: 重试次数：1，每次重试间隔： 1000 ms</span></span><br><span class="line">                    .retryPolicy(<span class="keyword">new</span> RetryNTimes(<span class="number">1</span>, <span class="number">1000</span>))</span><br><span class="line">                    <span class="comment">// 连接超时时间</span></span><br><span class="line">                    .connectionTimeoutMs(<span class="number">5000</span>);</span><br><span class="line">            String authority = url.getAuthority();</span><br><span class="line">            <span class="keyword">if</span> (authority != <span class="keyword">null</span> &amp;&amp; authority.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                builder = builder.authorization(<span class="string">"digest"</span>, authority.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 构建 CuratorFramework 实例</span></span><br><span class="line">            client = builder.build();</span><br><span class="line">            <span class="comment">// 添加连接监听器。在连接状态发生变化时，调用#stateChange(state)方法，进行StateListener的回调</span></span><br><span class="line">            client.getConnectionStateListenable().addListener(<span class="keyword">new</span> ConnectionStateListener() &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 在连接状态发生变化时，调用 #stateChange(state) 方法，进行 StateListener 的回调。</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment">                 * <span class="doctag">@param</span> state</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState state)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (state == ConnectionState.LOST) &#123;</span><br><span class="line">                        CuratorZookeeperClient.<span class="keyword">this</span>.stateChanged(StateListener.DISCONNECTED);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == ConnectionState.CONNECTED) &#123;</span><br><span class="line">                        CuratorZookeeperClient.<span class="keyword">this</span>.stateChanged(StateListener.CONNECTED);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == ConnectionState.RECONNECTED) &#123;</span><br><span class="line">                        CuratorZookeeperClient.<span class="keyword">this</span>.stateChanged(StateListener.RECONNECTED);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 启动客户端 (当连接不上zk服务时，默认将一直重试)</span></span><br><span class="line">            client.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 CuratorZookeeperClient 的属性中，可以得到上文中的一个答案，stateChanged 方法调用的入口，CuratorZookeeperClient 构造方法执行完毕，Zookeeper 的 Curator 客户端连接创建完毕。</p><h4 id="操作节点方法"><a href="#操作节点方法" class="headerlink" title="操作节点方法"></a>操作节点方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorZookeeperClient</span> <span class="keyword">extends</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">CuratorWatcher</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 path 持久节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPersistent</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.create().forPath(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NodeExistsException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 path 临时节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createEphemeral</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.create().withMode(CreateMode.EPHEMERAL).forPath(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NodeExistsException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 path 节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path 节点路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.delete().forPath(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoNodeException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 path 节点下的子节点列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getChildren</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> client.getChildren().forPath(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoNodeException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查 path 节点是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkExists</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (client.checkExists().forPath(path) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接是否已经关闭</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.getZookeeperClient().isConnected();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CuratorZookeeperClient 中的操作节点的方法很简单，直接调用 Curator 的 API 即可。</p><h4 id="子节点监听器"><a href="#子节点监听器" class="headerlink" title="子节点监听器"></a>子节点监听器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorZookeeperClient</span> <span class="keyword">extends</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">CuratorWatcher</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个监听path子节点的watcher 注意：这里只是创建一个CuratorWatcher监听器，并没有对节点进行绑定</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CuratorWatcher <span class="title">createTargetChildListener</span><span class="params">(String path, ChildListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CuratorWatcherImpl(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为path节点绑定CuratorWatcher监听器，并返回path的子路径列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addTargetChildListener</span><span class="params">(String path, CuratorWatcher listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> client.getChildren().usingWatcher(listener).forPath(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoNodeException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeTargetChildListener</span><span class="params">(String path, CuratorWatcher listener)</span> </span>&#123;</span><br><span class="line">        ((CuratorWatcherImpl) listener).unwatch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现CuratorWatcher接口，实现监听器功能。CuratorWatcherImpl 就是 CuratorZookeeperClient 实现 AbstractZookeeperClient 时指定的泛型类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorWatcherImpl</span> <span class="keyword">implements</span> <span class="title">CuratorWatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ChildListener 匿名对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> ChildListener listener;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CuratorWatcherImpl</span><span class="params">(ChildListener listener)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.listener = listener;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unwatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.listener = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 当path节点下的子节点发生变化的时候，会首先调用TargetChildListener的process(WatchedEvent event)方法，</span></span><br><span class="line"><span class="comment">         * 2 在该方法中又会调用ChildListener实例的childChanged(String parentPath, List&lt;String&gt; currentChilds)方法</span></span><br><span class="line"><span class="comment">         * 3 配置信息还是通过客户端拉取</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String path = event.getPath() == <span class="keyword">null</span> ? <span class="string">""</span> : event.getPath();</span><br><span class="line">                <span class="comment">// 主动调用ChildListener 匿名对象的方法</span></span><br><span class="line">                listener.childChanged(path,</span><br><span class="line">                        <span class="comment">// if path is null, curator using watcher will throw NullPointerException.</span></span><br><span class="line">                        <span class="comment">// if client connect or disconnect to server, zookeeper will queue</span></span><br><span class="line">                        <span class="comment">// watched event(Watcher.Event.EventType.None, .., path = null).</span></span><br><span class="line">                        StringUtils.isNotEmpty(path)</span><br><span class="line">                                ? client.getChildren().usingWatcher(<span class="keyword">this</span>).forPath(path) <span class="comment">// 重新发起连接，并传入最新的子节点列表</span></span><br><span class="line">                                : Collections.&lt;String&gt;emptyList());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子节点监听器，核心是实现 CuratorWatcher 接口，实现监听器功能，CuratorWatcherImpl 就是 CuratorZookeeperClient 实现 AbstractZookeeperClient 时指定的泛型类。当监听的节点下的子节点发生变化时，会在监听器的回调方法中主动调用 ChildListener 匿名对象的 childChanged 方法，这是 Dubbo 中订阅的核心点。</p><h3 id="ZkclientZookeeperClient"><a href="#ZkclientZookeeperClient" class="headerlink" title="ZkclientZookeeperClient"></a>ZkclientZookeeperClient</h3><p>ZkclientZookeeperClient 并没有直接封装 ZkClient 对象，而是通过 ZkClientWrapper 封装了 ZkClient 对象，我们先来分析 ZkClientWrapper。</p><h4 id="ZkClientWrapper"><a href="#ZkClientWrapper" class="headerlink" title="ZkClientWrapper"></a>ZkClientWrapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkClientWrapper</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(ZkClientWrapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Zookeeper 的 ZkClient 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ZkClient client;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> KeeperState state;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FutureTask</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ListenableFutureTask&lt;ZkClient&gt; listenableFutureTask;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverAddr Zookeeper 服务端地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout    超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZkClientWrapper</span><span class="params">(<span class="keyword">final</span> String serverAddr, <span class="keyword">long</span> timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">        listenableFutureTask = ListenableFutureTask.create(<span class="keyword">new</span> Callable&lt;ZkClient&gt;() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 通过回调创建 Zookeeper 的 ZkClient 客户端</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ZkClient <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ZkClient(serverAddr, Integer.MAX_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Z ookeeper 的 ZkClient 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">            Thread connectThread = <span class="keyword">new</span> Thread(listenableFutureTask);</span><br><span class="line">            connectThread.setName(<span class="string">"DubboZkclientConnector"</span>);</span><br><span class="line">            connectThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            connectThread.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                client = listenableFutureTask.get(timeout, TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.error(<span class="string">"Timeout! zookeeper server can not be connected in : "</span> + timeout + <span class="string">"ms!"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.warn(<span class="string">"Zkclient has already been started!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置客户端监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(<span class="keyword">final</span> IZkStateListener listener)</span> </span>&#123;</span><br><span class="line">        listenableFutureTask.addListener(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    client = listenableFutureTask.get();</span><br><span class="line">                    client.subscribeStateChanges(listener);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    logger.warn(Thread.currentThread().getName() + <span class="string">" was interrupted unexpectedly, which may cause unpredictable exception!"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Got an exception when trying to create zkclient instance, can not connect to zookeeper server, please check!"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ZkClient 是否处理连接状态</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client != <span class="keyword">null</span> &amp;&amp; state == KeeperState.SyncConnected;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 ZkClient AIP 创建持久节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPersistent</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        client.createPersistent(path, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 ZkClient AIP 创建临时节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createEphemeral</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        client.createEphemeral(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 ZkClient AIP 删除节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        client.delete(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 ZkClient AIP 获取 path 节点下的子节点列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getChildren</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        <span class="keyword">return</span> client.getChildren(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 ZkClient AIP 判断是否存在 path 节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        <span class="keyword">return</span> client.exists(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断开 Zookeeper 连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为 path 节点绑定其子节点的监听器，用于监听 path 节点下子节点的变化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">subscribeChildChanges</span><span class="params">(String path, <span class="keyword">final</span> IZkChildListener listener)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        <span class="keyword">return</span> client.subscribeChildChanges(path, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 path 节点的子节点监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribeChildChanges</span><span class="params">(String path, IZkChildListener listener)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(client, <span class="keyword">new</span> IllegalStateException(<span class="string">"Zookeeper is not connected yet!"</span>));</span><br><span class="line">        client.unsubscribeChildChanges(path, listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZkClientWrapper 用来创建 Zookeeper 的 ZkClient 客户端，并调用 ZkClient API 操作节点以及绑定监听器，代码已经详细注释。下面我们继续看 ZkclientZookeeperClient 实现类。</p><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkclientZookeeperClient</span> <span class="keyword">extends</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">IZkChildListener</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装了 Zookeeper 的 ZkClient 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZkClientWrapper client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> KeeperState state = KeeperState.SyncConnected;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ZkclientZookeeperClient 构造方法主要用于创建和启动 ZkClient 实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZkclientZookeeperClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 ZkClientWrapper 【包装了ZkClient,实现监听】</span></span><br><span class="line">        client = <span class="keyword">new</span> ZkClientWrapper(url.getBackupAddress(), <span class="number">30000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听器到 ZkClient 对象</span></span><br><span class="line">        client.addListener(<span class="keyword">new</span> IZkStateListener() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 处理状态变化</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> state</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStateChanged</span><span class="params">(KeeperState state)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ZkclientZookeeperClient.<span class="keyword">this</span>.state = state;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 状态变更进行回调 &#123;<span class="doctag">@link</span> StateListener#stateChanged(int)&#125;</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (state == KeeperState.Disconnected) &#123;</span><br><span class="line">                    stateChanged(StateListener.DISCONNECTED);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == KeeperState.SyncConnected) &#123;</span><br><span class="line">                    stateChanged(StateListener.CONNECTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 处理新会话 （处理失败重连），最终会回调&#123;<span class="doctag">@link</span> StateListener#stateChanged(int)&#125;</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNewSession</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                stateChanged(StateListener.RECONNECTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client 属性对应的 ZkClientWrapper 中封装了 ZkClient 客户端对象，构造方法主要做了两件事，创建 ZkClient 并为其绑定状态监听器。</p><h4 id="操作节点方法-1"><a href="#操作节点方法-1" class="headerlink" title="操作节点方法"></a>操作节点方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkclientZookeeperClient</span> <span class="keyword">extends</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">IZkChildListener</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用 ZkClientWrapper 的 createPersistent 方法，以下同理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPersistent</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.createPersistent(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZkNodeExistsException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createEphemeral</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.createEphemeral(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZkNodeExistsException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.delete(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZkNoNodeException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getChildren</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> client.getChildren(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ZkNoNodeException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkExists</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> client.exists(path);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state == KeeperState.SyncConnected;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子节点监听器-1"><a href="#子节点监听器-1" class="headerlink" title="子节点监听器"></a>子节点监听器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkclientZookeeperClient</span> <span class="keyword">extends</span> <span class="title">AbstractZookeeperClient</span>&lt;<span class="title">IZkChildListener</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建节点监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IZkChildListener <span class="title">createTargetChildListener</span><span class="params">(String path, <span class="keyword">final</span> ChildListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IZkChildListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 监听的子节点发生变化会回调该方法，方法主动调用 ChildListener的匿名对象的方法</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> parentPath 父节点</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> currentChilds 子节点列表</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleChildChange</span><span class="params">(String parentPath, List&lt;String&gt; currentChilds)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                listener.childChanged(parentPath, currentChilds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为 path 节点绑定子节点监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener path的子节点监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addTargetChildListener</span><span class="params">(String path, <span class="keyword">final</span> IZkChildListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> client.subscribeChildChanges(path, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除 path 节点绑定的子节点监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener path的子节点监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeTargetChildListener</span><span class="params">(String path, IZkChildListener listener)</span> </span>&#123;</span><br><span class="line">        client.unsubscribeChildChanges(path, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现上和 Curator 客户端有所差别，但本质上是相同的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，dubbo-remoting-zookeeper 模块的核心实现就介绍完了，该模块作为 Dubbo 与 Zookeeper 交互的基础，不仅支撑了基于 Zookeeper 的注册中心的实现，还支撑了基于 Zookeeper 的服务发现的实现。Dubbo 中的 Zookeeper 客户端主要两部分操作，节点的操作和节点监听器的操作，节点的操作主要是注册服务的元数据信息，节点监听器的操作主要是用于订阅通知，订阅通知依赖服务节点的元数据变化信息，这正是监听器来完成的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/f70c2f2e/&quot;&gt;Dubbo源码分析 - Zookee
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - Zookeeper注册中心</title>
    <link href="https://gentryhuang.com/posts/f70c2f2e/"/>
    <id>https://gentryhuang.com/posts/f70c2f2e/</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2020-11-14T03:14:54.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://gentryhuang.com/posts/dafcd048/">注册中心总览</a> 中介绍了 Dubbo 的注册中心抽象层，包括注册中心及其工厂。本篇文章将介绍 Dubbo 的 Zookeeper 注册中心及其工厂。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubb-zookeeper.png" alt></p><p>UML 图中 <code>ZookeeperRegistryFactory</code> 中有个 <code>ZookeeperTransporter</code> 属性，该属性就是创建 Zookeeper 客户端的关键对象，下一篇文章会详细介绍 Dubbo 对 Zookeeper 客户端的封装。</p><h2 id="Dubbo-中的-Zookeeper-注册中心"><a href="#Dubbo-中的-Zookeeper-注册中心" class="headerlink" title="Dubbo 中的 Zookeeper 注册中心"></a>Dubbo 中的 Zookeeper 注册中心</h2><p>Zookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。下图是 Dubbo 使用 Zookeeper 作为注册中心的元数据信息：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubb-zookeeper-meta.jpg" alt></p><br><p><strong>Dubbo 中的 Zookeeper 注册中心说明</strong></p><p>Zookeeper 是树形结构的注册中心，每个节点的类型分为持久节点、持久顺序节点、临时节点和临时顺序节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">持久节点：服务注册后保证节点不会丢失，注册中心重启也会存在。</span><br><span class="line">持久顺序节点：在持久节点特性的基础上增加了节点先后顺序的特点。</span><br><span class="line">临时节点：节点注册后，如果客户端与服务端的连接断开或会话超时，节点会自动被删除。</span><br><span class="line">临时顺序节点：在临时节点特性的基础上增加了节点先后属性的特点。</span><br></pre></td></tr></table></figure><p>Dubbo 使用 Zookeeper 作为注册中心时，只会创建持久节点和临时节点，不关心节点的顺序。</p><p><strong>节点路径说明</strong></p><ul><li>Root 层：Zookeeper的根目录，默认是 dubbo ，也可以进行设置。对应图中的dubbo。</li><li>Service 层：服务接口的全路径名，对应图中的 <em>com.foo.BarService</em> 。</li><li>Type 层：目录，对于 Dubbo 而言就是分类，目前 Dubbo 有四个分类，服务提供者列表（providers）、服务消费者列表（consumers）、路由规则列表（routers）和 配置规则列表(configurators)</li><li>URL 层：Dubbo 的 URL，可以是服务提供者 URL、服务消费者 URL、路由规则 URL、以及配置规则 URL，具体哪类，看在哪个 Type 层下。</li></ul><p>注意，URL 层的元数据信息是临时节点，其上层的节点是持久节点。</p><p><strong>树形结构的关系</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dubbo</span><br><span class="line">  +-- service</span><br><span class="line">    +-- providers</span><br><span class="line">    +-- consumers</span><br><span class="line">    +-- routers</span><br><span class="line">    +-- configurators</span><br></pre></td></tr></table></figure><ul><li>树的根节点默认是dubbo，下面有多个服务接口，根节点可以手动设置。</li><li>服务接口下包含四种子目录，分别是 providers、consumers、routers、configurators，这些路径是持久节点。</li><li>服务提供者目录[/dubbo/service/providers]下面包含的接口有多个服务提供者URL元数据信息</li><li>服务消费者目录[/dubbo/service/consumers]下面包含的接口有多个消费者URL元数据信息</li><li>路由规则目录[/dubbo/service/routers]下面包含多个用于消费者路由策略URL元数据信息</li><li>动态配置目录[/dubbo/service/configurators]下面包含多个用于服务提供者动态配置URL元数据信息</li></ul><p>在 Dubbo 框架启动启动时，会根据用户配置的服务，在 Zookeeper 注册中心中创建4个目录，这里说的 Dubbo 框架启动包括提供者和消费者启动。</p><p><strong>流程简单说明：</strong></p><ul><li>服务提供者启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址</li><li>服务消费者启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址</li><li>监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址</li></ul><p><font color="#c7254e">注意:</font> 上面描述的并不是完整的流程，只是根据图进行简单说明，比如，服务提供者不仅写入了自己的 URL 地址，还订阅了 <strong>configurators</strong> 目录下的 URL 地址，消费者除了订阅 <strong>providers</strong> 目录下的 URL 地址，还订阅了 <strong>routers</strong> 和 <strong>configurators</strong> 目录下的 URL 地址。 在 Dubbo 框架进行服务调用时，用户可以通过服务治理平台在运行时改变服务参数，服务端会通过订阅机制决定是否需要重新暴露服务，消费端通过订阅机制决定是否更新服务目录等。</p><p><strong>支持但不限于以下功能：</strong></p><ul><li>当提供者出现断电等异常停机时，注册中心能自动删除提供者信息</li><li>当注册中心重启时，能自动恢复注册数据，以及订阅请求</li><li>当会话过期时，能自动恢复注册数据，以及订阅请求</li><li>当设置 &lt;dubbo:registry check=”false” /&gt; 时，记录失败注册和订阅请求，后台定时重试</li><li>可通过 &lt;dubbo:registry username=”admin” password=”1234” /&gt; 设置 zookeeper 登录信息</li><li>可通过 &lt;dubbo:registry group=”dubbo” /&gt; 设置 zookeeper 的根节点，不配置将使用默认的根节点。</li><li>支持 * 号通配符 &lt;dubbo:reference group=”*” version=”*” /&gt;，可订阅服务的所有分组和所有版本的提供者</li></ul><h2 id="ZookeeperRegistryFactory"><a href="#ZookeeperRegistryFactory" class="headerlink" title="ZookeeperRegistryFactory"></a>ZookeeperRegistryFactory</h2><p>实现 AbstractRegistryFactory 抽象类，该抽象类仅仅是提供了缓存 Registry 对象的功能，具体创建逻辑交给子类完成，这里是 ZookeeperRegistry 的工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistryFactory</span> <span class="keyword">extends</span> <span class="title">AbstractRegistryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * zookeeperTransporter 由 SPI 在运行时注入，类型为 ZookeeperTransporter$Adaptive。 是Zookeeper的客户端工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ZookeeperTransporter zookeeperTransporter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置Zookeeper客户端 工厂，该方法通过Dubbo IOC 注入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zookeeperTransporter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZookeeperTransporter</span><span class="params">(ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zookeeperTransporter = zookeeperTransporter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ZookeeperRegistry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZookeeperRegistryFactory 就是用来创建 ZookeeperRegistry 对象的，而 ZookeeperRegistry 对象需要依赖创建 Zookeeper 客户端的 ZookeeperTransporter 对象，该对象是通过 Dubbo IOC 注入的，详细可参考 <a href="https://gentryhuang.com/posts/5d81f464/"> Dubbo SPI</a> 。ZookeeperTransporter 所在的模块是 dubbo-remoting-zookeeper ，它虽然是 dubbo-remoting 模块的子模块，但它并不依赖 dubbo-remoting 中的其它模块，是相对独立的，我们在下一篇文章中介绍它。 下面我们来看看 ZookeeperRegistry 的实现。</p><h2 id="ZookeeperRegistry"><a href="#ZookeeperRegistry" class="headerlink" title="ZookeeperRegistry"></a>ZookeeperRegistry</h2><p>该类继承抽象类 FailbackRegistry ，具有重试功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZookeeperRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ZookeeperRegistry<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Zookeeper 默认端口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_ZOOKEEPER_PORT = <span class="number">2181</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo 元数据写入Zookeeper上的根节点，默认值是 dubbo </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT_ROOT = <span class="string">"dubbo"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Zookeeper 根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service 接口全名集合。该属性适合用于监控中心，订阅整个Service层，因为Service层是动态的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; anyServices = <span class="keyword">new</span> ConcurrentHashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听器集合，建立NotifyListener和ChildListener的映射关系，k1为订阅URL,k2为监听器,value为ChildListener【真正起作用的对象】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt; zkListeners = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Zookeeper 客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZookeeperClient zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"registry address == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取组名，默认为 'dubbo'，url.parameters.group 参数值，即Zookeeper的根节点</span></span><br><span class="line">        String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">        <span class="keyword">if</span> (!group.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">            <span class="comment">// 订正路径： group = "/" + group;</span></span><br><span class="line">            group = Constants.PATH_SEPARATOR + group;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确定根路径，以组名作为根路径</span></span><br><span class="line">        <span class="keyword">this</span>.root = group;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter，由SPI确定具体的实例。创建好Zookeeper客户端，意味着注册中心的创建完成【Zookeeper服务端必需先启动，Dubbo应用作为Zookeeper的客户端进行连接，然后操作Zookeeper】</span></span><br><span class="line">        zkClient = zookeeperTransporter.connect(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加 StateListener 状态监听器，该监听器在重连时，调用恢复方法 recover()，重新发起注册和订阅【将之前已经注册和订阅的数据进行重试】</span></span><br><span class="line"><span class="comment">         * 注意：</span></span><br><span class="line"><span class="comment">         *  StateListener 不是真正意义上的监听器，这里就是创建了一个匿名对象，其中的 #stateChanged 方法触发需要主动调用该匿名对象的该方法 &#123;<span class="doctag">@link</span> AbstractZookeeperClient#stateChanged(int)&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        zkClient.addStateListener(<span class="keyword">new</span> StateListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (state == RECONNECTED) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        recover();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ZookeeperRegistry 的构造方法中，会通过 ZookeeperTransporter 创建 ZookeeperClient 实例并连接到 Zookeeper 集群，同时还会添加一个连接状态的监听器。在该监听器中主要关注RECONNECTED 状态，在当前 Dubbo 节点于 Zookeeper 的连接恢复时，会重新进行注册，订阅操作，防止数据丢失。</p><h3 id="doRegister-注册"><a href="#doRegister-注册" class="headerlink" title="doRegister 注册"></a>doRegister 注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZookeeperRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用Zookeeper客户端创建服务节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1 通过 Zookeeper 客户端创建节点，节点路径由 toUrlPath 方法生成，路径格式如下: /$&#123;group&#125;/$&#123;serviceInterface&#125;/$&#123;Type&#125;/$&#123;url&#125;</span></span><br><span class="line"><span class="comment">             * 比如： /dubbo/com.alibaba.dubbo.demo.DemoService/providers/dubbo%3A%2F%2F127.0.0.1......</span></span><br><span class="line"><span class="comment">             * 2 url.parameters.dynamic ,是否动态数据。若为false，该数据为持久数据，当注册方退出时，数据仍然保存在注册中心</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to register "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>该方法是实现了其父类 FailbackRegistry 的模版方法，使用 Zookeeper 客户端进行节点的创建。服务提供者和消费者都需要把自己注册到注册中心，服务提供者的注册是为了让消费者发现自己从而发起远程调用。也让治理中心感知有新的服务提供者上线。消费者的发布是为了让服务治理中心发现自己。</p><h3 id="doUnregister-取消注册"><a href="#doUnregister-取消注册" class="headerlink" title="doUnregister 取消注册"></a>doUnregister 取消注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZookeeperRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 取消注册，删除节点</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doUnregister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             zkClient.delete(toUrlPath(url));</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to unregister "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>该方法是实现了其父类 FailbackRegistry 的模版方法，使用 Zookeeper 客户端进行节点的删除。</p><h3 id="doSubscribe-订阅"><a href="#doSubscribe-订阅" class="headerlink" title="doSubscribe 订阅"></a>doSubscribe 订阅</h3><p>订阅通常有 pull 和 push 两种方式，一种是客户端定时轮询注册中心拉取配置，另一种是注册中心主动推送数据给客户端。目前 Dubbo 采用的是 <strong>第一次启动拉取方式，后续接收事件重新拉取数据</strong>。在服务暴露时，服务提供者会订阅 <code>configurators</code> 用于监听动态配置。在消费端启动时，消费者会订阅 <code>providers</code>,<code>routers</code> 和 <code>configurators</code> 这三个目录，用于分别监听服务提供者、路由规则和动态配置。Zookeeper 注册中心采用的是 <strong>事件通知 + 客户端拉取</strong> 的方式，第一次订阅时会把对应目录下的全量数据都拉取过来（客户端拉取），并在订阅的节点上注册监听器监听其子节点的变化。客户端与注册中心之间保持 TCP 长连接，后续每个订阅节点有任何数据变化（子节点变化也属于该节点变化，具体可参数ZK客户端API）时，注册中心会根据监听器的回调主动通知客户端（事件通知），客户端接到通知后，会把对应节点下的全量数据都拉取过来（客户端拉取），即子节点变化时监听器捕捉到事件后会回调它的方法，该回调方法会调用<code>childChanged</code>方法，而<code>childChanged</code>方法会把对应节点下的全量数据都拉取过来（客户端拉取）。需要说明的，Zookeeper 监听器被触发时，由 Zookeeper 集群<strong>主动</strong>将更新推送给 Zookeeper 客户端，而不需要客户端轮询。 Dubbo 应用作为一个 Zookeeper 客户端，当监听的节点发生变化时 Zookeeper 集群会主动把对应节点下的更新推送给 Zookeeper 客户端也就是 Dubbo 应用，这个过程是注册中心主动推的，但 Dubbo 是将这个更新通过自己内部的方法 <code>childChanged</code> 传递出去的，这个过程属于客户端拉取。这样我们就明白了，在 Dubbo 使用 Zookeeper 作为注册中心时，获取配置信息总体来说采用的都是客户端拉取的方式，在注册监听器后的情况是更新的数据会被 Zookeeper 集群主动推送过来，然后在 Zookeeper 监听的回调方法中 Dubbo 调用内部方法把数据传递出去，这一定意义上是拉取的方式。 </p><p>订阅有两种情况，一种是服务治理中心会处理所有Service层订阅，Service被设置成统配符，另一种是某一个Service层的订阅。订阅的核心是通过 ZookeeperClient 在指定的路径上（category节点）添加 <code>ChildListener</code> 监听器，当订阅的节点发生变化时，会通过 <code>ChildListener</code> 监听器触发 <code>notify</code> 方法，进而触发 <code>NotifyListener</code> 监听器。</p><h4 id="服务治理中心订阅"><a href="#服务治理中心订阅" class="headerlink" title="服务治理中心订阅"></a>服务治理中心订阅</h4><p>服务治理中心订阅最终的处理还是会走某个Service层的订阅逻辑。这个分支的处理逻辑是在根节点上添加一个 ChildListener 监听器，当 Service 层的节点变化时，会触发这个 ChildListener。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ----------------- 订阅所有Service层的节点，例如监控中心的订阅 ---------------------/</span></span><br><span class="line">            <span class="keyword">if</span> (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123; <span class="comment">// service 层是 *</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据节点</span></span><br><span class="line">                String root = toRootPath();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获的订阅的url 对应的监听器集合</span></span><br><span class="line">                ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不存在，进行创建</span></span><br><span class="line">                <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    zkListeners.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;NotifyListener, ChildListener&gt;());</span><br><span class="line">                    listeners = zkListeners.get(url);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ChildListener zkListener = listeners.get(listener);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不存在ChildListener 对象，进行创建ChildListener对象</span></span><br><span class="line">                <span class="keyword">if</span> (zkListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    listeners.putIfAbsent(listener, <span class="keyword">new</span> ChildListener() &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 节点变化回调，根节点下的子节点有变化就回调。</span></span><br><span class="line"><span class="comment">                         * <span class="doctag">@param</span> parentPath 根节点</span></span><br><span class="line"><span class="comment">                         * <span class="doctag">@param</span> currentChilds 根节点下的 service 层节点列表</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childChanged</span><span class="params">(String parentPath, List&lt;String&gt; currentChilds)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 遍历子节点列表</span></span><br><span class="line">                            <span class="keyword">for</span> (String child : currentChilds) &#123;</span><br><span class="line">                                <span class="comment">// 解码</span></span><br><span class="line">                                child = URL.decode(child);</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 如果存在子节点还未被订阅，则说明是新的节点，则发起该Service层的订阅，走另一个分支</span></span><br><span class="line">                                <span class="keyword">if</span> (!anyServices.contains(child)) &#123;</span><br><span class="line">                                    <span class="comment">// 记录该节点已经订阅过</span></span><br><span class="line">                                    anyServices.add(child);</span><br><span class="line">                                    <span class="comment">// 处理具体 service 层订阅</span></span><br><span class="line">                                    subscribe(url.setPath(child).addParameters(Constants.INTERFACE_KEY, child, Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)), listener);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    zkListener = listeners.get(listener);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建Service 节点，该节点为持久化节点</span></span><br><span class="line">                zkClient.create(root, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 向Zookeeper service节点发起订阅</span></span><br><span class="line">                List&lt;String&gt; services = zkClient.addChildListener(root, zkListener);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 首次订阅时，要处理当前已有的 Service 层的订阅，调用subscribe(url,listener)，即走另一个分支</span></span><br><span class="line">                <span class="keyword">if</span> (services != <span class="keyword">null</span> &amp;&amp; !services.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String service : services) &#123;</span><br><span class="line">                        service = URL.decode(service);</span><br><span class="line">                        anyServices.add(service);</span><br><span class="line">                        subscribe(url.setPath(service).addParameters(Constants.INTERFACE_KEY, service, Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)), listener);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// $&#123;某个Service 层订阅&#125;</span></span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该分支是订阅根节点下的所有Service层数据，当Service层发生变更时，若变更的有新增Service接口，即新增服务，则调用subscribe(url,listener)方法发起订阅，走处理指定Service层节点的逻辑。</p><h4 id="订阅指定Service层节点"><a href="#订阅指定Service层节点" class="headerlink" title="订阅指定Service层节点"></a>订阅指定Service层节点</h4><p>该方法会根据订阅 URL 中的 category 属性获取关注的 category 节点集合，然后在每个 category 节点上添加 ChildListener 监听器。首次订阅或监听的 category 节点数据发生变化，会拉取该类别下的子节点的数据进行通知。</p><ul><li>如果是providers类别的数据，则订阅方（一般是消费者）会更新本地的服务目录。</li><li>如果是routers类别的数据，则订阅方会更新本地路由规则列表。</li><li>如果是configurators类别的数据，则订阅方会更新或覆盖本地动态参数列表。</li><li>如果是consumers类别的数据，则服务治理中心会更新缓存中的数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//----------------- 订阅所有Service层的节点，例如监控中心的订阅 ------------------------/</span></span><br><span class="line">            <span class="keyword">if</span> (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123; <span class="comment">// service 层是 *</span></span><br><span class="line">              <span class="comment">// $&#123;所有Service 层订阅&#125;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * ConcurrentMap&lt;URL, ConcurrentMap&lt;NotifyListener, ChildListener&gt;&gt; zkListeners</span></span><br><span class="line"><span class="comment">                 * 1 根据url获取ConcurrentMap&lt;NotifyListener, ChildListener&gt;，没有就创建</span></span><br><span class="line"><span class="comment">                 * 2 根据listener从ConcurrentMap&lt;NotifyListener, ChildListener&gt;获取ChildListener，没有就创建</span></span><br><span class="line"><span class="comment">                 * 3 创建path持久化节点</span></span><br><span class="line"><span class="comment">                 * 4 创建path子节点监听器</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 子节点数据数组</span></span><br><span class="line">                List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环分类数组，其中，调用toCategoriesPath(url)方法，解析订阅url获得分类数组，即要订阅的path，如：/dubbo/com.alibaba.dubbo.demo.DemoService/configurators </span></span><br><span class="line">                <span class="keyword">for</span> (String path : toCategoriesPath(url)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获得分类路径（由订阅的url得到的） 对应的监听器映射</span></span><br><span class="line">                    ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 不存在，进行创建</span></span><br><span class="line">                    <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        zkListeners.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;NotifyListener, ChildListener&gt;());</span><br><span class="line">                        listeners = zkListeners.get(url);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 1 获得listener(NotifyListener)对应的ChildListener对象，没有就会创建，一个NotifyListener关联一个ChildListener。</span></span><br><span class="line"><span class="comment">                     * 注意：</span></span><br><span class="line"><span class="comment">                     * ChildListener的childChanged方法实际上就是当parentPath[即toCategoriesPath方法处理后的path]下的currentChilds发生变化时回调的方法，该方法内部又会回调NotifyListener#notify方法</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line"></span><br><span class="line">                    ChildListener zkListener = listeners.get(listener);</span><br><span class="line">                    <span class="keyword">if</span> (zkListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listeners.putIfAbsent(listener, <span class="keyword">new</span> ChildListener() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childChanged</span><span class="params">(String parentPath, List&lt;String&gt; currentChilds)</span> </span>&#123; </span><br><span class="line">                                <span class="comment">// 变更时，调用 notity方法，回调 NotifyListener</span></span><br><span class="line">                                ZookeeperRegistry.<span class="keyword">this</span>.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        zkListener = listeners.get(listener);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 创建 Type 节点，该节点为持久节点，如： /dubbo/com.alibaba.dubbo.demo.DemoService/configurators。为了确保该path在Zookeeper 上存在</span></span><br><span class="line">                    zkClient.create(path, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 向Zookeeper path节点发起订阅，并返回该节点下的子路径</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    List&lt;String&gt; children = zkClient.addChildListener(path, zkListener);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 添加到urls 中</span></span><br><span class="line">                    <span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        urls.addAll(toUrlsWithEmpty(url, path, children));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 首次订阅会主动调用NofityListener#notify(url,listener,currentChilds)方法，执行NotifyListener的逻辑</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                notify(url, listener, urls);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>订阅时涉及到的绑定监听器以及 ChildListener 匿名对象方法回调，会在下一章节 Zookeeper 客户端详细说明。订阅的核心是为指定的类目绑定监听器，该监听器用于监听类目下的子节点变化，发生变化则会调用 ChildListener 匿名对象方法，传递类目下变更后的子节点列表，有了这个新的子节点列表，就可以根据需要进行服务的重新暴露、服务目录重新生成等。</p><h3 id="doUnsubscribe-取消订阅"><a href="#doUnsubscribe-取消订阅" class="headerlink" title="doUnsubscribe 取消订阅"></a>doUnsubscribe 取消订阅</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZookeeperRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 真正取消订阅的逻辑，删除对应的监听器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doUnsubscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ChildListener zkListener = listeners.get(listener);</span><br><span class="line">            <span class="keyword">if</span> (zkListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">                    String root = toRootPath();</span><br><span class="line">                    zkClient.removeChildListener(root, zkListener);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String path : toCategoriesPath(url)) &#123;</span><br><span class="line">                        zkClient.removeChildListener(path, zkListener);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>该方法是实现了其父类 FailbackRegistry 的模版方法，使用 Zookeeper 客户端删除订阅 URL 对应的监听器，达到不再监听该path的目的。</p><h3 id="订阅时辅助方法"><a href="#订阅时辅助方法" class="headerlink" title="订阅时辅助方法"></a>订阅时辅助方法</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-registry-zookeeper-path.jpg" alt></p><h4 id="获取Root层路径"><a href="#获取Root层路径" class="headerlink" title="获取Root层路径"></a>获取Root层路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获得根目录</span></span><br><span class="line"><span class="comment">   * root</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">toRootDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root.equals(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">          <span class="keyword">return</span> root;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> root + Constants.PATH_SEPARATOR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Root</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 根路径</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">toRootPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="获取Service层路径"><a href="#获取Service层路径" class="headerlink" title="获取Service层路径"></a>获取Service层路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获得服务路径 ， Root + service</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> String <span class="title">toServicePath</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">       String name = url.getServiceInterface();</span><br><span class="line">       <span class="keyword">if</span> (Constants.ANY_VALUE.equals(name)) &#123;</span><br><span class="line">           <span class="keyword">return</span> toRootPath();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> toRootDir() + URL.encode(name);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="获得分类路径"><a href="#获得分类路径" class="headerlink" title="获得分类路径"></a>获得分类路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得分类路径 如： 到 providers/consumers/routes/configurations 的路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 分类路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">toCategoryPath</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toServicePath(url) + Constants.PATH_SEPARATOR + url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获得URL路径"><a href="#获得URL路径" class="headerlink" title="获得URL路径"></a>获得URL路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得URL 路径，即 要注册到注册中心上的完整路径</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Root + Service + Type + URL</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 被 &#123;<span class="doctag">@link</span> #doRegister(URL)&#125; 和 &#123;<span class="doctag">@link</span> #doUnregister(URL)&#125; 调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">toUrlPath</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toCategoryPath(url) + Constants.PATH_SEPARATOR + URL.encode(url.toFullString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="URL匹配"><a href="#URL匹配" class="headerlink" title="URL匹配"></a>URL匹配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获得providers 中，和consumer 匹配的URL数组</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> consumer  订阅URL 如：provider://10.1.22.101:20880/com.alibaba.dubbo.demo.DemoService?key=value&amp;...</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> providers 订阅URL映射的路径的子路径集合</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 匹配的URL数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> List&lt;URL&gt; <span class="title">toUrlsWithoutEmpty</span><span class="params">(URL consumer, List&lt;String&gt; providers)</span> </span>&#123;</span><br><span class="line">     List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">     <span class="comment">// 遍历所有的服务列表</span></span><br><span class="line">     <span class="keyword">if</span> (providers != <span class="keyword">null</span> &amp;&amp; !providers.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 遍历子路径</span></span><br><span class="line">         <span class="keyword">for</span> (String provider : providers) &#123;</span><br><span class="line">             <span class="comment">// 解码</span></span><br><span class="line">             provider = URL.decode(provider);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 是URL的路径才会处理</span></span><br><span class="line">             <span class="keyword">if</span> (provider.contains(<span class="string">"://"</span>)) &#123;</span><br><span class="line">                 <span class="comment">// 将字符串转为URL</span></span><br><span class="line">                 URL url = URL.valueOf(provider);</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 子路径URL是否匹配订阅URL，以关键属性进行匹配，如服务接口名、类目、服务group、服务version等</span></span><br><span class="line">                 <span class="keyword">if</span> (UrlUtils.isMatch(consumer, url)) &#123;</span><br><span class="line">                     urls.add(url);</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> urls;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Dubbo 客户端根据本地 URL 配置（引用配置信息）的接口、分类、分组和版本做过滤，通过上述方法对服务列表进行过滤，得到符合条件的服务。</p><h4 id="筛选URL"><a href="#筛选URL" class="headerlink" title="筛选URL"></a>筛选URL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 1 从providers中筛选和consumer匹配的URL集合</span></span><br><span class="line"><span class="comment">   * 2 如果URL集合不为空，直接返回这个集合</span></span><br><span class="line"><span class="comment">   * 3 如果URL集合为空，首先从path中获取category的值，然后将consumer的协议换成empty并添加参数category=path中的category的值。</span></span><br><span class="line"><span class="comment">   * 形式：'empty://' 的URL返回，通过这样的方式，可以处理类似服务提供者为空的情况</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> consumer  订阅URL 如：provider://10.1.22.101:20880/com.alibaba.dubbo.demo.DemoService?key=value&amp;...</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> path      订阅URL映射的路径 如：/dubbo/com.alibaba.dubbo.demo.DemoService/configurators</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> providers 订阅URL映射的路径的子路径集合</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> List&lt;URL&gt; <span class="title">toUrlsWithEmpty</span><span class="params">(URL consumer, String path, List&lt;String&gt; providers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从providers中筛选和consumer 匹配的URL数组</span></span><br><span class="line">      List&lt;URL&gt; urls = toUrlsWithoutEmpty(consumer, providers);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果不存在匹配的，则创建 'empty://' 的URL返回</span></span><br><span class="line">      <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">int</span> i = path.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line">          String category = i &lt; <span class="number">0</span> ? path : path.substring(i + <span class="number">1</span>);</span><br><span class="line">          URL empty = consumer.setProtocol(Constants.EMPTY_PROTOCOL).addParameter(Constants.CATEGORY_KEY, category);</span><br><span class="line">          urls.add(empty);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> urls;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="获得Type层路径"><a href="#获得Type层路径" class="headerlink" title="获得Type层路径"></a>获得Type层路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获得分类路径数组</span></span><br><span class="line"><span class="comment">  * Root + Service + Type</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> url 订阅URL</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 分类路径数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String[] toCategoriesPath(URL url) &#123;</span><br><span class="line">     String[] categories;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果category的值为 * ，表示分别订阅：providers,consumers,routers,configurators</span></span><br><span class="line">     <span class="keyword">if</span> (Constants.ANY_VALUE.equals(url.getParameter(Constants.CATEGORY_KEY))) &#123;</span><br><span class="line">         categories = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">                 Constants.PROVIDERS_CATEGORY,</span><br><span class="line">                 Constants.CONSUMERS_CATEGORY,</span><br><span class="line">                 Constants.ROUTERS_CATEGORY,</span><br><span class="line">                 Constants.CONFIGURATORS_CATEGORY</span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 如果category的值不为 * ，就取出 category的值，如果没有值，就把providers作为默认值。注意，当category的值不为空时会使用 ',' 分割category的值，为数组</span></span><br><span class="line">         categories = url.getParameter(Constants.CATEGORY_KEY, <span class="keyword">new</span> String[]&#123;Constants.DEFAULT_CATEGORY&#125;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获得分类路径数组</span></span><br><span class="line">     String[] paths = <span class="keyword">new</span> String[categories.length];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; categories.length; i++) &#123;</span><br><span class="line">         <span class="comment">// 构建分类路径</span></span><br><span class="line">         paths[i] = toServicePath(url) + Constants.PATH_SEPARATOR + categories[i];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> paths;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="销毁方法"><a href="#销毁方法" class="headerlink" title="销毁方法"></a>销毁方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ZookeeperRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">extends</span> <span class="title">FailbackRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">super</span>.destroy();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 关闭 Zookeeper 客户端连接</span></span><br><span class="line">             zkClient.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             logger.warn(<span class="string">"Failed to close zookeeper client "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>重写了父类 FailbackRegistry 的销毁方法，使用 Zookeeper 客户端关闭会话，该方法会先调用父类的销毁方法。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章主要介绍了 Dubbo 封装的 ZookeeperRegistry，该注册中心类将具体操作任务交给内部封装的 Zookeeper 客户端去完成，自己本身只是处理 Zookeeper 客户端操作前的逻辑，如调用父类方法、解析URL的所属类目等，其中创建 Zookeeper 客户端的直接入口就在该类的构造方法中。此外，该类中的一些方法没有分析到，它们和订阅与通知相关，会和订阅通知一起分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://gentryhuang.com/posts/dafcd048/&quot;&gt;注册中心总览&lt;/a&gt; 中介绍了 Dubb
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Zookeeper" scheme="https://gentryhuang.com/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 注册中心总览</title>
    <link href="https://gentryhuang.com/posts/dafcd048/"/>
    <id>https://gentryhuang.com/posts/dafcd048/</id>
    <published>2020-04-12T16:00:00.000Z</published>
    <updated>2020-10-25T02:22:09.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 Dubbo 体系中，注册中心是核心组件之一。Dubbo 本身是一个分布式的 RPC 框架，依赖于 Dubbo 的应用都是单独部署的，为了让各个应用能够实时获取彼此的信息，就需要依赖一个一致性的服务注册和发现组件。Dubbo 通过注册中心实现了分布式环境中各服务之间的注册与发现，是各个分布式节点之间的纽带。主要作用如下：</p><ol><li>动态加入。服务提供方通过注册中心记录自己的信息并动态地把自己暴露给其他消费者。</li><li>动态发现。一个消费者可以动态地感知新的配置、路由规则、新的服务，无需重新启动服务。一个服务提供者可以动态地感知配置的变化无需启动服务。</li><li>动态调整。注册中心支持参数的动态调整，新参数自动更新到相关服务节点。</li></ol><p>Registry 只是 Consumer 和 Provider 感知彼此状态变化和配置改变（强调服务治理）的一种途径，实际通讯交互过程是直接进行的，对于 Registry 来说是透明无感知的。需要说明的是，我们所说的注册中心其实是指应用中的注册中心客户端，真正的注册中心服务是独立部署的进程或进程组成的集群，如 Zookeeper 集群、Redis 集群。对于注册中心而言，Provider 和 Consumer 仅是一个 URL。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li>服务提供者启动时，会向注册中心写入自己的元数据信息，并订阅配置元数据信息。</li><li>消费者启动时，也会向注册中心写入自己的元数据信息，并订阅服务提供者、路由会配置元数据信息。</li><li>服务治理中心(dubbo-admin)启动时，会同时订阅所有服务提供者、服务消费者、路由和配置元数据信息。</li><li>服务提供者下线或新的服务提供者加入时，注册中心服务提供者目录会发生变化，变化信息会动态通知给消费者、服务治理中心。</li><li>消费方发起服务调用时，会异步将调用、统计信息等上报给监控中心。</li></ol><p>需要注意的是，Dubbo 中的注册中心总体流程相同，框架对流程进行了抽象，采用抽象工厂和模版方法模式，主要区别是不同的注册中心有不同的具体实现，其数据结构也不相同。</p><p>注册中心在 Dubbo 架构中的位置为下图的 Registry，其中红框中的是我们接下来几篇文章着重分析的内容。<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo/dubbo-frame-registry.png" alt></p><h2 id="注册中心抽象API"><a href="#注册中心抽象API" class="headerlink" title="注册中心抽象API"></a>注册中心抽象API</h2><p>Dubbo服务暴露、服务引用以及服务调用等几乎都会使用到注册中心，这篇文章对Dubbo 的注册中心抽象API进行说明。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-registry-struct-outline.jpg" alt></p><p>上图是Dubbo的注册中心抽象API代码结构图，红框中的代码都是抽象API的基础代码，黄框是具体的注册中心抽象API。</p><h2 id="注册中心核心抽象API的UML"><a href="#注册中心核心抽象API的UML" class="headerlink" title="注册中心核心抽象API的UML"></a>注册中心核心抽象API的UML</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-registry-outline.png" alt></p><p>UML图非常清楚，注册中心核心抽象API中主要有三个角色，注册中心、注册中心工厂、注册中心的监听器。它们之间采用继承、组合、以及工厂的方式联系在一起，需要注意的是该图中的 <code>ZookeeperRegistry</code> 注册中心实现没有涉及到具体的客户端，关于 Dubbo 的 Zookeeper 客户端会单独写一篇文章进行详细说明。从UML图可以看出当前 Dubbo 版本支持四种注册中心的实现。Zookeeper 是官方推荐的注册中心，在生产环境中有过实际使用。Redis 注册中心并没有经过长时间运行的可靠性验证，其稳定性依赖 Redis 本身。Simple 注册中心是一个简单的基于内存的注册中心实现，它本身就是一个标准的PRC服务，不支持集群。Multicast 模块则不需要启动任何注册中心，只要通过广播地址，就可以互相发现，不推荐生产环境使用。下面分别介绍该UML图中涉及到的组件。</p><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前节点的 URL</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> url.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测当前节点是否可用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> available.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁当前节点，释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，在 Dubbo 中，一般使用 Node 这个接口来抽象节点的概念。Node 不仅可以表示 Provider 和 Consumer节点，还可以表示注册中心节点。Node 接口是一个顶级接口，Dubbo 中的核心组件几乎都继承该接口，只封装了三个和节点相关的方法。</p><h2 id="RegistryService"><a href="#RegistryService" class="headerlink" title="RegistryService"></a>RegistryService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册数据，如：提供者地址，消费者地址，路由规则，覆盖规则等数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin          </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  取消注册数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * - 订阅符合条件的已注册数据，当订阅的数据发生改变时，注册中心会主动通知 listener 对象，NotifyListener 接口中定义的 notify 方法就是用来接收通知的。</span></span><br><span class="line"><span class="comment">     * - 在 URL的category 属性上，表示订阅的数据分类。目前有四种类型：</span></span><br><span class="line"><span class="comment">     * 1 consumers 服务消费者列表</span></span><br><span class="line"><span class="comment">     * 2 providers 服务提供者列表</span></span><br><span class="line"><span class="comment">     * 3 routers 路由规则列表</span></span><br><span class="line"><span class="comment">     * 4 configurations 配置规则列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener A listener of the change event, not allowed to be empty</span></span><br><span class="line"><span class="comment">     *                </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  取消订阅</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener A listener of the change event, not allowed to be empty</span></span><br><span class="line"><span class="comment">     *                </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询符合条件的已注册数据，它与 subscribe() 方法是有区别的，subscribe() 方法采用的是 push 模式，lookup() 方法采用的是 pull 模式。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url Query condition, is not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The registered information list, which may be empty, the meaning is the same as the parameters of &#123;<span class="doctag">@link</span> com.alibaba.dubbo.registry.NotifyListener#notify(List&lt;URL&gt;)&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.alibaba.dubbo.registry.NotifyListener#notify(List)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;URL&gt; <span class="title">lookup</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RegistryService 接口也是一个顶级接口，是注册中心服务接口，抽象了注册服务的基本行为。定义了节点的注册/反注册、订阅/反订阅以及查询三种操作方法。Dubbo 在上层进行了抽象，具体的实现细节交给不同的注册中心。</p><h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registry. (SPI, Prototype, ThreadSafe)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.registry.RegistryFactory#getRegistry(com.alibaba.dubbo.common.URL)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.registry.support.AbstractRegistry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Registry</span> <span class="keyword">extends</span> <span class="title">Node</span>, <span class="title">RegistryService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册中心接口，该接口中没有定义方法只是继承了 Node 和 RegistryService 接口，因此具备了注册、订阅、查询等操作，注册中心具体实现都要继承该接口。</p><h2 id="AbstractRegistry"><a href="#AbstractRegistry" class="headerlink" title="AbstractRegistry"></a>AbstractRegistry</h2><p>Registry 的抽象类，实现了通用的注册、订阅、查询以及通知等方法。其中，实现了当前节点订阅的数据（URL）缓存到本地及持久化到文件，一方面为了减轻注册中心组件的压力，另一方面该文件可用于当消费者无法从注册中心拉取服务提供者列表信息时就从该文件中获取，支持了即使注册中心宕机消费者仍然可以和提供者通信。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Log output</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// URL地址分割符，用于文件缓存中，分割URL</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> URL_SEPARATOR = <span class="string">' '</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// URL地址分隔正则表达式，用于解析文件缓存中URL列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL_SPLIT = <span class="string">"\\s+"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本地磁盘缓存</span></span><br><span class="line"><span class="comment">     * 1 其中特殊的 key值为 registries， 对应的值记录注册中心列表， 其他的均为&#123;<span class="doctag">@link</span> #notified&#125; 服务提供者列表</span></span><br><span class="line"><span class="comment">     * 2 数据流向： 创建注册中心实例时从file读取数据到 properties中；监听到注册中心数据发生变更时，修改properties对应的值，并写入file</span></span><br><span class="line"><span class="comment">     * 3 数据的键-值对</span></span><br><span class="line"><span class="comment">     * （1）大多数情况下，键为订阅者的服务键 &#123;<span class="doctag">@link</span> URL#getServiceKey()&#125;,值为 服务提供者列表/路由规则列表/配置规则列表</span></span><br><span class="line"><span class="comment">     * （2）特殊情况下是 键为 registries，值为注册中心列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// Local disk cache, where the special key value.registies records the list of registry centers, and the others are the list of notified service providers</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心数据缓存线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService registryCacheExecutor = Executors.newFixedThreadPool(<span class="number">1</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboSaveRegistryCache"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * properties发生变更时，是否同步写入文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> syncSaveFile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据版本号 &#123;<span class="doctag">@link</span> #properties&#125;，每次写入 file 文件时都是全覆盖写入，而不是修改文件，因此需要并发处理，防止旧数据覆盖新数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lastCacheChanged = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 已注册 URL 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;URL&gt; registered = <span class="keyword">new</span> ConcurrentHashSet&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅 URL 的监听器集合</span></span><br><span class="line"><span class="comment">     * key： 订阅URL，也即被监听的URL</span></span><br><span class="line"><span class="comment">     * value: 订阅URL相应的监听器集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; subscribed = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知的URL到监听器监听到数据变化后的 结果URL集合</span></span><br><span class="line"><span class="comment">     * key1: 订阅URL，当前节点作为消费者或提供者的一个订阅URL，如服务引用时进行订阅的 consumer协议的的URL，服务暴暴露时订阅的 provider协议的URL，和 &#123;<span class="doctag">@link</span> #subscribed&#125; 的键一致</span></span><br><span class="line"><span class="comment">     * key2: 分类，如： providers,consumers,routes,configurators。【对于消费着来说一般是无consumers,因为消费者不会去订阅另外的消费者的列表】</span></span><br><span class="line"><span class="comment">     * value: 新的URL集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, Map&lt;String, List&lt;URL&gt;&gt;&gt; notified = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, Map&lt;String, List&lt;URL&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心 URL，包含了创建当前Registry对象的全部配置信息，注意，AbstractRegistryFactory 对其进行了规范化处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> URL registryUrl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存数据的磁盘文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> File file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，每次创建注册中心都会同步磁盘文件数据到缓存中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        setUrl(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可以指定注册中心磁盘缓存文件，配置方式：</span></span><br><span class="line"><span class="comment">         * 1 使用file属性指定  &lt;dubbo:registry address="xxx" file="/opt/xxx"/&gt;</span></span><br><span class="line"><span class="comment">         * 2 使用save.file属性指定 &lt;dubbo:registry address="xxx" save.file="/opt/xxx"/&gt;</span></span><br><span class="line"><span class="comment">         * 3 不显示指定的话，使用默认值：System.getProperty("user.home") + "/.dubbo/dubbo-registry-" + 应用名 + "-" + url.getAddress() + ".cache"</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// Start file save timer</span></span><br><span class="line">        syncSaveFile = url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 获得 file</span></span><br><span class="line">        String filename = url.getParameter(Constants.FILE_KEY, System.getProperty(<span class="string">"user.home"</span>) + <span class="string">"/.dubbo/dubbo-registry-"</span> + url.getParameter(Constants.APPLICATION_KEY) + <span class="string">"-"</span> + url.getAddress() + <span class="string">".cache"</span>);</span><br><span class="line">        File file = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.isNotEmpty(filename)) &#123;</span><br><span class="line">            file = <span class="keyword">new</span> File(filename);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists() &amp;&amp; file.getParentFile() != <span class="keyword">null</span> &amp;&amp; !file.getParentFile().exists()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!file.getParentFile().mkdirs()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid registry store file "</span> + file + <span class="string">", cause: Failed to create directory "</span> + file.getParentFile() + <span class="string">"!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.file = file;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载本地磁盘缓存文件到内存缓存，即 properties.load(in)，到properties属性中</span></span><br><span class="line">        loadProperties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知监听器，URL 变化结果 。 为什么构造方法要通知，zk连接都没有建立，监听器更没有注册，即 subscribed 里面还没有值</span></span><br><span class="line">        notify(url.getBackupUrls());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractRegistry 抽象类中的属性大致有四类，注册的URL、缓存数据相关的、订阅URL的监听器、通知URL对应的变更URL。在 AbstractRegistry 初始化时，会将对应的 file 文件中的订阅数据加载到 properties 字段中。当 properties 中的注册数据发生变化时，会写入本地的 file 文件进行同步。本地缓存文件的路径如下：</p><blockquote><p>user.home/.dubbo/dubbo-registry-${当前应用名}-${当前注册中心所在的IP地址}.cache</p></blockquote><h3 id="注册-反注册"><a href="#注册-反注册" class="headerlink" title="注册/反注册"></a>注册/反注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先添加到 registered 缓存中，进行状态的维护。再由子类 FailbackRegistry类 真正注册</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"register url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Register: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        registered.add(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先从 registered 缓存中移除，再由子类 FailbackRegistry 真正取消注册</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url Registration information , is not allowed to be empty, e.g: dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"unregister url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Unregister: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        registered.remove(url);</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractRegistry 抽象类中的注册和反注册方法只是操作缓存，真正的实现交给子类 FailbackRegistry 完成。</p><h3 id="订阅-反订阅"><a href="#订阅-反订阅" class="headerlink" title="订阅/反订阅"></a>订阅/反订阅</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先缓存到 subscribed 中，再通过子类 FailbackRegistry 具体执行订阅逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      订阅条件，不允许为空，如：consumer://10.10.10.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 变更事件监听器，不允许为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"subscribe url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"subscribe listener == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Subscribe: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 从ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; subscribed中获取key为url的集合Set&lt;NotifyListener&gt;</span></span><br><span class="line"><span class="comment">         * 2 如果该集合存在，直接将当前的NotifyListener实例存入该集合,如果集合不存在，先创建，之后放入subscribed中，并将当前的NotifyListener实例存入刚刚创建的集合</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;NotifyListener&gt; listeners = subscribed.get(url);</span><br><span class="line">        <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subscribed.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashSet&lt;NotifyListener&gt;());</span><br><span class="line">            listeners = subscribed.get(url);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先从缓存中移除，再通过子类 FailbackRegistry 具体执行取消订阅的逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener A listener of the change event, not allowed to be empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"unsubscribe url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"unsubscribe listener == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Unsubscribe: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;NotifyListener&gt; listeners = subscribed.get(url);</span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listeners.remove(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractRegistry 抽象类中的订阅和反订阅方法只是操作缓存，真正的实现交给子类 FailbackRegistry 完成。</p><h3 id="断线重连"><a href="#断线重连" class="headerlink" title="断线重连"></a>断线重连</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 和注册中心断开，重连成功会调用该方法，恢复注册和订阅</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// register</span></span><br><span class="line">        Set&lt;URL&gt; recoverRegistered = <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered());</span><br><span class="line">        <span class="keyword">if</span> (!recoverRegistered.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Recover register url "</span> + recoverRegistered);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (URL url : recoverRegistered) &#123;</span><br><span class="line">                <span class="comment">// 放入缓存</span></span><br><span class="line">                register(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// subscribe</span></span><br><span class="line">        Map&lt;URL, Set&lt;NotifyListener&gt;&gt; recoverSubscribed = <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed());</span><br><span class="line">        <span class="keyword">if</span> (!recoverSubscribed.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Recover subscribe url "</span> + recoverSubscribed.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : recoverSubscribed.entrySet()) &#123;</span><br><span class="line">                URL url = entry.getKey();</span><br><span class="line">                <span class="keyword">for</span> (NotifyListener listener : entry.getValue()) &#123;</span><br><span class="line">                    subscribe(url, listener);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>AbstractRegistry 抽象类中的断线重连逻辑是，与注册中心断开后重新连接时会从缓存中取出已经注册的URL集合，然后放入缓存，订阅同理。</p><h3 id="通知于本地缓存"><a href="#通知于本地缓存" class="headerlink" title="通知于本地缓存"></a>通知于本地缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 订阅URL映射的节点对应的子节点发生变化时，通知监听器</span></span><br><span class="line"><span class="comment">    * @param url      订阅URL</span></span><br><span class="line"><span class="comment">    * @param listener 订阅ULR对应的监听器</span></span><br><span class="line"><span class="comment">    * @param urls     订阅URL映射的路径下的子路径集合（全量数据）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify listener == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((urls == <span class="keyword">null</span> || urls.isEmpty()) &amp;&amp; !Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Ignore empty notify urls for subscribe url "</span> + url);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Notify urls for subscribe url "</span> + url + <span class="string">", urls: "</span> + urls);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 将 `urls` 按照 URL中的 'category` 参数进行分类，添加到Map集合result中</span></span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;String, List&lt;URL&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (URL u : urls) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 子路径URL是否匹配订阅URL</span></span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">                <span class="comment">// 获取分类，默认为 providers</span></span><br><span class="line">                String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 加入到结果集</span></span><br><span class="line">                List&lt;URL&gt; categoryList = result.get(category);</span><br><span class="line">                <span class="keyword">if</span> (categoryList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    categoryList = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">                    result.put(category, categoryList);</span><br><span class="line">                &#125;</span><br><span class="line">                categoryList.add(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得订阅URL对应的缓存`notified`,即通知的 URL 变化结果（全量数据），会把result中的值放入到 categoryNotified中</span></span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.get(url);</span><br><span class="line">        <span class="keyword">if</span> (categoryNotified == <span class="keyword">null</span>) &#123;</span><br><span class="line">            notified.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;String, List&lt;URL&gt;&gt;());</span><br><span class="line">            categoryNotified = notified.get(url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理通知的 URL 变化结果（全量数据），即按照分类，循环处理通知的URL变化结果（全量数据）</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 获得分类名</span></span><br><span class="line">            String category = entry.getKey();</span><br><span class="line">            <span class="comment">// 获得分类名对应的通知ULR列表</span></span><br><span class="line">            List&lt;URL&gt; categoryList = entry.getValue();</span><br><span class="line">            <span class="comment">// 1 将result 覆盖到 `notified`缓存【更新notified集合中的通知ULR列表】，需要注意：当某个分类的数据为空时，会依然有URL，如 empty://...` ，通过这种方式统一处理所有订阅URL对应的数据为空的情况。</span></span><br><span class="line">            categoryNotified.put(category, categoryList);</span><br><span class="line">            <span class="comment">// 2 保存订阅url对应的被通知的URL到 properties和文件 中 // 在循环中的保存的原因是，订阅url对应的通知url可能是变动的，上一步的操作会更新notified集合，为了让 properties和文件中的 订阅-通知关系正确就需要不断更新。</span></span><br><span class="line">            saveProperties(url);</span><br><span class="line">            <span class="comment">// 3 调用传入的listener的notify()方法</span></span><br><span class="line">            listener.notify(categoryList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>需要说明的是，向注册中心发起订阅后，会获取到订阅URL所对应的全量数据，接着调用该上述方法；当注册中心监控的数据发生变更时，会调用上述方法，虽然变化的是增量的，但是从注册中心拉取的是全量的数据，即最新的数据。该方法的使用主要在服务暴露过程中服务提供者订阅配置信息，便于配置发生改变时通过监听器进行捕捉然后回调该方法，最终完成服务重新暴露。在服务引用过程中消费者订阅服务信息、配置信息等最终完成服务引用。该方法在 Dubbo 整个生命周期内发挥重要的作用，在分析完服务暴露和服务引用后会单独写一篇文章详细说明。</p><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Destroy registry:"</span> + getUrl());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消注册逻辑</span></span><br><span class="line">        Set&lt;URL&gt; destroyRegistered = <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered());</span><br><span class="line">        <span class="keyword">if</span> (!destroyRegistered.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (URL url : <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 取消注册，操作缓存，具体实现交给子类</span></span><br><span class="line">                        unregister(url);</span><br><span class="line">                        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(<span class="string">"Destroy unregister url "</span> + url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"Failed to unregister url "</span> + url + <span class="string">" to registry "</span> + getUrl() + <span class="string">" on destroy, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消订阅，操作缓存，具体实现交给子类</span></span><br><span class="line">        Map&lt;URL, Set&lt;NotifyListener&gt;&gt; destroySubscribed = <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed());</span><br><span class="line">        <span class="keyword">if</span> (!destroySubscribed.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : destroySubscribed.entrySet()) &#123;</span><br><span class="line">                <span class="comment">// 订阅URL</span></span><br><span class="line">                URL url = entry.getKey();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 订阅URL对应的监听器列表</span></span><br><span class="line">                <span class="keyword">for</span> (NotifyListener listener : entry.getValue()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 取消订阅</span></span><br><span class="line">                        unsubscribe(url, listener);</span><br><span class="line">                        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(<span class="string">"Destroy unsubscribe url "</span> + url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"Failed to unsubscribe url "</span> + url + <span class="string">" to registry "</span> + getUrl() + <span class="string">" on destroy, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>主要是取消注册和订阅。需要注意的是，无论是服务提供者还是消费者，都会向Registry发起注册和订阅，所以在JVM关闭示，都要进行取消。</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 订阅URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveProperties</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// notified 缓存的值： 订阅URL 对应的映射集合，只要订阅URL关联的路径下有节点变化，就会不断刷新，最新最全数据。</span></span><br><span class="line">            Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.get(url);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (categoryNotified != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (List&lt;URL&gt; us : categoryNotified.values()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (buf.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            buf.append(URL_SEPARATOR);</span><br><span class="line">                        &#125;</span><br><span class="line">                        buf.append(u.toFullString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            properties.setProperty(url.getServiceKey(), buf.toString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 版本号，使用CAS</span></span><br><span class="line">            <span class="keyword">long</span> version = lastCacheChanged.incrementAndGet();</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// 保存变更数据到磁盘文件</span></span><br><span class="line">            <span class="keyword">if</span> (syncSaveFile) &#123;</span><br><span class="line">                doSaveProperties(version);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                registryCacheExecutor.execute(<span class="keyword">new</span> SaveProperties(version));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>该方法中会取出订阅的各个分类下的URL连接起来（中间以空格分隔），然后以订阅URL的服务键为key先保存到内存中的 <code>Properties</code> 中，然后在同步或异步保存到磁盘文件中，同步或异步根据 <code>syncSaveFile</code> 参数值。接着分析保存变更数据到磁盘文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version 版本号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSaveProperties</span><span class="params">(<span class="keyword">long</span> version)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 安全措施：</span></span><br><span class="line"><span class="comment">         * 1 CAS判断：</span></span><br><span class="line"><span class="comment">         *   在saveProperties(URL url)方法中执行了long version = lastCacheChanged.incrementAndGet();</span></span><br><span class="line"><span class="comment">         * 这里进行if (version &lt; lastCacheChanged.get())判断，如果满足这个条件，说明当前线程在进行doSaveProperties(long version)时，</span></span><br><span class="line"><span class="comment">         * 已经有其他线程执行了saveProperties(URL url)，马上就要执行doSaveProperties(long version)，所以当前线程放弃操作，让后边的这个线程来做保存操作。</span></span><br><span class="line"><span class="comment">         * 2 文件锁 FileLock：</span></span><br><span class="line"><span class="comment">         *   FileLock 是进程文件锁，用于进程间并发，控制不同程序（JVM）对同一文件的并发访问，文件锁可以解决多个进程并发访问、可以通过对一个可写文件加锁，保证同时只有一个进程可以拿到文件锁，这个进程从而可以对文件进行操作，</span></span><br><span class="line"><span class="comment">         *   而其它拿不到锁的进程要么被挂起等待，要么可以去做一些其它事情，这种机制保证了进程间文件的并发安全操作。修改同一个文件的问题，但不能解决多线程并发访问、修改同一文件的问题。FileLock 文件锁的效果是与操作系统相关的，是由操作系统底层来实现。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (version &lt; lastCacheChanged.get()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (file == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Save</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File lockfile = <span class="keyword">new</span> File(file.getAbsolutePath() + <span class="string">".lock"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!lockfile.exists()) &#123;</span><br><span class="line">                lockfile.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(lockfile, <span class="string">"rw"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileChannel channel = raf.getChannel();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 对文件加锁，默认为排它锁，没有获取到锁的进程阻塞等待</span></span><br><span class="line">                    FileLock lock = channel.tryLock();</span><br><span class="line">                    <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Can not lock the registry cache file "</span> + file.getAbsolutePath() + <span class="string">", ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Save</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                            file.createNewFile();</span><br><span class="line">                        &#125;</span><br><span class="line">                        FileOutputStream outputFile = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            properties.store(outputFile, <span class="string">"Dubbo Registry Cache"</span>);</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            outputFile.close();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 释放文件锁</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.release();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                raf.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (version &lt; lastCacheChanged.get()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                registryCacheExecutor.execute(<span class="keyword">new</span> SaveProperties(lastCacheChanged.incrementAndGet()));</span><br><span class="line">            &#125;</span><br><span class="line">            logger.warn(<span class="string">"Failed to save registry store file, cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>该方法用于将 <code>Properties</code> 文件中的变更数据保存到磁盘文件中，在保存的时候做了并发处理操作，详细见代码注释。</p><h3 id="加载变更数据到内存"><a href="#加载变更数据到内存" class="headerlink" title="加载变更数据到内存"></a>加载变更数据到内存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file != <span class="keyword">null</span> &amp;&amp; file.exists()) &#123;</span><br><span class="line">            InputStream in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">                properties.load(in);</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Load registry store file "</span> + file + <span class="string">", data: "</span> + properties);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Failed to load registry store file "</span> + file, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        in.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        logger.warn(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><p>该方法用于将磁盘文件中的变更数据加载到内存中的 <code>Properties</code> 中。</p><h3 id="获取订阅URL对应的变更URL列表"><a href="#获取订阅URL对应的变更URL列表" class="headerlink" title="获取订阅URL对应的变更URL列表"></a>获取订阅URL对应的变更URL列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> url 订阅URL</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> List&lt;URL&gt; <span class="title">getCacheUrls</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">             <span class="comment">// 映射URL</span></span><br><span class="line">             String key = (String) entry.getKey();</span><br><span class="line">             <span class="comment">// 映射URL 对应的 通知URL串</span></span><br><span class="line">             String value = (String) entry.getValue();</span><br><span class="line"> </span><br><span class="line">             <span class="keyword">if</span> (key != <span class="keyword">null</span> &amp;&amp; key.length() &gt; <span class="number">0</span> &amp;&amp; key.equals(url.getServiceKey()) &amp;&amp; (Character.isLetter(key.charAt(<span class="number">0</span>)) || key.charAt(<span class="number">0</span>) == <span class="string">'_'</span>) &amp;&amp; value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">// 对通知的URL串 以 '空格' 进行分割成字符串</span></span><br><span class="line">                 String[] arr = value.trim().split(URL_SPLIT);</span><br><span class="line">                 List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line"> </span><br><span class="line">                 <span class="keyword">for</span> (String u : arr) &#123;</span><br><span class="line">                     <span class="comment">// 解析URL串</span></span><br><span class="line">                     urls.add(URL.valueOf(u));</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">return</span> urls;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br></pre></td></tr></table></figure><h3 id="AbstractRegistry-小结"><a href="#AbstractRegistry-小结" class="headerlink" title="AbstractRegistry 小结"></a>AbstractRegistry 小结</h3><p>AbstractRegistry 核心功能是本地文件缓存，在 AbstractRegistry 初始化时，会调用 loadProperties() 方法将本地文件加载到 properties 对象中。当网络抖动等情况导致订阅失败时，消费者端的 Registry 就可以调用 getCacheUrls() 方法获取本地缓存，从而得到最近注册的服务提供者URL列表（还有其它列表），AbstractRegistry 通过本地缓存提供了一种容错机制，保证了服务的可靠性。</p><h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><p>在微服务系统中，注册中心一般都会独立部署成一个集群，其它应用通过客户端连接集群，以完成注册、订阅等操作。但网络通信是不可靠的，为了保证服务的可靠性，重试机制就变得必不可少了。</p><h2 id="FailbackRegistry"><a href="#FailbackRegistry" class="headerlink" title="FailbackRegistry"></a>FailbackRegistry</h2><p>继承了 AbstractRegistry 抽闲类，支持失败重试的 Registry 抽象类。AbstractRegistry 中的注册、订阅操作更多的是操作缓存，并没有和注册中心交互。FailbackRegistry 在 AbstractRegistry 的基础上提供了注册和订阅的模版方法交由具体子类实现逻辑，并支持失败重试操作。也就是说 FailbackRegistry 及其上层将整个流程模型构建好了，具体实现如 ZookeeperRegistry、RedisRegistry 等只需关注功能点即可，无需关注整个注册中心流程。</p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时任务执行器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService retryExecutor = Executors.newScheduledThreadPool(<span class="number">1</span>, <span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboRegistryFailedRetryTimer"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败重试ScheduledFuture，定时检查是否有请求失败，如有，无限次重试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledFuture&lt;?&gt; retryFuture;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册失败的URL集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;URL&gt; failedRegistered = <span class="keyword">new</span> ConcurrentHashSet&lt;URL&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消注册失败的URL集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;URL&gt; failedUnregistered = <span class="keyword">new</span> ConcurrentHashSet&lt;URL&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订阅失败的监听器集合 key: 订阅失败的URL value: 对应的监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; failedSubscribed = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消订阅失败的监听器集合 key: 订阅URL value: 对应的监听器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; failedUnsubscribed = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知失败的URL集合 key1: 订阅URL key2: 订阅URL对应的监听器  value: 订阅URL对应的变更数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt; failedNotified = <span class="keyword">new</span> ConcurrentHashMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The time in milliseconds the retryExecutor will wait // 重试操作的时间间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> retryPeriod;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FailbackRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行父类构造方法， 加载本地磁盘缓存文件到内存缓存，即 properties.load(in)，到properties属性中。</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 这个很重要，注册中心宕机的情况下，依赖缓存文件中的信息可以构建Invoker，不影响服务的调用，只是不能调用新的服务了。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">super</span>(url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重试频率，单位 毫秒</span></span><br><span class="line">        <span class="keyword">this</span>.retryPeriod = url.getParameter(Constants.REGISTRY_RETRY_PERIOD_KEY, Constants.DEFAULT_REGISTRY_RETRY_PERIOD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建失败重试定时器【就是将一堆失败记录进行对应的重试操作】</span></span><br><span class="line">        <span class="keyword">this</span>.retryFuture = retryExecutor.scheduleWithFixedDelay(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Check and connect to the registry</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行重试操作</span></span><br><span class="line">                    retry();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Defensive fault tolerance</span></span><br><span class="line">                    logger.error(<span class="string">"Unexpected error occur at failed retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==== Template method ====</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doUnregister</span><span class="params">(URL url)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doUnsubscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该抽象类主要维护了注册/取消注册失败、订阅/取消订阅失败、通知失败的缓存，以及提供者了注册/取消注册、订阅/取消订阅的模版方法。进行注册或订阅操作时，会先调用其父类 AbstractRegistry 中的方法进行缓存操作，然后再调用其具体子类的方法。</p><h3 id="register"><a href="#register" class="headerlink" title="register"></a>register</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类操作缓存的方法</span></span><br><span class="line">        <span class="keyword">super</span>.register(url);</span><br><span class="line">        failedRegistered.remove(url);</span><br><span class="line">        failedUnregistered.remove(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 发起注册请求到注册中心服务器，具体由子类实现，通过注册中心客户端连接到服务端</span></span><br><span class="line">            doRegister(url);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果开启了启动时检测，则直接抛出异常</span></span><br><span class="line">            <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">            <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">            <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                    t = t.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to register "</span> + url + <span class="string">" to registry "</span> + getUrl().getAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to register "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录注册失败的URL到注册失败的列表中，为了以后定时重试</span></span><br><span class="line">            failedRegistered.add(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unregister"><a href="#unregister" class="headerlink" title="unregister"></a>unregister</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类操作缓存的方法</span></span><br><span class="line">        <span class="keyword">super</span>.unregister(url);</span><br><span class="line">        failedRegistered.remove(url);</span><br><span class="line">        failedUnregistered.remove(url);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 发起取消注册请求到注册中心服务器，具体由子类实现，通过注册中心客户端连接到服务端</span></span><br><span class="line">            doUnregister(url);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the startup detection is opened, the Exception is thrown directly.</span></span><br><span class="line">            <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());</span><br><span class="line">            <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">            <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                    t = t.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to unregister "</span> + url + <span class="string">" to registry "</span> + getUrl().getAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to uregister "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Record a failed registration request to a failed list, retry regularly</span></span><br><span class="line">            failedUnregistered.add(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 调用父类 将listener实例加入到url所对应的监听器集合中 &#123;<span class="doctag">@link</span> #subscribed &#125; 中 */</span></span><br><span class="line">        <span class="keyword">super</span>.subscribe(url, listener);</span><br><span class="line">        <span class="comment">// 将listener从failedSubscribed/failedUnsubscribed中删除 ，接着从failedNotified获取当前url的通知失败Map&lt;NotifyListener, List&lt;URL&gt;&gt;，然后从中 删除掉listener 到 需要通知的所有url 的映射</span></span><br><span class="line">        removeFailedSubscribed(url, listener);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向服务端发送订阅请求,具体请求处理由子类实现 </span></span><br><span class="line">            doSubscribe(url, listener);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/** 如果在订阅的过程抛出异常，那么尝试获取缓存url，如果有缓存url，则进行失败通知。之后“将失败的订阅请求记录到失败列表，定时重试”，如果没有缓存url，</span></span><br><span class="line"><span class="comment">             * 若开启了启动时检测或者直接抛出的异常是SkipFailbackWrapperException，则直接抛出异常，不会“将失败的订阅请求记录到失败列表，定时重试”</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             * 从Properties缓存文件中取出通知URL集合</span></span><br><span class="line"><span class="comment">             * 【注意：这些URL是由注册中心维护的，每次订阅方请求订阅时，注册中心都会把对应的要通知的URL列表记录到properties文件中，然后写入磁盘，注意 empty://的情况】</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            List&lt;URL&gt; urls = getCacheUrls(url);</span><br><span class="line">            <span class="keyword">if</span> (urls != <span class="keyword">null</span> &amp;&amp; !urls.isEmpty()) &#123;</span><br><span class="line">                notify(url, listener, urls);</span><br><span class="line">                logger.error(<span class="string">"Failed to subscribe "</span> + url + <span class="string">", Using cached list: "</span> + urls + <span class="string">" from cache file: "</span> + getUrl().getParameter(Constants.FILE_KEY, System.getProperty(<span class="string">"user.home"</span>) + <span class="string">"/dubbo-registry-"</span> + url.getHost() + <span class="string">".cache"</span>) + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果开启了启动时检测check=true,则直接抛出异常</span></span><br><span class="line">                <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>) &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                        t = t.getCause();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to subscribe "</span> + url + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.error(<span class="string">"Failed to subscribe "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将失败的订阅请求记录到失败列表，定时重试</span></span><br><span class="line">            addFailedSubscribed(url, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中向服务端发送订阅请求会交给子类处理，失败时会进入到 <code>catch</code> 块中的逻辑，注册中心维护的通知URL列表用在了这里，即当订阅发生异常时，会取出缓存中的通知ULR列表，调用 notify 方法进行通知。该逻辑也解释了即使注册中心宕机了，无论是消费方在注册中心宕机前启动完成还是宕机后启动，只要消费方缓存中的服务提供者可用，就可以实现服务调用。</p><h3 id="unsubscribe"><a href="#unsubscribe" class="headerlink" title="unsubscribe"></a>unsubscribe</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消订阅，移除相关的缓存。真正的取消订阅由子类执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      Subscription condition, not allowed to be empty, e.g. consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener A listener of the change event, not allowed to be empty</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类方法，移除url对应的listener实例</span></span><br><span class="line">        <span class="keyword">super</span>.unsubscribe(url, listener);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移除相关的 订阅/取消订阅失败缓存，以及失败通知缓存</span></span><br><span class="line">        removeFailedSubscribed(url, listener);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 向服务端发送取消订阅请求,具体请求处理由子类实现 </span></span><br><span class="line">            doUnsubscribe(url, listener);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Throwable t = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the startup detection is opened, the Exception is thrown directly.</span></span><br><span class="line">            <span class="keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>)</span><br><span class="line">                    &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">boolean</span> skipFailback = t <span class="keyword">instanceof</span> SkipFailbackWrapperException;</span><br><span class="line">            <span class="keyword">if</span> (check || skipFailback) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skipFailback) &#123;</span><br><span class="line">                    t = t.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to unsubscribe "</span> + url + <span class="string">" to registry "</span> + getUrl().getAddress() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to unsubscribe "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录取消订阅，便于重试</span></span><br><span class="line">            Set&lt;NotifyListener&gt; listeners = failedUnsubscribed.get(url);</span><br><span class="line">            <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                failedUnsubscribed.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashSet&lt;NotifyListener&gt;());</span><br><span class="line">                listeners = failedUnsubscribed.get(url);</span><br><span class="line">            &#125;</span><br><span class="line">            listeners.add(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      订阅URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urls     通知的URL变化结果（全量数据）【注意：全量指的是至少要是一个分类的全量[动态类型的]，而不一定是全部数据】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify listener == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 进行通知</span></span><br><span class="line">            doNotify(url, listener, urls);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception t) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将失败的通知请求记录到失败列表中，定时重试</span></span><br><span class="line">            Map&lt;NotifyListener, List&lt;URL&gt;&gt; listeners = failedNotified.get(url);</span><br><span class="line">            <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                failedNotified.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;NotifyListener, List&lt;URL&gt;&gt;());</span><br><span class="line">                listeners = failedNotified.get(url);</span><br><span class="line">            &#125;</span><br><span class="line">            listeners.put(listener, urls);</span><br><span class="line">            logger.error(<span class="string">"Failed to notify for subscribe "</span> + url + <span class="string">", waiting for retry, cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会调用父类的通知方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url      订阅URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener 监听器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urls     订阅URL映射路径 下的子路径集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.notify(url, listener, urls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FailbackRegistry 中的 notify方法 本质上还是调用 AbstractRegistry 中的 notify 方法，区别在于 FailbackRegistry 会收集失败通知请求并记录到缓存中，便于重试。</p><h3 id="断线重连-1"><a href="#断线重连-1" class="headerlink" title="断线重连"></a>断线重连</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           <span class="comment">// register</span></span><br><span class="line">           Set&lt;URL&gt; recoverRegistered = <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered());</span><br><span class="line">           <span class="keyword">if</span> (!recoverRegistered.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                   logger.info(<span class="string">"Recover register url "</span> + recoverRegistered);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">for</span> (URL url : recoverRegistered) &#123;</span><br><span class="line">                   failedRegistered.add(url);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// subscribe</span></span><br><span class="line">           Map&lt;URL, Set&lt;NotifyListener&gt;&gt; recoverSubscribed = <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed());</span><br><span class="line">           <span class="keyword">if</span> (!recoverSubscribed.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                   logger.info(<span class="string">"Recover subscribe url "</span> + recoverSubscribed.keySet());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : recoverSubscribed.entrySet()) &#123;</span><br><span class="line">                   URL url = entry.getKey();</span><br><span class="line">                   <span class="keyword">for</span> (NotifyListener listener : entry.getValue()) &#123;</span><br><span class="line">                       addFailedSubscribed(url, listener);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FailbackRegistry 完全覆写父类方法(即不像前几个方法，会调用父类的方法)，将已注册和订阅的URL添加到 {@link #failedRegistered} ,{@link #failedSubscribed} 属性中，这样在{@link #retry()}方法中会进行重试。</p><h3 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重新注册没有注册成功的URL集合</span></span><br><span class="line">        <span class="keyword">if</span> (!failedRegistered.isEmpty()) &#123;</span><br><span class="line">            Set&lt;URL&gt; failed = <span class="keyword">new</span> HashSet&lt;URL&gt;(failedRegistered);</span><br><span class="line">            <span class="keyword">if</span> (failed.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Retry register "</span> + failed);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (URL url : failed) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            doRegister(url);</span><br><span class="line">                            failedRegistered.remove(url);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                            logger.warn(<span class="string">"Failed to retry register "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                    logger.warn(<span class="string">"Failed to retry register "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新取消注册没有取消注册成功的URL集合</span></span><br><span class="line">        <span class="keyword">if</span> (!failedUnregistered.isEmpty()) &#123;</span><br><span class="line">            Set&lt;URL&gt; failed = <span class="keyword">new</span> HashSet&lt;URL&gt;(failedUnregistered);</span><br><span class="line">            <span class="keyword">if</span> (!failed.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Retry unregister "</span> + failed);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (URL url : failed) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            doUnregister(url);</span><br><span class="line">                            failedUnregistered.remove(url);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                            logger.warn(<span class="string">"Failed to retry unregister  "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                    logger.warn(<span class="string">"Failed to retry unregister  "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 重新订阅 之前订阅失败的URL</span></span><br><span class="line"><span class="comment">         *1 把要订阅的URL映射的路径与监听器绑定</span></span><br><span class="line"><span class="comment">         *2 创建该监听器关联的ChildListener，底层又会使用TargetChildListener去包裹ChildListener，注意，TargetChildListener的实现会有不同</span></span><br><span class="line"><span class="comment">         *3 TargetChildListener直接监听订阅的URL映射路径的子路径，当子路径有变化，先触发TargetChildListener的方法，然后该方法会调用ChildListener的childChanged方法，接着调用监听的notify方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * TargetChildListener</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!failedSubscribed.isEmpty()) &#123;</span><br><span class="line">            Map&lt;URL, Set&lt;NotifyListener&gt;&gt; failed = <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failedSubscribed);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failed).entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getValue() == <span class="keyword">null</span> || entry.getValue().size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    failed.remove(entry.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (failed.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Retry subscribe "</span> + failed);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : failed.entrySet()) &#123;</span><br><span class="line">                        URL url = entry.getKey();</span><br><span class="line">                        Set&lt;NotifyListener&gt; listeners = entry.getValue();</span><br><span class="line">                        <span class="keyword">for</span> (NotifyListener listener : listeners) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                doSubscribe(url, listener);</span><br><span class="line">                                listeners.remove(listener);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                                logger.warn(<span class="string">"Failed to retry subscribe "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                    logger.warn(<span class="string">"Failed to retry subscribe "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新移除URL映射路径下的子路径关联的监听器</span></span><br><span class="line">        <span class="keyword">if</span> (!failedUnsubscribed.isEmpty()) &#123;</span><br><span class="line">            Map&lt;URL, Set&lt;NotifyListener&gt;&gt; failed = <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failedUnsubscribed);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(failed).entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getValue() == <span class="keyword">null</span> || entry.getValue().isEmpty()) &#123;</span><br><span class="line">                    failed.remove(entry.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (failed.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Retry unsubscribe "</span> + failed);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : failed.entrySet()) &#123;</span><br><span class="line">                        URL url = entry.getKey();</span><br><span class="line">                        Set&lt;NotifyListener&gt; listeners = entry.getValue();</span><br><span class="line">                        <span class="keyword">for</span> (NotifyListener listener : listeners) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                doUnsubscribe(url, listener);</span><br><span class="line">                                listeners.remove(listener);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                                logger.warn(<span class="string">"Failed to retry unsubscribe "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                    logger.warn(<span class="string">"Failed to retry unsubscribe "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新通知【看通知的URL列表（发生改变的URL列表）和原始的URL列表对比，看是否改变，改变了就需要重新暴露服务】</span></span><br><span class="line">        <span class="keyword">if</span> (!failedNotified.isEmpty()) &#123;</span><br><span class="line">            Map&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt; failed = <span class="keyword">new</span> HashMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt;(failedNotified);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt; entry : <span class="keyword">new</span> HashMap&lt;URL, Map&lt;NotifyListener, List&lt;URL&gt;&gt;&gt;(failed).entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getValue() == <span class="keyword">null</span> || entry.getValue().size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    failed.remove(entry.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (failed.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Retry notify "</span> + failed);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Map&lt;NotifyListener, List&lt;URL&gt;&gt; values : failed.values()) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Map.Entry&lt;NotifyListener, List&lt;URL&gt;&gt; entry : values.entrySet()) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                NotifyListener listener = entry.getKey();</span><br><span class="line">                                List&lt;URL&gt; urls = entry.getValue();</span><br><span class="line">                                listener.notify(urls);</span><br><span class="line">                                values.remove(listener);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                                logger.warn(<span class="string">"Failed to retry notify "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="comment">// Ignore all the exceptions and wait for the next retry</span></span><br><span class="line">                    logger.warn(<span class="string">"Failed to retry notify "</span> + failed + <span class="string">", waiting for again, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重试方法就是遍历缓存中五个 failedXxx属性，重试对应的操作，很清晰。</p><h3 id="销毁-1"><a href="#销毁-1" class="headerlink" title="销毁"></a>销毁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FailbackRegistry</span> <span class="keyword">extends</span> <span class="title">AbstractRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父方法，取消注册和订阅</span></span><br><span class="line">        <span class="keyword">super</span>.destroy();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 取消重试任务</span></span><br><span class="line">            retryFuture.cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 优雅关闭线程池</span></span><br><span class="line">        ExecutorUtil.gracefulShutdown(retryExecutor, retryPeriod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其它代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取消注册和订阅，并关闭重试任务。取消注册和订阅还是调用其父类 AbstractRegistry 的 destroy 的方法，在父类基础上增加了对任务取消操作以及关闭重试线程池。</p><h2 id="RegistryFactory"><a href="#RegistryFactory" class="headerlink" title="RegistryFactory"></a>RegistryFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RegistryFactory. (SPI, Singleton, ThreadSafe) 注册中心工厂接口，创建的注册中心，包含注册中心客户端。注意和注册中心客户端工厂的区别。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.registry.support.AbstractRegistryFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span>(<span class="string">"dubbo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取注册中心</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 注册中心地址，不允许为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注册中心引用，总不返回空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;<span class="string">"protocol"</span>&#125;)</span><br><span class="line">    <span class="function">Registry <span class="title">getRegistry</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册中心工厂，它是一个 Dubbo 的扩展点，默认扩展名是 <code>dubbo</code> ，即默认的扩展实现是 DubboRegistryFactory ，<code>@Adaptive</code> 注解表示会生成适配器类并根据 URL 参数中的 protocol 参数值选择相应的实现。用于负责创建 Registry 对象，每个 Registry 实现类都有对应的 RegistryFactory 工厂实现。</p><h2 id="AbstractRegistryFactory"><a href="#AbstractRegistryFactory" class="headerlink" title="AbstractRegistryFactory"></a>AbstractRegistryFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractRegistryFactory. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.registry.RegistryFactory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistryFactory</span> <span class="keyword">implements</span> <span class="title">RegistryFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Log output</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(AbstractRegistryFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LOCK 锁，用于 #destroyAll() 和 #getRegistry(url) 方法，处理对 REGISTRIES 属性访问的竞争。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock LOCK = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registry 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Registry&gt; REGISTRIES = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Registry&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get all registries</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> all registries</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Registry&gt; <span class="title">getRegistries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableCollection(REGISTRIES.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁所有的Registry对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isInfoEnabled()) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">"Close all registries "</span> + getRegistries());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得锁</span></span><br><span class="line">        <span class="comment">// Lock up the registry shutdown process</span></span><br><span class="line">        LOCK.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 循环调用 destroy() 方法</span></span><br><span class="line">            <span class="keyword">for</span> (Registry registry : getRegistries()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// AbstractRegistry 实现了公用的销毁逻辑，取消注册和订阅</span></span><br><span class="line">                    registry.destroy();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    LOGGER.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清空缓存</span></span><br><span class="line">            REGISTRIES.clear();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Release the lock</span></span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Registry <span class="title">getRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        url = url.setPath(RegistryService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()) // 将 <span class="title">RegistryService</span> 的类名设置为 <span class="title">URL</span> 的 <span class="title">path</span> 值</span></span><br><span class="line"><span class="class">                .<span class="title">addParameter</span>(<span class="title">Constants</span>.<span class="title">INTERFACE_KEY</span>, <span class="title">RegistryService</span>.<span class="title">class</span>.<span class="title">getName</span>()) // 将 <span class="title">RegistryService</span> 的类名设置为 <span class="title">URL</span> 的<span class="title">interface</span> 值，该属性在后来的订阅通知很有用</span></span><br><span class="line"><span class="class">                .<span class="title">removeParameters</span>(<span class="title">Constants</span>.<span class="title">EXPORT_KEY</span>, <span class="title">Constants</span>.<span class="title">REFER_KEY</span>)</span>; <span class="comment">// 规范 URL 操作，及删除 export 和 refer 参数</span></span><br><span class="line">        String key = url.toServiceString();</span><br><span class="line">        <span class="comment">// Lock the registry access process to ensure a single instance of the registry</span></span><br><span class="line">        LOCK.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 访问缓存</span></span><br><span class="line">            Registry registry = REGISTRIES.get(key);</span><br><span class="line">            <span class="keyword">if</span> (registry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> registry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 缓存未命中，创建Registry 实例，交给具体子类实现</span></span><br><span class="line">            registry = createRegistry(url);</span><br><span class="line">            <span class="keyword">if</span> (registry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not create registry "</span> + url);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写入缓存</span></span><br><span class="line">            REGISTRIES.put(key, registry);</span><br><span class="line">            <span class="keyword">return</span> registry;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Release the lock</span></span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建注册中心的模版方法，由具体子类实现，过程包括：</span></span><br><span class="line"><span class="comment">     * 1 创建注册中心客户端</span></span><br><span class="line"><span class="comment">     * 2 启动客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 注册中心地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Registry 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 RegistryFactory 接口，是RegistryFactory 抽象类，主要两个工作，将获取的注册中心放入到缓存和实现了公用的销毁逻辑，取消注册和订阅。</p><h2 id="NotifyListener"><a href="#NotifyListener" class="headerlink" title="NotifyListener"></a>NotifyListener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NotifyListener. (API, Prototype, ThreadSafe)  通知监听器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> com.alibaba.dubbo.registry.RegistryService#subscribe(URL, NotifyListener)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NotifyListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当收到订阅URL对应的数据发生变化，通知触发</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urls 已注册信息列表，总不为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口的实现类主要分为两大类，RegistryDirectory 和 匿名类内部类，具体的作用在订阅通知章节说明。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章主要介绍了注册的抽象层，接下来的文章会分析 Zookeeper 和 Redis 的实现，其他两种不做分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 Dubbo 体系中，注册中心是核心组件之一。Dubbo 本身是一个分布式的 RPC 框架，依赖于 Dubbo 的应用都是单独部署的，为了
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 服务容器</title>
    <link href="https://gentryhuang.com/posts/714ea63d/"/>
    <id>https://gentryhuang.com/posts/714ea63d/</id>
    <published>2020-04-09T16:00:00.000Z</published>
    <updated>2020-09-04T07:39:03.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面的 Dubbo SPI、Dubbo配置等文章描述的几乎都只是服务暴露、服务引用、服务调用之前的准备工作，有了这些准备工作后，下面介绍Dubbo的服务容器，通过Dubbo服务容器可以非常方便启动一个Dubbo服务。</p><h2 id="Dubbo服务容器"><a href="#Dubbo服务容器" class="headerlink" title="Dubbo服务容器"></a>Dubbo服务容器</h2><p>Dubbo的服务容器只是一个简单的Main，类似SpringBoot,负责初始化和启动不同功能的 <font color="#c7254e"> Container </font>，如果说dubbo的服务容器是一个简单的Main方法，那么承载不同功能的Container就是服务容器的具体实现，可以有不同的类型。uml关系图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/main-container.jpg" alt></p><h2 id="容器扩展点"><a href="#容器扩展点" class="headerlink" title="容器扩展点"></a>容器扩展点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Container. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 服务容器接口，Dubbo的扩展点，默认为 spring</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span>(<span class="string">"spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * start. 启动容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * stop. 体制容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动器Main"><a href="#启动器Main" class="headerlink" title="启动器Main"></a>启动器Main</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Main<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Container的配置项，如 dubbo.container=spring,log4j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTAINER_KEY = <span class="string">"dubbo.container"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo 优雅停机配置项，如 dubbo.shutdown.hook=true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SHUTDOWN_HOOK_KEY = <span class="string">"dubbo.shutdown.hook"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Container扩展点的加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ExtensionLoader&lt;Container&gt; loader = ExtensionLoader.getExtensionLoader(Container<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReentrantLock LOCK = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Condition STOP = LOCK.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 启动参数，可以在启动时指定要加载的容器，如 java com.alibaba.dubbo.container.Main spring log4j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 main 方法的参数没有传入值，则从配置中加载。如果获取不到就使用Container 默认扩展 spring</span></span><br><span class="line">            <span class="keyword">if</span> (args == <span class="keyword">null</span> || args.length == <span class="number">0</span>) &#123;</span><br><span class="line">                String config = ConfigUtils.getProperty(CONTAINER_KEY, loader.getDefaultExtensionName());</span><br><span class="line">                args = Constants.COMMA_SPLIT_PATTERN.split(config);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> List&lt;Container&gt; containers = <span class="keyword">new</span> ArrayList&lt;Container&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 使用Dubbo SPI 加载 Container ,并把加载的Container 放入到List中</span></span><br><span class="line">                containers.add(loader.getExtension(args[i]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">"Use container type("</span> + Arrays.toString(args) + <span class="string">") to run dubbo serivce."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当配置JVM启动参数带有 -Ddubbo.shutdown.hook=true时，添加关闭的ShutdownHook</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"true"</span>.equals(System.getProperty(SHUTDOWN_HOOK_KEY))) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 优雅停机</span></span><br><span class="line">                Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="string">"dubbo-container-shutdown-hook"</span>) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span> (Container container : containers) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 关闭容器</span></span><br><span class="line">                                container.stop();</span><br><span class="line">                                logger.info(<span class="string">"Dubbo "</span> + container.getClass().getSimpleName() + <span class="string">" stopped!"</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                                logger.error(t.getMessage(), t);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 获得 ReentrantLock</span></span><br><span class="line">                                LOCK.lock();</span><br><span class="line">                                <span class="comment">// 唤醒 Main 主线程的等待</span></span><br><span class="line">                                STOP.signal();</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                <span class="comment">// 释放 LOCK</span></span><br><span class="line">                                LOCK.unlock();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动容器</span></span><br><span class="line">            <span class="keyword">for</span> (Container container : containers) &#123;</span><br><span class="line">                container.start();</span><br><span class="line">                logger.info(<span class="string">"Dubbo "</span> + container.getClass().getSimpleName() + <span class="string">" started!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"[yyyy-MM-dd HH:mm:ss]"</span>).format(<span class="keyword">new</span> Date()) + <span class="string">" Dubbo service server started!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发生异常，打印错误日志，并JVM退出</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获得 LOCK 锁</span></span><br><span class="line">            LOCK.lock();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 释放锁，进入等待，直到被唤醒</span></span><br><span class="line"><span class="comment">             * 作用：线程不结束，不触发JVM退出，这样Dubbo就不会退出。如果不等待，main方法执行完成，就会触发JVM退出，导致Dubbo服务退出</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            STOP.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Dubbo service server stopped, interrupted by other thread!"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放 LOCK</span></span><br><span class="line">            LOCK.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><ul><li>dubbo服务容器只是一个简单Main 方法，默认情况下只会加载一个简单的Spring容器，用于暴露服务。Dubbo服务容器的加载内容可以扩展，即可通过容器扩展点进行扩展，如：spring、logback等。</li><li>dubbo服务容器是dubbo服务的启动器，它的本质是启动时加载dubbo的相关内容【通过spring配置，log4j配置等体现】然后启动Container。但是 实际生产中，一般不会直接使用dubbo的服务容器，更多主流的是使用Spring或者SpringBoot</li></ul><h2 id="SpringContainer"><a href="#SpringContainer" class="headerlink" title="SpringContainer"></a>SpringContainer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringContainer. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * 实现Container接口，Spring容器实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringContainer</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SpringContainer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 配置属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_CONFIG = <span class="string">"dubbo.spring.config"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认配置文件地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SPRING_CONFIG = <span class="string">"classpath*:META-INF/spring/*.xml"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 上下文 ，静态属性，全局唯一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> ClassPathXmlApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassPathXmlApplicationContext <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得Spring 配置文件的地址【先优先从JVM参数中取，没有再从dubbo.properties文件中取】</span></span><br><span class="line">        String configPath = ConfigUtils.getProperty(SPRING_CONFIG);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有配置就使用默认路径下的配置文件</span></span><br><span class="line">        <span class="keyword">if</span> (configPath == <span class="keyword">null</span> || configPath.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            configPath = DEFAULT_SPRING_CONFIG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Spring 上下文</span></span><br><span class="line">        context = <span class="keyword">new</span> ClassPathXmlApplicationContext(configPath.split(<span class="string">"[,\\s]+"</span>), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听器 [dubbo服务暴露、服务销毁以及优雅停机的关键]</span></span><br><span class="line">        context.addApplicationListener(<span class="keyword">new</span> DubboApplicationListener());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听容器关闭 [注册优雅停机钩子]</span></span><br><span class="line">        context.registerShutdownHook();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 刷新Spring容器</span></span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="comment">// 启动Spring容器，加载Dubbo的配置，从而启动Dubbo 服务</span></span><br><span class="line">        context.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 停止上下文，会触发 ContextStoppedEvent 事件</span></span><br><span class="line">                context.stop();</span><br><span class="line">                <span class="comment">// 关闭上下文，会触发 ContextClosedEvent 事件</span></span><br><span class="line">                context.close();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 置空，便于被回收</span></span><br><span class="line">                context = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><ul><li>DubboApplicationListener实现了ApplicationListener接口，用于监听Spring容器的起停，在启动和销毁的时候分别执行服务暴露和取消服务暴露以及执行优雅停机</li><li>创建DubboApplicationListener对象的时候，都会创建DubboBootstrap对象，该对象主要完成服务暴露、取消服务暴露、注册与移除jdk shutdownhook</li><li>在创建DubboBootstrap对象时，会为该类注入DubboShutdownHook对象，该对象继承了Thread，将释放资源的方法作为任务体，该对象是真正要注册到系统中的钩子，当JVM退出时该钩子会回调它的任务体</li></ul><p><strong>关系图如下</strong><br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/container-hook.jpg" alt></p><h3 id="DubboApplicationListener"><a href="#DubboApplicationListener" class="headerlink" title="DubboApplicationListener"></a>DubboApplicationListener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An application listener that listens the ContextClosedEvent.</span></span><br><span class="line"><span class="comment"> * Upon the event, this listener will do the necessary clean up to avoid memory leak.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo引导程序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DubboBootstrap dubboBootstrap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboApplicationListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建DubboBootstrap</span></span><br><span class="line">        dubboBootstrap = <span class="keyword">new</span> DubboBootstrap(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboApplicationListener</span><span class="params">(DubboBootstrap dubboBootstrap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dubboBootstrap = dubboBootstrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听spring事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationEvent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent applicationEvent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// spring容器刷新完成</span></span><br><span class="line">        <span class="keyword">if</span> (applicationEvent <span class="keyword">instanceof</span> ContextRefreshedEvent) &#123;</span><br><span class="line">            dubboBootstrap.start();</span><br><span class="line">            <span class="comment">// spring容器销毁</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (applicationEvent <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">            dubboBootstrap.stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DubboBootstrap"><a href="#DubboBootstrap" class="headerlink" title="DubboBootstrap"></a>DubboBootstrap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A bootstrap class to easily start and stop Dubbo via programmatic API.</span></span><br><span class="line"><span class="comment"> * The bootstrap class will be responsible to cleanup the resources during stop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboBootstrap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务配置对象列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ServiceConfig&gt; serviceConfigList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动期间是否注册 钩子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> registerShutdownHookOnStart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在嵌入式环境下[Main方法]运行Dubbo时使用的 钩子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DubboShutdownHook shutdownHook;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboBootstrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取DubboShutdownHook，并注入到该类中</span></span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">true</span>, DubboShutdownHook.getDubboShutdownHook());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboBootstrap</span><span class="params">(<span class="keyword">boolean</span> registerShutdownHookOnStart)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 获取DubboShutdownHook，并注入到该类中</span></span><br><span class="line">        <span class="keyword">this</span>(registerShutdownHookOnStart, DubboShutdownHook.getDubboShutdownHook());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboBootstrap</span><span class="params">(<span class="keyword">boolean</span> registerShutdownHookOnStart, DubboShutdownHook shutdownHook)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceConfigList = <span class="keyword">new</span> ArrayList&lt;ServiceConfig&gt;();</span><br><span class="line">        <span class="keyword">this</span>.shutdownHook = shutdownHook;</span><br><span class="line">        <span class="keyword">this</span>.registerShutdownHookOnStart = registerShutdownHookOnStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register service config to bootstrap, which will be called during &#123;<span class="doctag">@link</span> DubboBootstrap#stop()&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceConfig the service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the bootstrap instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DubboBootstrap <span class="title">registerServiceConfig</span><span class="params">(ServiceConfig serviceConfig)</span> </span>&#123;</span><br><span class="line">        serviceConfigList.add(serviceConfig);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dubbo引导程序 - start</span></span><br><span class="line"><span class="comment">     * 1 是否注册shutdown hook</span></span><br><span class="line"><span class="comment">     * 2 服务暴露</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动期间是否注册过shutdown hook</span></span><br><span class="line">        <span class="keyword">if</span> (registerShutdownHookOnStart) &#123;</span><br><span class="line">            registerShutdownHook();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果DubboShutdown hook 已经注册到系统中，需要移除掉</span></span><br><span class="line">            removeShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环服务配置对象，依次进行服务暴露</span></span><br><span class="line">        <span class="keyword">for</span> (ServiceConfig serviceConfig: serviceConfigList) &#123;</span><br><span class="line">            serviceConfig.export();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dubbo引导程序 - stop</span></span><br><span class="line"><span class="comment">     * 1 取消服务暴露</span></span><br><span class="line"><span class="comment">     * 2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ServiceConfig serviceConfig: serviceConfigList) &#123;</span><br><span class="line">            serviceConfig.unexport();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行 shutdown hook 释放资源</span></span><br><span class="line">        shutdownHook.destroyAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果启动期已经注册过，则从系统中移除 todo ??? 为什么还要注册到系统，直接根据spring销毁事件然后执行释放任务不就可以了吗？</span></span><br><span class="line">        <span class="keyword">if</span> (registerShutdownHookOnStart) &#123;</span><br><span class="line">            removeShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 shutdown hook</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(shutdownHook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除 shutdown hook</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().removeShutdownHook(shutdownHook);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">            <span class="comment">// ignore - VM is already shutting down</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DubboShutdownHook"><a href="#DubboShutdownHook" class="headerlink" title="DubboShutdownHook"></a>DubboShutdownHook</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The shutdown hook thread to do the clean up stuff.</span></span><br><span class="line"><span class="comment"> * This is a singleton in order to ensure there is only one shutdown hook registered.</span></span><br><span class="line"><span class="comment"> * Because &#123;<span class="doctag">@link</span> ApplicationShutdownHooks&#125; use &#123;<span class="doctag">@link</span> java.util.IdentityHashMap&#125;</span></span><br><span class="line"><span class="comment"> * to store the shutdown hooks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboShutdownHook</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DubboShutdownHook<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShutdownHook,类属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DubboShutdownHook dubboShutdownHook = <span class="keyword">new</span> DubboShutdownHook(<span class="string">"DubboShutdownHook"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DubboShutdownHook <span class="title">getDubboShutdownHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dubboShutdownHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Has it already been destroyed or not?</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 是否已经被销毁标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean destroyed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DubboShutdownHook</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShutdownHook的任务体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Run shutdown hook now."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        destroyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Destroy all the resources, including registries and protocols.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 销毁所有的资源，包括 Registry相关 和 Protocol相关</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果已经销毁则忽略</span></span><br><span class="line">        <span class="keyword">if</span> (!destroyed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁所有的 Registry,取消应用程序中的服务提供者和消费者的订阅与注册</span></span><br><span class="line">        AbstractRegistryFactory.destroyAll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 销毁所有的 Protocol</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * 这里的Protocol比较多，大体上可以分两类：</span></span><br><span class="line"><span class="comment">         * 1 和Registry相关的Protocol，RegistryProtocol关注服务的注册</span></span><br><span class="line"><span class="comment">         * 2 具体协议，如 DubboProtocol、httpProtocol等,关注服务的暴露和引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ExtensionLoader&lt;Protocol&gt; loader = ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (String protocolName : loader.getLoadedExtensions()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Protocol protocol = loader.getLoadedExtension(protocolName);</span><br><span class="line">                <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    protocol.destroy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LogbackContainer"><a href="#LogbackContainer" class="headerlink" title="LogbackContainer"></a>LogbackContainer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * LogbackContainer. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * 实现 Container 接口，Logback 容器实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogbackContainer</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志文件路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGBACK_FILE = <span class="string">"dubbo.logback.file"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志文件级别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGBACK_LEVEL = <span class="string">"dubbo.logback.level"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志保留天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGBACK_MAX_HISTORY = <span class="string">"dubbo.logback.maxhistory"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认日志级别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_LOGBACK_LEVEL = <span class="string">"ERROR"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得 logback 配置的日志文件路径</span></span><br><span class="line">        String file = ConfigUtils.getProperty(LOGBACK_FILE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (file != <span class="keyword">null</span> &amp;&amp; file.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获得日志级别</span></span><br><span class="line">            String level = ConfigUtils.getProperty(LOGBACK_LEVEL);</span><br><span class="line">            <span class="keyword">if</span> (level == <span class="keyword">null</span> || level.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                level = DEFAULT_LOGBACK_LEVEL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得日志保留天数，如果是0则永久保留</span></span><br><span class="line">            <span class="keyword">int</span> maxHistory = StringUtils.parseInteger(ConfigUtils.getProperty(LOGBACK_MAX_HISTORY));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化 logback</span></span><br><span class="line">            doInitializer(file, level, maxHistory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止为空，因为不需要关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 logback</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file       日志文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> level      日志级别</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxHistory 日志保留天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doInitializer</span><span class="params">(String file, String level, <span class="keyword">int</span> maxHistory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取日志工厂</span></span><br><span class="line">        LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过工厂获取Logger</span></span><br><span class="line">        Logger rootLogger = loggerContext.getLogger(Logger.ROOT_LOGGER_NAME);</span><br><span class="line">        rootLogger.detachAndStopAllAppenders();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建日志追加器</span></span><br><span class="line">        RollingFileAppender&lt;ILoggingEvent&gt; fileAppender = <span class="keyword">new</span> RollingFileAppender&lt;ILoggingEvent&gt;();</span><br><span class="line">        fileAppender.setContext(loggerContext);</span><br><span class="line">        fileAppender.setName(<span class="string">"application"</span>);</span><br><span class="line">        fileAppender.setFile(file);</span><br><span class="line">        fileAppender.setAppend(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建滚动策略</span></span><br><span class="line">        TimeBasedRollingPolicy&lt;ILoggingEvent&gt; policy = <span class="keyword">new</span> TimeBasedRollingPolicy&lt;ILoggingEvent&gt;();</span><br><span class="line">        policy.setContext(loggerContext);</span><br><span class="line">        policy.setMaxHistory(maxHistory);</span><br><span class="line">        policy.setFileNamePattern(file + <span class="string">".%d&#123;yyyy-MM-dd&#125;"</span>);</span><br><span class="line">        policy.setParent(fileAppender);</span><br><span class="line">        policy.start();</span><br><span class="line">        fileAppender.setRollingPolicy(policy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 格式</span></span><br><span class="line">        PatternLayoutEncoder encoder = <span class="keyword">new</span> PatternLayoutEncoder();</span><br><span class="line">        encoder.setContext(loggerContext);</span><br><span class="line">        encoder.setPattern(<span class="string">"%date [%thread] %-5level %logger (%file:%line\\) - %msg%n"</span>);</span><br><span class="line">        encoder.start();</span><br><span class="line">        fileAppender.setEncoder(encoder);</span><br><span class="line"></span><br><span class="line">        fileAppender.start();</span><br><span class="line"></span><br><span class="line">        rootLogger.addAppender(fileAppender);</span><br><span class="line">        rootLogger.setLevel(Level.toLevel(level));</span><br><span class="line">        rootLogger.setAdditive(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Log4jContainer"><a href="#Log4jContainer" class="headerlink" title="Log4jContainer"></a>Log4jContainer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Log4jContainer. (SPI, Singleton, ThreadSafe)</span></span><br><span class="line"><span class="comment"> * 实现Container接口，Log4j容器实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jContainer</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志文件路径配置，如 dubbo.log4j.file=/opt/log/access.log</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG4J_FILE = <span class="string">"dubbo.log4j.file"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志级别 如： dubbo.log4j.level=WARN</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG4J_LEVEL = <span class="string">"dubbo.log4j.level"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志子路径配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOG4J_SUBDIRECTORY = <span class="string">"dubbo.log4j.subdirectory"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认日志级别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_LOG4J_LEVEL = <span class="string">"ERROR"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动配置log4j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 log4j 配置的日志文件路径</span></span><br><span class="line">        String file = ConfigUtils.getProperty(LOG4J_FILE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取日志级别</span></span><br><span class="line">        <span class="keyword">if</span> (file != <span class="keyword">null</span> &amp;&amp; file.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String level = ConfigUtils.getProperty(LOG4J_LEVEL);</span><br><span class="line">            <span class="keyword">if</span> (level == <span class="keyword">null</span> || level.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                level = DEFAULT_LOG4J_LEVEL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建PropertyConfigurator所需的 Properties 对象，</span></span><br><span class="line">            Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">            properties.setProperty(<span class="string">"log4j.rootLogger"</span>, level + <span class="string">",application"</span>);</span><br><span class="line">            properties.setProperty(<span class="string">"log4j.appender.application"</span>, <span class="string">"org.apache.log4j.DailyRollingFileAppender"</span>);</span><br><span class="line">            properties.setProperty(<span class="string">"log4j.appender.application.File"</span>, file);</span><br><span class="line">            properties.setProperty(<span class="string">"log4j.appender.application.Append"</span>, <span class="string">"true"</span>);</span><br><span class="line">            properties.setProperty(<span class="string">"log4j.appender.application.DatePattern"</span>, <span class="string">"'.'yyyy-MM-dd"</span>);</span><br><span class="line">            properties.setProperty(<span class="string">"log4j.appender.application.layout"</span>, <span class="string">"org.apache.log4j.PatternLayout"</span>);</span><br><span class="line">            properties.setProperty(<span class="string">"log4j.appender.application.layout.ConversionPattern"</span>, <span class="string">"%d [%t] %-5p %C&#123;6&#125; (%F:%L) - %m%n"</span>);</span><br><span class="line">            PropertyConfigurator.configure(properties);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得日志子目录，用于多进程启动时，避免冲突</span></span><br><span class="line">        String subdirectory = ConfigUtils.getProperty(LOG4J_SUBDIRECTORY);</span><br><span class="line">        <span class="keyword">if</span> (subdirectory != <span class="keyword">null</span> &amp;&amp; subdirectory.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取 Logger 列表</span></span><br><span class="line">            Enumeration&lt;org.apache.log4j.Logger&gt; ls = LogManager.getCurrentLoggers();</span><br><span class="line">            <span class="keyword">while</span> (ls.hasMoreElements()) &#123;</span><br><span class="line">                org.apache.log4j.Logger l = ls.nextElement();</span><br><span class="line">                <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 拿到当前Logger 的追加器</span></span><br><span class="line">                    Enumeration&lt;Appender&gt; as = l.getAllAppenders();</span><br><span class="line">                    <span class="keyword">while</span> (as.hasMoreElements()) &#123;</span><br><span class="line">                        Appender a = as.nextElement();</span><br><span class="line">                        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> FileAppender) &#123;</span><br><span class="line">                            FileAppender fa = (FileAppender) a;</span><br><span class="line">                            String f = fa.getFile();</span><br><span class="line">                            <span class="keyword">if</span> (f != <span class="keyword">null</span> &amp;&amp; f.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">int</span> i = f.replace(<span class="string">'\\'</span>, <span class="string">'/'</span>).lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line">                                String path;</span><br><span class="line">                                <span class="keyword">if</span> (i == -<span class="number">1</span>) &#123;</span><br><span class="line">                                    path = subdirectory;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    path = f.substring(<span class="number">0</span>, i);</span><br><span class="line">                                    <span class="keyword">if</span> (!path.endsWith(subdirectory)) &#123;</span><br><span class="line">                                        path = path + <span class="string">"/"</span> + subdirectory;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    f = f.substring(i + <span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 设置新的文件名</span></span><br><span class="line">                                fa.setFile(path + <span class="string">"/"</span> + f);</span><br><span class="line">                                <span class="comment">// 生效配置</span></span><br><span class="line">                                fa.activateOptions();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空方法，无需关闭</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h2><ul><li><p>通过加载properties配置文件加载目标容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo.container&#x3D;spring,logback,log4j</span><br></pre></td></tr></table></figure></li><li><p>缺省只加载spring容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java org.apache.dubbo.container.Main</span><br></pre></td></tr></table></figure></li><li><p>通过main方法参数传入要加载的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java org.apache.dubbo.container.Main spring logback log4j</span><br></pre></td></tr></table></figure></li><li><p>通过 JVM 启动参数传入要加载的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java org.apache.dubbo.container.Main -Ddubbo.container&#x3D;spring,jetty,log4j</span><br></pre></td></tr></table></figure></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然实际生产中一般不会直接使用dubbo的服务容器，但是它的实现机制我们可以学习下。了解了Dubbo服务容器后，我们从源码层面上重新认识了Dubbo的启停流程，从下一篇文章开始正式进入到Dubbo的核心模块源码分析阶段。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面的 Dubbo SPI、Dubbo配置等文章描述的几乎都只是服务暴露、服务引用、服务调用之前的准备工作，有了这些准备工作后，下面介绍Du
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
      <category term="Spring" scheme="https://gentryhuang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo源码分析 - 注解配置</title>
    <link href="https://gentryhuang.com/posts/1a889dcd/"/>
    <id>https://gentryhuang.com/posts/1a889dcd/</id>
    <published>2020-04-01T16:00:00.000Z</published>
    <updated>2020-09-04T07:15:55.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://gentryhuang.com/posts/a8d76a91/">Dubbo源码分析 - XML配置</a> 中，详细介绍了Dubbo的XML配置方式，本篇文章介绍Dubbo注解配置方式，使用示例见 <a href="https://gentryhuang.com/posts/7202a9c0/">Dubbo示例 - 注解配置</a>。</p><h2 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationProvider</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Java Config + 注解的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ProviderConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableDubbo</span>(scanBasePackages = <span class="string">"com.alibaba.dubbo.examples.annotation.impl"</span>)</span><br><span class="line">    <span class="meta">@PropertySource</span>(<span class="string">"classpath:/com/alibaba/dubbo/examples/annotation/dubbo-provider.properties"</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里通过Java Config显示组装Bean，会注入给Dubbo服务，即标注有<span class="doctag">@Service</span>的类。如果不显示装配，Dubbo会默认创建内置的配置类定义，创建内置的配置类定义的前提是配置了相关的属性，否则不会创建。其他配置类似。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ProviderConfig <span class="title">providerConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ProviderConfig providerConfig = <span class="keyword">new</span> ProviderConfig();</span><br><span class="line">            providerConfig.setTimeout(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> providerConfig;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 <a href="https://gentryhuang.com/posts/7202a9c0/">Dubbo示例 - 注解配置</a> 中的提供者配置进行说明。当Spring启动后，会先获取配置类上的 <code>@PropertySource</code> 注解，把外部配置进行解析然后放入Spring环境中，为之后流程中的Dubbo配置类的对象进行属性赋值。Spring会递归获取配置类的 <code>@Import</code> 注解，即搜集配置相关的所有<code>@Import</code>注解，以获取使用该注解引入的Selector或Registrar类，这些类是用来给Spring容器导入组件的。Dubbo的注解实现包括两大部分，一个是外部化配置，另一个是注解驱动，它们的能力是由Selector或Registrar类导入所需组件实现的，笔者调试这块花了很多时间，细节点还是挺多的，由于这些都是Spring源码的知识点就不进行分析了。</p><h2 id="注解配置代码结构"><a href="#注解配置代码结构" class="headerlink" title="注解配置代码结构"></a>注解配置代码结构</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-annotation-struct.jpg" alt></p><p>在 Dubbo 2.5.7之前的版本 ，Dubbo 提供了两个核心注解 <code>@Service</code> 以及 <code>@Reference</code>，分别用于Dubbo 服务提供和 Dubbo 服务引用。<code>@Service</code> 作为 XML配置&lt;dubbo:service&gt;的替代，与 Spring Framework @Service 类似，用于服务暴露。<code>@Reference</code> 则是替代&lt;dubbo:reference &gt; ，类似于 Spring 中的 <code>@Autowired</code>，引用服务。但2.5.7之前Dubbo注解是基于AnnotationBean实现的，主要存在以下几个问题：</p><ul><li>注解支持不充分，需要XML配置&lt;dubbo:annotation&gt;</li><li>@Service 不支持Spring AOP</li><li>@Reference 不支持字段继承性</li></ul><p>基于原来实现思路的基础上无法解决历史遗留问题，从2.5.7开始Dubbo的注解实现已经完全重写，AnnotationBean已经被废弃。</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>Spring Framework 3.1 引入了 <code>@ComponentScan</code> 完全替代了 XML 元素 &lt;context:component-scan&gt; 。同样地， <code>@DubboComponentScan</code> 作为 Dubbo 2.5.7 新增的 Annotation，也是XML 元素 &lt;dubbo:annotation&gt; 的替代方案，与注解驱动相关。 <code>@DubboComponentScan</code> 相对比较繁重，原因在于处理Dubbo <code>@Service</code> 标注的类暴露Dubbo服务外，还要支持Spring Bean的 <code>@Reference</code> 字段或方法注入Dubbo服务代理，即 <code>@DubboComponentScan</code> 除了扫描 Dubbo @Service 组件以外，还需要处理 @Reference注入。需要注意的是，如果 <code>@Reference</code> 字段或方法所在的类不是 Spring Bean 的话， <code>@DubboComponentScan</code> 不会处理 <code>@Reference</code> 注入，其原理与 Spring <code>@Autowired</code> 一致。<code>@EnableDubboConfig</code> 用于支持Dubbo的外部化配置，常用于显示指定Dubbo的配置。需要注意的是Dubbo框架中的dubbo.properties从某种意义上来说是特殊的Dubbo的外部化配置，框架默认情况下会加载类路径下的该配置文件，详细参见 <a href="http://localhost:4000/posts/1d3295e6/" target="_blank" rel="noopener">属性配置</a>。</p><h2 id="注解介绍"><a href="#注解介绍" class="headerlink" title="注解介绍"></a>注解介绍</h2><h3 id="Service-注解"><a href="#Service-注解" class="headerlink" title="@Service 注解"></a>@Service 注解</h3><p><code>@Service</code> 用来配置Dubbo的服务提供方，通过 <code>@Service</code> 上提供的属性，可以进一步的定制化 Dubbo 的服务提供者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; interfaceClass() <span class="keyword">default</span> <span class="keyword">void</span><span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">interfaceName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">version</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">group</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">path</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">export</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">token</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">deprecated</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dynamic</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">accesslog</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">executes</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">document</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">delay</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">local</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">stub</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">cluster</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">proxy</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">connections</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">callbacks</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">onconnect</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">ondisconnect</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">owner</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">layer</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">retries</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">loadbalance</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">async</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">actives</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">sent</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">mock</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">validation</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">cache</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    String[] filter() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] listener() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] parameters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function">String <span class="title">application</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">module</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">provider</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    String[] protocol() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function">String <span class="title">monitor</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    String[] registry() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Service定义在一个类上，表示一个服务的具体实现，比较重要的属性：</p><blockquote><p>interfaceClass：指定服务提供方实现的 interface 的类<br> interfaceName：指定服务提供方实现的 interface 的类名<br> version：指定服务的版本号<br> group：指定服务的分组<br> export：是否暴露服务<br> registry：是否向注册中心注册服务<br> application：应用配置<br> module：模块配置<br> provider：服务提供方配置<br> protocol：协议配置<br> monitor：监控中心配置<br> registry：注册中心配置</p></blockquote><p>其中，application、module、provider、protocol、monitor、registry属性需要提供的是对应的Spring Bean的名字，Bean组装方式可以通过XML配置，也可以通过Java Config配置。</p><h3 id="Reference-注解"><a href="#Reference-注解" class="headerlink" title="@Reference 注解"></a>@Reference 注解</h3><p><code>@Reference</code> 用来配置Dubbo的服务消费方，通过 <code>@Reference</code> 上提供的属性，可以进一步的定制化 Dubbo 的服务消费方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reference</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@export</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Reference &#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; interfaceClass() <span class="keyword">default</span> <span class="keyword">void</span><span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">interfaceName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">version</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">group</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">url</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">client</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">generic</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">injvm</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">lazy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">stubevent</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">reconnect</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">sticky</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">proxy</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">stub</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">cluster</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">connections</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">callbacks</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">onconnect</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">ondisconnect</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">owner</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">layer</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">retries</span><span class="params">()</span> <span class="keyword">default</span> 2</span>;</span><br><span class="line">    <span class="function">String <span class="title">loadbalance</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">async</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">actives</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">sent</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">mock</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">validation</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">cache</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    String[] filter() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] listener() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] parameters() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function">String <span class="title">application</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">module</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">consumer</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">monitor</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    String[] registry() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Reference 可以定义在类中的一个字段上，也可以定义在一个方法上，甚至可以用来修饰另一个 annotation，表示一个服务引用。一般多把@Reference 定义在一个字段上，该注解有以下重要属性：</p><blockquote><p>interfaceClass：指定服务的 interface 的类<br> interfaceName：指定服务的 interface 的类名<br> version：指定服务的版本号<br> group：指定服务的分组<br> url：通过指定服务提供方的 URL 地址直接绕过注册中心发起调用<br> application：应用配置<br> module：模块配置<br> consumer：服务消费方配置<br> protocol：协议配置<br> monitor：监控中心配置<br> registry：注册中心配置</p></blockquote><p>其中，application、module、consumer、protocol、monitor、registry属性需要提供的是对应的Spring Bean的名字，Bean组装方式可以通过XML配置，也可以通过Java Config配置。</p><h3 id="EnableDubbo-注解"><a href="#EnableDubbo-注解" class="headerlink" title="@EnableDubbo 注解"></a>@EnableDubbo 注解</h3><p><code>@EnableDubbo</code> 注解是 <code>@EnableDubboConfig</code> 和 <code>@DubboComponentScan</code> 两者组合的便捷表达方式。与注解驱动相关的是 <code>@DubboComponentScan</code>，与外部化配置相关的是 <code>@EnableDubboConfig</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@EnableDubboConfig</span>  <span class="comment">// 开启Dubbo Config 【DubboConfig对象的创建和DubboConfig中的属性设置】</span></span><br><span class="line"><span class="meta">@DubboComponentScan</span> <span class="comment">// 扫描Dubbo 的@Service 和 @Reference 注解的包或者类，从而创建Bean对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableDubbo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 配置<span class="doctag">@DubboComponentScan</span> 注解 扫描的包</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Base packages to scan for annotated <span class="doctag">@Service</span> classes.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Use &#123;<span class="doctag">@link</span> #scanBasePackageClasses()&#125; for a type-safe alternative to String-based</span></span><br><span class="line"><span class="comment">     * package names.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> DubboComponentScan#basePackages()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(annotation = DubboComponentScan<span class="class">.<span class="keyword">class</span>, <span class="title">attribute</span> </span>= <span class="string">"basePackages"</span>)</span><br><span class="line">    String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 配置 <span class="doctag">@DubboComponentScan</span> 注解 扫描的类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Type-safe alternative to &#123;<span class="doctag">@link</span> #scanBasePackages()&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment">     * scan for annotated <span class="doctag">@Service</span> classes. The package of each class specified will be</span></span><br><span class="line"><span class="comment">     * scanned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> classes from the base packages to scan</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> DubboComponentScan#basePackageClasses</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(annotation = DubboComponentScan<span class="class">.<span class="keyword">class</span>, <span class="title">attribute</span> </span>= <span class="string">"basePackageClasses"</span>)</span><br><span class="line">    Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置 <span class="doctag">@EnableDubboConfig</span> 注解，是否将配置属性绑定到多个Spring Bean 上</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It indicates whether &#123;<span class="doctag">@link</span> AbstractConfig&#125; binding to multiple Spring Beans.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the default value is &lt;code&gt;false&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> EnableDubboConfig#multiple()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(annotation = EnableDubboConfig<span class="class">.<span class="keyword">class</span>, <span class="title">attribute</span> </span>= <span class="string">"multiple"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">multipleConfig</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@EnableDubbo</code> 可以通过 <strong>scanBasePackages属性</strong> 指定要扫描的包，通过 <strong>scanBasePackageClasses属性</strong> 指定要扫描的类[最后还是会转为扫描包的方式]，进而扫描Dubbo 的服务提供者（以 @Service 标注）以及 Dubbo 的服务消费者（以 Reference 标注）。扫描到 Dubbo 的服务提供方和消费者之后，对其做相应的组装并初始化，并最终完成服务暴露或者引用的工作。如果不使用外部化配置的话，也可以直接使用 @DubboComponentScan。</p><h3 id="EnableDubboConfig-注解"><a href="#EnableDubboConfig-注解" class="headerlink" title="@EnableDubboConfig 注解"></a>@EnableDubboConfig 注解</h3><p>该注解用于开启Dubbo配置，支持外部化配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * As  a convenient and multiple &#123;<span class="doctag">@link</span> EnableDubboConfigBinding&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBinding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigConfiguration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigConfigurationSelector</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 开启Dubbo配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(DubboConfigConfigurationSelector<span class="class">.<span class="keyword">class</span>) </span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableDubboConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置是否绑定到多个Spring Bean上，即表示是否支持多Dubbo配置Bean的绑定，默认值为false，即单Dubbo 配置Bean的绑定。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It indicates whether binding to multiple Spring Beans.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the default value is &lt;code&gt;false&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@revised</span> 2.5.9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">multiple</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解有一个核心的属性，<code>multiple</code> 属性用于支持多Dubbo配置Bean的数据绑定。<code>@Import</code> 的value属性值 <code>DubboConfigConfigurationSelector</code> 用于给Spring容器导入组件，导入的组件是 <code>DubboConfigConfiguration.Single</code> 或 <code>DubboConfigConfiguration.Multiple</code>，具体导入哪个组件取决于 <code>multiple</code> 的值。</p><h4 id="DubboConfigConfigurationSelector"><a href="#DubboConfigConfigurationSelector" class="headerlink" title="DubboConfigConfigurationSelector"></a>DubboConfigConfigurationSelector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigConfigurationSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> importingClassMetadata <span class="doctag">@Import</span>(DubboConfigConfigurationSelector.class) 所标注的注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 @EnableDubboConfig注解的属性</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationAttributes.fromMap(</span><br><span class="line">                importingClassMetadata.getAnnotationAttributes(EnableDubboConfig<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">//获得multiple属性</span></span><br><span class="line">        <span class="keyword">boolean</span> multiple = attributes.getBoolean(<span class="string">"multiple"</span>);</span><br><span class="line">        <span class="comment">// 如果为true，则注册 DubboConfigConfiguration.Multiple Bean对象</span></span><br><span class="line">        <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">            <span class="keyword">return</span> of(DubboConfigConfiguration.Multiple<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果为false，则注册 DubboConfigConfiguration.Single Bean对象</span></span><br><span class="line">            <span class="keyword">return</span> of(DubboConfigConfiguration.Single<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T[] of(T... values) &#123;</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HIGHEST_PRECEDENCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类实现了Spring的ImportSelector接口，功能如下：</p><ol><li>利用ImportSelector要导入哪些组件，只需要返回要导入组件的全限定类名，即 selectImports方法返回值。</li><li>如果selectImports方法返回值对应的类，它里面有使用@Bean注解的方法，那么此时给容器中导入的不只有当前返回值对应类的实例，还有该类型中加了@Bean对应的实例。</li><li>给容器导入的不是 DubboConfigConfigurationSelector，因为它实现了ImportSelector接口，导入的是该类的selectImports方法中返回的值对应的类。</li></ol><p>通过以上规则可以知道，该类就是给Spring容器导入 <code>DubboConfigConfiguration.Single</code> 或 <code>DubboConfigConfiguration.Multiple</code> 组件。可以看出它们都是 DubboConfigConfiguration 类的内部类，下面我们看下该类的具体信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dubbo &#123;<span class="doctag">@link</span> AbstractConfig Config&#125; &#123;<span class="doctag">@link</span> Configuration&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Configuration</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBindings</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBinding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ApplicationConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ModuleConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> RegistryConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ProtocolConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> MonitorConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ProviderConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConsumerConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Single Dubbo &#123;<span class="doctag">@link</span> AbstractConfig Config&#125; Bean Binding</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@EnableDubboConfigBinding</span> 注解 prefix 都是单数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@EnableDubboConfigBindings</span>(&#123;</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.application"</span>, type = ApplicationConfig<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">            @<span class="title">EnableDubboConfigBinding</span>(<span class="title">prefix</span> </span>= <span class="string">"dubbo.module"</span>, type = ModuleConfig<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">            @<span class="title">EnableDubboConfigBinding</span>(<span class="title">prefix</span> </span>= <span class="string">"dubbo.registry"</span>, type = RegistryConfig<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">            @<span class="title">EnableDubboConfigBinding</span>(<span class="title">prefix</span> </span>= <span class="string">"dubbo.protocol"</span>, type = ProtocolConfig<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">            @<span class="title">EnableDubboConfigBinding</span>(<span class="title">prefix</span> </span>= <span class="string">"dubbo.monitor"</span>, type = MonitorConfig<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">            @<span class="title">EnableDubboConfigBinding</span>(<span class="title">prefix</span> </span>= <span class="string">"dubbo.provider"</span>, type = ProviderConfig<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">            @<span class="title">EnableDubboConfigBinding</span>(<span class="title">prefix</span> </span>= <span class="string">"dubbo.consumer"</span>, type = ConsumerConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    &#125;)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">static</span> <span class="title">class</span> <span class="title">Single</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Multiple Dubbo &#123;<span class="doctag">@link</span> AbstractConfig Config&#125; Bean Binding</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@EnableDubboConfigBinding</span> 注解 prefix 都是复数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@EnableDubboConfigBindings</span>(&#123;</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.applications"</span>, type = ApplicationConfig<span class="class">.<span class="keyword">class</span>, <span class="title">multiple</span> </span>= <span class="keyword">true</span>),</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.modules"</span>, type = ModuleConfig<span class="class">.<span class="keyword">class</span>, <span class="title">multiple</span> </span>= <span class="keyword">true</span>),</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.registries"</span>, type = RegistryConfig<span class="class">.<span class="keyword">class</span>, <span class="title">multiple</span> </span>= <span class="keyword">true</span>),</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.protocols"</span>, type = ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">multiple</span> </span>= <span class="keyword">true</span>),</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.monitors"</span>, type = MonitorConfig<span class="class">.<span class="keyword">class</span>, <span class="title">multiple</span> </span>= <span class="keyword">true</span>),</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.providers"</span>, type = ProviderConfig<span class="class">.<span class="keyword">class</span>, <span class="title">multiple</span> </span>= <span class="keyword">true</span>),</span><br><span class="line">            <span class="meta">@EnableDubboConfigBinding</span>(prefix = <span class="string">"dubbo.consumers"</span>, type = ConsumerConfig<span class="class">.<span class="keyword">class</span>, <span class="title">multiple</span> </span>= <span class="keyword">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiple</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DubboConfigConfiguration 类中没有属性和方法，只有两个静态内部类，具体导入哪个类上面已经介绍过了，下面我们来详介绍下 <code>@EnableDubboConfigBindings</code> 和 <code>@EnableDubboConfigBinding</code> 注解。</p><h4 id="EnableDubboConfigBindings-注解"><a href="#EnableDubboConfigBindings-注解" class="headerlink" title="@EnableDubboConfigBindings 注解"></a>@EnableDubboConfigBindings 注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Multiple &#123;<span class="doctag">@link</span> EnableDubboConfigBinding&#125; &#123;<span class="doctag">@link</span> Annotation&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBinding</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(DubboConfigBindingsRegistrar<span class="class">.<span class="keyword">class</span>) </span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableDubboConfigBindings</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value of &#123;<span class="doctag">@link</span> EnableDubboConfigBindings&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    EnableDubboConfigBinding[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解有一个value属性，类型是 <code>EnableDubboConfigBinding[]</code> ，即 <code>@EnableDubboConfigBinding</code> 数组。该注解上使用 <code>@Import</code> 注解，使用DubboConfigBindingsRegistrar 类给Spring容器导入组件，下面我们继续跟进，看下具体导入哪些组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AbstractConfig Dubbo Config&#125; binding Bean registrar for &#123;<span class="doctag">@link</span> EnableDubboConfigBindings&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBindings</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigBindingRegistrar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigBindingsRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> importingClassMetadata 标注类注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry Bean定义注册表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获得 EnableDubboConfigBindings 注解</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBindings<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">// 获得EnableDubboConfigBindings 注解的value 属性值（这里是 EnableDubboConfigBinding 注解数组）</span></span><br><span class="line">        AnnotationAttributes[] annotationAttributes = attributes.getAnnotationArray(<span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">// 创建DubboConfigBindignRegistrar 对象，并设置环境变量</span></span><br><span class="line">        DubboConfigBindingRegistrar registrar = <span class="keyword">new</span> DubboConfigBindingRegistrar();</span><br><span class="line">        registrar.setEnvironment(environment);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次遍历 EnableDubboConfigBinding 注解集合，调用 DubboConfigBindingRegistrar的注册Bean方法进行组件注册</span></span><br><span class="line">        <span class="keyword">for</span> (AnnotationAttributes element : annotationAttributes) &#123;</span><br><span class="line">            <span class="comment">// 根据 EnableDubboConfigBinding 注解信息，进行对应组件的注册</span></span><br><span class="line">            registrar.registerBeanDefinitions(element, registry);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        Assert.isInstanceOf(ConfigurableEnvironment<span class="class">.<span class="keyword">class</span>, <span class="title">environment</span>)</span>;</span><br><span class="line">        <span class="keyword">this</span>.environment = (ConfigurableEnvironment) environment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的类主要做了三件事情：</p><ol><li>获取 @EnableDubboConfigBindings 注解信息，并获取该注解的value属性值，即获取的是 @EnableDubboConfigBinding 注解数组。</li><li>创建 DubboConfigBindingRegistrar对象。</li><li>遍历@EnableDubboConfigBinding 注解数组，调用DubboConfigBindingRegistrar对象的 registerBeanDefinitions方法。</li></ol><p>我们可以发现，@EnableDubboConfigBindings利用DubboConfigBindingsRegistrar导入组件逻辑很简单，因为整个导入逻辑都封装在了DubboConfigBindingRegistrar对象的 registerBeanDefinitions方法中。我们接着分析DubboConfigBindingsRegistrar类，需要说明的是@EnableDubboConfigBinding注解就是通过@Import注解使用该类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigBindingRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;其他代码&#125;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> attributes <span class="doctag">@EnableDubboConfigBinding</span>注解信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry Bean定义注册表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationAttributes attributes, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得prefix 属性（因为有可能有占位符，需要要解析）</span></span><br><span class="line">        String prefix = environment.resolvePlaceholders(attributes.getString(<span class="string">"prefix"</span>));</span><br><span class="line">        <span class="comment">// 获得type属性，即AbstractConfig的实现类，这就是要导入的组件。需要特别说明的是，使用注解方式创建Dubbo的配置Bean，Dubbo Config 都是固定写在@EnableDubboConfigBinding注解属性中。</span></span><br><span class="line">        Class&lt;? extends AbstractConfig&gt; configClass = attributes.getClass(<span class="string">"type"</span>);</span><br><span class="line">        <span class="comment">// 获的multiple属性，决定配置是否用于多BeanDefinition</span></span><br><span class="line">        <span class="keyword">boolean</span> multiple = attributes.getBoolean(<span class="string">"multiple"</span>);</span><br><span class="line">        <span class="comment">// 注册Dubbo Config Bean</span></span><br><span class="line">        registerDubboConfigBeans(prefix, configClass, multiple, registry);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可以看出DubboConfigBindingsRegistrar就是使用 <code>DubboConfigBindingRegistrar</code> 对象解析@EnableDubboConfigBinding 注解信息，即配置属性的前缀和配置属性对应的Dubbo Config类，接着调用registerDubboConfigBeans 方法执行注册Bean定义逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigBindingRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册dubbo Config Bean对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefix      配置属性前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configClass 配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> multiple    是否支持多Bean配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry    Spring注册表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDubboConfigBeans</span><span class="params">(String prefix,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;? extends AbstractConfig&gt; configClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">boolean</span> multiple,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得prefix 开头的配置属性，以map形式返回 【environment.getPropertySources() 获得是系统属性、系统变量和@ResourceProperty注解导入的propertis配置属性】</span></span><br><span class="line">        Map&lt;String, Object&gt; properties = getSubProperties(environment.getPropertySources(), prefix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置类没有配置相关属性，则不创建对应的BeanDefinition</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(properties)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">"There is no property for binding to dubbo config class ["</span> + configClass.getName()</span><br><span class="line">                        + <span class="string">"] within prefix ["</span> + prefix + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 获得配置类的Bean名称，Bean名称生成规则取决与 multiple 的值</span></span><br><span class="line">        Set&lt;String&gt; beanNames = multiple ? resolveMultipleBeanNames(properties) : Collections.singleton(resolveSingleBeanName(properties, configClass, registry));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历Bean名字集合</span></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 注册Dubbo Config的Bean 对象【没有设置属性值】</span></span><br><span class="line">            registerDubboConfigBean(beanName, configClass, registry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 注册Dubbo Config的Bean对象对应的DubboConfigBindingBeanPostProcessor对象，即Dubbo配置属性绑定的后置处理器【注意，每一个Dubbo Config的Bean对象都对应一个绑定配置的后置处理器】</span></span><br><span class="line">            registerDubboConfigBindingBeanPostProcessor(prefix, beanName, multiple, registry);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册Dubbo ConfigBean对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName Bean的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configClass 配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry 注册表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDubboConfigBean</span><span class="params">(String beanName, Class&lt;? extends AbstractConfig&gt; configClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 configClass对应的Bean定义Builder [该过程Bean定义已经创建]</span></span><br><span class="line">        BeanDefinitionBuilder builder = rootBeanDefinition(configClass);</span><br><span class="line">        <span class="comment">// 由 Bean定义Builder 获取Bean定义</span></span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line">        <span class="comment">// 注册到 Spring 的注册表中</span></span><br><span class="line">        registry.registerBeanDefinition(beanName, beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">            log.info(<span class="string">"The dubbo config bean definition [name : "</span> + beanName + <span class="string">", class : "</span> + configClass.getName() +</span><br><span class="line">                    <span class="string">"] has been registered."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建的Dubbo Config的Bean对象的DubboConfigBindingBeanPostProcessor对象 【目的：实现对Dubbo Config的Bean对象的配置属性设置】</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefix   配置属性前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName Bean的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> multiple 是否支持多Bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry Spring注册表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerDubboConfigBindingBeanPostProcessor</span><span class="params">(String prefix, String beanName, <span class="keyword">boolean</span> multiple,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                             BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Dubbo配置绑定 Bean后置处理器对应的BeanDefinitionBuilder对象</span></span><br><span class="line">        Class&lt;?&gt; processorClass = DubboConfigBindingBeanPostProcessor<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        BeanDefinitionBuilder builder = rootBeanDefinition(processorClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 构造方法的参数为 actualPrefix 和 beanName，即创建DubboConfigBindingBeanPostProcessor对象需要这两个参数，后面属性绑定会用到这两个属性。</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> DubboConfigBindingBeanPostProcessor#DubboConfigBindingBeanPostProcessor(java.lang.String, java.lang.String)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String actualPrefix = multiple ? normalizePrefix(prefix) + beanName : prefix;</span><br><span class="line">        builder.addConstructorArgValue(actualPrefix).addConstructorArgValue(beanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 DubboConfigBindingBeanPostProcessor 的 BeanDefinition 对象</span></span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line">        <span class="comment">// 设置rol属性</span></span><br><span class="line">        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        <span class="comment">// 注册到注册表</span></span><br><span class="line">        registerWithGeneratedName(beanDefinition, registry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">            log.info(<span class="string">"The BeanPostProcessor bean definition ["</span> + processorClass.getName()</span><br><span class="line">                    + <span class="string">"] for dubbo config bean [name : "</span> + beanName + <span class="string">"] has been registered."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略代码&#125; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerDubboConfigBeans 方法主要完成了两个核心的工作，创建Dubbo Config的Bean定义和Dubbo Config的属性绑定后置处理器。Dubbo Config是约定好的配置类，具体约定的配置类可以参见 <code>DubboConfigConfiguration</code>，并且指定了这些配置类的外部配置属性的前缀。这个过程还涉及到Dubbo Config的Bean定义的名称生成，我们来看下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigBindingRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得配置类对应的Bean 名称的集合。配置用于多个Bean的情况</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 例如： dubbo.application.$&#123;beanName&#125;.name=dubbo-demo-annotation-provider，$&#123;beanName&#125;就是配置类对应的Bean的名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> properties 配置属性集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;String&gt; <span class="title">resolveMultipleBeanNames</span><span class="params">(Map&lt;String, Object&gt; properties)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; beanNames = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String propertyName : properties.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 获取$&#123;beanName&#125; 字符串</span></span><br><span class="line">            <span class="keyword">int</span> index = propertyName.indexOf(<span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                String beanName = propertyName.substring(<span class="number">0</span>, index);</span><br><span class="line"></span><br><span class="line">                beanNames.add(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanNames;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得配置类对应的Bean 名称</span></span><br><span class="line"><span class="comment">     * 例如： dubbo.application.name=dubbo-demo-annotation-provider</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> properties</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">resolveSingleBeanName</span><span class="params">(Map&lt;String, Object&gt; properties, Class&lt;? extends AbstractConfig&gt; configClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得Bean的名称</span></span><br><span class="line">        String beanName = (String) properties.get(<span class="string">"id"</span>);</span><br><span class="line">        <span class="comment">// 没有没有定义，就基于Spring提供的机制生成对应的Bean的名字。 如： org.apache.dubbo.config.ApplicationConfig#0</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            BeanDefinitionBuilder builder = rootBeanDefinition(configClass);</span><br><span class="line">            beanName = BeanDefinitionReaderUtils.generateBeanName(builder.getRawBeanDefinition(), registry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可以看出，配置用于多个Bean的时候Bean的名称直接从配置属性值中获取，即获取${beanName} 的值作为Bean名称，Bean的名称可能会有多个。配置用于单个Bean的时候Bean的名称先尝试使用id属性值，没有配置id属性就自动生成。这两种情况可能一下子不好理解，下文还会详细说明。上面的过程中Bean定义是注册到了注册表中，但是Bean的属性还没有设置，下面我们来分析 DubboConfigBindingBeanPostProcessor 是如何进行属性绑定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dubbo Config Binding &#123;<span class="doctag">@link</span> BeanPostProcessor&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBinding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigBindingRegistrar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 处理Dubbo AbstractConfig Bean的配置属性注入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigBindingBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span>, <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属性配置前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String prefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Binding Bean Name  // Bean的名字，每个配置类的Bean都有自己的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo 配置属性绑定器 ，用来绑定配置属性到Dubbo Config中 （内部使用Spring DataBinder完成属性绑定）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> DubboConfigBinder dubboConfigBinder;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否忽略未知的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ignoreUnknownFields = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否忽略类型不对的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ignoreInvalidFields = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，属性前缀和配置类的Bean是通过构造方法传入进来的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefix   the prefix of Configuration Properties</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName the binding Bean Name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DubboConfigBindingBeanPostProcessor</span><span class="params">(String prefix, String beanName)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(prefix, <span class="string">"The prefix of Configuration Properties must not be null"</span>);</span><br><span class="line">        Assert.notNull(beanName, <span class="string">"The name of bean must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">        <span class="keyword">this</span>.beanName = beanName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean后处理器的 前置处理方法。将配置属性绑定到Dubbo Config中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 选择bean的名称是 this.beanName【针对注解机制创建Bean定义，其他方式创建的Bean定义不符合条件】，并且是AbstractConfig类型的 Bean定义</span></span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="keyword">this</span>.beanName) &amp;&amp; bean <span class="keyword">instanceof</span> AbstractConfig) &#123;</span><br><span class="line"></span><br><span class="line">            AbstractConfig dubboConfig = (AbstractConfig) bean;</span><br><span class="line">            <span class="comment">// 设置prefix开头的配置属性到 DubboConfig中</span></span><br><span class="line">            dubboConfigBinder.bind(prefix, dubboConfig);</span><br><span class="line">            <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">                log.info(<span class="string">"The properties of bean [name : "</span> + beanName + <span class="string">"] have been binding by prefix of "</span> +</span><br><span class="line">                        <span class="string">"configuration properties : "</span> + prefix);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean后处理器的后置处理方法，这里直接返回Dubbo Config的Bean对象，不做其他的处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 Dubbo 配置属性绑定器，注意它的触发时机。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得DubboConfigBinder对象</span></span><br><span class="line">        <span class="keyword">if</span> (dubboConfigBinder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dubboConfigBinder = applicationContext.getBean(DubboConfigBinder<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException ignored) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                    log.debug(<span class="string">"DubboConfigBinder Bean can't be found in ApplicationContext."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Use Default implementation // 创建默认的配置绑定器</span></span><br><span class="line">                dubboConfigBinder = createDubboConfigBinder(applicationContext.getEnvironment());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 是否忽略未知/无效的属性</span></span><br><span class="line">        dubboConfigBinder.setIgnoreUnknownFields(ignoreUnknownFields);</span><br><span class="line">        dubboConfigBinder.setIgnoreInvalidFields(ignoreInvalidFields);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create &#123;<span class="doctag">@link</span> DubboConfigBinder&#125; instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> environment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> DefaultDubboConfigBinder&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DubboConfigBinder <span class="title">createDubboConfigBinder</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建DefaultDubboConfigBinder对象</span></span><br><span class="line">        DefaultDubboConfigBinder defaultDubboConfigBinder = <span class="keyword">new</span> DefaultDubboConfigBinder();</span><br><span class="line">        <span class="comment">// 设置environment属性</span></span><br><span class="line">        defaultDubboConfigBinder.setEnvironment(environment);</span><br><span class="line">        <span class="keyword">return</span> defaultDubboConfigBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIgnoreUnknownFields</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ignoreUnknownFields;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIgnoreUnknownFields</span><span class="params">(<span class="keyword">boolean</span> ignoreUnknownFields)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ignoreUnknownFields = ignoreUnknownFields;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIgnoreInvalidFields</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ignoreInvalidFields;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIgnoreInvalidFields</span><span class="params">(<span class="keyword">boolean</span> ignoreInvalidFields)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ignoreInvalidFields = ignoreInvalidFields;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DubboConfigBinder <span class="title">getDubboConfigBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dubboConfigBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDubboConfigBinder</span><span class="params">(DubboConfigBinder dubboConfigBinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dubboConfigBinder = dubboConfigBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo Config的属性绑定后置处理器逻辑不算复杂，就是从Spring环境中获取配置属性，然后利用Spring的数据绑定器DataBinder完成Dubbo Config的Bean属性的绑定，逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default &#123;<span class="doctag">@link</span> DubboConfigBinder&#125; implementation based on Spring &#123;<span class="doctag">@link</span> DataBinder&#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 使用Spring DataBinder，将配置属性设置到Dubbo Config对象中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDubboConfigBinder</span> <span class="keyword">extends</span> <span class="title">AbstractDubboConfigBinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;C extends AbstractConfig&gt; <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(String prefix, C dubboConfig)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将Dubbo Config包装成 DataBinder对象</span></span><br><span class="line">        DataBinder dataBinder = <span class="keyword">new</span> DataBinder(dubboConfig);</span><br><span class="line">        <span class="comment">// 是否忽略无效和未知属性</span></span><br><span class="line">        dataBinder.setIgnoreInvalidFields(isIgnoreInvalidFields());</span><br><span class="line">        dataBinder.setIgnoreUnknownFields(isIgnoreUnknownFields());</span><br><span class="line">        <span class="comment">// 从PropertySources中获取prefix开头的配置属性 [getPropertySources() : 系统属性，系统环境和@ProperSources的属性k-v]</span></span><br><span class="line">        Map&lt;String, Object&gt; properties = getSubProperties(getPropertySources(), prefix);</span><br><span class="line">        <span class="comment">// 根据配置属性集合 创建 MutablePropertyValues对象</span></span><br><span class="line">        MutablePropertyValues propertyValues = <span class="keyword">new</span> MutablePropertyValues(properties);</span><br><span class="line">        <span class="comment">// 绑定配置属性到 Dubbo的配置对象中</span></span><br><span class="line">        dataBinder.bind(propertyValues);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring的后置处理器的方法中会调用 DefaultDubboConfigBinder#bind方法进行Dubbo Config的Bean的属性设置，本质是使用Spring的DataBinder完成属性设置。至此，<code>@EnableDubboConfigBindings</code>涉及的处理逻辑分析完毕，这个过程创建了Dubbo Config的Bean，并且创建了该Bean对应的属性绑定Bean后置处理器，在Spring的生命周期中该Bean后置处理器会回调对应的方法以完成属性的绑定。接下来我们再来分析 <code>@EnableDubboConfigBinding</code> 注解，该注解是 <code>@EnableDubboConfigBindings</code> 注解的属性数组的类型， <code>@EnableDubboConfigBindings</code> 注解的逻辑处理基本就是  <code>@EnableDubboConfigBinding</code> 注解的逻辑处理。</p><h4 id="EnableDubboConfigBinding-注解"><a href="#EnableDubboConfigBinding-注解" class="headerlink" title="@EnableDubboConfigBinding 注解"></a><code>@EnableDubboConfigBinding</code> 注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enables Spring's annotation-driven &#123;<span class="doctag">@link</span> AbstractConfig Dubbo Config&#125; from &#123;<span class="doctag">@link</span> PropertySources properties&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Default , &#123;<span class="doctag">@link</span> #prefix()&#125; associates with a prefix of &#123;<span class="doctag">@link</span> PropertySources properties&#125;, e,g. "dubbo.application."</span></span><br><span class="line"><span class="comment"> * or "dubbo.application"</span></span><br><span class="line"><span class="comment"> * &lt;pre class="code"&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigBindingRegistrar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigBindingBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBindings</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(DubboConfigBindingRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableDubboConfigBinding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置属性的前缀，用于映射到 AbstractConfig 中的属性</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The name prefix of the properties that are valid to bind to &#123;<span class="doctag">@link</span> AbstractConfig Dubbo Config&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the name prefix of the properties to bind</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">prefix</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dubbo Config 配置类，这是一个约定，Dubbo Config配置类有哪些是固定的，这个配置必须是AbstractConfig的实现子类。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The binding type of &#123;<span class="doctag">@link</span> AbstractConfig Dubbo Config&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> AbstractConfig</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ApplicationConfig</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ModuleConfig</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> RegistryConfig</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends AbstractConfig&gt; type();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否支持配置用于多个Bean</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * It indicates whether &#123;<span class="doctag">@link</span> #prefix()&#125; binding to multiple Spring Beans.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the default value is &lt;code&gt;false&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">multiple</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解有三个属性，每个属性的作用已经注释过了，我们直接来看 <code>@Import(DubboConfigBindingRegistrar.class)</code>，DubboConfigBindingRegistrar的主要逻辑已经在上面分析过了，我们在简单看下没有分析到的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AbstractConfig Dubbo Config&#125; binding Bean registrar</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableDubboConfigBinding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboConfigBindingBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 处理 <span class="doctag">@EnableDubboConfigBinding</span> 注解，注册相应的 Dubbo AbstractConfig 到Spring 容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfigBindingRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 @EnableDubboConfigBinding注解信息</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(EnableDubboConfigBinding<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 根据 @EnableDubboConfigBinding注解信息 注册配置对应的 BeanDefinition 对象</span></span><br><span class="line">        registerBeanDefinitions(attributes, registry);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，<code>@EnableDubboConfig</code> 注解已经分析完了，该注解就是用于开启Dubbo的配置，创建Dubbo框架内置的配置类的Bean，并且创建配置类的Bean对应的属性绑定Bean后置处理器，Spring应用上下文启动后，就可以实现配置对象的创建与初始化。但是需要注意的是，并不是指定了配置类就会创建对应的Bean，只有当规约的外部配置存在时，配置类才会提升为Spring Bean。</p><h4 id="Dubbo配置Bean绑定及自定义配置Bean绑定"><a href="#Dubbo配置Bean绑定及自定义配置Bean绑定" class="headerlink" title="Dubbo配置Bean绑定及自定义配置Bean绑定"></a>Dubbo配置Bean绑定及自定义配置Bean绑定</h4><p>这块内容还是不少的，这里就不详细说明了。我们直接看 Dubbo PMC 的文章 <a href="https://segmentfault.com/a/1190000012661402#articleHeader4" target="_blank" rel="noopener">Dubbo 新编程模型之外部化配置</a>，里面详细介绍了多配置Bean的属性绑定以及自定义Bean的属性绑定。</p><h3 id="DubboComponentScan-注解"><a href="#DubboComponentScan-注解" class="headerlink" title="@DubboComponentScan 注解"></a>@DubboComponentScan 注解</h3><p>该注解用于配置要扫描 <code>@Service</code> 和 <code>@Reference</code> 注解的包或类，进而创建对应的Bean对象。注解扫描是委托给Spring的，本质上使用ASM库进行字节码扫描注解元数据。当用户使用注解 <code>@DubboComponentScan</code> 时，会激活 <code>DubboComponentScanRegistrar</code>，这个类就是实现服务提供者通过注解 <code>@Service</code> 进行服务暴露的，对消费者通过注解 <code>@Reference</code> 进行服务引用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dubbo Component Scan &#123;<span class="doctag">@link</span> Annotation&#125;,scans the classpath for annotated components that will be auto-registered as</span></span><br><span class="line"><span class="comment"> * Spring beans. Dubbo-provided &#123;<span class="doctag">@link</span> Service&#125; and &#123;<span class="doctag">@link</span> Reference&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Reference</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(DubboComponentScanRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">DubboComponentScan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Alias for the &#123;<span class="doctag">@link</span> #basePackages()&#125; attribute. Allows for more concise annotation</span></span><br><span class="line"><span class="comment">     * declarations e.g.: &#123;<span class="doctag">@code</span> <span class="doctag">@DubboComponentScan</span>("org.my.pkg")&#125; instead of</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> <span class="doctag">@DubboComponentScan</span>(basePackages="org.my.pkg")&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 和 basePackages 等价</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base packages to scan for annotated <span class="doctag">@Service</span> classes. &#123;<span class="doctag">@link</span> #value()&#125; is an</span></span><br><span class="line"><span class="comment">     * alias for (and mutually exclusive with) this attribute.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Use &#123;<span class="doctag">@link</span> #basePackageClasses()&#125; for a type-safe alternative to String-based</span></span><br><span class="line"><span class="comment">     * package names.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the base packages to scan</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 要扫描包的数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Type-safe alternative to &#123;<span class="doctag">@link</span> #basePackages()&#125; for specifying the packages to</span></span><br><span class="line"><span class="comment">     * scan for annotated <span class="doctag">@Service</span> classes. The package of each class specified will be</span></span><br><span class="line"><span class="comment">     * scanned.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> classes from the base packages to scan</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 要扫描的类的数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注解的属性作用已经注释，我们重点关注下@Import的value属性值 <code>DubboComponentScanRegistrar</code> ，它用于处理DubboComponentScan注解，为Spring容器注册ServiceAnnotation和ReferenceAnnotation的Bean后置处理器，进而创建ServiceBean和ReferenceBean对象。下面我们就来详细分析Dubbo注解实现的这个核心类。</p><h4 id="DubboComponentScanRegistrar"><a href="#DubboComponentScanRegistrar" class="headerlink" title="DubboComponentScanRegistrar"></a>DubboComponentScanRegistrar</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dubbo &#123;<span class="doctag">@link</span> DubboComponentScan&#125; Bean Registrar</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> DubboComponentScan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ImportBeanDefinitionRegistrar</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ServiceAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ReferenceAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.7</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> importingClassMetadata <span class="doctag">@DubboComponentScan</span> 注解的信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry               Bean定义注册表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 获得要扫描的包</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;String&gt; packagesToScan = getPackagesToScan(importingClassMetadata);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2. 创建 ServiceAnnotationBeanPostProcessor Bean 对象，后续扫描 `<span class="doctag">@Service</span>` 注解的类，创建对应的 Service Bean 对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        registerServiceAnnotationBeanPostProcessor(packagesToScan, registry);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3. 创建 ReferenceAnnotationBeanPostProcessor Bean 对象，后续扫描 `<span class="doctag">@Reference</span>` 注解的类，创建对应的 Reference Bean 对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        registerReferenceAnnotationBeanPostProcessor(registry);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// $&#123;省略其他的代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DubboComponentScanRegistrar 实现 ImportBeanDefinitionRegistrar接口，用来处理 @DubboComponentScan注解，注册 ServiceAnnotationBeanPostProcessor 和 ReferenceAnnotationBeanPostProcessor 到Spring容器，Spring应用上下文启动后，就可以实现Service Bean对象和Reference Bean对象的创建。下面我们依次分析以上三个步骤的具体逻辑。</p><h4 id="获取要扫描的包"><a href="#获取要扫描的包" class="headerlink" title="获取要扫描的包"></a>获取要扫描的包</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得 DubboComponentScan注解扫描的包</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metadata</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;String&gt; <span class="title">getPackagesToScan</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得 @DubboComponentScan 注解</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(DubboComponentScan<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">// 获得basePackages 属性值</span></span><br><span class="line">        String[] basePackages = attributes.getStringArray(<span class="string">"basePackages"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得basePackageClasses属性值</span></span><br><span class="line">        Class&lt;?&gt;[] basePackageClasses = attributes.getClassArray(<span class="string">"basePackageClasses"</span>);</span><br><span class="line">        <span class="comment">// 获得默认属性（basePackages的默认属性）</span></span><br><span class="line">        String[] value = attributes.getStringArray(<span class="string">"value"</span>);</span><br><span class="line">        <span class="comment">// 将属性添加到 packagesToScan 集合中</span></span><br><span class="line">        Set&lt;String&gt; packagesToScan = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(Arrays.asList(value));</span><br><span class="line">        packagesToScan.addAll(Arrays.asList(basePackages));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理 扫描的类的数组 ，得到每个类的包名，然后添加到 包路径数组中</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; basePackageClass : basePackageClasses) &#123;</span><br><span class="line">            packagesToScan.add(ClassUtils.getPackageName(basePackageClass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// packagesToScan 为空的话，则默认使用DubboComponentScan注解类所在的包做为扫描包</span></span><br><span class="line">        <span class="keyword">if</span> (packagesToScan.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.singleton(ClassUtils.getPackageName(metadata.getClassName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> packagesToScan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取要扫描的包逻辑还是很直观的，将配置的扫描包路径和配置的扫描类对应的包路径聚合在一起作为目标包路径，需要注意的是当配置扫描类时需要获取扫描类的包名，即还是会转为包扫描。如果没有配置扫描包及扫描类，那么就是使用DubboComponentScan注解类所在的包做为扫描包。</p><h4 id="创建扫描-Service-注解的后置处理器"><a href="#创建扫描-Service-注解的后置处理器" class="headerlink" title="创建扫描 @Service 注解的后置处理器"></a>创建扫描 @Service 注解的后置处理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Registers &#123;<span class="doctag">@link</span> ServiceAnnotationBeanPostProcessor&#125;</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> packagesToScan packages to scan without resolving placeholders</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> registry       &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment">      * &lt;p&gt;</span></span><br><span class="line"><span class="comment">      * 创建 ServiceAnnotationBeanPostProcessor Bean 对象，后续扫描 <span class="doctag">@Service</span> 注解的类，创建对应的 Service Bean 对象</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceAnnotationBeanPostProcessor</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 创建ServiceAnnotationBeanPostProcessor的BeanDefinitionBuilder 对象</span></span><br><span class="line">         BeanDefinitionBuilder builder = rootBeanDefinition(ServiceAnnotationBeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">         <span class="comment">// 设置构造方法参数为 packagesToScan</span></span><br><span class="line">         builder.addConstructorArgValue(packagesToScan);</span><br><span class="line">         <span class="comment">// 设置 role 属性</span></span><br><span class="line">         builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">         <span class="comment">// 获得 AbstractBeanDefinition 对象</span></span><br><span class="line">         AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line">         <span class="comment">// 注册到注册表中</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinition, registry);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建扫描 @Service 注解的类的后置处理器逻辑很简单，就是创建一个Bean定义然后注册到注册表中。下面我们重点分析这个后置处理的逻辑，看它是如何将 <code>@Service</code> 标注的类提升为Spring Bean的。</p><h4 id="ServiceAnnotationBeanPostProcessor"><a href="#ServiceAnnotationBeanPostProcessor" class="headerlink" title="ServiceAnnotationBeanPostProcessor"></a>ServiceAnnotationBeanPostProcessor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Service&#125; Annotation</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> BeanDefinitionRegistryPostProcessor Bean Definition Registry Post Processor&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要扫描的包的集合，通过构造方法进行设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; packagesToScan;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环境</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceAnnotationBeanPostProcessor</span><span class="params">(String... packagesToScan)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Arrays.asList(packagesToScan));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceAnnotationBeanPostProcessor</span><span class="params">(Collection&lt;String&gt; packagesToScan)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> LinkedHashSet&lt;String&gt;(packagesToScan));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceAnnotationBeanPostProcessor</span><span class="params">(Set&lt;String&gt; packagesToScan)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.packagesToScan = packagesToScan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;省略其他逻辑代码&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ServiceAnnotationBeanPostProcessor 实现 BeanDefinitionRegistryPostProcessor、EnvironmentAware、ResourceLoaderAware、BeanClassLoaderAware 接口，具备了Spring的特定功能，如Spring容器中所有Bean注册之后回调 <code>postProcessBeanDefinitionRegistry</code> 方法。该类主要是将 <code>@Service</code> 标注的类提升为Spring Bean，主要的逻辑如下：</p><ol><li>解析扫描包集合，处理存在占位符的包名。</li><li>创建DubboClassPathBeanDefinitionScanner对象，用于扫描指定包下的 @Service 标注的类并注册该类的Bean定义到注册表。</li><li>为每个@Service标注的类创建对应的 ServiceBean，并注册到注册表。</li></ol><p><strong>解析扫描包集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry 注册表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 解析 packagesToScan集合，包名可能存在占位符的情况</span></span><br><span class="line">        Set&lt;String&gt; resolvedPackagesToScan = resolvePackagesToScan(packagesToScan);</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(resolvedPackagesToScan)) &#123;</span><br><span class="line">            <span class="comment">// 扫描 packagesToScan 包，创建对应的 Spring BeanDefinition 对象，从而触发 Dubbo ServiceBean 定义和注册</span></span><br><span class="line">            registerServiceBeans(resolvedPackagesToScan, registry);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"packagesToScan is empty , ServiceBean registry will be ignored!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要处理包名存在占位符的情况，同时上面的方法也是Spring的Bean后处理器的回调方法，在Spring的生命周期内进行回调。接下我们看扫描Dubbo的 <code>@Service</code> 注解的逻辑。</p><p><strong>扫描Dubbo的 <code>@Service</code> 注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 扫描 packagesToScan 包，创建对应的 Spring BeanDefinition 对象，从而创建 Dubbo Service Bean 对象</span></span><br><span class="line"><span class="comment">      * &lt;p&gt;</span></span><br><span class="line"><span class="comment">      * Registers Beans whose classes was annotated &#123;<span class="doctag">@link</span> Service&#125;</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> packagesToScan 要扫描的包集合</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> registry      注册表</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBeans</span><span class="params">(Set&lt;String&gt; packagesToScan, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 创建 Dubbo的类路径Bean定义扫描对象，该类继承了Spring的 ClassPathBeanDefinitionScanner，即用于扫描指定包下符合条件的类，将符合条件的类创建对应的BeanDefinition对象</span></span><br><span class="line">         DubboClassPathBeanDefinitionScanner scanner = <span class="keyword">new</span> DubboClassPathBeanDefinitionScanner(registry, environment, resourceLoader);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 获得 BeanNameGenerator 对象，并设置 beanNameGenerator 到 scanner 中</span></span><br><span class="line">         BeanNameGenerator beanNameGenerator = resolveBeanNameGenerator(registry);</span><br><span class="line">         scanner.setBeanNameGenerator(beanNameGenerator);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 指定扫描器扫描带有Dubbo的@Service注解的类，不会扫描Spring的@Service注解</span></span><br><span class="line">         scanner.addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(Service<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// 遍历扫描的包集合</span></span><br><span class="line">         <span class="keyword">for</span> (String packageToScan : packagesToScan) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 执行扫描，并注册目标类的Bean定义到注册表，使用beanNameGenerator生成Bean的名称</span></span><br><span class="line">             scanner.scan(packageToScan);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 创建每个被扫描的类的BeanDefinitionHolder对象，返回BeanDefinitionHolder集合，用于生成ServiceBean定义【注意，这里也会创建扫描的类的Bean定义，也是使用 beanNameGenerator 生成名称，但没有注册到注册表】</span></span><br><span class="line">             Set&lt;BeanDefinitionHolder&gt; beanDefinitionHolders = findServiceBeanDefinitionHolders(scanner, packageToScan, registry, beanNameGenerator);</span><br><span class="line"> </span><br><span class="line">             <span class="comment">// 为每个@Service标注的类创建对应的 ServiceBean，并注册到注册表。</span></span><br><span class="line">             <span class="keyword">if</span> (!CollectionUtils.isEmpty(beanDefinitionHolders)) &#123;</span><br><span class="line">                 <span class="keyword">for</span> (BeanDefinitionHolder beanDefinitionHolder : beanDefinitionHolders) &#123;</span><br><span class="line">                     registerServiceBean(beanDefinitionHolder, registry, scanner);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                     logger.info(beanDefinitionHolders.size() + <span class="string">" annotated Dubbo's @Service Components &#123; "</span> +</span><br><span class="line">                             beanDefinitionHolders +</span><br><span class="line">                             <span class="string">" &#125; were scanned under package["</span> + packageToScan + <span class="string">"]"</span>);</span><br><span class="line">                 &#125;</span><br><span class="line"> </span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                     logger.warn(<span class="string">"No Spring Bean annotating Dubbo's @Service was found under package["</span></span><br><span class="line">                             + packageToScan + <span class="string">"]"</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码主要做了四件事情，如下：</p><ol><li>创建类路径扫描器 DubboClassPathBeanDefinitionScanner，指定扫描的注解包含Dubbo的@Service注解。</li><li>获取BeanNameGenerator对象，用于 @Service 标注类的Bean定义名称。</li><li>使用扫描器扫描包，提升@Service标注的类为Spring Bean，并注册到注册表中。</li><li>获取第3步的Spring Bean的BeanDefinitionHolder集合，将用于创建Dubbo的ServiceBean对象。</li></ol><p>代码中的主要逻辑已经详细标注，胖友自己瞅瞅，下面我们简单分析下扫描器的原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">ClassPathBeanDefinitionScanner#scan(String... basePackages) &#123;</span><br><span class="line">    <span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line">    <span class="comment">// 扫描逻辑                                                                      </span></span><br><span class="line">    doScan(basePackages);                                                       </span><br><span class="line">    <span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">       &#125;                                                               </span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 扫描包逻辑</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">     Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">   Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        <span class="comment">// 从包中获取候选BeanDefinition</span></span><br><span class="line">     Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">   <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">  ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">  candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">              <span class="comment">// 使用beanNameGenerator 生成BeanDefinition的名称</span></span><br><span class="line">   String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">   <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">  postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">  AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">    &#125;</span><br><span class="line">               <span class="comment">// 是否是候选BeanDefinition</span></span><br><span class="line">    <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">  BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">  definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">  beanDefinitions.add(definitionHolder);</span><br><span class="line">                 <span class="comment">// 注册到注册表</span></span><br><span class="line">  registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">    &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从包中获取BeanDefinition集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">  * Scan the class path for candidate components.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> basePackage the package to check for annotated classes</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> a corresponding Set of autodetected bean definitions</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line"> Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinition&gt;();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 类路径下的指定包下的所有.class文件 （如：classpath*:com/code/resource/reading/consumer/annotation/consumer/**/*.class）</span></span><br><span class="line"> String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line"> Resource[] resources = <span class="keyword">this</span>.resourcePatternResolver.getResources(packageSearchPath);</span><br><span class="line"> <span class="keyword">boolean</span> traceEnabled = logger.isTraceEnabled();</span><br><span class="line"> <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"> <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line"> <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line"> logger.trace(<span class="string">"Scanning "</span> + resource);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> MetadataReader metadataReader = <span class="keyword">this</span>.metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">                         <span class="comment">// 是否是候选 BeanDefinition</span></span><br><span class="line"> <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">                            <span class="comment">// 创建 BeanDefinition</span></span><br><span class="line"> ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line"> sbd.setResource(resource);</span><br><span class="line"> sbd.setSource(resource);</span><br><span class="line"> <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line"> <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line"> logger.debug(<span class="string">"Identified candidate component class: "</span> + resource);</span><br><span class="line"> &#125;</span><br><span class="line"> candidates.add(sbd);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line"> logger.debug(<span class="string">"Ignored because not a concrete top-level class: "</span> + resource);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line"> logger.trace(<span class="string">"Ignored because not matching any filter: "</span> + resource);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"> <span class="string">"Failed to read candidate component class: "</span> + resource, ex);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line"> logger.trace(<span class="string">"Ignored because not readable: "</span> + resource);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"I/O failure during classpath scanning"</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> candidates;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们只要大致了解下扫描器是怎么把指定包下的注解标注的类提升为Spring Bean就可以了。有了目标类的Bean定义，接下来我们分析Dubbo是如何创建该目标类对应的ServiceBean对象的。</p><p><strong>创建ServiceBean并注册到注册表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers &#123;<span class="doctag">@link</span> ServiceBean&#125; from new annotated &#123;<span class="doctag">@link</span> Service&#125; &#123;<span class="doctag">@link</span> BeanDefinition&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanDefinitionHolder <span class="doctag">@Service</span>标注的类的BeanDefinitionHolder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry             注册表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> scanner              扫描器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ServiceBean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> BeanDefinition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerServiceBean</span><span class="params">(BeanDefinitionHolder beanDefinitionHolder, BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     DubboClassPathBeanDefinitionScanner scanner)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从holder中取出BeanDefinition，并解析出对应的类</span></span><br><span class="line">        Class&lt;?&gt; beanClass = resolveClass(beanDefinitionHolder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得@Service 注解</span></span><br><span class="line">        Service service = findAnnotation(beanClass, Service<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得注解标注类的接口</span></span><br><span class="line">        Class&lt;?&gt; interfaceClass = resolveServiceInterfaceClass(beanClass, service);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得Bean的名字</span></span><br><span class="line">        String annotatedServiceBeanName = beanDefinitionHolder.getBeanName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  创建AbstractBeanDefinition 对象 ，这里真正创建ServiceBean</span></span><br><span class="line">        AbstractBeanDefinition serviceBeanDefinition = buildServiceBeanDefinition(service, interfaceClass, annotatedServiceBeanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新生成Bean 的名字 【格式：ServiceBean:$&#123;interfaceClassName&#125;:$&#123;version&#125;:$&#123;group&#125;】，重新创建的ServiceBean名称是把上面的BeanDefinition注册到注册表中，需要一个名称</span></span><br><span class="line">        String beanName = generateServiceBeanName(service, interfaceClass, annotatedServiceBeanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验在 注册表 中是否已经存在beanName，若不存在则进行注册</span></span><br><span class="line">        <span class="keyword">if</span> (scanner.checkCandidate(beanName, serviceBeanDefinition)) &#123; </span><br><span class="line">            <span class="comment">// 注册</span></span><br><span class="line">            registry.registerBeanDefinition(beanName, serviceBeanDefinition);</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"The BeanDefinition["</span> + serviceBeanDefinition +</span><br><span class="line">                        <span class="string">"] of ServiceBean has been registered with name : "</span> + beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"The Duplicated BeanDefinition["</span> + serviceBeanDefinition +</span><br><span class="line">                        <span class="string">"] of ServiceBean[ bean name : "</span> + beanName +</span><br><span class="line">                        <span class="string">"] was be found , Did @DubboComponentScan scan to same package in many times?"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法主要是为创建ServiceBean提供条件，如：获取Dubbo的@Service标注类的Class及接口、获取@Service信息、获取Dubbo的@Service标注类的Bean定义的名称。有了这些信息，就可以创建目标服务类（Dubbo的@Service标注的类）的ServiceBean。在分析创建ServiceBean之前，我们先来看下目标服务类的接口获取逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得<span class="doctag">@Service</span> 注解的类的接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotatedServiceBeanClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; resolveServiceInterfaceClass(Class&lt;?&gt; annotatedServiceBeanClass, Service service) &#123;</span><br><span class="line">        <span class="comment">// 从注解属性中获取</span></span><br><span class="line">        Class&lt;?&gt; interfaceClass = service.interfaceClass();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">interfaceClass</span>)) </span>&#123;</span><br><span class="line">            interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获得@Service 注解的interfaceName 属性</span></span><br><span class="line">            String interfaceClassName = service.interfaceName();</span><br><span class="line">            <span class="comment">// 如果存在，获得其对应的类</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasText(interfaceClassName)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ClassUtils.isPresent(interfaceClassName, classLoader)) &#123;</span><br><span class="line">                    interfaceClass = resolveClassName(interfaceClassName, classLoader);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从注解属性中获得不到，则从被注解的类上获得其实现的第一个接口</span></span><br><span class="line">        <span class="keyword">if</span> (interfaceClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取接口列表</span></span><br><span class="line">            Class&lt;?&gt;[] allInterfaces = annotatedServiceBeanClass.getInterfaces();</span><br><span class="line">            <span class="comment">// 存在的话取第一个接口</span></span><br><span class="line">            <span class="keyword">if</span> (allInterfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                interfaceClass = allInterfaces[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(interfaceClass,<span class="string">"@Service interfaceClass() or interfaceName() or interface class must be present!"</span>);</span><br><span class="line">        Assert.isTrue(interfaceClass.isInterface(),<span class="string">"The type that was annotated @Service is not an interface!"</span>);</span><br><span class="line">        <span class="keyword">return</span> interfaceClass;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取目标服务类的接口规则是先从@Service注解属性中取，没有设置再获取目标服务类的第一个实现接口。下面我们来分析下ServiceBean的定义如何生成，可以对比下XML配置的生成规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAnnotationBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span>, <span class="title">EnvironmentAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建AbstraceBeanDefinition对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service                  <span class="doctag">@Service</span> 注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaceClass           目标服务类的接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotatedServiceBeanName 目标服务类的Bean定义的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> AbstractBeanDefinition <span class="title">buildServiceBeanDefinition</span><span class="params">(Service service, Class&lt;?&gt; interfaceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                              String annotatedServiceBeanName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建ServiceBean的BeanDefinitionBuilder对象</span></span><br><span class="line">        BeanDefinitionBuilder builder = rootBeanDefinition(ServiceBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得ServiceBean的AbstractBeanDefinition 对象</span></span><br><span class="line">        AbstractBeanDefinition beanDefinition = builder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 MutablePropertyValues对象，后续可以通过它为ServiceBean添加属性</span></span><br><span class="line">        MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建AnnotationPropertyValuesAdapter 对象，添加到propertyValues中。注意是将注解上的属性设置到PropertyValues中，并且指定哪些属性要忽略。被忽略的属性会单独设置。</span></span><br><span class="line">        String[] ignoreAttributeNames = of(<span class="string">"provider"</span>, <span class="string">"monitor"</span>, <span class="string">"application"</span>, <span class="string">"module"</span>, <span class="string">"registry"</span>, <span class="string">"protocol"</span>, <span class="string">"interface"</span>);</span><br><span class="line">        propertyValues.addPropertyValues(<span class="keyword">new</span> AnnotationPropertyValuesAdapter(service, environment, ignoreAttributeNames));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置ServiceBean ref 属性，即@Service标注的类的Bean定义名称</span></span><br><span class="line">        addPropertyReference(builder, <span class="string">"ref"</span>, annotatedServiceBeanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置ServiceBean的 interface 属性</span></span><br><span class="line">        builder.addPropertyValue(<span class="string">"interface"</span>, interfaceClass.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加ServiceBean的 provider 属性</span></span><br><span class="line">        String providerConfigBeanName = service.provider();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(providerConfigBeanName)) &#123;</span><br><span class="line">            addPropertyReference(builder, <span class="string">"provider"</span>, providerConfigBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 添加ServiceBean的monitor属性</span></span><br><span class="line">        String monitorConfigBeanName = service.monitor();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(monitorConfigBeanName)) &#123;</span><br><span class="line">            addPropertyReference(builder, <span class="string">"monitor"</span>, monitorConfigBeanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加ServiceBean 的 application 属性</span></span><br><span class="line">        String applicationConfigBeanName = service.application();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(applicationConfigBeanName)) &#123;</span><br><span class="line">            addPropertyReference(builder, <span class="string">"application"</span>, applicationConfigBeanName);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 添加ServiceBean的 module 属性对应的 ModuleConfig Bean 对象</span></span><br><span class="line">        String moduleConfigBeanName = service.<span class="keyword">module</span>();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(moduleConfigBeanName)) &#123;</span><br><span class="line">            addPropertyReference(builder, <span class="string">"module"</span>, moduleConfigBeanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//-------------- 下面两个属性和上面的不一样，因为可能会有多个 ，即多注册中心，多协议的情况-------------------/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加ServiceBean的 registries 属性</span></span><br><span class="line">        String[] registryConfigBeanNames = service.registry();</span><br><span class="line">        List&lt;RuntimeBeanReference&gt; registryRuntimeBeanReferences = toRuntimeBeanReferences(registryConfigBeanNames);</span><br><span class="line">        <span class="keyword">if</span> (!registryRuntimeBeanReferences.isEmpty()) &#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">"registries"</span>, registryRuntimeBeanReferences);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加ServiceBean的 protocols 属性</span></span><br><span class="line">        String[] protocolConfigBeanNames = service.protocol();</span><br><span class="line">        List&lt;RuntimeBeanReference&gt; protocolRuntimeBeanReferences = toRuntimeBeanReferences(protocolConfigBeanNames);</span><br><span class="line">        <span class="keyword">if</span> (!protocolRuntimeBeanReferences.isEmpty()) &#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">"protocols"</span>, protocolRuntimeBeanReferences);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.getBeanDefinition();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是为ServiceBean设置简单属性值和引用类型的值，当ServiceBean的属性是引用类型时，解析器会依据依赖bean的name创建一个RuntimeBeanReference对像，将这个对像放入ServiceBean的BeanDefinition的MutablePropertyValues中。ServiceBean的Bean定义创建完成后，接着就把该Bean定义注册到注册表中。至此，扫描 <code>@Service</code> 注解的Bean后置处理器逻辑已经分析完毕。下面我们开始分析扫描 <code>@Reference</code> 注解的后置处理器。</p><h4 id="创建扫描-Reference-注解的后置处理器"><a href="#创建扫描-Reference-注解的后置处理器" class="headerlink" title="创建扫描 @Reference 注解的后置处理器"></a>创建扫描 @Reference 注解的后置处理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboComponentScanRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers &#123;<span class="doctag">@link</span> ReferenceAnnotationBeanPostProcessor&#125; into &#123;<span class="doctag">@link</span> BeanFactory&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry &#123;<span class="doctag">@link</span> BeanDefinitionRegistry&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerReferenceAnnotationBeanPostProcessor</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register @Reference Annotation Bean Processor</span></span><br><span class="line">        BeanRegistrar.registerInfrastructureBean(registry, ReferenceAnnotationBeanPostProcessor.BEAN_NAME, ReferenceAnnotationBeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建扫描 <code>@Reference</code> 注解的后置处理器需要注意该Bean定义的名称是 <code>referenceAnnotationBeanPostProcessor</code>，是常量维护的。下面我们开始分析ReferenceAnnotationBeanPostProcessor的逻辑，看它又是如何为 <code>@Reference</code> 注解的属性或方法引入代理对象。</p><h4 id="ReferenceAnnotationBeanPostProcessor"><a href="#ReferenceAnnotationBeanPostProcessor" class="headerlink" title="ReferenceAnnotationBeanPostProcessor"></a>ReferenceAnnotationBeanPostProcessor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanPostProcessor&#125; implementation</span></span><br><span class="line"><span class="comment"> * that Consumer service &#123;<span class="doctag">@link</span> Reference&#125; annotated fields</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2.5.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">AnnotationInjectedBeanPostProcessor</span>&lt;<span class="title">Reference</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bean name of &#123;<span class="doctag">@link</span> ReferenceAnnotationBeanPostProcessor&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = <span class="string">"referenceAnnotationBeanPostProcessor"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cache size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHE_SIZE = Integer.getInteger(BEAN_NAME + <span class="string">".cache.size"</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ReferenceBean 缓存 Map,key:Reference Bean 的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ReferenceBean&lt;?&gt;&gt; referenceBeanCache = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ReferenceBean&lt;?&gt;&gt;(CACHE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ReferenceBeanInvocationHandler 缓存 Map，key：Reference Bean的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, ReferenceBeanInvocationHandler&gt; localReferenceBeanInvocationHandlerCache = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ReferenceBeanInvocationHandler&gt;(CACHE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用属性进行注入的 <span class="doctag">@Reference</span> Bean 的缓存 Map。（这种方式使用的较多）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; injectedFieldReferenceBeanCache = <span class="keyword">new</span> ConcurrentHashMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt;(CACHE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用方法进行注入的 <span class="doctag">@Reference</span> Bean 的缓存 Map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; injectedMethodReferenceBeanCache = <span class="keyword">new</span> ConcurrentHashMap&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt;(CACHE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets all beans of &#123;<span class="doctag">@link</span> ReferenceBean&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null read-only &#123;<span class="doctag">@link</span> Collection&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.5.9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;ReferenceBean&lt;?&gt;&gt; getReferenceBeans() &#123;</span><br><span class="line">        <span class="keyword">return</span> referenceBeanCache.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get &#123;<span class="doctag">@link</span> ReferenceBean&#125; &#123;<span class="doctag">@link</span> Map&#125; in injected field.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null &#123;<span class="doctag">@link</span> Map&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.5.11</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; getInjectedFieldReferenceBeanMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(injectedFieldReferenceBeanCache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get &#123;<span class="doctag">@link</span> ReferenceBean&#125; &#123;<span class="doctag">@link</span> Map&#125; in injected method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null &#123;<span class="doctag">@link</span> Map&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.5.11</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;InjectionMetadata.InjectedElement, ReferenceBean&lt;?&gt;&gt; getInjectedMethodReferenceBeanMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableMap(injectedMethodReferenceBeanCache);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是扫描 <code>@Reference</code> 注解的后置处理器的属性信息，该类继承了AnnotationInjectedBeanPostProcessor抽象类，该类中有几个很重要的方法和类，它们属于Spring源码的知识点，为了使整个逻辑完整我们还是一起来看看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationInjectedBeanPostProcessor</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">InstantiationAwareBeanPostProcessorAdapter</span> <span class="keyword">implements</span> <span class="title">MergedBeanDefinitionPostProcessor</span>, <span class="title">PriorityOrdered</span>,</span></span><br><span class="line"><span class="class">        <span class="title">BeanFactoryAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;省略其他的代码&#125;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 1. Bean后置处理器的回调方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取BeanType中的字段和方法上的注解，即对于Dubbo框架来说就是查找Bean所有标注了@Reference的字段和方法。</span></span><br><span class="line">            InjectionMetadata metadata = findInjectionMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">            metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 创建Bean对象的过程中需要填充Bean对象的属性值，会调用该方法。即在Spring的Bean初始化前会触发该方法。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Bean对象的类中的字段和方法的注解对象 - AnnotatedInjectionMetadata，即对于Dubbo框架来说就是查找Bean所有标注了@Reference的字段和方法。</span></span><br><span class="line">        InjectionMetadata metadata = findInjectionMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用AnnotatedInjectionMetadata的inject方法，对字段或方法进行反射绑定</span></span><br><span class="line">            metadata.inject(bean, beanName, pvs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Injection of @"</span> + getAnnotationType().getName()</span><br><span class="line">                    + <span class="string">" dependencies is failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4. 属性和方法注解包装对象</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> A&#125; &#123;<span class="doctag">@link</span> InjectionMetadata&#125; implementation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedInjectionMetadata</span> <span class="keyword">extends</span> <span class="title">InjectionMetadata</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字段注解对象集合</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;AnnotatedFieldElement&gt; fieldElements;</span><br><span class="line">        <span class="comment">// 方法注解对象集合</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;AnnotatedMethodElement&gt; methodElements;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AnnotatedInjectionMetadata</span><span class="params">(Class&lt;?&gt; targetClass, Collection&lt;AnnotatedFieldElement&gt; fieldElements,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Collection&lt;AnnotatedMethodElement&gt; methodElements)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(targetClass, combine(fieldElements, methodElements));</span><br><span class="line">            <span class="keyword">this</span>.fieldElements = fieldElements;</span><br><span class="line">            <span class="keyword">this</span>.methodElements = methodElements;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;AnnotatedFieldElement&gt; <span class="title">getFieldElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fieldElements;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;AnnotatedMethodElement&gt; <span class="title">getMethodElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> methodElements;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 方法注解</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> A&#125; &#123;<span class="doctag">@link</span> Method&#125; &#123;<span class="doctag">@link</span> InjectionMetadata.InjectedElement&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedMethodElement</span> <span class="keyword">extends</span> <span class="title">InjectionMetadata</span>.<span class="title">InjectedElement</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">        <span class="comment">// 注解</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> A annotation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Object object;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">AnnotatedMethodElement</span><span class="params">(Method method, PropertyDescriptor pd, A annotation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(method, pd);</span><br><span class="line">            <span class="keyword">this</span>.method = method;</span><br><span class="line">            <span class="keyword">this</span>.annotation = annotation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object bean, String beanName, PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// 获取属性类型</span></span><br><span class="line">            Class&lt;?&gt; injectedType = pd.getPropertyType();</span><br><span class="line">            <span class="comment">// H偶去依赖</span></span><br><span class="line">            Object injectedObject = getInjectedObject(annotation, bean, beanName, injectedType, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 设置可访问</span></span><br><span class="line">            ReflectionUtils.makeAccessible(method);</span><br><span class="line">            <span class="comment">// 反射注入依赖</span></span><br><span class="line">            method.invoke(bean, injectedObject);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 属性注解</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> A&#125; &#123;<span class="doctag">@link</span> Field&#125; &#123;<span class="doctag">@link</span> InjectionMetadata.InjectedElement&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedFieldElement</span> <span class="keyword">extends</span> <span class="title">InjectionMetadata</span>.<span class="title">InjectedElement</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 属性对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Field field;</span><br><span class="line">        <span class="comment">// 注解</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> A annotation;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Object bean;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">AnnotatedFieldElement</span><span class="params">(Field field, A annotation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(field, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.field = field;</span><br><span class="line">            <span class="keyword">this</span>.annotation = annotation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object bean, String beanName, PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="comment">// 获取属性类型</span></span><br><span class="line">            Class&lt;?&gt; injectedType = field.getType();</span><br><span class="line">            <span class="comment">// 获取依赖</span></span><br><span class="line">            Object injectedObject = getInjectedObject(annotation, bean, beanName, injectedType, <span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">// 设置可访问</span></span><br><span class="line">            ReflectionUtils.makeAccessible(field);</span><br><span class="line">            <span class="comment">// 反射设置值</span></span><br><span class="line">            field.set(bean, injectedObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectionMetadata</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 遍历注入元素对象（可能是字段，也可能是方法），完成注入</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, String beanName, PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line"> Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line"> (<span class="keyword">this</span>.checkedElements != <span class="keyword">null</span> ? <span class="keyword">this</span>.checkedElements : <span class="keyword">this</span>.injectedElements);</span><br><span class="line"> <span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line"> <span class="keyword">boolean</span> debug = logger.isDebugEnabled();</span><br><span class="line"> <span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line"> <span class="keyword">if</span> (debug) &#123;</span><br><span class="line"> logger.debug(<span class="string">"Processing injected element of bean '"</span> + beanName + <span class="string">"': "</span> + element);</span><br><span class="line"> &#125;</span><br><span class="line"> element.inject(target, beanName, pvs);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码执行的顺序已经标注，执行顺序比较粗略，先查找服务引用的字段或方法，然后触发字段或方法值的反射注入。但是目的已经达到了，从代码中我们可以看出注解信息已经收集完毕，接下来就是获取依赖对象了，找到依赖对象就可以通过反射注入，对于@Reference注解而言，获取依赖的方法就是 <code>ReferenceAnnotationBeanPostProcessor#doGetInjectedBean</code>。下面我们开始分析 ReferenceAnnotationBeanPostProcessor 中的逻辑。</p><p><strong>获取要注入的依赖Bean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">AnnotationInjectedBeanPostProcessor</span>&lt;<span class="title">Reference</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略代码&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得要注入的 依赖</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> reference       <span class="doctag">@Reference</span>注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean            <span class="doctag">@Reference</span>注解标注属性或方法所在的类的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName        <span class="doctag">@Reference</span>注解标注属性或方法所在的类的对象名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> injectedType    要注入依赖的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> injectedElement 注入元信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">doGetInjectedBean</span><span class="params">(Reference reference, Object bean, String beanName, Class&lt;?&gt; injectedType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       InjectionMetadata.InjectedElement injectedElement)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获得要注入依赖的名字</span></span><br><span class="line">        String referencedBeanName = buildReferencedBeanName(reference, injectedType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建ReferenceBean 对象 [比较复杂]</span></span><br><span class="line">        ReferenceBean referenceBean = buildReferenceBeanIfAbsent(referencedBeanName, reference, injectedType, getClassLoader());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 缓存到 injectedFieldReferenceBeanCache 或 injectedMethodReferenceBeanCache</span></span><br><span class="line">        cacheInjectedReferenceBean(referenceBean, injectedElement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 创建 Proxy 代理</span></span><br><span class="line">        Object proxy = buildProxy(referencedBeanName, referenceBean, injectedType);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $&#123;省略代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doGetInjectedBean 方法主要完成以上4个流程，我们重点分析创建ReferenceBean和Proxy代理流程。</p><p><strong>创建ReferenceBean对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">AnnotationInjectedBeanPostProcessor</span>&lt;<span class="title">Reference</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略代码&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得 ReferenceBean 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referencedBeanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> reference</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referencedType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ReferenceBean <span class="title">buildReferenceBeanIfAbsent</span><span class="params">(String referencedBeanName, Reference reference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     Class&lt;?&gt; referencedType, ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先从缓存中获得referencedBeanName 对应的 ReferenceBean 对象</span></span><br><span class="line">        ReferenceBean&lt;?&gt; referenceBean = referenceBeanCache.get(referencedBeanName);</span><br><span class="line">        <span class="comment">// 如果不存在，则进行创建，然后添加到缓存中</span></span><br><span class="line">        <span class="keyword">if</span> (referenceBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ReferenceBeanBuilder beanBuilder = ReferenceBeanBuilder</span><br><span class="line">                    .create(reference, classLoader, applicationContext)</span><br><span class="line">                    <span class="comment">// 引用类型作为接口类型</span></span><br><span class="line">                    .interfaceClass(referencedType);</span><br><span class="line">            <span class="comment">// 创建ReferenceBean【1. 创建ReferenceBean对象 2.ReferenceBean 配置】</span></span><br><span class="line">            referenceBean = beanBuilder.build();</span><br><span class="line">            referenceBeanCache.put(referencedBeanName, referenceBean);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> referenceBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $&#123;省略代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buildReferenceBeanIfAbsent 方法基本没有核心逻辑，所有的逻辑都封装在了 ReferenceBeanBuilder 中，它是ReferenceBean的构建器，我们继续跟进该类。</p><p><strong>ReferenceBean对象的构建器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReferenceBeanBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span>&lt;<span class="title">Reference</span>, <span class="title">ReferenceBean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将注解的属性设置到ReferenceBean，忽略以下属性，这些属性会单独处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] IGNORE_FIELD_NAMES = of(<span class="string">"application"</span>, <span class="string">"module"</span>, <span class="string">"consumer"</span>, <span class="string">"monitor"</span>, <span class="string">"registry"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ReferenceBeanBuilder</span><span class="params">(Reference annotation, ClassLoader classLoader, ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(annotation, classLoader, applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建ReferenceBeanBuilder</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classLoader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationContext</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReferenceBeanBuilder <span class="title">create</span><span class="params">(Reference annotation, ClassLoader classLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ReferenceBean 的构建器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReferenceBeanBuilder(annotation, classLoader, applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>由于很多属性都在其父类 <code>AbstractAnnotationConfigBeanBuilder</code> 中，如上面的interfaceClass，以及很重要的build方法。我们再分析下该类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>, <span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractInterfaceConfig</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> A annotation;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 应用上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Object bean;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; interfaceClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span><span class="params">(A annotation, ClassLoader classLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(annotation, <span class="string">"The Annotation must not be null!"</span>);</span><br><span class="line">        Assert.notNull(classLoader, <span class="string">"The ClassLoader must not be null!"</span>);</span><br><span class="line">        Assert.notNull(applicationContext, <span class="string">"The ApplicationContext must not be null!"</span>);</span><br><span class="line">        <span class="keyword">this</span>.annotation = annotation;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">        <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> &lt;T extends AbstractAnnotationConfigBeanBuilder&lt;A, B&gt;&gt; <span class="function">T <span class="title">bean</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.bean = bean;</span><br><span class="line">         <span class="keyword">return</span> (T) <span class="keyword">this</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="comment">// 设置接口</span></span><br><span class="line">     <span class="keyword">public</span> &lt;T extends AbstractAnnotationConfigBeanBuilder&lt;A, B&gt;&gt; <span class="function">T <span class="title">interfaceClass</span><span class="params">(Class&lt;?&gt; interfaceClass)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.interfaceClass = interfaceClass;</span><br><span class="line">         <span class="keyword">return</span> (T) <span class="keyword">this</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码比较简单，只需注意设置的接口即可，下面我们分析创建ReferenceBean的build方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>, <span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractInterfaceConfig</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Build &#123;<span class="doctag">@link</span> B&#125;  构造泛型B对象，此处就是构造ReferenceBean对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> non-null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> B <span class="title">build</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 校验依赖，目前是个空方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        checkDependencies();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建 Bean 对象，具体实现交给子类</span></span><br><span class="line">        B bean = doBuild();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 配置Bean 对象</span></span><br><span class="line">        configureBean(bean);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"The bean[type:"</span> + bean.getClass().getSimpleName() + <span class="string">"] has been built."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码使用了模版方法模式，我们先看doBuild()方法的具体实现，然后再分析配置Bean对象的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReferenceBeanBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span>&lt;<span class="title">Reference</span>, <span class="title">ReferenceBean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ReferenceBeanBuilder#build的方法调用，用来创建Reference对象。【对父类方法的重写】</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ReferenceBean <span class="title">doBuild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ReferenceBean对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReferenceBean&lt;Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一行代码就搞定了，直接创建ReferenceBean对象，我们接着分析配置Bean逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>, <span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractInterfaceConfig</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 配置ReferenceBean对象</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureBean</span><span class="params">(B bean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 前置配置Bean逻辑，具体实现交给子类</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         preConfigureBean(annotation, bean);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 尝试从Spring中获取<span class="doctag">@Reference</span>注解中配置的registry属性值对应的RegistryConfig对象集合，然后设置到的ReferenceBean对象的registries属性中</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         configureRegistryConfigs(bean);</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 设置ReferenceBean的monitor属性，原理同上</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         configureMonitorConfig(bean);</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 设置ReferenceBean的application属性，原理同上</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         configureApplicationConfig(bean);</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 设置 ReferenceBean的module属性，原理同上</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         configureModuleConfig(bean);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 后置配置Bean逻辑，具体实现交给子类</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         postConfigureBean(annotation, bean);</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码也是使用模版方法模式，其中ReferenceBean的registries、monitor、application、module属性的值是通过该方法进行设置的，前置配置Bean和后置配置Bean的逻辑是由子类实现的，我们继续跟进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReferenceBeanBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigBeanBuilder</span>&lt;<span class="title">Reference</span>, <span class="title">ReferenceBean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * ReferenceBean 的前置配置</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> reference</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> referenceBean</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preConfigureBean</span><span class="params">(Reference reference, ReferenceBean referenceBean)</span> </span>&#123;</span><br><span class="line">          Assert.notNull(interfaceClass, <span class="string">"The interface class must set first!"</span>);</span><br><span class="line">          <span class="comment">// 创建DataBinder对象,将ReferenceBean包装成DataBinder,进行属性绑定，绑定到的对象就是ReferenceBean</span></span><br><span class="line">          DataBinder dataBinder = <span class="keyword">new</span> DataBinder(referenceBean);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Register CustomEditors for special fields   // 注册指定属性的自定义Editor</span></span><br><span class="line">          dataBinder.registerCustomEditor(String.class, "filter", new StringTrimmerEditor(true));</span><br><span class="line">          dataBinder.registerCustomEditor(String.class, "listener", new StringTrimmerEditor(true));</span><br><span class="line">          dataBinder.registerCustomEditor(Map.class, "parameters", new PropertyEditorSupport() &#123;</span><br><span class="line">  </span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> java.lang.IllegalArgumentException </span>&#123;</span><br><span class="line">                  <span class="comment">// Trim all whitespace</span></span><br><span class="line">                  String content = StringUtils.trimAllWhitespace(text);</span><br><span class="line">                  <span class="keyword">if</span> (!StringUtils.hasText(content)) &#123; <span class="comment">// No content , ignore directly</span></span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// replace "=" to ","</span></span><br><span class="line">                  content = StringUtils.replace(content, <span class="string">"="</span>, <span class="string">","</span>);</span><br><span class="line">                  <span class="comment">// replace ":" to ","</span></span><br><span class="line">                  content = StringUtils.replace(content, <span class="string">":"</span>, <span class="string">","</span>);</span><br><span class="line">                  <span class="comment">// String[] to Map</span></span><br><span class="line">                  Map&lt;String, String&gt; parameters = CollectionUtils.toStringMap(commaDelimitedListToStringArray(content));</span><br><span class="line">                  setValue(parameters);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">  </span><br><span class="line">          <span class="comment">/** Bind annotation attributes 将注解的属性设置到ReferenceBean中，排除 &#123;<span class="doctag">@link</span> IGNORE_FIELD_NAMES&#125; 属性，这些属性后续单独处理 &#123;<span class="doctag">@link</span> AbstractAnnotationConfigBeanBuilder#configureBean(com.alibaba.dubbo.config.AbstractInterfaceConfig) */</span></span><br><span class="line">          dataBinder.bind(<span class="keyword">new</span> AnnotationPropertyValuesAdapter(reference, applicationContext.getEnvironment(), IGNORE_FIELD_NAMES));</span><br><span class="line">  </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ReferenceBean 的后置配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postConfigureBean</span><span class="params">(Reference annotation, ReferenceBean bean)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 设置 Spring 上下文到 ReferenceBean 中，并且 将 Dubbo 和 Spring容器打通，即 设置SpringExtensionFactory中的上下文</span></span><br><span class="line">        bean.setApplicationContext(applicationContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置服务接口</span></span><br><span class="line">        configureInterface(annotation, bean);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试从Spring中获取@Reference注解中配置的consumer属性值对应的ConsumerConfig对象，然后设置到的ReferenceBean对象的consumer属性中</span></span><br><span class="line">        configureConsumerConfig(annotation, bean);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主动触发 ReferenceBean 的 afterPropertiesSet 方法</span></span><br><span class="line">        bean.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// $&#123;省略其他代码&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，创建ReferenceBean对象分析完毕，我们再回过头分析 ReferenceAnnotationBeanPostProcessor#doGetInjectedBean 方法中的创建 <code>Proxy</code> 对象的逻辑。</p><p><strong>创建Proxy对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceAnnotationBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">AnnotationInjectedBeanPostProcessor</span>&lt;<span class="title">Reference</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// $&#123;省略代码&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Proxy代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referencedBeanName </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referenceBean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> injectedType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">buildProxy</span><span class="params">(String referencedBeanName, ReferenceBean referenceBean, Class&lt;?&gt; injectedType)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 创建ReferenceBeanInvocationHandler对象</span></span><br><span class="line">        InvocationHandler handler = buildInvocationHandler(referencedBeanName, referenceBean);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 使用JDK的动态代理创建服务接口的代理对象</span></span><br><span class="line">        Object proxy = Proxy.newProxyInstance(getClassLoader(), <span class="keyword">new</span> Class[]&#123;injectedType&#125;, handler);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建ReferenceBeanInvocationHandler对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referencedBeanName 注入依赖的名字，即服务的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referenceBean ReferenceBean对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> InvocationHandler <span class="title">buildInvocationHandler</span><span class="params">(String referencedBeanName, ReferenceBean referenceBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从缓存中获取对应的 handler对象</span></span><br><span class="line">        ReferenceBeanInvocationHandler handler = localReferenceBeanInvocationHandlerCache.get(referencedBeanName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不存在则创建ReferenceBean的 InvocationHandler 对象</span></span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handler = <span class="keyword">new</span> ReferenceBeanInvocationHandler(referenceBean);</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 如果应用上下文中已经初始化了，说明引入的服务是本地的@Service Bean ，则将引入的Dubbo服务的InvocationHandler添加到本地缓存中，不进行初始化（要想初始化，引入的服务必须是已经暴露的状态）</span></span><br><span class="line">        <span class="keyword">if</span> (applicationContext.containsBean(referencedBeanName)) &#123;</span><br><span class="line">            <span class="comment">// ReferenceBeanInvocationHandler's initialization has to wait for current local @Service Bean has been exported.</span></span><br><span class="line">            localReferenceBeanInvocationHandlerCache.put(referencedBeanName, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果应用上下文中没有，则说明是引入的是远程的服务对象，则立即初始化</span></span><br><span class="line">            handler.init();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// $&#123;省略代码&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码只做了一件事情，为服务接口创建一个代理对象，创建代理对象是使用JDK的动态代理。其中代理对象的执行逻辑封装在ReferenceBeanInvocationHandler对象中，下面我们就来详细分析该Handler。</p><p><strong>ReferenceBeanInvocationHandler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实现了 Dubbo 的 InvocationHandler接口</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBeanInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * ReferenceBean对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> ReferenceBean referenceBean;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Bean 对象(引用的服务)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> Object bean;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">ReferenceBeanInvocationHandler</span><span class="params">(ReferenceBean referenceBean)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.referenceBean = referenceBean;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">           <span class="comment">// 调用 Bean 的对应的方法</span></span><br><span class="line">           <span class="keyword">return</span> method.invoke(bean, args);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1 通过初始化方法，获得 ReferenceBean.ref (引用的服务)，即代理对象</span></span><br><span class="line"><span class="comment">        * 2 调用ReferenceBean#get()方法，进行引用的Bean的初始化，最后返回服务接口代理对象</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.bean = referenceBean.get();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>ReferenceBeanInvocationHandler是ReferenceAnnotationBeanPostProcessor的静态内部类，实现了InvocationHander接口。其中referenceBean属性值是通过构造方法设置的，bean属性的值就是引用的服务，即服务接口代理对象。invoke方法是回调方法，当消费方通过创建的proxy调用服务方法就会回调。至此，<code>@Reference</code> 所需要的依赖已经创建完毕，通过反射设置到所需组件中即可。</p><h2 id="Dubbo注解配置流程总结"><a href="#Dubbo注解配置流程总结" class="headerlink" title="Dubbo注解配置流程总结"></a>Dubbo注解配置流程总结</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/rpc/dubbo-annotation-summary.jpg" alt></p><p>前面已经详细分析Dubbo注解配置的流程，这里进行小结。Dubbo的注解解析机制主要依赖上图中的核心组件。如果用户使用了配置文件，则Dubbo框架按需生成对应的Bean。Dubbo框架会将所有使用Dubbo的注解@Service标注的类提升为Bean，为使用@Reference注解的字段或方法注入代理对象。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码量远比预计得多，写的还是有点混乱的。从代码整个流程可以看出，虽然注解使用更加简洁、方便，但是背后的工作一点都没有少，甚至更多更复杂。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/a8d76a91/&quot;&gt;Dubbo源码分析 - XML配置&lt;
      
    
    </summary>
    
    
      <category term="RPC" scheme="https://gentryhuang.com/categories/RPC/"/>
    
    
      <category term="Dubbo" scheme="https://gentryhuang.com/tags/Dubbo/"/>
    
  </entry>
  
</feed>
