<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gentryhuang‘s blog</title>
  
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gentryhuang.com/"/>
  <updated>2022-05-26T13:09:47.858Z</updated>
  <id>https://gentryhuang.com/</id>
  
  <author>
    <name>gentryhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>集合 - ConcurrentHashMap</title>
    <link href="https://gentryhuang.com/posts/218dc61f/"/>
    <id>https://gentryhuang.com/posts/218dc61f/</id>
    <published>2022-05-14T02:30:35.000Z</published>
    <updated>2022-05-26T13:09:47.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>HashMap 不是线程安全的，在高并发环境下可能会出现系列问题，如链表成环（JDK1.7)、数据覆盖（JDK1.8)。想要避免 HashMap 的线程安全问题有很多办法，比如改用 HashTable 或者使用 Collections.synchronizedMap() 将 HashMap 包装成线程安全的。虽然这两种方法能解决线程安全问题，但是性能成了一个问题，无论读写操作都会给整个集合加锁，导致同一时间的其他操作阻塞。这个时候 ConcurrentHashMap 就应运而生了，它是基于 HashMap 实现的线程安全的集合。</p><p>考虑到 ConcurrentHashMap 在 JDK 不同的版本中实现差异较大，我们先对 JDK 1.7 版本进行简单介绍，然后重点介绍 JDK 1.8 版本中的实现。</p><h1 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h1><p>JDK 1.7 对 ConcurrentHashMap 的实现关键是：<strong>HashMap + Segment</strong>。哈希项的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希桶数组</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashEntry 的成员变量 value 和 next 是被关键字 volatile 修饰的，也就是说所有线程都可以及时检查到其他线程对这两个变量的改变，因此可以在不加锁的情况下读取到这两个引用的最新值。</p><p>Segment 通过继承 ReentrantLock 来进行加锁，通过每次锁住一个 Segment 来降低锁的粒度并保证了每个 Segment 内操作的线程安全性，从而实现全局线程安全。Segment 本身就相当于一个 HashMap 对象，每个 Segment 包含一个 HashEntry 数组。整个 ConcurrentHashMap 的结构如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-1.png" alt></p><p>可以看到，ConcurrentHashMap 是一个二级哈希表，桶数组是 Segment 数组，数组中的每个元素对应一个 HashMap 。</p><p>ConcurrentHashMap 设计成二级哈希表的目的就是采用<strong>锁分段技术</strong>提高并发度，每个 Segment 各自持有一把锁，Segment 之间互不影响。在保证线程安全的同时降低了锁的粒度，使并发操作效率更高。下面看看 ConcurrentHashMap 并发读写的几种情况：</p><ul><li>不同 Segment 的并发写入<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-2.png" alt><br> 不同 Segment 的写入是可以并发执行的，因为每个 Segment 持有的锁不是同一个。</li><li>同一个 Segment 的并发读写<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-3.png" alt><br> 同一个 Segment 的读写可以并发执行。</li><li>同一个 Segment 的并发写入<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-4.png" alt><br> Segment 的写入是需要上锁的，因此对同一个 Segment 的并发写入会被阻塞。</li></ul><p>了解了 ConcurrentHashMap 并发读写的情况后，下面我们对常见的几个方法的执行流程简单说明。</p><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><ol><li>对输入的 key 做 hash 运算得到 hash 值；</li><li>通过 hash 值对 Segment 数组定位对应的 Segment 对象；</li><li>再次通过 hash 值定位到 Segment 中数组的具体桶；</li></ol><p>可以看到，计算 key 的 hash 值后，<strong>要进行两次定位</strong>，第一次为了定位这个 key 是属于哪个 Segment；第二次为了定位这个 key 属于 Segment 中数组哪个桶；</p><h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h2><ol><li>对输入的 key 做 hash 运算得到 hash 值；</li><li>通过 hash 值对 Segment 数组定位对应的 Segment 对象；</li><li>获取 Segment 对应的可重入锁；</li><li>再次通过 hash 值定位到 Segment 中数组的具体桶；</li><li>插入或覆盖 HashEntry 对象；</li><li>释放可重入锁；</li></ol><h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>size 方法是统计 ConcurrentHashMap 中的元素数量，需要把各个 Segment 内的元素数量汇总起来。</p><ol><li>遍历所有的 Segment；</li><li>把 Segment 的元素数量累加起来；</li><li>把 Segment 的修改次数累加起来；</li><li>判断所有 Segment 的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数+1；如果不是。说明没有修改，统计结束。</li><li>如果尝试次数超过阈值，则对每一个 Segment 加锁，再重新统计。</li><li>判断所有 Segment 的总修改次数是否大于上一次的总修改次数，由于已经加锁，次数一定和上次相等。</li><li>依次释放 Segment 锁，统计结束；</li></ol><p><strong>说明：</strong>这里的 size 方法的思想有点类似乐观锁喝悲观锁。为了尽量不锁住 Segment ，先乐观地统计元素数量，当尝试一定次数后仍然失败才会加锁统计。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>ConcurrentHashMap 的结构图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-5.png" alt></p><br><ul><li>ConcurrentHashMap 是线程安全的，其读取不需要加锁，通过引入 Segment 将写锁粒度缩小，每个 Segment 中的桶数组就相当于 HashTable；</li><li>由于引入了 Segment ，在读取和写入的时候需要做两次映射定位，第一次定位 Segment，第二次定位 Segment 中数组的桶；</li><li>到了第二次定位桶的过程，就和 HashMap 是一致的了；</li></ul><h1 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h1><p>相比 JDK 1.7 使用的 Segment 保证线程安全，JDK 1.8 进行了重写式优化，<strong>取消了 Segment 的设计，取而代之的是通过 CAS 操作和 synchronized 关键字来实现线程安全</strong>。当然，在存储结构上仍然基于 HashMap 。</p><p>ConcurrentHashMap 主要 UML 类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-6.png" alt></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>写到这里，脑海里又响起了一阵声音，为什么要研究 ConcurrentHashMap 源码？我始终认为知其然知其所以然，才能算得上真正了解一个事物。在分析源码之前，我们以问题的方式进行驱动。</p><ul><li>ConcurrentHashMap 是怎么保证线程安全的？如，初始化时怎么保证安全、扩容时怎么保证安全、如何安全地执行读写操作、如何安全获取元素个数。</li><li>ConcurrentHashMap 并发效率是如何提高的？怎么控制并发的。</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Constants -------------- */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大容量，当两个构造函数中任何一个带参数的函数隐式指定较大的值时使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认容量大小 16，大小必须是 2^N</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶的树化阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶的链表还原阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最小树化容量阈值：使用红黑树时最小的表容量。当 HashMap 中的容量 &gt;= 该值时，才允许树形化链表即将链表转成红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sizeCtl 中用于生成标记的位数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> RESIZE_STAMP_BITS = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以帮助调整大小的最大线程数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RESIZERS = (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 sizeCtl 中记录大小标记的位移，为 16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESIZE_STAMP_SHIFT = <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 节点中的 hash </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED = -<span class="number">1</span>; <span class="comment">//  ForwardingNode 类型节点的 hash 值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN = -<span class="number">2</span>; <span class="comment">// 红黑树的根节点的 hash 值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// 普通节点哈希的可用位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CPU 的数量，以限制某些大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储数据的 Node 数组，长度是 2 的幂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用 volatile 来保证每次获取到的都是最新的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K, V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下一个要使用的表；仅在调整大小时为非空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K, V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基本计数器值，主要在没有争用时使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个含义，要重点理解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整大小时要拆分的下一个表索引（加一个）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整大小和/或创建 CounterCell 时使用自旋锁（通过 CAS 锁定）。</span></span><br><span class="line"><span class="comment"> * 0：不 busy  1：busy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计数单元桶。当非空时，大小是 2 的幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 中的属性比较多，属于 HashMap 中的属性就不再说明，下面对核心属性进行说明。</p><p><strong>MOVED:</strong> ForwardingNode 类型节点的 hash 值，在数组扩容的过程中如果旧数组的某个桶元素为空或者迁移完毕就会使用 ForwardingNode 对象填充，作为一个标记；<br><strong>baseCount:</strong> 记录元素个数的基本计数器，主要在没有竞争的情况下使用；<br><strong>counterCells:</strong> 元素个数的计数单元桶，在并发环境下将元素个数的记录分摊到不同的计数器上，缓解单个计数器的竞争；<br><strong>cellsBusy:</strong> 调整或创建计数单元 CounterCell 时的标记，表示某个线程竞争成功；</p><h4 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h4><p>sizeCtl 这个属性非常重要，对理解整个 ConcurrentHashMap 至关重要。</p><ol><li>正常情况下，sizeCtl 存储的是扩容阈值，固定为数组容量的 0.75 倍，默认值为 0；</li><li>当初始化数组时，sizeCtl 会被设置为 -1，表示某个线程抢到了初始化数组的资格，没有抢到资格的线程自旋以等待数组初始化完成。数组初始化完成后，会把 sizeCtl 设置为扩容的阈值；</li><li>当数组达到扩容条件时，sizeCtl 不再存储扩容阈值，而是用来标识正处于扩容过程。在扩容前，会将 sizeCtl 设置为一个负数，在扩容完成后会重新计算扩容阈值并赋值到 sizeCtl 。</li></ol><p>其中，扩容过程中 sizeCtl 为负数的情况不太好理解，下面我们详细说说这种情况下的 sizeCtl 为负数时的组成。假设场景为某时刻数组的容量为 16 ，此时达到了扩容的条件。</p><p><strong>第一步：</strong>扩容前先标识数组处于扩容的过程，即设置 sizeCtl 的值；</p><p>线程通过执行 <code>U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</code> 代码片段设置 sizeCtl 的值，因为此时数组容量为 16，针对该容量扩容的标识值 rs=32795（计算出来的），对应的二进制数为：<code>1000 0000 0001 1011 0000 0000 0000 0010</code> ，具体组成如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-7.png" alt></p><p><strong>第二步：</strong>一旦扩容开始了，执行写操作（新增、删除）的线程<strong>发现</strong>集合处于扩容过程，此时就会加入到迁移元素的流程中，加快扩容进度；其中“发现”的情况如下：</p><ul><li>线程在新增元素后，如果判断达到扩容条件，那么会进入到扩容流程，如果此时已经有线程在扩容了，那么当前线程会加入到迁移元素的流程；</li><li>线程在定位数组桶时，发现桶中元素类型是 ForwardingNode ，那么会先加入到迁移元素流程，完成迁移后再执行写操作；</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用默认初始表大小 (16) 创建一个新的空映射。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new, empty map with an initial table size</span></span><br><span class="line"><span class="comment"> * accommodating the specified number of elements without the need</span></span><br><span class="line"><span class="comment"> * to dynamically resize.</span></span><br><span class="line"><span class="comment"> * 创建一个新的空映射，其初始表大小可容纳指定数量的元素，无需动态调整大小。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity The implementation performs internal</span></span><br><span class="line"><span class="comment"> *                        sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity of</span></span><br><span class="line"><span class="comment"> *                                  elements is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传入容量大小计算容量，返回大于 initialCapacity 且最近的2的整数次幂的数</span></span><br><span class="line">    <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">            MAXIMUM_CAPACITY :</span><br><span class="line">            tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容量大小赋值给 sizeCtl，初始化后 sizeCtl 作为扩容阈值</span></span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化 ConcurrentHashMap 时底层数组是没有进行初始化的，会等到第一次添加元素时才会初始化。此外，相比 HashMap 控制数组容量及填充度分别使用了 <code>threshold</code> 和 <code>loadFactor</code>，ConcurrentHashMap 使用了 sizeCtl 属性来控制，具体如下：</p><ul><li>非扩容的情况下，sizeCtl 表示的语意同 threshold；</li><li>在计算扩容阈值时，使用了固定的负载因子 0.75；</li></ul><p>这个在后续的源码中会有体现。</p><h3 id="put-新增元素"><a href="#put-新增元素" class="headerlink" title="put() - 新增元素"></a>put() - 新增元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * key 和 value，都不允许为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认覆盖式</span></span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，使用 put 方法默认式覆盖式新增元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 整体流程和 HashMap 类似</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key          key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value        value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 是否覆盖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key 、value 都不允许为空</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于记录要插入的元素所在桶的元素个数，主要用于判断是否将链表转为红黑树的情况</span></span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自旋，结合 CAS 使用（如果 CAS 失败，则会重新取整个桶进行下面的流程），直到 put 操作完成后退出循环</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K, V&gt;[] tab = table; ; ) &#123;</span><br><span class="line">        Node&lt;K, V&gt; f;</span><br><span class="line">        <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  1 如果数组为空，则进行数组初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化数组</span></span><br><span class="line">            tab = initTable();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 定位到 hash 值对应的数组下标，得到第一个节点 f</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果数组该位置没有节点，则使用一次 CAS 操作将这个新值放入其中即可。</span></span><br><span class="line">            <span class="comment">// 如果 CAS 失败，说明是并发操作，进入到下一个循环重试；如果 CAS 成功，则 break ，流程结束</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                    <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="comment">// 插入成功，退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 如果 hash 值对应的位置有节点，且取的第一个节点的 hash 值为 MOVED ，说明当前数组处于扩容过程，则当前线程帮忙一起迁移元素，</span></span><br><span class="line">        <span class="comment">// 然后再执行插入元素操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 辅助数据迁移</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 非以上三种情况，也就是当前定位的桶不为空，且不在迁移元素，那么锁住这个桶（以桶的第一个元素作为锁对象-分段锁）</span></span><br><span class="line">            <span class="comment">// 要插入的元素在该桶，则替换值（onlyIfAbsent=false）；不在该桶，则插入到链表结尾或插入树中；</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.1 获取 synchronized 的锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 再次检测第一个元素是否有变化，如果有变化则进入下一次循环，从头来过</span></span><br><span class="line">                <span class="comment">// Unsafe 类的 volatile 式查看值，保证获取到的值都是最新的</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果第一个元素的hash值大于等于0（说明不是在迁移，也不是树），那就是桶中的元素使用的是链表方式存储</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 记录链表的元素个数</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 遍历链表，尾节点插入数据</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; e = f; ; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 如果发现了相同的 key ，判断是否要进行值覆盖，然后也就可以 break 了</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                            (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 找到了相同 key 的元素，根据情况进行覆盖并退出循环</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 到了链表的末尾还没发现相同 key 的元素，那么就将这个新值放到链表的最后，尾插法</span></span><br><span class="line">                            Node&lt;K, V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K, V&gt;(hash, key,</span><br><span class="line">                                        value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 树结构</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K, V&gt; p;</span><br><span class="line">                        <span class="comment">// 记录树中元素个数为 2「注意，树的情况没有进行累加」</span></span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 调用红黑树的插入方法插入元素，如果成功则返回 null，否则返回找到的节点</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K, V&gt;) f).putTreeVal(hash, key,</span><br><span class="line">                                value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 找到了相同 key 的元素，根据情况进行覆盖并退出循环</span></span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 binCount不为0，说明成功插入了元素或者寻找到了元素</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果链表元素个数 &gt;= 8 ，那么尝试进行链表树化「只有数组容量 &gt;= 64 时才会真正进行树化，否则优先扩容」</span></span><br><span class="line">                <span class="comment">// 因为上面把元素插入到树中时，binCount只赋值了2，并没有计算整个树中元素的个数，所以不会重复树化</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 树化</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果要插入的元素已经存在，那么把旧值返回</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 退出外层大循环，流程结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是插入元素的情况，则：累加元素个数 &amp; 判断扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功插入元素返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述新增元素的源码中可以看到，如果将并发控制的逻辑剔除，剩下的逻辑和 HashMap 的 put 方法基本类似。主干流程如下：</p><ol><li>不允许 key 或 value 为 null；</li><li>如果桶数组未初始化，执行初始化流程，然后再尝试添加元素；</li><li>如果待插入的元素所在的桶为空，则使用 CAS 尝试将元素放到该桶中；</li><li>如果数组正处于扩容过程，那么当前线程一起加入到扩容的过程中；</li><li>如果待插入的元素所在的桶不为空，且没有迁移元素，那么锁住这个桶，锁粒度就是桶元素对象；<ul><li>如果当前桶中元素以链表方式存储，则在链表中寻找该元素或者<strong>尾插入元素</strong>；</li><li>如果当前桶中元素以红黑树方式存储，则在红黑树中寻找该元素或者插入元素；</li></ul></li><li>针对链表的情况判断是否需要进行树化；</li><li>如果要插入的元素（元素 key）存在，则返回旧值，此时不需要累加元素个数以及判断容量情况；</li><li>如果要插入的元素（元素 key）不存在，则累加元素个数，并检查是否需要扩容；</li></ol><p>了解了添加元素的主干逻辑后，<strong>下面我们对上述方法中针对并发控制的关键点进行说明</strong>：</p><ul><li>使用<strong>自旋结合CAS的方式</strong>完成新增元素操作；</li><li>使用<strong>Unsafe 类的 volatile 式的获取方法查看元素，保证每次获取到的元素都是最新的</strong>。注意，虽然桶数组 table 使用了 volatile 修饰，但也只能保证其引用的可见性，并不能确保其数组中的元素是否是最新的，所以通过 Unsafe 类的 volatile 式获取到最新的元素；</li><li>协同扩容流程优先，新增元素流程靠后；</li><li>使用 <code>synchronized</code> 实现分段锁，完成新增元素的流程。注意，这里将 key 映射的桶元素作为锁对象，达到缩小锁范围的目的。在 hash 不冲突的情况下，可同时支持 n 个线程同时 put 操作，n 为桶数组的大小。</li></ul><h3 id="initTable-初始化数组"><a href="#initTable-初始化数组" class="headerlink" title="initTable() - 初始化数组"></a>initTable() - 初始化数组</h3><p>初始化数组流程是在新增元素时进行的，通过对新增元素的源码分析后我们知道，初始化数组流程是不受锁的保护的，那么该方法是如何处理并发问题的呢？下面我们一起来看看源码是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K, V&gt;[] initTable() &#123;</span><br><span class="line">       Node&lt;K, V&gt;[] tab;</span><br><span class="line">       <span class="keyword">int</span> sc;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 每次循环都获取最新的 Node 数组引用</span></span><br><span class="line">       <span class="comment">// 初始化数组时，sizeCtl 为数组容量大小，默认为 0；如果 sizeClt &gt; 0 ，那使用的是带有初始化容量的构造方法</span></span><br><span class="line">       <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 如果 sizeCtl &lt; 0 ，说明其它线程正在进行初始化或扩容，那么就让出 CPU，从运行状态回到就绪状态</span></span><br><span class="line">           <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">               Thread.yield(); <span class="comment">// lost initialization race; just spin 初始化失败，只是旋转</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// CAS 一下，将 sizeCtl 设置为 -1，代表抢到了初始化数组的资格，当前线程进入初始化，成功后退出循环。</span></span><br><span class="line">               <span class="comment">// 如果原子更新失败则说明有其它线程先一步进入初始化了，则进入下一次循环，如果下一次循环时还没初始化完毕，则sizeCtl&lt;0进入上面if的逻辑让出CPU，如果初始化完毕退出循环；</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 再次检查table是否为空</span></span><br><span class="line">                   <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 如果 sc 为 0，则使用 DEFAULT_CAPACITY 默认初始容量是 16</span></span><br><span class="line">                       <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 创建数组，长度为 16 或初始化时提供的长度（也是 2^N)</span></span><br><span class="line">                       <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                       Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node&lt;?, ?&gt;[n];</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 将创建的数组赋值给 table</span></span><br><span class="line">                       table = tab = nt;</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 设置 sc 为数组长度的 0.75 倍</span></span><br><span class="line">                       <span class="comment">// n - (n &gt;&gt;&gt; 2) = n - n/4 = 0.75 * n</span></span><br><span class="line">                       sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">// 由于这里只会有一个线程在执行，直接赋值即可，没有线程安全问题。把sc赋值给sizeCtl，这时存储的是扩容阈值</span></span><br><span class="line">                   sizeCtl = sc;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>初始化数组的主要过程如下：</p><ol><li>使用 CAS 设置 sizeCtl 为 -1 ，控制只有一个线程初始化桶数组，CAS 失败的线程会等待桶数组初始化完毕；</li><li>sizeCtl 在初始化后存储的是桶数组的扩容阈值，其中扩容阈值的计算是固定的，大小为<strong>桶数组大小的 0.75 倍</strong>。这里的负载因子和扩容阈值相当于都是固定了，这也正是没有使用 threshold 和 loadFactor 属性而是使用 sizeCtl 控制数组的原因。</li></ol><p>可见，就算有多个线程同时进行 put 操作，在初始化数组时使用了乐观锁 CAS 操作来决定哪个线程有资格进行初始化，其它线程只能等待数组初始化完成。处理并发点如下：</p><ul><li>桶数组 table 使用了 volatile 修饰，保证获取到的都是最新的值；</li><li>数组控制 sizeCtl 属性使用了 volatile 修饰，保证线程间的可见性；</li><li>使用 CAS 操作保证设置 sizeCtl 标记的原子性，只有一个线程能设置成功，没有设置成功的线程，等待数组初始化完成即可；</li></ul><h3 id="addCount-计数并判断扩容"><a href="#addCount-计数并判断扩容" class="headerlink" title="addCount() - 计数并判断扩容"></a>addCount() - 计数并判断扩容</h3><p>每次添加元素后（注意，是添加不是覆盖），集合中的元素数需要加 1，然后判断是否达到扩容阈值，达到了需要进行扩容或协助迁移元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x     要累加的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> check 如果&lt;0，不检查调整大小；如果&lt;= 1，只检查是否无竞争；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*----------------------- 1、累加元素个数  ---------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里使用的思想和 LongAdder 类很类似。</span></span><br><span class="line">    CounterCell[] as;</span><br><span class="line">    <span class="keyword">long</span> b, s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计元素个数的操作</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">            !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 执行到这里，说明：</span></span><br><span class="line"><span class="comment">        1.counterCells被初始化完成了，不为null</span></span><br><span class="line"><span class="comment">        2.增加数量到 baseCount 失败了，存在线程竞争，接下来尝试增加到当前线程映射到的桶上</span></span><br><span class="line"><span class="comment">        3.先优先尝试把数量加到 baseCount 上，如果失败再加到对应的 CounterCell 上</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        CounterCell a;</span><br><span class="line">        <span class="keyword">long</span> v;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//标志是否存在竞争</span></span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在计数桶数组中随机选一个计数桶，然后使用CAS操作将此计数桶中的value+1</span></span><br><span class="line">        <span class="comment">// 1 先判断计数桶是否还没初始化，也就是 as==nul，进入语句</span></span><br><span class="line">        <span class="comment">// 2 判断计数桶长度是否为空或，若是进入语句块</span></span><br><span class="line">        <span class="comment">// 3 这里做了一个线程变量随机数，与上桶大小-1，若桶的这个位置为空，进入语句块</span></span><br><span class="line">        <span class="comment">// 4 到这里说明桶已经初始化了，且随机的这个位置不为空，尝试CAS操作使桶加1，失败进入语句块</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                        U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若CAS操作失败，证明有竞争，进入fullAddCount方法</span></span><br><span class="line">            <span class="comment">// 失败几次，那么就对counterCells进行扩容，以减少多个线程hash到同一个桶的概率</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算元素个数</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*------------------ 2、判断是否需要进行扩容 ----------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K, V&gt;[] tab, nt;</span><br><span class="line">        <span class="keyword">int</span> n, sc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果元素个数达到了扩容阈值，则进行扩容。</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>) (sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// rs 为要扩容容量为 n 的数组的一个标识，如数组容量 n=16，那 rs=32795</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// sc &lt; 0 说明有线程正在迁移</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//  判断扩容是否已经完成了，如果完成则退出循环</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 扩容未完成，则当前线程加入迁移元素流程中，并把扩容线程数加 1</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不为负数，则为第一个迁移的线程，此时多了创建新数组的操作</span></span><br><span class="line">                <span class="comment">// sizeCtl 的高 16 位存储 rs 这个标识</span></span><br><span class="line">                <span class="comment">// sizeCtl 的低 16 位存储扩容线程数，刚开始为2，表示有一个线程正在迁移，如果为3，代表2个线程正在迁移以此类推…</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进入扩容并迁移元素的逻辑，传入 nextTab 为 null 就会触发创建新数组进而扩容</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新计算元素个数</span></span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码中也可以看到，上述方法包含两部分的逻辑，一个是记录集合中元素个数，另一个是达到扩容阈值执行扩容逻辑。下面我们分别介绍。</p><h4 id="记数"><a href="#记数" class="headerlink" title="记数"></a>记数</h4><p>在 ConcurrentHashMap 中，快速统计元素个数是非常重要的，不仅使用方会关注集合中元素个数，而且集合内部需要根据元素个数来判断是否需要扩容。使用的思想和 LongAdder 类似，如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/concurrent-hashmap-8.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶是由线程对应的，多个线程可以对应一个桶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前桶对应的元素数量，可见性保证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    CounterCell(<span class="keyword">long</span> x) &#123;</span><br><span class="line">        value = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在设计时，使用了<strong>分而治之</strong>的思想，除了基础的计数，将每一个计数都分散到各个 CounterCell 对象（桶）中，使竞争最小化。总的来说，ConcurrentHashMap 的大小分为两部分：</p><ul><li>基础计数 baseCount: 在记录元素个数时优先 CAS 更新该属性，如果 CAS 失败才会采用分治桶计数的方式。即在线程竞争不大的时候，直接使用CAS操作baseCount值即可；</li><li>分治桶计数 CounterCell[]: 若出现了CAS操作失败的情况，则证明此时有线程竞争了，计数方式转变为分而治之的桶计数方式，也就是线程映射到不同的 CounterCell；</li></ul><p>了解了 ConcurrentHashMap 计数的思想后，下面看看源码是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*----------------------- 1、累加元素个数  ---------------------------*/</span></span><br><span class="line">      CounterCell[] as;</span><br><span class="line">      <span class="keyword">long</span> b, s;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 统计元素个数的操作</span></span><br><span class="line">      <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">              !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*------------- 执行到这里，说明：</span></span><br><span class="line"><span class="comment">          1.counterCells被初始化完成了，不为null</span></span><br><span class="line"><span class="comment">          2.增加数量到 baseCount 失败了，存在线程竞争，接下来尝试增加到当前线程映射到的桶上</span></span><br><span class="line"><span class="comment">          3.先优先尝试把数量加到 baseCount 上，如果失败再加到对应的 CounterCell 上</span></span><br><span class="line"><span class="comment">          ----------------*/</span></span><br><span class="line">          CounterCell a;</span><br><span class="line">          <span class="keyword">long</span> v;</span><br><span class="line">          <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//标志是否存在竞争</span></span><br><span class="line">          <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 在计数桶数组中根据当前线程选一个计数桶，然后使用CAS操作将此计数桶中的value+1</span></span><br><span class="line">          <span class="comment">// 1 先判断计数桶是否还没初始化，也就是 as==nul，进入语句</span></span><br><span class="line">          <span class="comment">// 2 判断计数桶长度是否为空或，若是进入语句块</span></span><br><span class="line">          <span class="comment">// 3 这里做了一个线程变量随机数，与上桶大小-1，若桶的这个位置为空，进入语句块</span></span><br><span class="line">          <span class="comment">// 4 到这里说明桶已经初始化了，且随机的这个位置不为空，尝试CAS操作使桶加1，失败进入语句块</span></span><br><span class="line">          <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                  (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                  !(uncontended =</span><br><span class="line">                          U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">//若CAS操作失败，证明有竞争，进入fullAddCount方法</span></span><br><span class="line">              <span class="comment">// 失败几次，那么就对counterCells进行扩容，以减少多个线程hash到同一个桶的概率</span></span><br><span class="line">              fullAddCount(x, uncontended);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 返回</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 计算元素个数</span></span><br><span class="line">          s = sumCount();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//... 省略判断扩容逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中也能看到，在计数时优先使用基础计数，有竞争的情况下会使用<strong>分而治之桶计数</strong>，对应的逻辑在 <code>fullAddCount</code> 方法中。这里有两种情况，一种是计数桶数组还没有初始化，另外一种是计数数组已经初始化过了，此外，<strong>如果计数桶数组存在，优先使用分而治之桶计数</strong>。下面我们从源码层面看这两种情况。</p><h5 id="初始化计数桶数组"><a href="#初始化计数桶数组" class="headerlink" title="初始化计数桶数组"></a>初始化计数桶数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See LongAdder version for explanation</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 线程对应的随机值</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">         ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">         h = ThreadLocalRandom.getProbe();</span><br><span class="line">         wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 自旋，更新元素个数</span></span><br><span class="line">     <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">         CounterCell[] as;</span><br><span class="line">         CounterCell a;</span><br><span class="line">         <span class="keyword">int</span> n;</span><br><span class="line">         <span class="keyword">long</span> v;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果计数单元桶!=null，证明已经初始化过，那么就针对当前线程映射一个计算单元并累加数量</span></span><br><span class="line">         <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">//... 略</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">// 进入此语句块进行计数桶的初始化</span></span><br><span class="line">             <span class="comment">// CAS设置cellsBusy=1，表示现在计数桶 busy 中，控制并发</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 若有线程同时初始化计数桶，由于CAS操作只有一个线程进入这里</span></span><br><span class="line">             <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">//再次确认计数桶为空</span></span><br><span class="line">                 <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                     <span class="comment">//初始化一个长度为2的计数桶</span></span><br><span class="line">                     CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line">                     <span class="comment">//h为当前线程相关的一个随机数，&amp; 1 代表，在 0、1中随机的一个</span></span><br><span class="line">                     <span class="comment">//也就是在0、1下标中随便选一个计数桶，x=1，放入1的值代表增加1个容量</span></span><br><span class="line">                     rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">                     <span class="comment">//将初始化好的计数桶赋值给ConcurrentHashMap中的属性</span></span><br><span class="line">                     counterCells = rs;</span><br><span class="line">                     init = <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 <span class="comment">//最后将busy标识设置为0，表示不busy了</span></span><br><span class="line">                 cellsBusy = <span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 初始化计数桶数组后退出循环</span></span><br><span class="line">             <span class="keyword">if</span> (init)</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//若有线程同时来初始化计数桶，则没有抢到busy资格的线程就CAS递增基础计数 baseCount</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">             <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看到，当更新基础计数器 baseCount 失败后，获取到初始化资格的线程会初始化一个大小为 2 的计算桶数组。<strong>完成了计数桶数组的初始化后，在之后的计数都将会使用计算桶来计数</strong>。</p><p><strong>注意：</strong>这里同样使用了 CAS 保证并发安全，如果在初始化时，有并发竞争，那么竞争失败的线程会 CAS 更新基础计数器 baseCount，尽可能提高并发度。</p><h5 id="扩容计数桶"><a href="#扩容计数桶" class="headerlink" title="扩容计数桶"></a>扩容计数桶</h5><p>从上面初始化计数桶数组中我们知道，计数桶的长度为 2，在并发大的时候竞争依然会很大，因此就需要计数桶数组的扩容，这个过程就对应 fullAddCount 方法的另一个分支。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程对应的随机值，用于对计数桶数组取模定位计算桶</span></span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自旋，更新元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        CounterCell[] as;</span><br><span class="line">        CounterCell a;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">long</span> v;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果计数单元桶!=null，证明已经初始化过，那么就针对当前线程映射一个计算桶并计算元素数</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从计数桶数组中定位当前线程映射的计数桶，若为null表示该桶为空，需要创建一个</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断计数单元 的 busy 状态（用于控制并发），为 0 表示不忙碌，即没有线程竞争</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 创建一个计数单元桶，初始值为传入的个数 x</span></span><br><span class="line">                    CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// CAS 操作 busy 为 1，标记计数桶处理中</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            CounterCell[] rs;</span><br><span class="line">                            <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="comment">// 再检查一次计数桶为null</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                    (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//将刚刚创建的计数桶赋值给对应位置</span></span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">// 处理完成后，标记计数桶处理完成</span></span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果是创建计数桶的情况，直接退出循环即可</span></span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*------------- 走到这里，说明当前线程映射的计数桶不为空 ----------------*/</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//走到这里代表计数桶不为null，尝试递增计数桶</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//若CAS操作失败了，到了这里，会先进入一次，然后再走一次刚刚的for循环</span></span><br><span class="line">                <span class="comment">//若是第二次for循环，collide=true，则不会走进去</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 走到这里，说明竞争较大，多个线程都映射到了一个计数桶，导致更新计数失败较多，那么就需要通过扩容计数桶数组来减小竞争 */</span></span><br><span class="line">                <span class="comment">//一个线程若进行了多次CAS操作计数桶失败，那么就需要进行计数桶扩容逻辑，完成扩容后重新计数</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 确认计数桶还是同一个</span></span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//将长度扩大到2倍</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 遍历旧计数桶，直接将旧计数桶拿过来填充</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 完成扩容后，标记计数桶处理完成</span></span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新计算当前线程的随机值，用于定位对应的计数桶</span></span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进入此语句块进行计数桶的初始化</span></span><br><span class="line">            <span class="comment">// CAS设置cellsBusy=1，表示现在计数桶 busy 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//... 省略</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//若有线程同时来初始化计数桶，则没有抢到busy资格的线程就先来CAS递增baseCount</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 CAS 操作计数桶失败多次之后，会先进行扩容计数桶数组流程，扩容完毕后再次尝试 CAS 操作映射的计数桶。一般扩容后再次 CAS 操作大都会成功，除非并发太大了。</p><h5 id="统计元素个数"><a href="#统计元素个数" class="headerlink" title="统计元素个数"></a>统计元素个数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算所有计数桶及 baseCount 的数量之和</span></span><br><span class="line">    CounterCell[] as = counterCells;</span><br><span class="line">    CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历 CounterCell ，不保证可见性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 使用 getObjectVolatile 方法保证可见性</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于集合中的元素存储在两个部分中，因此需要将两部分的数量累加起来。</p><p><strong>注意：</strong>上述统计元素个数的方法是弱一致性的，因为在遍历 CounterCell 数组时，不能保证其内部属性 value 的可见性。</p><h5 id="计数小结"><a href="#计数小结" class="headerlink" title="计数小结"></a>计数小结</h5><p>计数时优先利用 CAS 操作基础计数器 baseCount，在竞争不大时一般都能成功，此时性能没有啥大的损失；</p><p>若存在线程竞争基础计数器 baseCount，则初始化计数桶数组来分摊竞争。在初始化计数桶数组的过程中也存在竞争的话，通过 CAS 保证只有一个线程有资格进行初始化，没有抢到初始化资格的线程直接尝试 CAS 操作基础计数器的方式完成计数，没有完成计数的线程会进行自旋，<strong>尽可能最大化并发度</strong>。</p><p>如果已经存在计数桶数组，那么使用计数桶计数，采用分而治之的方式来计数。由于计数桶数组能同时提供计数的桶数量有限，如果还是存在频繁失败的情况，那么就对计数桶数组扩容，并发安全的处理同样使用 CAS 来保证，这样就可以支持同时更多线程并发计数了。其中，在为线程映射计数桶时，<strong>利用位运算和随机数以负载均衡的方式将线程计数请求接近均匀的分散到不同的计数桶中</strong>。</p><h4 id="判断扩容"><a href="#判断扩容" class="headerlink" title="判断扩容"></a>判断扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** because resizings are lagging additions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x     要累加的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> check 如果&lt;0，不检查调整大小；如果&lt;= 1，只检查是否无竞争；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*----------------------- 1、累加元素个数  ---------------------------*/</span></span><br><span class="line">    CounterCell[] as;</span><br><span class="line">    <span class="keyword">long</span> b, s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... 省略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算元素个数</span></span><br><span class="line">    s = sumCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*------------------ 2、判断是否需要进行扩容 ----------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K, V&gt;[] tab, nt;</span><br><span class="line">        <span class="keyword">int</span> n, sc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果元素个数达到了扩容阈值，则进行扩容。</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>) (sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// rs 为要扩容容量为 n 的数组的一个标识，如数组容量 n=16，那 rs=32795</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// sc &lt; 0 说明有线程正在迁移</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//  判断扩容是否已经完成了，如果完成则退出循环</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 扩容未完成，则当前线程加入迁移数据流程中，并把扩容线程数加 1</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不为负数，则为第一个迁移的线程，此时多了创建新数组的操作</span></span><br><span class="line">                <span class="comment">// sizeCtl 的高 16 位存储 rs 这个标识</span></span><br><span class="line">                <span class="comment">// sizeCtl 的低 16 位存储扩容线程数，刚开始为2，表示有一个线程正在迁移，如果为3，代表2个线程正在迁移以此类推…</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进入扩容并迁移元素的逻辑，传入 nextTab 为 null 就会触发创建新数组进而扩容</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新计算元素个数</span></span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次添加元素后，集合中的元素数量加 1。紧接着会判断是否达到扩容阈值，达到的话则<strong>进行扩容或协助扩容</strong>。</p><p>如果达到扩容条件，那么会有一个线程 CAS 设置扩容标识位 sizeCtl 成功，此时 <strong>sizeCtl 的含义</strong>前文已经详细介绍。获取到扩容资格的线程会执行 <code>transfer(tab, null)</code> 方法进入扩容和迁移元素流程，启动扩容流程后进入上述方法的线程会感知到 <code>sizeCtl&lt;0</code> ，此时如果扩容还没有结束，也会加入到迁移元素的流程中，<strong>此时需要注意 sizeCtl 值的更新</strong>。 </p><h3 id="tryPresize-扩容或迁移元素"><a href="#tryPresize-扩容或迁移元素" class="headerlink" title="tryPresize() - 扩容或迁移元素"></a>tryPresize() - 扩容或迁移元素</h3><p>除了执行 put 方法时检测到达到扩容阈值会扩容，检测链表是否要进行树化的时候也需要判断可否优先扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若数组长度小于64，则优先扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">      <span class="comment">// 尝试扩容</span></span><br><span class="line">      tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换为红黑树</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">        <span class="comment">//...转换为红黑树的操作</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>treeifyBin 方法会将链表转换为红黑树以增加查找效率，但在这之前会检查数组长度，若小于 64 则会优先做扩容操作。其中尝试扩容的方法和前文中的 <code>addCount</code> 方法的判断是否扩容分支逻辑基本类似，就不再重复说明，源代码注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取 2^n 值</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组没有在初始化或扩容</span></span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K, V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该分支用于初始化数组，主要用于 putAll 方法添加元素的场景</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node&lt;?, ?&gt;[n];</span><br><span class="line">                        table = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无需进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="comment">// 扩容 table 的 epoch</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果处于扩容过程中</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K, V&gt;[] nt;</span><br><span class="line">                <span class="comment">// 扩容完毕了，退出循环</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//  CAS 将 sizeCtl 加 1 表示当前线程加入到扩容过程，然后执行 transfer 方法</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// CAS 设置 sizeCtl 成功后执行 transfer 方法进行扩容</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                    (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transfer-扩容或迁移元素"><a href="#transfer-扩容或迁移元素" class="headerlink" title="transfer() - 扩容或迁移元素"></a>transfer() - 扩容或迁移元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab     旧数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nextTab 扩大2倍后的新数组，如果为空说明还没有创建新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K, V&gt;[] tab, Node&lt;K, V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录旧数组容量</span></span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据机器CPU核心数来计算，一条线程负责Node数组中多长的迁移量， stride 就是当前线程分到的迁移量</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*--------------------------------- 1、扩容 -------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// nextTab 为空，说明还没开始扩容，就创建一个新桶数组</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 新桶数组大小是原桶的 2 倍</span></span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K, V&gt;[] nt = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node&lt;?, ?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扩容期间的新数组</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// 旧数组容量作为迁移下标</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*--------------------------------- 2、迁移元素 ---------------------------------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新数组大小</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个 ForwardingNode 类型的标记节点，其 hash 值为 MOVED，并把新桶数组存储在里面，这个对象作为旧数组某个桶迁移完毕的标志。</span></span><br><span class="line">    ForwardingNode&lt;K, V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K, V&gt;(nextTab);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后往前，依次对旧数组每个桶进行元素的迁移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>; ; ) &#123;</span><br><span class="line">        Node&lt;K, V&gt; f;</span><br><span class="line">        <span class="keyword">int</span> fh;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1 确定要迁移的桶的下标</span></span><br><span class="line">        <span class="comment">// i 的值会从 n-1 依次递减，其中 n 是旧桶数组的大小。比如，i 从 15 开始一直减到 1 这样去迁移元素</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// i为当前正在处理的Node数组下标，每次处理一个Node节点就会自减1</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// CAS 下标，保证每个线程获取到正确的下标，支持并发迁移元素</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                    (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                            nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                    nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 确定好小标后，就可以退出确定下标的循环了</span></span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 对下标为 i 的桶进行处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果旧数组元素迁移完了</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果所有桶中的元素都迁移完成了，则替换旧桶数组，并设置下一次扩容阈值为新桶数组容量的 0.75 倍</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前线程扩容完成，把扩容线程数-1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 扩容完成，条件成立，也就是此时是最后一个线程走到这里，和首次进行扩容的 sizeCtl 一样</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 标记完成</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// i 重新赋值为 n，这样会再重新遍历一次桶数组，看看是不是都迁移完成了</span></span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果桶中无数据，直接在旧桶的 i 位置放入 ForwardingNode 表示该桶已迁移完</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果桶中第一个元素的 hash 值为 MOVED ，说明它是 ForwardingNode 节点，表示该桶已迁移完</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 迁移 i 位置桶中的元素</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 锁定该桶，并迁移元素</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 再次判断当前桶第一个元素是否有修改，也就是可能其它线程先一步迁移了元素</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K, V&gt; ln, hn;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 桶中第一个元素 fh &gt;= 0 说明桶是链表形式，这里与 HashMap 迁移算法基本一致，仅做了点优化</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K, V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 看看最后这几个元素归属于低位链表还是高位链表</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 遍历链表，把hash&amp;n为0的放在低位链表中，不为0的放在高位链表中</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash;</span><br><span class="line">                            K pk = p.key;</span><br><span class="line">                            V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K, V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K, V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 低位链表的位置不变 - CAS操作</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 高位链表的位置是原位置加n - CAS操作</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 使用 Unsafe 的 volatile 式标记该桶已迁移完成，即在该桶中放置 ForwardingNode 类型的元素以标记该桶迁移完成</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// advance为true，返回上面进行 --i 操作</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果桶中第一个元素是树节点，也是一样分化成两颗树，也是根据hash&amp;n为0放在低位树中，不为0放在高位树中， 基本同 HashMap</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K, V&gt; t = (TreeBin&lt;K, V&gt;) f;</span><br><span class="line">                        TreeNode&lt;K, V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K, V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K, V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K, V&gt; p = <span class="keyword">new</span> TreeNode&lt;K, V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果分化的树中元素个数小于等于6，则退化成链表</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K, V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K, V&gt;(hi) : t;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 低位树的位置不变 - CAS操作</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 高位树的位置是原位置加n - CAS操作</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 使用 Unsafe 的 volatile 式标记该桶已迁移，即在桶中放置 ForwardingNode 类型的元素，标记该桶迁移完成</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance为true，返回上面进行--i操作</span></span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法实现了<strong>扩容和迁移元素</strong>的逻辑。下面我们先对关键步骤进行说明，然后再对并发处理进行分析。</p><ol><li>如果还没开始扩容，那么就先进行扩容，扩容后的数组大小是旧数组的 2 倍；</li><li>创建完新的数组后，就可以开始将旧数组中的元素迁移到新数组中了，迁移的方式是从后往前逐个桶迁移：<ul><li>为当前执行的线程分配迁移的桶，该线程会根据具体情况处理该桶；</li><li>判断是否已经迁移完毕，迁移完毕就用新数组替换旧数组，并根据新数组的容量以 0.75 计算扩容阈值并赋予 sizeCtl，扩容过程结束；</li><li>判断当前桶是否为空，为空就直接 CAS 填充 ForwardingNode 对象，表示该桶迁移完了；</li><li>判断当前桶是否为 ForwardingNode 对象（也就是元素的 hash 值为 MOVED） ，如果是则表示该桶已经迁移完了，跳过即可；</li><li>以上条件都不成立，那么就锁定该桶，然后将该桶元素迁移到新数组中，迁移方式基本同 HashMap 的迁移方式，主要区别是在迁移完成后，使用 ForwardingNode 对象打标记，表示该桶已经完成了迁移；</li></ul></li></ol><p>在扩容时，ConcurrentHashMap 支持<strong>并发扩容</strong>，在扩容过程中同时支持查找元素。<strong>这种无阻塞算法，将并发度大大的提高了</strong>。下面我们就对并发处理进行分析。</p><ol><li>临时的新数组 nextTable 使用 volatile 修饰，保证可见性；</li><li>使用 ForwardingNode 类型对象封装新数组，这个对象非常重要，<strong>不仅作为旧数组某个桶迁移完成的标记，还支持了扩容时的元素查找</strong>；</li><li>使用 CAS 为不同的线程分配待迁移的不同桶，实现并发扩容；</li><li>使用 <code>synchronized</code> 分段锁保证迁移桶元素时的安全；</li></ol><h3 id="helpTransfer-辅助数据迁移"><a href="#helpTransfer-辅助数据迁移" class="headerlink" title="helpTransfer() - 辅助数据迁移"></a>helpTransfer() - 辅助数据迁移</h3><p>假设在进行 put 或 remove 操作时正处于迁移的过程，映射到的桶已经被迁移了（Node.hash==MOVED)，此时该怎么办呢？<strong>ConcurrentHashMap 采用的是辅助扩容的方式，完成扩容后再执行对应的写操作</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 辅助扩容（迁移元素）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *  f 所在桶元素迁移完了才去协助迁移其它桶元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tab 旧数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f   一般为 ForwardingNode 类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K, V&gt;[] helpTransfer(Node&lt;K, V&gt;[] tab, Node&lt;K, V&gt; f) &#123;</span><br><span class="line">    Node&lt;K, V&gt;[] nextTab;</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果桶数组不为空 &amp;&amp; 当前桶第一个元素 f 是 ForwardingNode 类型 &amp;&amp; 封装的 nextTab（新数组） 不为空，说明当前桶已经迁移完毕了，才去帮忙迁移其它桶的元素。</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab = ((ForwardingNode&lt;K, V&gt;) f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取扩容旧数组的标记位，类似 epoch 的概念</span></span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sizeCtl &lt; 0 &amp;&amp; nextTable 不为空，说明集合正处于扩容过程</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 协助迁移元素前，再次判断扩容是否结束，如果结束直接返回，无需协助迁移</span></span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 扩容线程数加 1 ，标示多一个线程参与协助迁移</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 当前线程帮忙迁移元素</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 帮忙迁移完元素后，返回新数组</span></span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非扩容过程，返回旧数组</span></span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>辅助扩容是为了支持并发扩容的，当检测到定位的桶是 <strong><code>MOVED</code></strong> 状态时，那么当前线程会先辅助一起完成扩容，然后再继续执行写操作，这个逻辑一般需要自旋支持，因此我们可以看到前面介绍的 put 方法有一个自旋逻辑，在后面要介绍的 remove 方法也是这么做的。下面我们对辅助扩容方法中关键点进行分析：</p><ol><li>判断是否在进行扩容的条件是 <strong>sizeCtl &lt; 0 &amp;&amp; nextTable != null</strong>，这两个条件缺一不可。<code>sizeCtl &lt; 0</code> 的情况有两种，一种是在初始化数组时，通过 CAS 设置为 -1 才能拿到初始化资格；另一种是在扩容的时候，通过 CAS 设置为一个负数，高16位和低16位分别表示扩容旧数组的 epoch，参与扩容的线程数，这个前文已经详细说明。<code>nextTable</code> 只有在扩容期间才不会为 null，扩容完成后会重置为 null；</li><li>在迁移元素前，需要再次判断扩容是否结束，结束的情况下旧直接返回即可；没有结束的话，就更新 <code>sizeCtl</code> 的值，也就是增加参与扩容线程数；</li><li>如果参与了协助扩容，就返回扩容完成后的新数组；如果没有参与扩容，那么还是返回旧数组；</li></ol><h3 id="remove-删除元素"><a href="#remove-删除元素" class="headerlink" title="remove() - 删除元素"></a>remove() - 删除元素</h3><p>删除元素和添加元素逻辑类似，都是先定位对应的桶，如果该桶被标记迁移了，那么就先辅助迁移元素，完成迁移后继续执行写操作；如果桶没有被标志迁移，那么就采用 <code>synchronized</code> 分段锁锁住整个桶，然后执行对应的写操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 调用替换节点方法</span></span><br><span class="line">     <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 计算 hash</span></span><br><span class="line">     <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 自旋</span></span><br><span class="line">     <span class="keyword">for</span> (Node&lt;K, V&gt;[] tab = table; ; ) &#123;</span><br><span class="line">         Node&lt;K, V&gt; f;</span><br><span class="line">         <span class="keyword">int</span> n, i, fh;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果数组为空，或目标 key 所在的桶不存在，跳出循环返回 null</span></span><br><span class="line">         <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">                 (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 如果桶中第一个元素的 hash 值为 MOVED ，说明这个桶已经迁移完了，但是其它的桶不知道，因此当前线程协助迁移，协助扩容完成后再进行删除操作</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">             tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 查找元素并执行删除</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             V oldVal = <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">// 标记是否处理过</span></span><br><span class="line">             <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 加锁（锁对象使用桶的第一个元素，达到分段的效果）</span></span><br><span class="line">             <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                 <span class="comment">// 再次验证当前桶的第一个元素是否被修改</span></span><br><span class="line">                 <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line"></span><br><span class="line">                     <span class="comment">// 桶的第一个元素的 hash &gt;= 0 表示是链表节点</span></span><br><span class="line">                     <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                         validated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                         <span class="comment">// 遍历链表寻找目标节点</span></span><br><span class="line">                         <span class="keyword">for</span> (Node&lt;K, V&gt; e = f, pred = <span class="keyword">null</span>; ; ) &#123;</span><br><span class="line">                             K ek;</span><br><span class="line">                             <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                     ((ek = e.key) == key ||</span><br><span class="line">                                             (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                 <span class="comment">// 找到目标节点</span></span><br><span class="line">                                 V ev = e.val;</span><br><span class="line"></span><br><span class="line">                                 <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                         (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                     oldVal = ev;</span><br><span class="line"></span><br><span class="line">                                     <span class="comment">// 如果 value 不为空则替换旧值</span></span><br><span class="line">                                     <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                         e.val = value;</span><br><span class="line">                                     <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                         <span class="comment">// 如果前置节点不为空，删除当前节点</span></span><br><span class="line">                                         pred.next = e.next;</span><br><span class="line">                                     <span class="keyword">else</span></span><br><span class="line">                                         <span class="comment">// 如果前置节点为空，说明是桶中第一个元素，删除即可</span></span><br><span class="line">                                         setTabAt(tab, i, e.next);</span><br><span class="line">                                 &#125;</span><br><span class="line">                                 <span class="keyword">break</span>;</span><br><span class="line">                             &#125;</span><br><span class="line">                             pred = e;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                             <span class="comment">// 遍历到链表尾部还没找到元素，跳出循环</span></span><br><span class="line">                             <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                 <span class="keyword">break</span>;</span><br><span class="line">                         &#125;</span><br><span class="line"></span><br><span class="line">                         <span class="comment">// 桶的第一个元素类型为树，则遍历树找目标节点</span></span><br><span class="line">                     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                         validated = <span class="keyword">true</span>;</span><br><span class="line">                         TreeBin&lt;K, V&gt; t = (TreeBin&lt;K, V&gt;) f;</span><br><span class="line">                         TreeNode&lt;K, V&gt; r, p;</span><br><span class="line">                         <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                 (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                             <span class="comment">// 找到目标节点</span></span><br><span class="line">                             V pv = p.val;</span><br><span class="line">                             <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                     (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                 oldVal = pv;</span><br><span class="line">                                 <span class="comment">// 如果value不为空则替换旧值</span></span><br><span class="line">                                 <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                     p.val = value;</span><br><span class="line">                                     <span class="comment">// 如果 value 为空，从树中删除</span></span><br><span class="line">                                 <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line"></span><br><span class="line">                                     <span class="comment">// 判断是否退化成链表</span></span><br><span class="line">                                     <span class="comment">//  t.removeTreeNode(p)这个方法返回true表示删除节点后树的元素个数较少，此时退化成链表</span></span><br><span class="line">                                     setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 如果处理过，就不需要循环了，可以退出了</span></span><br><span class="line">             <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                 <span class="comment">// 如果找到了元素，返回其旧值</span></span><br><span class="line">                 <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 如果要替换的值为空，元素个数减 1，不考虑调整数组大小</span></span><br><span class="line">                     <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                         addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                     <span class="keyword">return</span> oldVal;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 没找到元素返回空</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>删除方法和新增方法类似，就不再说明。需要注意的一点是，如果定位到的桶是以红黑树存储的，那么删除元素后需要判断是否要退化为链表。</p><h3 id="get-获取元素"><a href="#get-获取元素" class="headerlink" title="get() - 获取元素"></a>get() - 获取元素</h3><p>一般来说，对于 get 操作是没有线程安全问题的，只有可见性的问题，只需要确保获取的元素是线程间可见的即可，针对这个问题 ConcurrentHashMap 使用 <code>volatile</code> 关键字修饰节点的值 val 和后继指针来保证可见性。</p><p>除了可见性问题，ConcurrentHashMap 还需要解决一个问题，这个问题是由其支持<strong>并发扩容</strong>带来的。也就是说，<strong>在扩容期间访问元素的时候，集合中的元素可能分布在新旧两个数组中</strong>，针对这种情况的访问策略是，先访问旧数组，如果旧数组相应位置的桶已经被标记迁移完成了，那么就需要继续访问新数组以查询目标元素，否则只需访问旧数组即可（注意，即使定位到的旧数组桶处于迁移过程也没关系，在完成迁移之前该桶中的元素之间的关联是不变的）。而这个策略实现的核心是 <strong><code>ForwardingNode</code></strong> 类型对象，它作为旧数组某个桶迁移完成的标记的同时，内部封装了新数组，并且重写了查找元素的方法，而这个重写的查找方法就是从新数组中查找元素的。</p><p>下面我们对源码进行分析，看看 ConcurrentHashMap 具体是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; e, p;</span><br><span class="line">    <span class="keyword">int</span> n, eh;</span><br><span class="line">    K ek;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 hash</span></span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果元素所在的桶存在且里面有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">             <span class="comment">// 使用 Unsafe 的 volatile 式获取节点，保证最新值</span></span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果第一个元素就是要找的元素，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// hash &lt; 0 说明第一个元素是树类型，或者数组处于扩容过程（元素类型是 ForwardingNode）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 使用find寻找元素，find的寻找方式依据Node的不同子类有不同的实现方式：</span></span><br><span class="line">            <span class="comment">// 处于扩容过程：java.util.concurrent.ConcurrentHashMap.ForwardingNode.find</span></span><br><span class="line">            <span class="comment">// 非扩容过程，也就是树类型：java.util.concurrent.ConcurrentHashMap.TreeNode.find</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行到这里，说明元素所在的桶中是链表，遍历链表即可</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在访问元素时会计算 key 的 hash 值;</li><li>如果定位到的桶元素就是要查找的元素，那么直接返回对应的 value；</li><li>如果定位到的桶元素不是要查找的元素，那么就需要做出判断，这个判断非常重要，对应三种情况：<ul><li>如果桶元素的 <code>hash &lt; 0 &amp;&amp; hash == -1</code>，那么说明桶元素的类型是 <strong>ForwardingNode</strong>，此时集合处于扩容过程，查找元素调用 ForwardingNode 实现的查找方法；</li><li>如果桶元素的 <code>hash &lt; 0 &amp;&amp; hash == -2</code>，那么说明桶元素的类型是 <strong>TreeNode</strong>，是一颗红黑树，查找元素调用 TreeNode 实现的查找方法；</li><li>不是前面两种情况，那么桶中就是链表，遍历链表查找即可；</li></ul></li><li>没有定位到对应的桶，直接返回 null；</li></ol><p>关于链表和红黑树查找没有可说的，下面我们对处于扩容状态的查找进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容期间作为桶迁移完成的标志元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容期间的新数组。保存新Node数组的引用是为了支持在迁移的过程不阻塞地查找值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K, V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tab 新数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ForwardingNode(Node&lt;K, V&gt;[] tab) &#123;</span><br><span class="line">        <span class="comment">// hash 固定为 MOVED </span></span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩容期间查找元素，那么从扩容期间的新数组查找</span></span><br><span class="line"><span class="comment">     *    </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Node&lt;K, V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></span><br><span class="line">        outer:</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K, V&gt;[] tab = nextTable; ; ) &#123;</span><br><span class="line">            Node&lt;K, V&gt; e;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 新的数组为空，或者对应的桶为空，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">                    (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定位桶查找目标元素</span></span><br><span class="line">            <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> eh;</span><br><span class="line">                K ek;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否是要查找的元素</span></span><br><span class="line">                <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                        ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 非链表的情况</span></span><br><span class="line">                <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果元素是 ForwardingNode ，说明该桶的元素已经迁移到新的数组中，那么需要从新的数组中查找</span></span><br><span class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</span><br><span class="line">                        tab = ((ForwardingNode&lt;K, V&gt;) e).nextTable;</span><br><span class="line">                        <span class="keyword">continue</span> outer;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果 e 元素对应的桶还没有迁移，则根据红黑树查找</span></span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> e.find(h, k);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，<strong><code>ForwardingNode</code></strong> 这个特殊节点的作用已经介绍完毕了，下面再进行总结：</p><ul><li>标识旧数组某个桶迁移完成，以支持并发扩容；</li><li>封装新数组，以支持在迁移的过程中非阻塞查找值；</li></ul><h4 id="浅谈Redis-rehash"><a href="#浅谈Redis-rehash" class="headerlink" title="浅谈Redis rehash"></a>浅谈Redis rehash</h4><p>如果了解 Redis 的扩容机制的话，你会发现两者有异曲同工之处。</p><ul><li><strong>扩容操作：</strong>Redis 实现的是渐进式 rehash，主线程以一定的步长迁移桶元素；ConcurrentHashMap 实现的是辅助扩容，多个线程可以并发迁移桶元素；</li><li><strong>扩容期间查找元素：</strong>Redis 在扩容的时候使用到了两个哈希表，会先从 0 号哈希表查找，没有再从 1 号哈希表查找；ConcurrentHashMap 在扩容过程也同时使用了两个桶数组，查找的时候也会先到旧数组中定位桶元素，如果桶元素是迁移标识元素 ForwardingNode，那么会再从新数组中查找；</li></ul><h2 id="JDK1-7-与-JDK1-8的区别"><a href="#JDK1-7-与-JDK1-8的区别" class="headerlink" title="JDK1.7 与 JDK1.8的区别"></a>JDK1.7 与 JDK1.8的区别</h2><p>JDK 1.7 的核心实现也采用了分段锁的技术，每个段 Segment 中对应一个小 HashMap，Segment 通过继承 ReentrantLock 来保证其内部的 HashMap 安全。</p><p>JDK 1.8 废弃了 Segment 分段锁的实现，采用<strong>多种 CAS + Node 级别的 synchronized 锁</strong>来保证并发安全，整体减小了锁竞争，减小程序同步的部分。</p><h2 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h2><p>这里我们讨论的一致性问题是针对 put 和 get 方法来说的。</p><p>JDK 1.7 的实现中 ConcurrentHashMap 表现为弱一致性，因为写操作只是简单赋值操作，读操作也是简单读操作。具体实现如下：</p><p><strong>写操作：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">  lock();</span><br><span class="line">  ...</span><br><span class="line">    tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(...);</span><br><span class="line">  ...</span><br><span class="line">    unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读操作：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count != <span class="number">0</span>) &#123; <span class="comment">// read-volatile</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = getFirst(hash);</span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;</span><br><span class="line">                V v = e.value;</span><br><span class="line">                <span class="keyword">if</span> (v != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> v;</span><br><span class="line">                <span class="keyword">return</span> readValueUnderLock(e); <span class="comment">// recheck</span></span><br><span class="line">            &#125;</span><br><span class="line">            e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行写操作时，先加锁，然后直接给数组中的桶赋值，此时虽然数组 tab 使用 vlolatile 修饰保证可见性，但是不保证元素的可见性，因此无法保证能及时读取到写入的元素。由此可以看出，在 JDK 1.8 之前的读写操作是弱一致性的。</p><p>要保证读写强一致性，一般可以加锁，或者使用 volatile 修饰变量。如果采用加锁的方式，会导致 ConcurrentHashMap 的性能问题，这也违背了设计的初衷，因此可以考虑使用 volatile 来保证可见性。但是我们需要知道的是，volatile 可以修饰变量却不能修饰数组中的元素，也就是修饰数组只能保证数组的地址可见性。</p><p>JDK 1.8 正是从上述点进行突破，使用了 Unsafe 类来实现数组元素的可见性。</p><p><strong>写操作：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">      <span class="comment">// 使用 Unsafe 类 volatile 式的操作查看值</span></span><br><span class="line">      <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果数组该位置没有节点，则使用一次 CAS 操作将这个新值放入其中即可。  </span></span><br><span class="line">        <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                     <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读操作：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 如果元素所在的桶存在且里面有元素 </span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      <span class="comment">// 使用 Unsafe 的 volatile 式获取节点，保证最新值</span></span><br><span class="line">      (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>写操作使用 CAS 更新内存中数组中的元素；</li><li>读操作使用 Unsafe 的 volatile 式获取内存中数组中的元素；</li></ul><p>由于读写都是直接对内存操作，所以通过上述方式可以保证 put 和 get 的强一致性。ConcurrentHashMap 是通过 <code>compareAndSwapObject</code> 来取代对数组元素直接赋值的操作，通过 <code>getObjectVolatile</code> 来弥补无法对数组元素进行 volatile 读的缺陷。</p><p>需要注意，JDK 1.8 下的 ConcurrentHashMap 并非所有操作都是强一致性的，其中计算集合元素个数的 size() 方法就是弱一致性的，具体原因通过前面的源码就能看出来。</p><h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h1><p>ConcurrentHashMap 运用各类 CAS 操作保证并发安全，并在关键逻辑位置使用 <code>synchronized</code> 分段锁以小范围进行锁定保证安全。</p><p>在扩容时，ConcurrentHashMap 支持多线程并发扩容，在扩容过程的同时支持 get 获取元素，这种无阻塞算法，大大提高了并发度。其中，整个扩容过程都是通过 CAS 控制 <strong>sizeCtl</strong> 这个属性来进行的，某个桶完成迁移会使用 ForwardingNode 节点填充以标识该桶迁移完毕。整个迁移过程类似 Redis 中的 rehash 过程。</p><p>ConcurrentHashMap 元素个数的存储采用的是<strong>分段存储</strong>思想，类似 LongAdder 的实现，提高并发度。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>ConcurrentHashMap 设计非常精妙，读完源码后收获很大，很多设计让人眼前一亮，也开阔了技术视野。</p><ul><li>自旋 + CAS，采用乐观锁的思想，避免线程阻塞，减少线程上下文切换的时间；</li><li>分段锁的思想，使用 <code>synchronized</code> 锁住单个桶对象以减小锁范围；</li><li>分段存储集合元素个数，减小并发更新一个字段的竞争；</li><li>支持并发扩容，尽可能无阻塞实现读写；</li></ul><p><strong>参考：</strong></p><p><a href="https://mp.weixin.qq.com/s/1yWSfdz0j-PprGkDgOomhQ" target="_blank" rel="noopener">漫画：什么是ConcurrentHashMap</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;HashMap 不是线程安全的，在高并发环境下可能会出现系列问题，如链表成环（JDK1.7)、数据覆盖（JDK1.8)。想要避免 HashM
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="ConcurrentHashMap" scheme="https://gentryhuang.com/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>并发 - ScheduledThreadPoolExecutor</title>
    <link href="https://gentryhuang.com/posts/9012be3f/"/>
    <id>https://gentryhuang.com/posts/9012be3f/</id>
    <published>2022-05-02T01:55:06.000Z</published>
    <updated>2022-05-17T05:27:34.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ScheduledThreadPoolExecutor 是基于 ThreadPoolExecutor <strong>扩展的</strong>执行定时任务线程池，<strong>线程池相关的核心逻辑都是在后者中实现的</strong>，前者主要用于<strong>实现定时任务或周期性任务逻辑</strong>，后续的功能交给父类 ThreadPoolExecutor 实现。</p><p>为了保证任务是在未来某个时间点执行，ScheduledThreadPoolExecutor 使用的阻塞队列是具有延时特性的阻塞队列，但它并没有直接使用 DelayQueue ，而是自己实现了一个延时阻塞队列，不过跟 DelayQueue 实现原理是一样的。</p><p>ScheduledThreadPoolExecutor 相关的 UML 类图如下所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/scheduled-thread-pool-1.png" alt></p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 设置 线程池关闭后（shutdown)继续执行存在的周期性任务</span></span><br><span class="line">        scheduledThreadPoolExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// scheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy(true);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池关闭后（shutdown)是否继续执行存在的周期性任务（包括 fixedRate/fixedDelay）</span></span><br><span class="line">        System.out.println(<span class="string">"existingPeriodicTasksAfterShutdownPolicy: "</span> + scheduledThreadPoolExecutor.getContinueExistingPeriodicTasksAfterShutdownPolicy());</span><br><span class="line">        <span class="comment">// 线程关闭后（shutdown）是否继续执行存在的延迟任务</span></span><br><span class="line">        System.out.println(<span class="string">"existingDelayedTasksAfterShutdownPolicy: "</span> + scheduledThreadPoolExecutor.getExecuteExistingDelayedTasksAfterShutdownPolicy());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 固定频率 - 每 2s 执行一次</span></span><br><span class="line">        ScheduledFuture&lt;?&gt; scheduledFuture = scheduledThreadPoolExecutor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>)) + <span class="string">" 固定频率执行...."</span>);</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">4</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 固定延迟时间 - 每 3s 执行一次</span></span><br><span class="line">        ScheduledFuture&lt;?&gt; scheduledFuture1 = scheduledThreadPoolExecutor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>)) + <span class="string">" 固定延迟时间执行...."</span>);</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 延迟调度 - 执行无返回值任务</span></span><br><span class="line">        ScheduledFuture&lt;?&gt; scheduledFuture2 = scheduledThreadPoolExecutor.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"schedule...runnable..."</span>);</span><br><span class="line">        &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 延迟调度 - 执行有返回值任务</span></span><br><span class="line">        ScheduledFuture&lt;Object&gt; scheduledFuture3 = scheduledThreadPoolExecutor.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"schedule...callable..."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"future"</span>;</span><br><span class="line">        &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object o = scheduledFuture3.get();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 关闭线程池</span></span><br><span class="line">        scheduledThreadPoolExecutor.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"10s 后开始停止线程池，届时所有还未执行的任务会被终止！"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6 停止线程池</span></span><br><span class="line">        List&lt;Runnable&gt; runnables = scheduledThreadPoolExecutor.shutdownNow();</span><br><span class="line">        System.out.println(<span class="string">"还未执行的任务数："</span> + runnables.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ScheduledThreadPoolExecutor 执行的定时任务类型可分为四种</strong>，上述示例中已全部列出：</p><ul><li>定时任务，有返回值；</li><li>定时任务，无返回值；</li><li>周期性任务，按固定频率重复执行任务，无返回值；</li><li>周期性任务，按固定延时重复执行任务，无返回值；</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>ScheduledThreadPoolExecutor 相关的源码结构如下图所示：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/scheduled-thread-pool-2.png" alt></p><p>ScheduledThreadPoolExecutor 主要通过以下方式对 <a href="https://gentryhuang.com/posts/d7cef21d/">线程池</a> 进行扩展：</p><ul><li>自定义任务类型 <strong><code>ScheduledFutureTask</code></strong>，统一任务为延迟任务；</li><li>自定义延时队列 <strong><code>DelayedWorkQueue</code></strong>，同 DelayQueue 是无界的延时阻塞队列；</li><li>支持可配置的 <strong><code>run-after-shutdown</code></strong> 参数，在线程池关闭后（shutdown)对任务执行进行干预；</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池关闭后（shutdown)是否继续执行存在的周期性任务（包括 fixedRate/fixedDelay），默认为 flase</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> continueExistingPeriodicTasksAfterShutdown;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池关闭后（shutdown）是否继续执行存在的延迟任务，默认为 true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executeExistingDelayedTasksAfterShutdown = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消任务时，是否立即从队列中删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> removeOnCancel = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于生成任务添加到 ScheduledThreadPoolExecutor 中的序号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong sequencer = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 最大线程数为 Integer.MAX_VALUE；空闲线程存活时间为 0 ；阻塞队列为 ScheduledThreadPoolExecutor 自定义的延时队列 DelayedWorkQueue ；</span></span><br><span class="line">     <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">             <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">             <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">             <span class="keyword">new</span> DelayedWorkQueue(), handler);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">             <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor 的构造函数只需注意两点即可：</p><ul><li>最终调用父类 ThreadPoolExecutor 的构造方法创建线程池；</li><li>使用的阻塞队列是内置的 DelayedWorkQueue ，并且最大线程数固定为 <code>Integer.MAX_VALUE</code>，且空闲线程最大存活时间为 0；</li></ul><p><strong>注意：</strong>从 ScheduledThreadPoolExecutor 的构造方法中，我们可以知道执行定时任务的线程池底层使用的也是 ThreadPoolExecutor 的主流程，只是通过自定义阻塞队列 DelayedWorkQueue 来干预线程池的主流程。</p><h3 id="提交延时任务"><a href="#提交延时任务" class="headerlink" title="提交延时任务"></a>提交延时任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行延迟任务</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 没有返回值的任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay 延时时间粒度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 延时时间粒度的单位</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                   <span class="keyword">long</span> delay,</span><br><span class="line">                                   TimeUnit unit) &#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行钩子方法</span></span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,</span><br><span class="line">            <span class="comment">// 将普通的任务装饰成 ScheduledFutureTask</span></span><br><span class="line">            <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>,</span><br><span class="line">                    triggerTime(delay, unit)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延时执行</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回延时计算任务</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行延迟任务</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callable 有返回值的任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay 延时时间粒度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 延时时间粒度的单位</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">long</span> delay,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行钩子方法</span></span><br><span class="line">    RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,</span><br><span class="line">            <span class="comment">// 将普通的任务装饰成 ScheduledFutureTask</span></span><br><span class="line">            <span class="keyword">new</span> ScheduledFutureTask&lt;V&gt;(callable,</span><br><span class="line">                    triggerTime(delay, unit)));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 延时执行</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回延时计算任务</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提交周期性延时任务"><a href="#提交周期性延时任务" class="headerlink" title="提交周期性延时任务"></a>提交周期性延时任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交一个按固定频率执行的任务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command      没有返回值的任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialDelay 初始延时时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> period       频率</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit         延时时间粒度的单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException   &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                              <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                              <span class="keyword">long</span> period,</span><br><span class="line">                                              TimeUnit unit) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数判断</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 必须是固定频率（该方法就是按固定频率执行任务）</span></span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将普通的任务装饰成 ScheduledFutureTask</span></span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">            <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(</span><br><span class="line">                    command,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    triggerTime(initialDelay, unit),</span><br><span class="line">                    unit.toNanos(period));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法，可在任务执行之前进行干预</span></span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存任务 t，用于周期性执行</span></span><br><span class="line">    sft.outerTask = t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延时执行</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回延时计算任务</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交一个固定延迟的任务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command      没有返回值的任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialDelay 初始延时时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delay        固定延时时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit         延时时间粒度的单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException   &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                 <span class="keyword">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit) &#123;</span><br><span class="line">    <span class="comment">// 参数判断</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定延迟时间校验</span></span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将普通的任务装饰成 ScheduledFutureTask</span></span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">            <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    triggerTime(initialDelay, unit),</span><br><span class="line">                    unit.toNanos(-delay)); <span class="comment">// 注意这里是个负数，用于判断周期性任务属于哪一种</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法，可在任务执行之前进行干预</span></span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存任务 t，用于周期性执行</span></span><br><span class="line">    sft.outerTask = t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延时执行</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回延时计算任务</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提交零延时任务"><a href="#提交零延时任务" class="headerlink" title="提交零延时任务"></a>提交零延时任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    schedule(command, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Override AbstractExecutorService methods</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">return</span> schedule(task, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> schedule(Executors.callable(task, result), <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> schedule(task, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor 重写了 execute 和 submit 方法，<strong>通过这两个方法提交的任务会被当成 0 延时的任务进行提交</strong>。</p><h3 id="延时调度"><a href="#延时调度" class="headerlink" title="延时调度"></a>延时调度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param task the task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果线程池关闭了，执行拒绝策略</span></span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池未关闭</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 先把任务放到队列中（这个队列本质上是一个优先级队列）</span></span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次检查线程池状态，必要时取消并删除任务</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp;</span><br><span class="line">                !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;</span><br><span class="line">                remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 确保有线程执行任务</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延时调度方法 delayedExecute 是 ScheduledThreadPoolExecutor 提交任务最底层的方法，在此之前的流程都是上层延时计算任务的处理。该方法就相当于线程池中的 <code>execute</code> 方法，只是<strong>两者的流程不一样，根本原因是 ScheduledThreadPoolExecutor 执行的是延时任务</strong>。</p><p>下面对该流程进行说明：</p><ol><li>判断线程池是否关闭，关闭则执行拒绝策略以拒绝任务的调度；</li><li>将延时计算任务放入队列中。注意，ThreadPollExecutor 是 <code>&gt;=</code> 核心线程数时才添加任务到阻塞队列中。因为这里是定时线程池，任务时间到了才会执行，因此是要从任务队列中获取的。</li><li>再次判断线程池状态，如果是 shutdown 状态并且当前任务的特性是遇到线程池关闭则无需执行，那么就取消该任务，必要情况还会从队列中删除。</li><li>当前任务可以被执行，那么就需要确保有线程执行任务；</li></ol><h3 id="延时计算任务是否可执行"><a href="#延时计算任务是否可执行" class="headerlink" title="延时计算任务是否可执行"></a>延时计算任务是否可执行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRunInCurrentRunState</span><span class="params">(<span class="keyword">boolean</span> periodic)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">        final boolean isRunningOrShutdown(boolean shutdownOK) &#123;</span></span><br><span class="line"><span class="comment">           int rs = runStateOf(ctl.get());</span></span><br><span class="line"><span class="comment">           return rs == RUNNING || (rs == SHUTDOWN &amp;&amp; shutdownOK);</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="keyword">return</span> isRunningOrShutdown(periodic ?</span><br><span class="line">             <span class="comment">// 线程池关闭后是否继续执行周期性任务</span></span><br><span class="line">             continueExistingPeriodicTasksAfterShutdown :</span><br><span class="line">             <span class="comment">// 线程池关闭后是否继续执行延迟任务</span></span><br><span class="line">             executeExistingDelayedTasksAfterShutdown);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>判断延时计算任务是否可被执行的情况有两种：</p><ul><li>如果线程池处于运行状态，那么任务可被执行；</li><li>如果线程池处于关闭状态（shutdown)，那么只有该延时计算任务设置了线程池关闭后仍可被执行的情况下才能被执行；</li></ul><p>对于第二种情况就是 ScheduledThreadPoolExecutor 的 <code>run-after-shutdown</code> 的参数控制情况，也就是定时线程池提供了两个可配置参数用来控制即使线程池 shutdown 的情况下，是否继续执行延时计算任务。由于延时计算任务有两种，因此提供了两个可配置参数：</p><ul><li><code>continueExistingPeriodicTasksAfterShutdown:</code>线程池关闭后是否继续执行周期性任务(包括固定频率和固定延时);</li><li><code>executeExistingDelayedTasksAfterShutdown:</code>  线程池关闭后是否继续执行延迟任务;</li></ul><h3 id="确保有线程执行任务"><a href="#确保有线程执行任务" class="headerlink" title="确保有线程执行任务"></a>确保有线程执行任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ensurePrestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程池线程数</span></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(ctl.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程池中线程数未达到核心线程数，则创建核心线程</span></span><br><span class="line">        <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里处理核心线程数为 0 的情况，保证线程池至少有一个线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于 ScheduledThreadPoolExecutor 是定时线程池，它是先将延时任务放到队列中，然后再创建线程去执行，这个和 ThreadPoolExecutor 的调度流程不同。通过上述方法可以知道，<strong>如果设置了核心线程数(&gt;0)，那么每次都会创建新的线程直到达到核心线程数；如果没有设置核心线程数(=0)，那么线程池中最多只会有一个线程，每次判断线程池空了创建一个就行了。</strong></p><p>这也指导我们在使用 ScheduledThreadPoolExecutor 时最好设置合适的核心线程数，虽然构造方法中最大线程数是 <code>Integer.MAX_VALUE</code>，但事实上最大线程没啥特别的用处，只有当核心线程数为 0 时，才会作为是否能创建线程的条件，而且线程池同时最多有一个非核心线程。如果设置了核心线程数，那么就不会创建非核心线程了。</p><h3 id="重新排队周期任务"><a href="#重新排队周期任务" class="headerlink" title="重新排队周期任务"></a>重新排队周期任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 重新排队周期任务，除非当前运行状态排除它。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 除了丢弃任务而不是拒绝，其他的与 delayedExecute 方法基本相同</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> task the task</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 判断是否可以该运行任务</span></span><br><span class="line">     <span class="keyword">if</span> (canRunInCurrentRunState(<span class="keyword">true</span>)) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 将任务再次添加到任务队列中</span></span><br><span class="line">         <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 再次检查是否可以运行任务，如果不能运行则移除并取消任务</span></span><br><span class="line">         <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="keyword">true</span>) &amp;&amp; remove(task))</span><br><span class="line">             task.cancel(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="comment">// 确保有线程执行任务</span></span><br><span class="line">             ensurePrestart();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述方法用于 ScheduledThreadPoolExecutor 调度的是一个周期性任务，当任务执行完毕后，任务会重新被加入队列中等待调度。</p><h3 id="取消并清除不适应shutdown的任务"><a href="#取消并清除不适应shutdown的任务" class="headerlink" title="取消并清除不适应shutdown的任务"></a>取消并清除不适应shutdown的任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     BlockingQueue&lt;Runnable&gt; q = <span class="keyword">super</span>.getQueue();</span><br><span class="line">     <span class="comment">// 延迟任务关闭策略</span></span><br><span class="line">     <span class="keyword">boolean</span> keepDelayed =</span><br><span class="line">             getExecuteExistingDelayedTasksAfterShutdownPolicy();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 周期任务关闭策略</span></span><br><span class="line">     <span class="keyword">boolean</span> keepPeriodic =</span><br><span class="line">             getContinueExistingPeriodicTasksAfterShutdownPolicy();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 不支持线程池关闭执行，则取消并移除相关任务</span></span><br><span class="line">     <span class="keyword">if</span> (!keepDelayed &amp;&amp; !keepPeriodic) &#123;</span><br><span class="line">         <span class="keyword">for</span> (Object e : q.toArray())</span><br><span class="line">             <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture&lt;?&gt;)</span><br><span class="line">                 ((RunnableScheduledFuture&lt;?&gt;) e).cancel(<span class="keyword">false</span>);</span><br><span class="line">         q.clear();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Traverse snapshot to avoid iterator exceptions</span></span><br><span class="line">         <span class="keyword">for</span> (Object e : q.toArray()) &#123;</span><br><span class="line">             <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture) &#123;</span><br><span class="line">                 RunnableScheduledFuture&lt;?&gt; t =</span><br><span class="line">                         (RunnableScheduledFuture&lt;?&gt;) e;</span><br><span class="line">                 <span class="keyword">if</span> ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) || t.isCancelled()) &#123; <span class="comment">// also remove if already cancelled</span></span><br><span class="line">                     <span class="keyword">if</span> (q.remove(t))</span><br><span class="line">                         t.cancel(<span class="keyword">false</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 尝试终止线程池</span></span><br><span class="line">     tryTerminate();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在线程池 shutdown 时会取消并清除不适应线程池关闭的所有任务。也就是说，如果 continueExistingPeriodicTasksAfterShutdown 或者 continueExistingPeriodicTasksAfterShutdown 为 true，那么表示线程池关闭也会执行任务；为 false ，那么在关闭的时候就会移除并取消任务。</p><h3 id="内置任务-ScheduledFutureTask"><a href="#内置任务-ScheduledFutureTask" class="headerlink" title="内置任务 - ScheduledFutureTask"></a>内置任务 - ScheduledFutureTask</h3><p>ScheduledThreadPoolExecutor 自定义了 ScheduledFutureTask 类型的任务，用于描述延时计算任务。该类的 UML 类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/threadpool/scheduled-thread-pool-3.png" alt></p><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+--- ScheduledFutureTask</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前任务被添加到 ScheduledThreadPoolExecutor 中的序号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以 nanoTime 为单位，任务被执行的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重复任务的周期（以纳秒为单位）:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 正值表示固定频率执行。</span></span><br><span class="line"><span class="comment"> * 2. 负值表示固定延迟执行。</span></span><br><span class="line"><span class="comment"> * 3. 值 0 表示非重复任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由 reExecutePeriodic 重新入队的实际任务，用于周期性任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RunnableScheduledFuture&lt;V&gt; outerTask = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 索引到延迟队列，以支持更快的取消。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> heapIndex;</span><br></pre></td></tr></table></figure><ul><li><strong>sequenceNumber:</strong> 优先级排序使用，当执行时间 time 相同的情况下，越早加入到 ScheduledThreadPoolExecutor 中的任务优先级越高；</li><li><strong>time:</strong> 延时任务执行的时间；</li><li><strong>period:</strong> 任务的周期性特征，具体见注释；</li></ul><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">    <span class="comment">// FutureTask 的构造方法</span></span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">    <span class="comment">// FutureTask 的构造方法</span></span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = period;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">    <span class="comment">// FutureTask 的构造方法</span></span><br><span class="line">    <span class="keyword">super</span>(callable);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法可以看出，ScheduledFutureTask 主要是基于 FutureTask 异步计算任务进行扩展的；</p><h4 id="元素优先级"><a href="#元素优先级" class="headerlink" title="元素优先级"></a>元素优先级</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+--- ScheduledFutureTask </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元素优先级比较</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. time 小的排在前面（时间早的任务将被先执行）</span></span><br><span class="line"><span class="comment"> * 2. 如果两个任务的 time 相同，那么比较 sequenceNumber ，sequenceNumber 小的排在前面（如果两个任务的执行时间相同，那么先提交的任务将被先执行）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> other</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 元素相同</span></span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ScheduledFutureTask 类型的，则先比较 time 大小，无法区分大小再比较 sequenceNumber</span></span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;) other;</span><br><span class="line">        <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较剩余延时时间</span></span><br><span class="line">    <span class="keyword">long</span> diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</span><br><span class="line">    <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 ScheduledFutureTask 的比较方法将用于加入内置队列时判断元素的优先级，也就是最先执行的任务排在前面。</p><h4 id="任务体"><a href="#任务体" class="headerlink" title="任务体"></a>任务体</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+--- ScheduledFutureTask</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖 FutureTask 的方法，以便定期重置 requeue。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否周期性任务</span></span><br><span class="line">        <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否可以运行任务，不可以运行就取消并移除任务</span></span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">            cancel(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是一次性任务，直接调用父类的 run 方法，这个方法实际是 FutureTask 的方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">            ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是周期性任务，调用父类的 runAndReset() 方法，执行并重复任务，这个父类是 FutureTask 的方法</span></span><br><span class="line">            <span class="comment">// runAndReset 和 run 方法类似，只是其任务运行完毕后不会修改 NEW 状态</span></span><br><span class="line">            <span class="comment">// todo 如果任务执行异常，那么就不会继续周期性执行。注意，线程并没有退出。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">            <span class="comment">// 设置下次任务执行的时间</span></span><br><span class="line">            setNextRunTime();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重新排队周期任务</span></span><br><span class="line">            reExecutePeriodic(outerTask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ScheduledFutureTask 可能是延时任务，也可能是周期性延时任务，因此需要根据情况执行不同的分支逻辑。</p><ul><li>判断即使线程池关闭（shutdown)后是否可以继续执行 ScheduledFutureTask ；</li><li>如果是延时任务，直接调用父类的 run 方法执行任务即可；</li><li>如果是周期性延时任务，直接调用父类的 runAndReset 方法执行并重置任务，然后重新计算任务执行时间并加入到阻塞队列中。</li></ul><h4 id="周期性时间"><a href="#周期性时间" class="headerlink" title="周期性时间"></a>周期性时间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--- ScheduledFutureTask</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置下一次运行周期性任务的时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = period;</span><br><span class="line">    <span class="comment">// scheduleAtFixedRate 方式，以上一个任务开始时间为基础，计算下次触发时间</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">        time += p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// scheduleWithFixedDelay 方式，以上个任务结束时间即当前时间为基础，计算下次触发时间</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        time = triggerTime(-p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法只针对周期性任务，一次性延时任务不会用到该方法。</p><p><strong>注意：</strong>固定频率的周期任务 <code>period</code> 的值在提交任务时被设置为正数，固定延时时间的周期任务 <code>period</code> 的值在提交任务时被设置为负数；</p><h4 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消任务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mayInterruptIfRunning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用父类 FutureTask 的 cancel 方法</span></span><br><span class="line">    <span class="keyword">boolean</span> cancelled = <span class="keyword">super</span>.cancel(mayInterruptIfRunning);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消成功后，判断是否立即移除队列中的任务</span></span><br><span class="line">    <span class="keyword">if</span> (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= <span class="number">0</span>)</span><br><span class="line">        remove(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cancelled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScheduledFutureTask 重写了父类 FutureTask 中的取消任务方法，在此基础上加入了从内置队列中移除元素的逻辑，因为任务取消了，那么在队列中的该任务也就无需执行。</p><h3 id="内置延时队列-DelayedWorkQueue"><a href="#内置延时队列-DelayedWorkQueue" class="headerlink" title="内置延时队列 - DelayedWorkQueue"></a>内置延时队列 - DelayedWorkQueue</h3><p>我们知道，阻塞队列对于线程池来说是非常重要的，<strong>不仅可以缓冲任务，还可以根据阻塞队列的特性调整线程池的调度流程</strong>。ScheduledThreadPoolExecutor 是一个延时线程池，这个<strong>延时的特性其实就体现在它所使用的队列上</strong>。这就要求这个队列不能像普通的阻塞队列那样，队列中即使有任务，如果任务没有到期是不能拿出来的。<strong>从这个特点也解释了前面介绍的延时线程池的调度流程，先把任务放到队列中然后再确保线程执行该任务，目的就是为了延时执行</strong>。</p><p>具体对应到线程池中的执行逻辑如下，从队列中获取任务时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadPoolExecutor#getTask</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取线程池状态码</span></span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="comment">// 获取线程池状态</span></span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 线程池关闭且队列为空，应该回收线程。这个条件不仅可以回收非核心线程，也可以回收核心线程。todo 核心线程唯一回收条件</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="comment">// 减少线程池中的线程数</span></span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 线程池中的线程数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 允许核心线程数内的线程回收，或线程池中的线程数超过了核心线程数，那么有可能发生超时关闭</span></span><br><span class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果线程池中的线程数大于最大线程数或获取任务超时（不设置 allowCoreThreadTimeOut，核心线程没有超时概念），并且任务队列为空，则应该回收当前线程。</span></span><br><span class="line">            <span class="comment">// wc &gt; maximumPoolSize ，可能是执行 setMaximumPoolSize 方法修改了最大值。</span></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="comment">// 减少工作线程数</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从队列中取出任务</span></span><br><span class="line">                <span class="comment">// 注意，真正响应中断是在 poll() 方法或者 take() 方法中</span></span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                        <span class="comment">// 超时获取任务，因为线程超时要被回收。如果线程在等待的过程发生了中断，会抛出中断异常</span></span><br><span class="line">                        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                        <span class="comment">// 不需要超时</span></span><br><span class="line">                        workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取任务超时，进行重试</span></span><br><span class="line">                timedOut = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                <span class="comment">// 发生中断重置超时标记</span></span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor 为了<strong>控制任务在某个时刻执行</strong>，自己实现了一个和 DelayQueue 功能一致的内部延时队列 DelayedWorkQueue 。区别点是 DelayQueue 内部使用的是优先级队列 PriorityQueue ，延时逻辑由自身实现。而 DelayedWorkQueue 将优先级和延时特性重新实现了一遍，即将 PriorityQueue 和 DelayQueue 逻辑在一个类中实现，本质上同 DelayQueue 的特性和逻辑，源码部分就不再详细说明，参考 <a href="https://gentryhuang.com/posts/db98efcf/">DelayQueue</a> 即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>ScheduledThreadPoolExecutor 是<strong>基于 ThreadPoolExecutor 扩展的、可执行定时任务</strong>的线程池。前者重写了 ThreadPoolExecutor.execute 的调度流程，遵循任务先加入队列原则，根本原因是 ScheduledThreadPoolExecutor 是执行定时任务的线程池。</p><p>ScheduledThreadPoolExecutor 支持定时任务和周期性任务。对于定时任务，是通过内部的延时队列 DelayedWorkQueue 来实现的；对于周期性任务，是通过在任务执行后再次将任务加入到延时队列中来实现的。可见，延时队列在定时任务执行过程中的重要性。</p><p>ScheduledThreadPoolExecutor 通过内部的 ScheduledFutureTask 对任务进行了统一封装，使任务具备<strong>异步计算、延时</strong>的特性，这不仅是 ScheduledThreadPoolExecutor 的要求，也是内部延时队列 DelayedWorkQueue 的要求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;ScheduledThreadPoolExecutor 是基于 ThreadPoolExecutor &lt;strong&gt;扩展的&lt;/strong
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>并发 - FutureTask</title>
    <link href="https://gentryhuang.com/posts/a16a077e/"/>
    <id>https://gentryhuang.com/posts/a16a077e/</id>
    <published>2022-04-22T02:07:06.000Z</published>
    <updated>2022-05-17T05:26:13.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>FutureTask 表示异步计算的任务，通过间接实现了 Future 和 Runnable 接口，使其具备<strong>异步计算结果</strong>和<strong>任务</strong>的特性。异步计算结果支持检查任务是否完成、等待任务完成、获取任务结果、以及取消任务等方法；任务特性是指 FutueTask 是一个任务体，并且用于包装 Callable 或 Runnable 对象，即统一任务为 Callable 类型。</p><p>FutureTask 相关的 UML 类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/future-task-1.png" alt></p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>我们执行 5 个异步任务，在未来的某一个时刻收集任务执行的结果并打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">futureTaskTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 创建固定大小线程池</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">    Random random = <span class="keyword">new</span> Random(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 定义异步计算任务集合</span></span><br><span class="line">    HashSet&lt;Future&lt;String&gt;&gt; futureList = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// List&lt;Future&lt;String&gt;&gt; futureList = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// submit 方法提交的任务会被 FutureTask 包装，返回的也是这个 FutureTask 对象</span></span><br><span class="line">        <span class="keyword">int</span> finalI = i;</span><br><span class="line">        Future&lt;String&gt; future = threadPool.submit(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException interruptedException) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> Thread.currentThread().getName() + <span class="string">" is run future-task..."</span> + finalI;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        futureList.add(future);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 任务提交完成后，等待处理完成并打印</span></span><br><span class="line">    futureList.forEach(future -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 任务取消，不获取结果&#123;@link get()&#125;，否则会抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (future.isCancelled()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 任务已经在执行了，则阻塞等待最终的结果</span></span><br><span class="line">            <span class="keyword">if</span> (future.isDone()) &#123;</span><br><span class="line">                System.out.println(future.get(<span class="number">3</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 执行到这里，说明异步计算任务还是 NEW 状态，阻塞等待被调度、执行</span></span><br><span class="line">                System.out.println(future.get());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，上述使用示例是结合线程池 ThreadPoolExecutor 进行演示的，并没有直接使用 FutureTask API ，毕竟单独使用 FutureTask 并不多。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>FutureTask 相关的源码结构如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/future-task-2.png" alt></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FutureTask 封装的任务体。如果是 Runnable 类型，则会对Runnable进行适配转为 Callable 类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务最终的结果，要么是正常的结果，要么是异常。get 方法获取的就是这个属性值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行任务的线程，如线程池中的某个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待任务结果的线程节点，即调用者线程组成的链表结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>state:</strong> 表示异步计算任务的状态，通过该值可以<strong>追踪任务进行到哪个阶段</strong>了。该属性使用 <code>volatile</code> 进行了修饰；<br><strong>callable:</strong>  异步计算任务封装的任务体，类型统一为 Callable，原因就是异步计算任务需要知道任务执行的结果，而 Runnable 类型不关心任务的结果。这里使用了适配器模型，将任务类型进行了统一。<br><strong>outcome:</strong> 任务最终的结果，要么是正常的结果，要么是异常，get 方法获取的就是这个属性值。通过 state 属性值可以明确 outcome 属性值的情况；<br><strong>runner:</strong> 表示执行任务的线程，谁执行 callable 这个属性就记录谁；<br><strong>waiters:</strong> 等待任务结果的线程节点组成的等待链表，链表中的每个节点都封装了等待结果的线程；</p><h4 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h4><p>异步计算任务 FutureTask 的状态定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可能的状态转换：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 任务正常运行结束：NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * 任务异常运行结束：NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * 任务取消：NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * 任务被中断：NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 异步任务状态仅在 &#123;<span class="doctag">@link</span> set(V v)&#125;、&#123;<span class="doctag">@link</span> setException(Throwable t)&#125;、&#123;<span class="doctag">@link</span> cancel()&#125; 方法中转换为最终状态，</span></span><br><span class="line"><span class="comment"> * 在这期间，状态可能会采用 COMPLETING 或 INTERRUPTING 的中间状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW = <span class="number">0</span>; <span class="comment">// 新建状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING = <span class="number">1</span>; <span class="comment">// 执行中间态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL = <span class="number">2</span>;     <span class="comment">// 完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL = <span class="number">3</span>; <span class="comment">// 异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">4</span>; <span class="comment">// 取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>; <span class="comment">// 中断中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED = <span class="number">6</span>; <span class="comment">// 中断</span></span><br></pre></td></tr></table></figure><p>异步计算任务 FutureTask 的状态流转如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/future-task-3.png" alt></p><p>可以看到异步计算任务 FutureTask 具有生命周期的特性，每个阶段都对应着任务的执行进度。其中，需要强调两个状态：</p><ul><li><code>COMPLETING</code>: 表示任务计算过程的中间状态，任务快要完成，达到这个状态说明任务已经执行完成或者出现异常，紧接着保存结果或异常信息即可。</li><li><code>INTERRUPTING</code>: 表示对新建状态的任务进行中断处理中，如果任务正被线程在执行，那么就对该线程进行中断，否则不处理线程中断逻辑。达到这个状态说明已经成功对未完成的任务进行了中断处理，紧接着会将异步计算任务状态更新为 <code>INTERRUPTED</code>，此时中断才算完成。</li></ul><p>既然 <code>COMPLETING</code> 和 <code>INTERRUPTING</code> 都只是一个中间状态，那么它们的必要性体现在哪里呢？</p><ul><li><code>COMPLETING</code>: 表示任务快要完成，有了这个标志，获取任务结果的调用线程更加明确任务执行到哪个阶段了，可以选择等待结果还是直接获取结果；</li><li><code>INTERRUPTING</code>: 表示中断者准备对异步计算任务进行中断，只是还没有完成这个中断的整个过程，有了这个标志就可以明确异步任务被中断的阶段了；</li></ul><h4 id="等待链表"><a href="#等待链表" class="headerlink" title="等待链表"></a>等待链表</h4><p>异步计算任务 FutureTask 实现了一个单向链表，用来排队等待结果的业务线程。链表结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待任务结果的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建线程节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WaitNode() &#123;</span><br><span class="line">        thread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待链表本身比较简单，需要特别说明的是，进入到链表的线程都是处于等待（任务结果）状态，具体是通过 <code>LockSupport.park</code> 方法来实现阻塞的。当任务执行结束或被取消，那么等待链表中的线程会通过 <code>LockSupport.unpark</code> 方法依次被唤醒。</p><h4 id="CAS属性值"><a href="#CAS属性值" class="headerlink" title="CAS属性值"></a>CAS属性值</h4><p>异步计算任务 FutureTask 针对 <code>state</code>、<code>runner</code>、<code>waiters</code> 这 3 个属性，通过 Unsafe 实现了 CAS 机制对其进行写操作，保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="comment">// 内存地址偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> runnerOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> waitersOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = FutureTask<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            stateOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line">            runnerOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"runner"</span>));</span><br><span class="line">            waitersOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"waiters"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>FutureTask 的构造方法用于封装任务体以屏蔽不同任务的差异。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建任务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callable the callable task 可调用任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the callable is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务不允许为空</span></span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存到属性中</span></span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步计算任务状态初始化为新建状态</span></span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建任务，需要将 Runnable 类型包装成 Callable 类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable the runnable task 可运行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result   the result to return on successful completion. If</span></span><br><span class="line"><span class="comment"> *                 you don't need a particular result, consider using</span></span><br><span class="line"><span class="comment"> *                 constructions of the form:</span></span><br><span class="line"><span class="comment"> *                 &#123;<span class="doctag">@code</span> Future&lt;?&gt; f = new FutureTask&lt;Void&gt;(runnable, null)&#125;</span></span><br><span class="line"><span class="comment"> *                 成功完成后返回的结果。如果不需要特定结果，传入 null </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the runnable is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 将 Runnable 类型任务适配成 Callable 类型，并保存到属性中</span></span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 异步计算任务状态初始化为新建状态</span></span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法主要做了以下两个工作：</p><ul><li>将不同的任务统一处理成 Callable 类型，这是异步计算结果必须的；</li><li>异步计算任务在创建时的状态为<strong>新建状态 NEW</strong>；</li></ul><h3 id="任务执行-run"><a href="#任务执行-run" class="headerlink" title="任务执行 - run()"></a>任务执行 - run()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断任务是否可以执行</span></span><br><span class="line">    <span class="comment">// 任务状态不为 NEW 或 设置执行该任务的线程（也就是 runner 属性）失败 ，那么不能执行该任务</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                    <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 真正的任务，这里统一是 Callable 类型，Runnable 被适配成了 Callable 类型</span></span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务状态必须是 NEW 才能运行</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            <span class="comment">// 任务执行结果</span></span><br><span class="line">            V result;</span><br><span class="line">            <span class="comment">// 任务是否执行成功</span></span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行任务</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 出现异常</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 处理异常结果并更新任务状态</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 任务执行成功，设置结果并更新任务状态</span></span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 任务处理完成后，将 runner 置 null ，防止并发调用 run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新读取状态以防止漏掉中断的处理「想一下这种场景，线程在执行 c.call() 方法时被中断了」</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            <span class="comment">// 处理可能因取消时进行的中断，如果处于中断中，等待中断者完成即可</span></span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>任务可以执行的条件是：异步任务状态为 NEW &amp;&amp; 设置执行任务的线程为当前线程成功；</li><li>调用任务的 call() 方法，即方法调用，执行任务；</li><li>处理结果和异常，并更新异步任务状态以及唤醒等待异步计算结果的（调用）线程；</li><li>线程执行完任务后，置空 runner 为下次任务执行做准备（试想下，如果不置空会怎样？后续的线程可能不能执行任务，因为 CAS 不会成功），并且处理异步任务被中断的情况；</li></ol><h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将任务状态 NEW 更新为 COMPLETING</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结果设置为异常信息</span></span><br><span class="line">        <span class="comment">// 该属性是 get 方法返回的</span></span><br><span class="line">        outcome = t;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置任务最终的状态为 EXCEPTIONAL</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理任务完成的后续工作</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行任务的过程发生异常，就会执行该方法，该方法有四步操作：</p><ol><li>将异步计算任务状态 NEW 转换为 COMPLETING 状态，标志异步计算任务快完成了；</li><li>将异常信息保存到待返回的属性中，该属性是 get 方法获取的值；</li><li>将异步计算任务状态由 COMPLETING 转换为 EXCEPTIONAL 状态，标志异步计算任务执行异常，是个完结状态；</li><li>任务完结后的收尾工作，包括唤醒等待链表中的线程和置空任务体等；</li></ol><p>至此，FutureTask 的状态流转为：<strong>NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</strong></p><h4 id="处理结果"><a href="#处理结果" class="headerlink" title="处理结果"></a>处理结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将任务状态 NEW 更新为 COMPLETING</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结果设置为传入的值</span></span><br><span class="line">        <span class="comment">// 该属性是 get 方法返回的</span></span><br><span class="line">        outcome = v;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置任务最终的状态为  NORMAL</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理任务完成的后续工作</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行任务无异常，就会执行该方法，该方法同样有四步操作：</p><ol><li>将异步计算任务状态 NEW 转换为 COMPLETING 状态，标志异步计算任务快完成了；</li><li>将任务结果保存到待返回的属性中，该属性是 get 方法获取的值；</li><li>将异步计算任务状态由 COMPLETING 转换为 NORMAL 状态，标志异步计算任务完成，是个完结状态；</li><li>任务完结后的收尾工作，包括唤醒等待链表中的线程和置空任务体等；</li></ol><p>至此，FutureTask 的状态流转为：<strong>NEW -&gt; COMPLETING -&gt; NORMAL</strong></p><h4 id="处理异步任务被中断的情况"><a href="#处理异步任务被中断的情况" class="headerlink" title="处理异步任务被中断的情况"></a>处理异步任务被中断的情况</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确保在 run 或 runAndReset 执行时，来自可能的 cancel(true) 方法的中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待中断者完成中断，这里让出 CPU 等待</span></span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            Thread.yield(); <span class="comment">// wait out pending interrupt  等待挂起的中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行该方法的情况是，在线程执行任务的 <code>call()</code> 方法期间，任务被中断者中断了，一般是中断者调用 <code>cancel(true)</code> 方法，但是还没有完成整个中断流程，因此任务执行完毕后等待中断者完成整个中断逻辑；</p><h3 id="任务取消-cancel"><a href="#任务取消-cancel" class="headerlink" title="任务取消 - cancel"></a>任务取消 - cancel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消任务，可能是中断，也可能是取消</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mayInterruptIfRunning 是否中断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取消任务的条件：任务状态为 NEW &amp;&amp; 更新任务状态 NEW-&gt;INTERRUPTING 或者 NEW-&gt;CANCELLED 成功</span></span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">            UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">                    mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="comment">// 如果中断线程</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 中断线程</span></span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 完结任务</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步计算任务 FutureTask 支持取消任务，这个取消任务可能是中断任务，也可能是取消任务，由调用方决定。最终的结果是任务不能执行了。</p><ol><li>取消任务的前提是，异步计算任务的状态为 NEW，否则不能取消；</li><li>如果是中断式取消任务，那么即使任务正在线程执行，也会对该线程进行中断，没有被执行则忽略中断；</li><li>取消任务后，执行后续的收尾工作，包括唤醒等待结果的线程、置空任务体；</li></ol><p>取消任务的情况下，异步计算任务的状态变更：<strong>NEW-&gt;CANCELLED</strong>。<br>中断式取消任务的情况下，异步计算任务的状态变更：<strong>NEW-&gt;INTERRUPTING-&gt;INTERRUPTED</strong>。</p><p>其中，中断式取消任务的情况下，涉及到两个状态的变更。<code>INTERRUPTING</code> 只是标记中断开始，此时中断的整个过程还没有完成。还记得任务执行过程中对中断情况的特别处理吗？就是这里的情况。</p><h3 id="完结任务-finishCompletion"><a href="#完结任务-finishCompletion" class="headerlink" title="完结任务 - finishCompletion"></a>完结任务 - finishCompletion</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">     <span class="comment">// 如果线程等待队列不为空（这个线程队列实际上是调用者线程）</span></span><br><span class="line">     <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">         <span class="comment">// 置空队列</span></span><br><span class="line">         <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">             <span class="comment">// 唤醒并从等待列表中移除等待结果的节点</span></span><br><span class="line">             <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">                 Thread t = q.thread;</span><br><span class="line">                 <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     q.thread = <span class="keyword">null</span>;</span><br><span class="line">                     <span class="comment">// 唤醒线程 t</span></span><br><span class="line">                     LockSupport.unpark(t);</span><br><span class="line">                 &#125;</span><br><span class="line">                 WaitNode next = q.next;</span><br><span class="line">                 <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                 q = next;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 执行钩子方法</span></span><br><span class="line">     done();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 任务体完成后置空</span></span><br><span class="line">     callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>完结任务方法被多个地方使用，该方法主要做以下 3 件事：</p><ol><li>依次唤醒等待链表中的调用者线程，让它们去拿结果或异常；</li><li>执行钩子方法；</li><li>置空任务体 callable；</li></ol><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/juc/future-task-4.png" alt></p><h3 id="获取任务结果-get"><a href="#获取任务结果-get" class="headerlink" title="获取任务结果 - get"></a>获取任务结果 - get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得任务的执行结果，如果任务未执行完毕，会阻塞直到任务结束；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">// 任务执行状态</span></span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果任务还没可能完成，则进入等待链表中等待</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回任务的结果或异常</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 超时获取执行结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取任务的状态</span></span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果任务还没有完成，则超时等待（进入等待链表中），超时或有结果了会醒来</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">            (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        <span class="comment">// 超时无结果，抛出异常    </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回任务的结果或异常</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取任务结果有两种方式，一种是阻塞式，另一种是超时获取，它们分别对应上述的方法。</p><h4 id="等待任务完成-awaitDone"><a href="#等待任务完成-awaitDone" class="headerlink" title="等待任务完成 - awaitDone"></a>等待任务完成 - awaitDone</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在中断或超时时等待完成或中止</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timed true if use timed waits 是否超时等待</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nanos time to wait, if timed 等待时间长，纳秒</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> state upon completion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 等待的截止时间，非超时就是 0</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="comment">// 如果获取结果的线程被中断，则尝试移除节点 q，然后抛出中断异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务状态</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果任务状态 &gt; COMPLETING，那么可以返回了，此时能拿到最终的结果或异常「参考 report 中的逻辑」。</span></span><br><span class="line">        <span class="comment">// todo 这里是自旋出口</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果任务状态处于 COMPLETING 状态，说明任务快完成了，就差设置状态到NORMAL或EXCEPTIONAL和设置结果了</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet 还不能超时</span></span><br><span class="line">            <span class="comment">// 让出 CPU，优先完成任务「调用线程不占用CPU了，让任务尽快完成」</span></span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建线程节点，节点中记录调用者线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将线程节点 q 加入到等待链表中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">// CAS 的链表头插法</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                    q.next = waiters, q);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 超时获取结果</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            <span class="comment">// 计算是否超时</span></span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">// 超时了，则从等待链表中移除节点 q，并返回 state</span></span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 超时阻塞线程</span></span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 阻塞式获取结果，阻塞当前线程（调用者线程）</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 阻塞线程</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待任务完成的方法还是比较复杂的，它的特点是：<strong>在循环中控制整个流程，以状态 state 驱动流程，也就是随着 state 的不同，执行的分支流也不同</strong>。我们假设调用者线程获取结果时任务还没有完成，异步计算任务的状态为 NEW，那么一个完整的流程大致如下：</p><ol><li>第一次循环，state=NEW，此时会将调用者线程封装在 WaitNode 节点中；</li><li>第二次循环，state=NEW，此时调用者线程节点 WaitNode 会加入到等待链表的头部「<strong>这里是入等待链表的入口</strong>」，注意此时调用者线程并没有阻塞等待；</li><li>第三次循环，state=NEW，执行调用者线程会进入阻塞，假设调用者获取结果使用的是 get() 方法，那么就是 <code>LockSupport.park(this)</code>；</li><li>假设在调用者线程阻塞等待期间，任务完成了，在完结任务的处理方法中，会通过 <code>LockSupport.unpark(t)</code> 依次唤醒等待链表中的调用者线程；</li><li>第四次循环，此时 state &gt; COMPLETING ，退出方法；</li></ol><p>在获取任务结果时，异步计算任务的状态是 COMPLETING 的情况，那么就会让出 CPU 等待任务完成。</p><h4 id="任务最终执行结果"><a href="#任务最终执行结果" class="headerlink" title="任务最终执行结果"></a>任务最终执行结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为已完成的任务返回结果或抛出异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">// 任务执行的结果或异常</span></span><br><span class="line">    Object x = outcome;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果任务正常运行结束，返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V) x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果任务被取消或被中断，则抛出任务取消异常</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务异常运行</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable) x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果任务正常执行结束，则返回任务的执行结果；</li><li>如果任务被取消，则抛出取消异常；</li><li>如果任务异常结束，则包装成 ExecutionException 异常抛出；</li></ul><h3 id="任务执行并重置-runAndReset"><a href="#任务执行并重置-runAndReset" class="headerlink" title="任务执行并重置 - runAndReset()"></a>任务执行并重置 - runAndReset()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行计算而不设置其结果，然后将此未来计算任务重置为初始状态，如果计算遇到异常或被取消则任务失效，不能重复执行。</span></span><br><span class="line"><span class="comment"> * 该设计用于周期性任务。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successfully run and reset</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAndReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断任务是否已经开始执行，没有开始执行，那么设置执行该任务的线程，也就是 runner 属性</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                    <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行成功</span></span><br><span class="line">    <span class="keyword">boolean</span> ran = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; s == NEW) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行任务，但不设置结果，也不更新完成状态「任务可以重复执行」</span></span><br><span class="line">                c.call(); <span class="comment">// don't set result</span></span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 异常情况，设置异常并更新完成状态「任务不能再执行」</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 任务处理完成后，将 runner 置 null ，防止并发调用 run()</span></span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新读取状态以防止漏掉中断的处理「想一下这种场景，线程在执行 c.call() 方法时被中断了」</span></span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent leaked interrupts</span></span><br><span class="line">        s = state;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理可能因取消时进行的中断，如果处于中断中，等待中断者完成即可</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功运行并重置</span></span><br><span class="line">    <span class="keyword">return</span> ran &amp;&amp; s == NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法和 <code>run()</code> 方法基本一致，唯一区别点是，<strong>任务执行成功后该方法不会设置执行结果，也不会更新更新状态，这一设计是为周期性任务服务的</strong>。</p><p><strong>注意：</strong>一旦任务执行失败或被取消，那么这个任务就会失效，不能再次执行「异常时状态被更新为终止状态」。</p><h3 id="FutureTask-amp-ThreadPollExecutor"><a href="#FutureTask-amp-ThreadPollExecutor" class="headerlink" title="FutureTask &amp; ThreadPollExecutor"></a>FutureTask &amp; ThreadPollExecutor</h3><p>在介绍<a href="https://gentryhuang.com/posts/d7cef21d/">并发 - 线程池</a>一文中，我们简单地对 FutureTask 进行了介绍，下面我们收个尾，看看两者是如何配合使用的。</p><p>使用线程池提交任务时，一般有两种方法，其中的 <code>submit</code> 方法返回的就是 <code>FutureTask</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非空检查</span></span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 使用 FutureTask 封装任务</span></span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    <span class="comment">// 使用 execute 方法执行任务</span></span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="comment">// 返回 FutureTask </span></span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，任务提交到线程池后就会返回一个和任务相关的异步计算任务对象 FutureTask ，通过这个对象我们就可以对提交到线程池中的任务的状态进行追踪。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>RPC 框架中的同步调用和异步调用本质上都是异步调用，其中异步调用就可以使用 Future 衍生实现。比如 Dubbo 中的异步调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1 调用 RpcContext#setFuture(future) 方法，在 FutureFitler 中，异步回调。</span></span><br><span class="line"><span class="comment"> * 2 将DefaultFuture 对象封装到 FutureAdapter实例中，并将 FutureAdapter实例设置到RpcContext 中，我们可以在需要的地方取出使用 【在合适的地方调用 get方法】</span></span><br><span class="line"><span class="comment"> * 3 FutureAdapter 是一个适配器，用于将 Dubbo 中的 ResponseFuture 与 JDK 中的 Future 进行适配，这样当用户线程调用 Future 的 get 方法时，经过 FutureAdapter 适配，最终会调用 ResponseFuture 实现类对象的 get 方法，也就是 DefaultFuture 的 get 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> RpcContext.getContext().setFuture(<span class="keyword">new</span> FutureAdapter&lt;Object&gt;(future));</span><br><span class="line">  <span class="comment">// 返回 空结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>FutureTask 表示异步计算的任务，它支持检查任务是否完成、等待任务完成、获取任务结果、以及取消任务等方法。<strong>通过这个异步计算任务，我们可以追踪任务的状态，从而可以灵活操作任务</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;FutureTask 表示异步计算的任务，通过间接实现了 Future 和 Runnable 接口，使其具备&lt;strong&gt;异步计算结果&lt;/
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>MySQL - 乐观锁和悲观锁</title>
    <link href="https://gentryhuang.com/posts/3c450cc6/"/>
    <id>https://gentryhuang.com/posts/3c450cc6/</id>
    <published>2022-04-10T02:46:59.000Z</published>
    <updated>2022-04-14T09:04:39.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据库的锁机制是并发控制的重要手段，是保证数据正确性的最后的一道屏障。而锁的种类和范围，对并发控制的程度和效率又不大一样。本篇文章将围绕<strong>乐观锁和悲观锁</strong>，结合业务场景对这两个锁的实现进行说明。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假设我们有张商品库存表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;item_stock&#96; (</span><br><span class="line">  &#96;id&#96; bigint(19) NOT NULL COMMENT &#39;主键&#39;,</span><br><span class="line">  &#96;account&#96; varchar(18) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;商家编码&#39;,</span><br><span class="line">  &#96;total_stock_num&#96; int(9) NOT NULL COMMENT &#39;总库存&#39;,</span><br><span class="line">  &#96;remain_stock_num&#96; int(9) NOT NULL COMMENT &#39;剩余库存&#39;,</span><br><span class="line">  &#96;extend_fields&#96; varchar(200) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;扩展字段&#39;,</span><br><span class="line">  &#96;gmt_create&#96; bigint(20) NOT NULL COMMENT &#39;创建时间&#39;,</span><br><span class="line">  &#96;gmt_update&#96; bigint(20) NOT NULL COMMENT &#39;更新时间&#39;,</span><br><span class="line">  &#96;last_ver&#96; int(10) NOT NULL COMMENT &#39;版本号&#39;,</span><br><span class="line">  &#96;is_valid&#96; tinyint(4) NOT NULL COMMENT &#39;是否有效&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4 COMMENT&#x3D;&#39;商品库存&#39;;</span><br></pre></td></tr></table></figure><p>其中商品库存表中有一个字段 <code>remain_stock_num</code> 表示当前该商品的库存量。假设有一个 iphone13 ，其 id 为 100 ，<code>remain_stock_num=10</code>。现在我们按照一般的库存扣减方法进行操作，程序流程如下：</p><ol><li>step1: 查出商品剩余库存量<br>select remain_stock_num from item_stock where id = 100;</li><li>step2: 还有剩余库存，则录单<br>insert into order(id,item_id) values(null,100);</li><li>step3: 扣减商品库存<br>update item_stock set remain_stock_num = #{num} where id = 100;</li></ol><p>上述流程咋一看好像没有问题，在没有并发的情况下确实没有问题。那我们看存在并发的情况，操作序列如下：</p><table><thead><tr><th align="left">序列</th><th align="left">线程 A</th><th align="left">线程 B</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">step1 查询还有 10 个</td><td align="left">step1 查询还有 10 个</td></tr><tr><td align="left">2</td><td align="left"></td><td align="left">step2 生成订单</td></tr><tr><td align="left">3</td><td align="left">step2 生成订单</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left"></td><td align="left">step3 扣减库存 9 个</td></tr><tr><td align="left">5</td><td align="left">step3 扣减库存 2 个</td><td align="left"></td></tr></tbody></table><p>可以看到，上述流程会造成<strong>超卖</strong>问题。那如何解决上述问题呢，解决方式还是很多的，下面我们分别看如何使用悲观锁和乐观锁解决。</p><h2 id="乐观锁-amp-悲观锁"><a href="#乐观锁-amp-悲观锁" class="headerlink" title="乐观锁 &amp; 悲观锁"></a>乐观锁 &amp; 悲观锁</h2><p>乐观锁和悲观锁是锁的一种思想，并不局限于应用在数据库中。因此，不要把乐观锁和悲观锁狭隘地理解为数据库中的概念，更不要把它们和数据库中提供的锁机制混为一谈。</p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁是指在数据处理过程中，使数据资源处于锁定状态，<strong>数据库中使用锁机制实现</strong>。</p><p>悲观并发控制主要用于数据竞争激烈的场景，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。 </p><h4 id="MySQL中的悲观锁"><a href="#MySQL中的悲观锁" class="headerlink" title="MySQL中的悲观锁"></a>MySQL中的悲观锁</h4><p>对任意记录进行修改前，先尝试为该记录加上排他锁(exclusive locking) 。如果加锁失败，说明该记录正在被修改，那么是选择等待还是抛出异常由业务方决定。</p><p>要使用悲观锁，需要关闭 MySQL 的自动提交属性，因为 MySQL 默认使用 <code>auto commit</code> 模式，也就是说，当执行一个更新操作后，MySQL 会立即提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit&#x3D;0</span><br></pre></td></tr></table></figure><p>我们回到场景中，看使用悲观锁如何解决上述问题。在上面的场景中，商品从查询出来到最后的库存扣减，是没有对这个库存进行持续锁定的，仅仅在扣减的时候会进行锁定，查询的时候使用的是快照读。而使用悲观锁的原理就是，在查询出商品的过程就把当前的数据锁定，直到扣减完库存再解锁。</p><p>这样一来，整个过程中因为数据被锁定了，就不会有其他请求来同时进行修改了。需要说明的是，使用悲观锁的前提是需要将要执行的 SQL 语句放在一个事务中，否则达不到锁定数据的目的。大致过程如下：</p><ol><li>setp0: 开启事务<br>begin;</li><li>step1: 查出商品剩余库存量<br>select remain_stock_num from item_stock where id = 100 for update;</li><li>step2: 还有剩余库存，则录单<br>insert into order(id,item_id) values(null,100);</li><li>step3: 扣减商品库存<br>update item_stock set remain_stock_num = remain_stock_num - #{num} where id = 100;</li><li>step4: 提交事务<br>commit;   </li></ol><p>需要说明的是，上述流程中，使用了 <code>select...for update</code> 的方式实现了悲观锁。此时，商品库存 id=100 的那条记录被锁定了，其它的事务要访问这个数据就必须等本次事务提交之后才能执行，这样就保证了并发修改的问题。</p><p>此外，对于 MySQL 的 InnoDB 引擎来说，它支持行锁，而锁是基于索引的，如果一条语句用不到索引（全表扫描），那么在加锁的时候会把整个表锁住（在默认的 RR 隔离级别下）。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>悲观锁其实是采用<strong>先加锁后访问</strong>的保守策略，为数据处理的安全提供了保证。</p><p>悲观锁的加锁时间可能会过长，这会导致其它事务无法访问，无疑<strong>影响了程序的并发访问性</strong>；此外，这样对数据库<strong>性能开销影响也很大</strong>，特别是对长事务而言，同时还会<strong>增加生产死活的概率</strong>。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁相对悲观锁而言，它认为数据一般情况下不会造成冲突，因此只会在数据进行提交的时候才会进行冲突与否的判断，如果发现冲突了，则返回冲突的信息，让业务方决定如何去做，一般业务方会选择进行重试，这也是乐观锁的由来。</p><h4 id="MySQL中的乐观锁"><a href="#MySQL中的乐观锁" class="headerlink" title="MySQL中的乐观锁"></a>MySQL中的乐观锁</h4><p>实现乐观锁一般有以下两种方式：</p><ul><li>使用版本号实现乐观锁：数据版本号或时间戳；</li><li>使用条件限制实现乐观锁：缩小乐观锁的范围，<strong>适用于只更新时做数据安全校验</strong>；</li></ul><p><strong>注意：</strong></p><ul><li>使用乐观锁进行更新操作，最好用主键或者唯一索引来更新，这样是行锁，否则更新会锁表；</li><li>乐观锁<strong>不依赖数据库的锁机制</strong>，但更新数据库数据是一个写操作，会触发数据库锁机制。</li></ul><h5 id="版本号实现乐观锁"><a href="#版本号实现乐观锁" class="headerlink" title="版本号实现乐观锁"></a>版本号实现乐观锁</h5><p>使用数据版本记录机制实现是乐观锁最常用的一种实现方式。一般是通过为数据表增加一个数字类型的 <code>version</code> 字段来实现。当读取数据时，将 version 的值一同读出，数据每更新一次就对 version 值加 1。当提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的 version 值，如果数据库表当前版本号与第一次取出来的 version 值相等，则予以更新，否则认为是过期数据。流程如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-s-version-lock.png" alt></p><p>从上图可以看出，如果更新操作顺序执行，则数据的 version 一次递增，不会产生冲突。如果出现不同业务的事务操作同一版本的数据，那么先提交的会成功，后提交的会失败。<strong>注意，如果并发很大，会导致大量失败的情况</strong>。</p><p>使用时间戳也是类似的，就不再介绍。</p><p>需要说明的是，这种方式的乐观锁虽然更通用，但是也不是适用于所有的乐观锁场景，这个时候可以考虑条件限制实现的乐观锁。</p><h5 id="条件限制实现乐观锁"><a href="#条件限制实现乐观锁" class="headerlink" title="条件限制实现乐观锁"></a>条件限制实现乐观锁</h5><p>使用条件限制实现乐观锁，适用于更新时<strong>做数据安全校验</strong>，适合库存模型等，性能更高。</p><p>使用条件限制实现乐观锁还有一个重要原因，就是<strong>缩小锁范围</strong>。比如商品库存扣减时，特别是在秒杀等场景下，如果采用版本号实现的乐观锁，因为对于同一个版本的数据每次只有一个事务能更新成功，业务感知上就是大量操作失败。</p><p>缩小锁范围是指：采用条件限制，只会在不满足条件才会失败，这是一个范围概念，而版本号是等值的概念，后者失败率更高，并且这是可以避免的。</p><h5 id="乐观锁解决并发"><a href="#乐观锁解决并发" class="headerlink" title="乐观锁解决并发"></a>乐观锁解决并发</h5><p>我们回到场景中，看使用乐观锁如何解决上述问题。在上面的场景中，虽然扣减库存的时候会进行锁定，但是没有解决操作上的原子问题，也就是要修改的数据必须是查询到的数据。而使用乐观锁的原理就是，在查询出商品的时候会将数据的 version 也一同查出，然后在提交修改的时候在数据库层面进行 version 的对比，如果数据当前版本号与取出来的 version 值相等，则予以更新，否则认为是过期数据，不予更新。</p><p>使用版本号的乐观锁的大致过程如下：</p><ol><li>step1: 查出商品剩余库存量<br>select remain_stock_num from item_stock where id = 100;</li><li>step2: 还有剩余库存，则录单<br>insert into order(id,item_id) values(null,100);</li><li>step3: 扣减商品库存<br>update item_stock set remain_stock_num = remain_stock_num - #{num},version = version + 1 where id = 100 and version = #{version};</li></ol><p>这种乐观锁实现的并发控制虽然可以解决问题，但是锁的范围太大了，即业务感知上会有大量的操作失败。根本原因是，大量的库存查询确实存在，但是扣减的时候只有一个会成功。那如何尽可能地保证成功呢？可以采用条件限制实现的乐观锁方式，它的锁粒度更小，最大程度的提高并发能力。大概过程如下：</p><ol><li>step1: 查出商品剩余库存量<br>select remain_stock_num from item_stock where id = 100;</li><li>step2: 还有剩余库存，则录单<br>insert into order(id,item_id) values(null,100);</li><li>step3: 扣减商品库存<br>update item_stock set remain_stock_num = remain_stock_num - #{num} where id = 100 and remain_stock_num &gt;= #{num};</li></ol><p>通过 <code>remain_stock_num &gt;= #{num}</code> 条件，既实现了数据安全校验，又提高了并发性能。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>悲观锁和乐观锁各有优缺点，乐观锁适用于读多写少的情况下，即冲突真的很少发生的时候，这样可以省去不少的开销，加大系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致业务方会不断的进行 retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p><p>不过随着互联网架构的演进，对并发和性能要求越来越高，悲观锁已经越来越少的被应用到生产环境中了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;数据库的锁机制是并发控制的重要手段，是保证数据正确性的最后的一道屏障。而锁的种类和范围，对并发控制的程度和效率又不大一样。本篇文章将围绕&lt;s
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://gentryhuang.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis原理 - SCAN 原理</title>
    <link href="https://gentryhuang.com/posts/c1861d8c/"/>
    <id>https://gentryhuang.com/posts/c1861d8c/</id>
    <published>2022-03-12T14:14:47.000Z</published>
    <updated>2022-05-10T08:55:22.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SCAN 命令在 Redis 早期版本中就支持，主要是为了解决 Redis 去批量获取 key 时造成的阻塞情况。如 KEYS 命令是获取所有命令，这是一种阻塞操作，这里就可以使用 SCAN 命令来尽可能避免 Redis 的阻塞。</p><p>SCAN 命令的复杂度虽然是 O(N)，但它是分次进行的，不会阻塞线程。</p><h2 id="SCAN-命令集"><a href="#SCAN-命令集" class="headerlink" title="SCAN 命令集"></a>SCAN 命令集</h2><p>SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令<strong>都用于增量地迭代集合类元素</strong>。</p><ul><li>SCAN 命令用于迭代当前数据库中的数据库键；</li><li>SSCAN 命令用于迭代集合键中的元素；</li><li>HSCAN 命令用于迭代哈希键中的键值对；</li><li>ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）;</li></ul><p>以上列出的四个命令都支持<strong>增量式迭代</strong>， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题。当 KEYS 命令被用于处理一个大的数据库时，又或者 SMEMBERS 命令被用于处理一个大的集合键时，它们可能会阻塞服务器达数秒之久。</p><p>不过，增量式迭代命令也有很大的缺点，比如在对键进行增量式迭代的过程中，键可能会被修改；字典在进行 rehash 时，缩容的情况会造成重复读取数据；在增量迭代过程，如果增加或删除元素在一定程度上也会导致问题（如果把增量迭代看作完整的过程）。所以增量式迭代命令只能对被返回的元素提供有限的保证。</p><h2 id="SCAN-命令的基本用法"><a href="#SCAN-命令的基本用法" class="headerlink" title="SCAN 命令的基本用法"></a>SCAN 命令的基本用法</h2><p> SCAN 、 SSCAN 、 HSCAN 和 ZSCAN 四个命令的工作方式都非常相似，它们的区别如下：</p><ul><li>SSCAN 命令、 HSCAN 命令和 ZSCAN 命令的第一个参数总是一个数据库键；</li><li>SCAN 命令则不需要在第一个参数提供任何数据库键 —— 因为它迭代的是当前数据库中的所有数据库键。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> SCAN 命令</span></span><br><span class="line">127.0.0.1:6379&gt; SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]</span><br><span class="line"><span class="meta">#</span><span class="bash"> SSCAN 命令</span></span><br><span class="line">127.0.0.1:6379&gt; SSCAN key cursor [MATCH pattern] [COUNT count]</span><br></pre></td></tr></table></figure><p>SCAN 命令是一个基于游标的迭代器，也就是 SCAN 命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数， 以此来延续之前的迭代过程。</p><p>当 SCAN 命令的游标参数被设置为 0 时， 服务器将开始一次新的迭代， 而当服务器向用户返回值为 0 的游标时， 表示迭代已结束。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>以下是一个 SCAN 命令的迭代过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; scan 0</span><br><span class="line">1) "17"</span><br><span class="line">2)  1) "key:12"</span><br><span class="line">    2) "key:8"</span><br><span class="line">    3) "key:4"</span><br><span class="line">    4) "key:14"</span><br><span class="line">    5) "key:16"</span><br><span class="line">    6) "key:17"</span><br><span class="line">    7) "key:15"</span><br><span class="line">    8) "key:10"</span><br><span class="line">    9) "key:3"</span><br><span class="line">    10) "key:7"</span><br><span class="line">    11) "key:1"</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; scan 17</span><br><span class="line">1) "0"</span><br><span class="line">2) 1) "key:5"</span><br><span class="line">   2) "key:18"</span><br><span class="line">   3) "key:0"</span><br><span class="line">   4) "key:2"</span><br><span class="line">   5) "key:19"</span><br><span class="line">   6) "key:13"</span><br><span class="line">   7) "key:6"</span><br><span class="line">   8) "key:9"</span><br><span class="line">   9) "key:11"</span><br></pre></td></tr></table></figure><p>从上面的示例可以看到， SCAN 命令的回复是一个包含两个元素的数组， 第一个数组元素是用于进行下一次迭代的新游标， 而第二个数组元素则是一个数组， 这个数组中包含了所有被迭代的元素。</p><p>在第二次调用 SCAN 命令时， 命令返回了游标 0 ， 这表示迭代已经结束， 整个数据集已经被完整遍历过了。以 0 作为游标开始一次新的迭代， 一直调用 SCAN 命令， 直到命令返回游标 0 ， 我们称这个过程为一次完整遍历。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>SCAN 命令、 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都返回一个包含两个元素的 multi-bulk 回复： </p><ul><li>回复的第一个元素是字符串表示的无符号 64 位整数（游标）</li><li>回复的第二个元素是另一个 multi-bulk 回复， 这个 multi-bulk 回复包含了本次被迭代的元素。</li></ul><p>SCAN 命令返回的每个元素都是一个数据库键。</p><p>SSCAN 命令返回的每个元素都是一个集合成员。</p><p>HSCAN 命令返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。</p><p>ZSCAN 命令返回的每个元素都是一个有序集合元素，一个有序集合元素由一个成员（member）和一个分值（score）组成。</p><h3 id="SCAN-选项"><a href="#SCAN-选项" class="headerlink" title="SCAN 选项"></a>SCAN 选项</h3><h4 id="COUNT-选项"><a href="#COUNT-选项" class="headerlink" title="COUNT 选项"></a>COUNT 选项</h4><p>虽然增量式迭代命令不保证每次迭代所返回的元素数量， 但我们可以使用 <code>COUNT</code> 选项， 对命令的行为进行一定程度上的调整。 <code>COUNT</code> 选项的作用就是让用户告知迭代命令， 在每次迭代中应该从数据集里返回多少元素。注意， <code>COUNT</code> 选项只是对增量式迭代命令的一种提示，它只是一个参考值，因为 Redis 扫描数据是以哈希桶为单位的。</p><ul><li><code>COUNT</code> 参数的默认值为 <code>10</code> ；</li><li>在迭代一个足够大的、由哈希表实现的数据库、集合键、哈希键或者有序集合键时， 如果用户没有使用 <code>MATCH</code> 选项， 那么命令返回的元素数量通常和 <code>COUNT</code> 选项指定的一样， 或者比 <code>COUNT</code> 选项指定的数量稍多一些。</li><li>在迭代一个编码为整数集合（intset，一个只由整数值构成的小集合）、 或者编码为压缩列表（ziplist，由不同值构成的一个小哈希或者一个小有序集合）时， 增量式迭代命令通常会无视 <code>COUNT</code> 选项指定的值， 在第一次迭代就将数据集包含的<strong>所有元素</strong>都返回给用户。</li></ul><h4 id="MATCH-选项"><a href="#MATCH-选项" class="headerlink" title="MATCH 选项"></a>MATCH 选项</h4><p>和<code>keys</code>命令一样， 增量式迭代命令也可以通过提供一个 glob 风格的模式参数， 让命令只返回和给定模式相匹配的元素， 这一点可以通过在执行增量式迭代命令时， 通过给定 <code>MATCH &lt;pattern&gt;</code> 参数来实现。</p><p>需要注意的是， 对元素的模式匹配工作是在命令从数据集中取出元素之后， 向客户端返回元素之前的这段时间内进行的， 所以如果被迭代的数据集中只有少量元素和模式相匹配， 那么迭代命令或许会在多次执行中都不返回任何元素。</p><h3 id="SCAN-命令的保证"><a href="#SCAN-命令的保证" class="headerlink" title="SCAN 命令的保证"></a>SCAN 命令的保证</h3><p>SCAN 命令， 以及其他增量式迭代命令， 在进行完整遍历的情况下可以为用户带来以下保证： 从完整遍历开始直到完整遍历结束期间， 一直存在于数据集内的所有元素都会被完整遍历返回； 这意味着， 如果有一个元素， 它从遍历开始直到遍历结束期间都存在于被遍历的数据集当中， 那么 SCAN 命令总会在某次迭代中将这个元素返回给用户。</p><p>然而因为增量式命令<strong>仅仅使用游标来记录迭代状态</strong>， 所以这些命令带有以下缺点：</p><ul><li>同一个元素可能会被返回多次。 处理重复元素的工作交由应用程序负责， 比如说， 可以考虑将迭代返回的元素仅仅用于可以安全地重复执行多次的操作上。</li><li>如果一个元素是在迭代过程中被添加到数据集的， 又或者是在迭代过程中从数据集中被删除的， 那么这个元素可能会被返回， 也可能不会。</li></ul><p>因为迭代的所有状态都保存在游标里面， 而服务器无须为迭代保存任何状态， 所以客户端可以在中途停止一个迭代， 而无须对服务器进行任何通知。</p><p>使用间断的（broken）、负数、超出范围或者其他非正常的游标来执行增量式迭代并不会造成服务器崩溃， 但可能会让命令产生未定义的行为。未定义行为指的是， 增量式命令对返回值所做的保证可能会不再为真。只有两种游标是合法的：</p><ol><li>在开始一个新的迭代时， 游标必须为 <code>0</code> 。</li><li>增量式迭代命令在执行之后返回的， 用于延续（continue）迭代过程的游标。</li></ol><h3 id="SCAN-原理"><a href="#SCAN-原理" class="headerlink" title="SCAN 原理"></a>SCAN 原理</h3><p>Redis 使用了 Hash 表作为底层实现：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/data_structure/redis-practice-scan-1.png" alt></p><p>SCAN 命令就是对这个一维数组进行遍历，每次返回的游标值也都是这个数组的索引。如果不考虑字典的扩容缩容，直接按数组下标挨个遍历就行了。COUNT 参数表示遍历数据的数量，该值只是起到一个大致约束的作用，所以返回的结果取决于索引下挂接链表的长度，有些槽位可能是空的，还有些槽位上挂接的链表上的元素可能会有多个。</p><p>如果不考虑扩容与缩容，那么无论是从前遍历还是从后遍历都可以获取所有的key值。但是有扩容、缩容后就需要考虑遍历的<strong>准确性</strong>，是否存在重复遍历，是否存在遗漏的遍历。如果我们<strong>按照低位加法，即从前向后遍历</strong>，当扩容或者缩容时进行的rehash操作使得<strong>数据分散到不同的槽位，这就有可能发生重复遍历与遗漏遍历的情况</strong>。</p><p>因此，Redis 采用了<strong>高位加法进位</strong>计算游标的方式遍历集合，Redis 的 SCAN 命令遍历流程如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/data_structure/redis-practice-scan-2.png" alt></p><p>观察这张图，我们发现<strong>采用高位加法进位计算游标的遍历顺序，rehash 时游标指向的槽位在遍历顺序上是相邻的</strong>。这得益于 Redis rehash 机制:</p><ul><li>扩容时：原来属于 <code>1xx</code>槽位的所有元素分散到 <code>01xx</code>和 <code>11xx</code>槽位中，其中前者是原数组的槽位，后者是扩容的新数组的槽位；</li><li>缩容时：<code>1xx</code>槽位的所有元素由 <code>01xx</code>和11<code>xx</code>槽位中元素融合；</li></ul><p>假设当前即将要遍历 110 这个槽位 (橙色)，那么扩容发生时，当前槽位上所有的元素分散在槽位 0110 和 1110(深绿色)中，也就是在槽位的二进制数增加一个高位 0 或 1，其中 1110 就是通过<strong>高位加法进位</strong>算出的下个要扫描的槽位，该槽位对应了扩容的新数组的位置。这时我们可以直接从 0110 这个槽位开始往后继续遍历，0110 槽位之前的所有槽位都是已经遍历过的，这样就可以避免扩容后对已经遍历过的槽位进行重复遍历。注意，主线程在 <code>SCAN</code> 和 rehash 时只能进行一个。</p><p>再考虑缩容，假设当前即将要遍历 110 这个槽位 (橙色)，那么缩容时，当前槽位所有的元素分散在槽位 10(深绿色)和 110(橙色)中，其中槽位 10 也就是去掉槽位二进制最高位，这是通过<strong>高位加法进位</strong>算出的，该槽位对应了缩容的新数组的位置。这时我们可以直接从 10 这个槽位继续往后遍历，10 槽位之前的所有槽位都是已经遍历过的，但图中 010 这个槽位上的元素已经被遍历过了。可以理解为，对于遍历来说，缩容后 10 槽位的元素是 010 和 110 上挂接的元素的融合。</p><p>在使用SCAN命令时，<strong>不会漏key，但可能会得到重复的key，这主要和Redis的rehash机制有关</strong>。Redis的所有key存在一个全局的哈希表中，如果存入的key慢慢变多，在达到一定阈值后，为了避免哈希冲突导致查询效率降低，这个哈希表会进行扩容。与之对应的，key数量逐渐变少时，这个哈希表会缩容以节省空间。</p><ul><li>为什么不会漏 key：Redis在SCAN遍历全局哈希表时，采用<strong>高位加法进位</strong>的方式遍历哈希桶，当哈希表扩容后，通过这种算法遍历，旧哈希表中的数据映射到新哈希表，<strong>依旧会保留原来的先后顺序</strong>，这样就可以保证遍历时不会遗漏也不会重复。</li><li>为什么会得到重复的key：这个情况主要发生在哈希表缩容。已经遍历过的哈希桶在缩容时，可能会映射到新哈希表没有遍历到的位置，所以继续遍历就会对同一个key返回多次。</li></ul><p>SCAN是遍历整个实例的所有key，另外Redis针对Hash/Set/Sorted Set也提供了HSCAN/SSCAN/ZSCAN命令，用于遍历一个key中的所有元素，建议在获取一个bigkey的所有数据时使用，避免发生阻塞风险。</p><p>Hash/Set/Sorted Set元素数量比较少时，底层会采用intset/ziplist方式存储，如果以这种方式存储，在执行HSCAN/SSCAN/ZSCAN命令时，会无视count参数，直接把所有元素一次性返回。</p><p>在分片集群场景下 SCAN 命令是无法跨节点扫描的，只能是一个节点一个节点的进行扫描。</p><h3 id="SCAN-源码分析"><a href="#SCAN-源码分析" class="headerlink" title="SCAN 源码分析"></a>SCAN 源码分析</h3><p>Redis 对 SCAN 命令集处理的底层函数是 <code>scanGenericCommand</code> 。下面我们对该函数处理的主要过程进行说明。</p><h4 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// 默认是 10</span></span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">10</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 输入类型检查，必须针对 集合类型或者数据库</span></span><br><span class="line">    serverAssert(o == <span class="literal">NULL</span> || o-&gt;type == OBJ_SET || o-&gt;type == OBJ_HASH ||</span><br><span class="line">                 o-&gt;type == OBJ_ZSET);</span><br><span class="line">    <span class="comment">// 设置第一个选项参数的索引位置</span></span><br><span class="line">    <span class="comment">// 0    1      2      3</span></span><br><span class="line">    <span class="comment">// SCAN OPTION &lt;op_arg&gt;         SCAN 命令的选项值从索引 2 开始</span></span><br><span class="line">    <span class="comment">// HSCAN &lt;key&gt; OPTION &lt;op_arg&gt;  而其他 *SCAN 命令的选项值从索引 3 开</span></span><br><span class="line">    i = (o == <span class="literal">NULL</span>) ? <span class="number">2</span> : <span class="number">3</span>; <span class="comment">/* Skip the key argument if needed. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 解析参数</span></span><br><span class="line">    <span class="comment">// 如 zscan key cursor [MATCH pattern] [COUNT count]</span></span><br><span class="line">    <span class="comment">// 如 scan cursor [MATCH pattern] [COUNT count] [TYPE type]</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; c-&gt;argc) &#123;</span><br><span class="line">        j = c-&gt;argc - i;</span><br><span class="line">        <span class="comment">// 1.1 todo COUNT count 参数，指定了扫描哈希桶的个数</span></span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr, <span class="string">"count"</span>) &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 1.2 MATCH pattern 参数，指定 key 的匹配模式</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr, <span class="string">"match"</span>) &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 1.3 特定类型参数 type ，只能用于 scan DB，也就是 scan 命令，不像 zscan 这种</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr, <span class="string">"type"</span>) &amp;&amp; o == <span class="literal">NULL</span> &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 1.4 error 参数项无法识别</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyErrorObject(c, shared.syntaxerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果给定了对象 o ，那么它必须是一个哈希对象或者集合对象，如果 o 为 NULL 的话，函数将使用当前数据库作为迭代对象。</p><h4 id="判断要扫描的是否是哈希表"><a href="#判断要扫描的是否是哈希表" class="headerlink" title="判断要扫描的是否是哈希表"></a>判断要扫描的是否是哈希表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">/* Handle the case of a hash table. */</span></span><br><span class="line">    <span class="comment">// 处理哈希表的情况</span></span><br><span class="line">    ht = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 扫描数据库</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ht = c-&gt;db-&gt;dict;</span><br><span class="line">        <span class="comment">// set 数据类型，使用哈希表编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_SET &amp;&amp; o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        ht = o-&gt;ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hash 数据类型，使用哈希表编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_HASH &amp;&amp; o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        ht = o-&gt;ptr;</span><br><span class="line">        count *= <span class="number">2</span>; <span class="comment">/* We return key / value for this type. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// zset 数据类型，非压缩编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_ZSET &amp;&amp; o-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = o-&gt;ptr;</span><br><span class="line">        ht = zs-&gt;dict;</span><br><span class="line">        count *= <span class="number">2</span>; <span class="comment">/* We return key / value for this type. */</span></span><br><span class="line">    &#125;  </span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断要扫描的集合，是否使用内存紧凑型结构。如果对象的底层实现为 ziplist 、intset 而不是哈希表，那么这些对象通常都只包含了少量元素， 因此，为了避免服务器记录迭代状态，我们将 ziplist 或者 intset 里面的所有元素都一次返回给调用者，无视 count 参数，并向调用者返回游标 cursor 0 。</p><h4 id="扫描哈希表"><a href="#扫描哈希表" class="headerlink" title="扫描哈希表"></a>扫描哈希表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"> <span class="comment">// 3.1 哈希表编码情况</span></span><br><span class="line">    <span class="keyword">if</span> (ht) &#123;</span><br><span class="line">        <span class="keyword">void</span> *privdata[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 我们将最大迭代次数设置为指定 COUNT 的 10 倍，因此如果哈希表处于病态状态（非常稀疏），我们可以避免以不返回或返回很少元素为代价而阻塞太多时间。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> maxiterations = count * <span class="number">10</span>;</span><br><span class="line">        privdata[<span class="number">0</span>] = keys;</span><br><span class="line">        privdata[<span class="number">1</span>] = o;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描约 count 数量的数据</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 返回下次扫描的游标</span></span><br><span class="line">            <span class="built_in">cursor</span> = dictScan(ht, <span class="built_in">cursor</span>, scanCallback, <span class="literal">NULL</span>, privdata);</span><br><span class="line">                <span class="comment">// 游标不为 0</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">cursor</span> &amp;&amp; </span><br><span class="line">                 <span class="comment">// 递减迭代次数</span></span><br><span class="line">                 maxiterations-- &amp;&amp; </span><br><span class="line">      <span class="comment">// 扫描数据量达到指定的 count (一般都会大于 count ，因此扫描是以一个桶为单位）。一个桶不够，会扫描多个桶来凑count 大小</span></span><br><span class="line">                 listLength(keys) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) count); </span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，如果 SCAN 操作的数据结构是哈希表，那么就会采用<strong>高位加法进位的方式遍历哈希表</strong>，具体实现在 <code>dictScan</code>函数中。从以上代码可以看出：</p><ul><li>COUNT 参数项起到大致约束作用，告知 Redis 大约扫描 count 个数据；</li><li>这里设置了最大扫描哈希桶（槽位）的数量为 10*count ，目的是防止遇到过多空的哈希桶，一直达不到 count 的条件阻塞主线程；</li></ul><h5 id="高位加法进位遍历"><a href="#高位加法进位遍历" class="headerlink" title="高位加法进位遍历"></a>高位加法进位遍历</h5><p>由于 Redis 使用的是渐进式 rehash 机制，因此当 SCAN 命令执行时处于 rehash 阶段，就需要同时扫描新表和旧表，然后将结果返回客户端。</p><h6 id="未处于-rehash-过程"><a href="#未处于-rehash-过程" class="headerlink" title="未处于 rehash 过程"></a>未处于 rehash 过程</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> v, <span class="comment">// 游标</span></span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanFunction *fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanBucketFunction *bucketfn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *privdata)</span> </span>&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="keyword">const</span> dictEntry *de, *next;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> m0, m1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 跳过空字典</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 没有处于迁移过程，迭代只有一个哈希表的字典</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) &#123;</span><br><span class="line">        <span class="comment">// 指向哈希表</span></span><br><span class="line">        t0 = &amp;(d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 记录哈希表的 mask</span></span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指向游标 v 对应的哈希桶</span></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果游标 v 对应的哈希桶非空，则遍历游标 v 对应桶中的所有节点</span></span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            next = de-&gt;next;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = next;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        v |= ~m0;</span><br><span class="line">        <span class="comment">// 1）倒置游标 v</span></span><br><span class="line">        v = rev(v);</span><br><span class="line">        <span class="comment">// 2）加 1</span></span><br><span class="line">        v++;</span><br><span class="line">        <span class="comment">// 3）倒置加1后的游标 v</span></span><br><span class="line">        v = rev(v);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 正在迁移中，需要迭代两个哈希表</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 返回的游标是使用高位进位加法实现的</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据游标定位到哈希桶后，处理完后会紧接着计算下次使用的游标，而计算方法就是 <strong>高位加法进位</strong>。</p><p>下面举例进行说明：</p><p>假设当前哈希表有 4 个桶，也就是默认桶数量，使用 SCAN 命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCAN 0 MATCH * COUNT 1</span><br></pre></td></tr></table></figure><p>按照正规的操作步骤，假设得到一个完整的桶迭代顺序如下：</p><blockquote><p>0-&gt;2-&gt;1-&gt;3 ，转换成二进制为：00-&gt;10-&gt;01-&gt;11</p></blockquote><p>我们发现每次这个序列变化是，<strong>将游标倒置 -&gt; 加 1 -&gt; 再倒置</strong>。</p><p>要知道，普通二进制的加法，是从右往左相加、进位。而这个序列是从左往右相加、进位的。代码体现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1）倒置游标 v</span></span><br><span class="line">v = rev(v);</span><br><span class="line"><span class="comment">// 2）加 1</span></span><br><span class="line">v++;</span><br><span class="line"><span class="comment">// 3）倒置加1后的游标 v</span></span><br><span class="line">v = rev(v);</span><br></pre></td></tr></table></figure><h6 id="处于-rehash-过程"><a href="#处于-rehash-过程" class="headerlink" title="处于 rehash 过程"></a>处于 rehash 过程</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">unsigned</span> <span class="keyword">long</span> v, <span class="comment">// 游标</span></span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanFunction *fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       dictScanBucketFunction *bucketfn,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *privdata)</span> </span>&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="keyword">const</span> dictEntry *de, *next;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> m0, m1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 跳过空字典</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line">        <span class="comment">// 3 正在迁移中，需要迭代两个哈希表</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     </span><br><span class="line">        <span class="comment">// 3.1 指向两个哈希表，即 0 号和 1 号哈希表</span></span><br><span class="line">        t0 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        t1 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.1 确保 t0 比 t1 要小，即把字典中的两个哈希表较小的赋值给 t0</span></span><br><span class="line">        <span class="comment">// todo 这个是必须的，因为可能是扩容，也可能缩容。遍历顺序是先小表，再到表。</span></span><br><span class="line">        <span class="comment">// 扩容：小的是原哈希表</span></span><br><span class="line">        <span class="comment">// 缩容：小的是新哈希表</span></span><br><span class="line">        <span class="keyword">if</span> (t0-&gt;<span class="built_in">size</span> &gt; t1-&gt;<span class="built_in">size</span>) &#123;</span><br><span class="line">            t0 = &amp;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">            t1 = &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.3 记录两个哈希表的掩码</span></span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line">        m1 = t1-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">        <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 注意，rehash 的单位是哈希桶，因此数据要么在 3.3 中取到，要在 3.4 中取到 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.3 迭代 t0哈希表</span></span><br><span class="line">        <span class="comment">// 根据游标 v 定位到桶，并迭代桶中的所有节点</span></span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            next = de-&gt;next;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.4 迭代 t1 哈希表</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* Emit entries at cursor */</span></span><br><span class="line">            <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t1-&gt;table[v &amp; m1]);</span><br><span class="line">            <span class="comment">// 根据游标 v 定位到桶，并迭代桶中的所有节点</span></span><br><span class="line">            de = t1-&gt;table[v &amp; m1];</span><br><span class="line">            <span class="keyword">while</span> (de) &#123;</span><br><span class="line">                next = de-&gt;next;</span><br><span class="line">                fn(privdata, de);</span><br><span class="line">                de = next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Increment the reverse cursor not covered by the smaller mask.*/</span></span><br><span class="line">            v |= ~m1;</span><br><span class="line">            v = rev(v);</span><br><span class="line">            v++;</span><br><span class="line">            v = rev(v);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 当掩码差异覆盖的位不为零时继续</span></span><br><span class="line">            <span class="comment">// ^ 按位异或</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 返回的游标是使用高位进位加法实现的</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SCAN 命令处于 rehash 过程需要同时扫描新表和旧表，虽然扩容和缩容的情况使用的是同一套流程，但是意义上是不同的。下面对关键流程进行总结：</p><ol><li><p>根据字典中的两个哈希表的大小排序，将小的哈希表赋值给 t0，将大的哈希表赋值给 t1；</p></li><li><p>分别记录 t0、t1 的掩码值，用于后续根据游标计算桶的索引；</p></li><li><p>根据索引先后迭代 t0表、t1表；</p></li></ol><p>把 SCAN 扫描图再拿过来：</p><p><img src="/posts/c1861d8c/redis-practice-54.png" alt></p><p><strong>对于扩容来说，t0 是原数组，t1 是新数组：</strong></p><p>在读取游标 v 110 对应的槽位前，哈希表扩容了，此时原数组 t0 数组的 110 槽位的数据可能还在，也可能已经迁移到了新数组 t1 1110 槽位中。此时，SCAN 顺序是先 t0 的 110 槽位，再 t1 的 1110 槽位。可以看到，通过<strong>高位加法进位</strong>遍历，依旧会保留原来的先后顺序，这种情况可以保证遍历时不会遗漏也不会重复。</p><p><strong>对于缩容来说，t0 是新数组，t1 是原数组：</strong></p><p>在读取游标 v 110 对应的槽位前，哈希表缩容了，此时原数组 t1 数组的 110 槽位的数据可能还在，也可能已经迁移到了新数组 t0 10 槽位中。此时，SCAN 顺序是先 t0 的 10 槽位，再 t1 的 110 槽位。可以看到，通过<strong>高位加法进位</strong>遍历，虽然依旧会保留原来的先后顺序，但是出现了<strong>“往回读一个哈希桶”</strong>，要知道已经遍历过的哈希桶在缩容时，可能会映射到新哈希表没有遍历到的位置，所以继续遍历就会对同一个key返回多次。按照图中的就是，010 槽位的元素会被重复遍历，但 010 之前的都不会。</p><h4 id="扫描内存紧凑型结构"><a href="#扫描内存紧凑型结构" class="headerlink" title="扫描内存紧凑型结构"></a>扫描内存紧凑型结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"> <span class="comment">// 3.2 压缩模式，一次性返回所有数据，忽略 count</span></span><br><span class="line">    <span class="comment">// 3.2.1 整数编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_SET) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int64_t</span> ll;</span><br><span class="line">        <span class="keyword">while</span> (intsetGet(o-&gt;ptr, pos++, &amp;ll))</span><br><span class="line">            listAddNodeTail(keys, createStringObjectFromLongLong(ll));</span><br><span class="line">        <span class="comment">// 游标返回 0</span></span><br><span class="line">        <span class="built_in">cursor</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.2.2 ziplist b编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_HASH || o-&gt;type == OBJ_ZSET) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = ziplistIndex(o-&gt;ptr, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vll;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            ziplistGet(p, &amp;vstr, &amp;vlen, &amp;vll);</span><br><span class="line">            listAddNodeTail(keys,</span><br><span class="line">                            (vstr != <span class="literal">NULL</span>) ? createStringObject((<span class="keyword">char</span> *) vstr, vlen) :</span><br><span class="line">                            createStringObjectFromLongLong(vll));</span><br><span class="line">            p = ziplistNext(o-&gt;ptr, p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 游标返回 0</span></span><br><span class="line">        <span class="built_in">cursor</span> = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Not handled encoding in SCAN."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果对象的底层实现为 ziplist 、intset 而不是哈希表，那么这些对象通常都只包含了少量元素， 因此会将 ziplist 或者 intset 里面的所有元素都一次返回给调用者，无视 count 参数。</p><h4 id="匹配过滤"><a href="#匹配过滤" class="headerlink" title="匹配过滤"></a>匹配过滤</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// 4 如果指定了 key 的匹配模式，那么对扫描的结果进行过滤</span></span><br><span class="line">    node = listFirst(keys);</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        robj *kobj = listNodeValue(node);</span><br><span class="line">        nextnode = listNextNode(node);</span><br><span class="line">        <span class="keyword">int</span> filter = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Filter element if it does not match the pattern. */</span></span><br><span class="line">        <span class="keyword">if</span> (use_pattern) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Filter an element if it isn't the type we want. */</span></span><br><span class="line">        <span class="keyword">if</span> (!filter &amp;&amp; o == <span class="literal">NULL</span> &amp;&amp; <span class="keyword">typename</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Filter element if it is an expired key. */</span></span><br><span class="line">        <span class="keyword">if</span> (!filter &amp;&amp; o == <span class="literal">NULL</span> &amp;&amp; expireIfNeeded(c-&gt;db, kobj)) filter = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* Remove the element and its associated value if needed. */</span></span><br><span class="line">        <span class="keyword">if</span> (filter) &#123;</span><br><span class="line">            decrRefCount(kobj);</span><br><span class="line">            listDelNode(keys, node);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        node = nextnode;</span><br><span class="line">    &#125;</span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，对元素的模式匹配工作是在命令从数据集中取出元素之后， 向客户端返回元素之前的这段时间内进行的。</p><h4 id="返回扫描结果"><a href="#返回扫描结果" class="headerlink" title="返回扫描结果"></a>返回扫描结果</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">cursor</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 5 返回给客户端</span></span><br><span class="line">    <span class="comment">// 返回数据项是 2</span></span><br><span class="line">    addReplyArrayLen(c, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 第一项是 cursor</span></span><br><span class="line">    addReplyBulkLongLong(c, <span class="built_in">cursor</span>);</span><br><span class="line">    <span class="comment">// 第二项是值或是键值值，值：set和zset ，键值对：hash</span></span><br><span class="line">    addReplyArrayLen(c, listLength(keys));</span><br><span class="line">    <span class="keyword">while</span> ((node = listFirst(keys)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        robj *kobj = listNodeValue(node);</span><br><span class="line">        addReplyBulk(c, kobj);</span><br><span class="line">        decrRefCount(kobj);</span><br><span class="line">        listDelNode(keys, node);</span><br><span class="line">    &#125;</span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Redis 提供的 SCAN 命令就是用于增量迭代的。这个命令可以每次返回少量的元素，所以非常适合用来处理大的数据集的迭代。常见的使用场景如下：</p><ul><li>替代阻塞式的 <code>KEYS</code> 命令；</li><li>替代复杂度过高的集合查询命令，如 <code>SMEMBERS</code>、<code>LRANGE</code> 等。<br>虽然 SCAN 命令在效率上具有优势，但是也要注意它的缺陷，如有重复读取的可能、扫描过程对键值对的增删支持不友好。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;SCAN 命令在 Redis 早期版本中就支持，主要是为了解决 Redis 去批量获取 key 时造成的阻塞情况。如 KEYS 命令是获取所
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="SCAN" scheme="https://gentryhuang.com/tags/SCAN/"/>
    
  </entry>
  
  <entry>
    <title>MySQL - Double Write</title>
    <link href="https://gentryhuang.com/posts/e0c3e79e/"/>
    <id>https://gentryhuang.com/posts/e0c3e79e/</id>
    <published>2022-03-09T08:25:44.000Z</published>
    <updated>2022-04-14T08:54:16.950Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Double-Write-介绍"><a href="#Double-Write-介绍" class="headerlink" title="Double Write 介绍"></a>Double Write 介绍</h3><p>为了保证数据写入的可靠性，InnoDB 引入了 Double Write 特性。</p><p>具体来说，在刷脏页时先将脏页写入 double write 段中进行备份，写入成功后再将脏页写入数据文件中，保证页面的完整性。</p><h3 id="partial-write"><a href="#partial-write" class="headerlink" title="partial write"></a>partial write</h3><p>InnoDB的数据页默认是 16K ，而文件系统的数据页是 4K，磁盘IO操作是按页为单位进行读写的。这就可能出现数据库对一个 16K 的数据页操作后，触发刷盘动作，在该过程中可能数据库宕机导致没有完全将 16K 数据页写到磁盘，这种页就不是一个完整的页，这种现象称为 <strong>partial write</strong> 。</p><p>要知道，redo log 恢复数据的前提是页是完整的，数据页不完整是没办法使用 redo log 恢复的。那如果发生 <strong>partial write</strong> 该怎么办？为了解决这个问题， InnoDB 引入了 <strong>Double Write</strong> 特性。</p><h3 id="double-write-原理"><a href="#double-write-原理" class="headerlink" title="double write 原理"></a>double write 原理</h3><p>当 InnoDB 中有数据要变动，会先将其在 Buffer Poll 中的 page 进行更新，并且会记录对应的变动信息到 redo log 中，此时 Buffer Pool 中的该 page 就会被标记为 dirty page（脏页）。在适当的时候，如 Buffer Pool不够、dirty page 在 Buffer Pool 中的比例达到阈值设定等，这些 dirty page 会被刷新到磁盘。</p><p>在 dirty page 刷盘过程中，如果突然断电或系统奔溃，16K 的 dirty page 可能只有 4K 或 8K 被写到磁盘上。此时，磁盘上的数据页就被破坏了，是不完整的页，不可使用。</p><p>Double Write 机制就是为了解决这个问题的。当将脏数据刷新到磁盘时，会先将脏数据复制到内存中的 <code>double write buffer</code>，之后将该内存数据分 2 次，每次写入 1M 到共享表空间进行持久化备份。写入成功后，再将 dirty page 从 Buffer Pool 刷新到数据文件。</p><h3 id="Double-Write-恢复流程"><a href="#Double-Write-恢复流程" class="headerlink" title="Double Write 恢复流程"></a>Double Write 恢复流程</h3><p>dirty page 刷盘过程中，如果发生了系统宕机或断电，16K 的数据只有 4K 或者 8K 被写到磁盘上，InnoDB 崩溃恢复时发现 page 损坏（比较页面的checksum），直接从共享表空间的 double write 中找到该页的一个最近的副本，复制到数据文件，再应用 redo log 就完成了恢复过程。因为有副本所以也不担心表空间中数据页是否损坏。</p><p>如果在将 dirty page 从内存的 <code>double write buffer</code> 写到共享表空间过程中发生了宕机情况，此时数据文件中的 page 还是干净的，奔溃恢复时 InnoDB 可以利用 redo log 来进行数据的恢复。</p><h3 id="Double-Write-流程"><a href="#Double-Write-流程" class="headerlink" title="Double Write 流程"></a>Double Write 流程</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-db-write-process.png" alt></p><p>从 Double Write 流程图中可以看出，在奔溃恢复的时候，还使用到了 redo log 。这是因为有些 dirty page 的改动并没有写入到共享表空间的 double write 中，这部分数据需要使用 redo log 来恢复。</p><h3 id="附加"><a href="#附加" class="headerlink" title="附加"></a>附加</h3><p>一般来说，开启 Double Write 的性能会降低5%~25%的样子，但还是建议使用 Double Write 来保证数据写入的可靠性。</p><ul><li><p>是否开启 Double Write</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-db-write-param.jpg" alt></p><p>innodb_doublewrite 参数控制是否打开 Double Write，默认开启状态。</p></li></ul><ul><li><p>Double Write 使用情况</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/sql/mysql/mysql-db-write-use.jpg" alt></p></li></ul><p>上图显示，从 Buffer Pool 一共将 22842199 个 page 复制到 <code>double write buffer</code> 中，一共刷盘 1959018 次到系统表空间。相当于每次刷盘了 22842199/1959018 ~= 11.67 个数据页。从这里也能看出，开启 Double Write 不会对效率产生很大影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Double-Write-介绍&quot;&gt;&lt;a href=&quot;#Double-Write-介绍&quot; class=&quot;headerlink&quot; title=&quot;Double Write 介绍&quot;&gt;&lt;/a&gt;Double Write 介绍&lt;/h3&gt;&lt;p&gt;为了保证数据写入的可靠性，InnoD
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://gentryhuang.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>队列 - DelayQueue</title>
    <link href="https://gentryhuang.com/posts/db98efcf/"/>
    <id>https://gentryhuang.com/posts/db98efcf/</id>
    <published>2022-02-25T13:10:53.000Z</published>
    <updated>2022-05-10T08:53:44.444Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>DelayQueue 是一个<strong>线程安全的、无界的、延时阻塞</strong>的队列。线程安全体现在使用 <code>ReentrantLock</code> 保证并发安全；无界队列体现在内部使用 <code>PriorityQueue</code> 优先级队列作为容器维护元素；延时阻塞体现在队列元素必须实现 Delayed 接口，使元素对象成为<strong>延时对象</strong>。此外，Delayed 接口继承了 Comparable 接口，这样元素的优先级也就能保证了。</p><p>DelayQueue 保证<strong>只有在延迟期满时才能从中取出元素</strong>，否则就要阻塞等待剩余的到期时间。DelayQueue 相关的 UML 类图如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/delay-queue-1.png" alt></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>DelayQueue 相关源码结构如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/delay-queue-2.png" alt></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueue</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Delayed</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证线程安全的锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记取元素时是否有线程在排队，减少不必要的竞争</span></span><br><span class="line">    <span class="comment">// leader 不为空，说明有线程在等待元素，后来的线程乖乖地等着就行了，直到被唤醒</span></span><br><span class="line">    <span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否可获取元素的条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>lock：</strong>用于并发控制的可重入独占锁；</li><li><strong>available：</strong>获取元素时，如果队列为空，则线程进入该条件队列等待队列非空；</li><li><strong>q：</strong>优先级队列，DelayQueue 把元素的存储和维护交给了优先级队列，在上层进行并发控制和延迟处理逻辑；</li><li><strong>leader：</strong>标记在取元素的过程中等待的线程，有了这个标记可以减少不必要的竞争；</li><li><strong>E extends Delayed：</strong>说明队列元素必须实现 Delay 接口，这个是延时的关键；</li></ul><p>从属性可以知道，DelayQueue 主要是用优先级队列 PriorityQueue 来实现，并使用重入锁和条件来控制并发安全。由于优先级队列可以看作是无界的，所以这里只需要一个非空条件就可以了。</p><h3 id="Delayed"><a href="#Delayed" class="headerlink" title="Delayed"></a>Delayed</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在给定的时间单位内返回与此对象关联的剩余延迟</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 剩余的延迟；零或负值表示延迟已经过去</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Delayed 是一个继承自 Comparable 的接口，并且定义了一个 getDelay 方法，用于表示还有多少时间到期，到期了应返回小于等于 0 的数值。DelayQueue 要求其中的元素必须实现 Delayed 接口，这有两个意义：</p><ul><li>DelayQueue 内部是使用 PriorityQueue 这个优先级队列来存放和维护元素的，也就是说元素必须要有一定的顺序，而 DelayQueue 继承了 Comparable 接口，因此有序性就可以交给使用方了；</li><li>DelayQueue 是一个具有延时特性的队列，而 Delayed 接口的 getDelay 方法就可以描述元素的到期时间，元素通过实现该接口成为延迟对象；</li></ul><p><strong>注意：</strong>根据 DelayQueue 队列的意义，一般我们是将元素的剩余延迟时间作为元素优先级的，这样的话在队列头的元素一定具有最小的剩余延时时间（最先过期）。这个逻辑是在 Comparable 接口的比较方法中完成。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个空的 DelayQueue </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定集合创建 DelayQueue </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection of elements to initially contain</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection or any</span></span><br><span class="line"><span class="comment"> *         of its elements are null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DelayQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DelayQueue 构造方法本身没有什么可说的，我们对隐藏的两个信息进行说明：</p><ul><li>DelayQueue 中封装的 PriorityQueue 在实例化时就创建了，使用的是默认的构造方法；</li><li>DelayQueude 中封装的 PriorityQueue 对象是通过其默认构造方法创建的，也就意味着底层使用的是小顶堆，而且是根据元素自然顺序排序；</li></ul><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>由于 DelayQueue 内部使用的是优先级队列 PriorityQueue ，可以认为它是无界的，所以不会出现队列满了而阻塞入队线程的情况，因此入队的方法其实都是一样的。</p><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入此延迟队列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是对 offer 方法的简单封装调用。</p><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将指定元素插入此延迟队列。由于队列是无限的，这个方法永远不会阻塞。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是对 offer 方法的简单封装调用。</p><h4 id="超时等待-offer"><a href="#超时等待-offer" class="headerlink" title="超时等待 offer()"></a>超时等待 offer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将指定元素插入此延迟队列。由于队列是无限的，这个方法永远不会阻塞。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout This parameter is ignored as the method never blocks 此参数被忽略，因为该方法从不阻塞</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit This parameter is ignored as the method never blocks 此参数被忽略，因为该方法从不阻塞</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="offer"><a href="#offer" class="headerlink" title="offer()"></a>offer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入此延迟队列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将元素加入到优先队列中，会自动保证优先级</span></span><br><span class="line">        q.offer(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果添加的元素是堆顶元素</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            <span class="comment">// leader 需要置空，因为现在堆顶出现了新的元素，可能添加的时候就要过期，因此需要让等待的线程尝试获取下，</span></span><br><span class="line">            <span class="comment">// 因此 leader 这个等待获取堆顶元素的标记可以置空了</span></span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒可取条件队列上等待的线程，让其尝试获取元素</span></span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法是入队的核心方法，还是比较简单的，下面对关键点进行说明：</p><ol><li>在添加元素时需要加锁成功才行，保证了线程安全；</li><li>添加元素到优先级队列，一般都会成功，因为优先级队列可以认为是无界的；</li><li><strong>如果添加的元素成为了堆顶元素，就需要特别处理：</strong><ul><li>因为新添加的元素成为了堆顶元素，这个元素可能就要过期，因此需要对等待进行处理；</li><li>将正在等待堆顶的元素的标志置空和唤醒条件队列上等待的线程来<strong>尽可能及时</strong>获取堆顶元素；</li></ul></li><li>释放锁；</li></ol><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>DelayQueue 是一个延时阻塞队列，入队不会出现阻塞的情况，因为内部使用的优先级队列 PriorityQueue 可以认为是无界的。但是出队时可能会遇到队列为空的情况，这时会出现三种情况：阻塞式出队、非阻塞式出队以及阻塞超时出队。下面我们依次说明。</p><h4 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h4><p>出队阻塞方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检索并移除队列的头部元素，如有必要，则阻塞等待直到队列上有一个具有到期的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the head of this queue 队列头部元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125; 中断异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 自旋</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取堆顶元素</span></span><br><span class="line">            E first = q.peek();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为空则进入等待，阻塞式获取元素</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 堆顶不为空</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取元素的超时时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="comment">// 判断是否到期，到期直接弹出即可</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 执行到这里，说明堆顶元素还没有到期，不能弹出*/</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 要进入等待了，需要设置为 null</span></span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检验前面是否已有等待获取元素的线程，有的话就直接进入等待（快速进入等待）</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 还没有等待获取元素的线程，就把自己设置为等待线程，然后进入超时等待</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 等待的时间是，堆顶元素剩余的过期时间</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 唤醒后就把 leader 置空</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 没有等待元素的线程，并且队列还有数据，就唤醒下一个线程来取（如果有的话）</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队本身逻辑还是比较简单的，先判断堆顶元素是否为空，为空就直接阻塞等待；不为空也不能直接弹出，还要先判断堆顶元素是否到期了，没到期就等待剩余过期时间后再尝试获取、判断，到期了就直接弹出即可。</p><p>出于线程安全性、线程通信等方面的考虑，整个逻辑相对更完整和复杂一些：</p><ol><li>只有获取到锁才能进行出队操作；</li><li>判断堆顶元素是否为空，为空的话直接阻塞等待；</li><li>判断堆顶元素是否到期，到期了直接调用优先级队列的poll()弹出元素；</li><li>没到期，再根据等待标志 leader 快速判断前面是否有其它线程在等待，有则直接进入等待直到被唤醒，<strong>以减少不必要的竞争</strong>；</li><li>如果在此之前没有其它线程等待获取元素，则把自己设置为等待标记，这样可以让后续获取元素的线程直接进入等待；然后当前线程等待剩余的过期时间后会再尝试获取元素；</li><li>获取到元素之后再尝试唤醒下一个等待的线程；</li><li>释放锁；</li></ol><p><strong>注意：</strong>该方法使用自旋的作用，一方面是阻塞式获取，必须要返回一个到期的元素；另一方面是防止假唤醒；</p><p>这里我们不难看出，如果所有其他线程因为 leader 标志而阻塞等待，此时刚好进来一个最先过期的元素，那么是不是只能等待线程自动醒来呢？其实不是的，在 offer 方法中会判断这种情况，如果加入的是最先过期的元素，那么会唤醒一个阻塞线程，以通知尽快获取元素。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h4><p>出队非阻塞方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检索并删除队列的头部元素，如果队列没有具有到期的元素，则返回 null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回到期的元素，否则返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从优先队列中获取元素</span></span><br><span class="line">        E first = q.peek();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果为空，或者没有到期，则返回空</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 到期则取出堆顶元素</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> q.poll();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poll 方法相对 take 方法是快速失败，没有元素或元素没有到期不会等待，而是直接返回 null。</p><p>同样的套路，DelayQueue 在 take 方法和 poll 方法之间进行了折中，可以超时等待获取元素。具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * 检索并删除队列的头部元素，如有必要，等待直到队列上有一个具有到期的元素，或指定的等待时间过期。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the head of this queue, or &#123;<span class="doctag">@code</span> null&#125; if the</span></span><br><span class="line"><span class="comment">  * specified waiting time elapses before an element with</span></span><br><span class="line"><span class="comment">  * an expired delay becomes available</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="comment">// 计算超时等待的时长</span></span><br><span class="line">     <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 自旋</span></span><br><span class="line">         <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">             <span class="comment">// 获取堆顶元素</span></span><br><span class="line">             E first = q.peek();</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 队列为空，则进入超时等待</span></span><br><span class="line">             <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">// 等待时间到了，还是为空，则返回 null</span></span><br><span class="line">                 <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                     nanos = available.awaitNanos(nanos);</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 队列非空</span></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 获取元素的超时时间</span></span><br><span class="line">                 <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 判断是否到期，到期直接弹出即可</span></span><br><span class="line">                 <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                     <span class="keyword">return</span> q.poll();</span><br><span class="line">                 </span><br><span class="line">                 </span><br><span class="line">                 <span class="comment">/* 执行到这里，说明堆顶元素还没有到期，还不能弹出*/</span></span><br><span class="line"></span><br><span class="line">                 <span class="comment">// 判断超时时间到了没</span></span><br><span class="line">                 <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                 first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                 </span><br><span class="line">                 <span class="comment">// 当前超时小于到期剩余时间，或者前面已经有等待的线程了</span></span><br><span class="line">                 <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>)</span><br><span class="line">                     nanos = available.awaitNanos(nanos);</span><br><span class="line">                 </span><br><span class="line">                 <span class="keyword">else</span> &#123;</span><br><span class="line">                     Thread thisThread = Thread.currentThread();</span><br><span class="line">                     leader = thisThread;</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</span><br><span class="line">                         </span><br><span class="line">                         <span class="comment">// 计算剩余等待时长</span></span><br><span class="line">                         nanos -= delay - timeLeft;</span><br><span class="line">                     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                         <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                             leader = <span class="keyword">null</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">             available.signal();</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取堆顶元素但不删除</span></span><br><span class="line">        <span class="keyword">return</span> q.peek();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 从队列中删除指定元素（如果存在），无论它是否已过期。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 获取锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">     lock.lock();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 从优先级队列中删除该元素</span></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> q.remove(o);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 释放锁</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>DelayQueue 主要适用于定时任务。任务调度系统能够相对准确的把握任务的执行时间。为了具有调用行为，存放到 DelayDeque 的元素必须实现 Delayed 接口。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>DelayQueue 是一个线程安全的、无界的、延时阻塞队列，它使用的是优先级队列 PriorityQueue + 时间维度（到期时间）来实现。具体来说，是在队列的基础上增加了时间维度的优先级，然后通过锁和条件变量来控制入队和出队流程。</p><p>DelayQueue 为了减少不必要的竞争，使用了 <code>Thread leader</code> 来进行优化，作为快速进入条件队列等待的标志。</p><p>ScheduledThreadPoolExecutor 同样支持延时任务，它内部使用的阻塞队列是自己定义的内部类 DelayedWorkQueue ，这个内部类的功能和 DelayQueue 基本一样，唯一区别点是 DelayedWorkQueue 没有直接使用优先级队列 PriorityQueue，而是使用数组又实现了一遍优先级队列，本质上是没什么区别的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;DelayQueue 是一个&lt;strong&gt;线程安全的、无界的、延时阻塞&lt;/strong&gt;的队列。线程安全体现在使用 &lt;code&gt;Reent
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="Queue" scheme="https://gentryhuang.com/tags/Queue/"/>
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>队列 - PriorityQueue</title>
    <link href="https://gentryhuang.com/posts/62ea789a/"/>
    <id>https://gentryhuang.com/posts/62ea789a/</id>
    <published>2022-02-12T03:38:34.000Z</published>
    <updated>2022-05-10T02:39:06.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>队列是一种<strong>先进先出（FIFO）的数据结构</strong>。但有些情况下，操作的数据可能带有优先级，出队时需要优先级高的元素先出队列，这种数据结构就是<strong>优先级队列</strong>，也是我们今天的主角 <code>PriorityQueue</code>。</p><p>一般来说，优先级队列使用堆来实现，关于堆的简单介绍可以参考这里 <a href="https://gentryhuang.com/posts/d917ae55/">堆的简单介绍</a>。PriorityQueue 正是通过堆来实现优先级队列的。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>PriorityQueue 相关源码结构如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/priority-queue-1.png" alt></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7720805057305804111L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储元素的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] queue; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先级队列中的元素数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较器，如果优先级队列使用元素的自然顺序，则为 null。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先级队列的写次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line">        </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>PriorityQueue 主要有以下五个属性，下面对每个属性的作用进行说明：</p><ul><li><strong>DEFAULT_INITIAL_CAPACITY</strong> PriorityQueue 的默认容量为 11；</li><li><strong>queue:</strong> PriorityQueue 核心是使用堆来组织数据，该数组就是用来存放元素的；</li><li><strong>size:</strong> 用来记录优先级队列中元素的个数，也就是数组中的元素个数；</li><li><strong>comparator:</strong> 元素比较器，在 PriorityQueue 中有两种方式比较元素，一种是元素的自然顺序，这个要求元素实现 Comparable 接口；另一种是通过指定的比较器来比较，如果使用元素自然顺序，则该属性可以为 null；</li><li><strong>modCount:</strong> 记录对 PriorityQueue 进行写操作的次数，用于实现 <code>fast-fail</code>。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个默认初始容量为 11 的 PriorityQueue，它根据元素的自然顺序对其元素进行排序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个指定容量大小的 PriorityQueue，它根据元素的自然顺序对其元素进行排序。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity the initial capacity for this priority queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> initialCapacity&#125; is less</span></span><br><span class="line"><span class="comment"> *                                  than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个默认初始容量为 11 的 PriorityQueue，它根据指定的比较器对其元素进行排序。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator the comparator that will be used to order this</span></span><br><span class="line"><span class="comment"> *                   priority queue.  If &#123;<span class="doctag">@code</span> null&#125;, the &#123;<span class="doctag">@linkplain</span> Comparable</span></span><br><span class="line"><span class="comment"> *                   natural ordering&#125; of the elements will be used.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity  优先级队列的初始容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> comparator       将用于排序此优先级队列的比较器。如果为 null，将使用元素的 &#123;<span class="doctag">@linkplain</span> Comparable 自然排序&#125;。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> initialCapacity&#125; is less than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">    <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建数组容器</span></span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置元素比较器，可以为空</span></span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入此优先级队列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException   if the specified element cannot be</span></span><br><span class="line"><span class="comment"> *                              compared with elements currently in this priority queue</span></span><br><span class="line"><span class="comment"> *                              according to the priority queue's ordering</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用 offer 方法</span></span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，add 方法是直接调用 offer 方法的。</p><h4 id="offer"><a href="#offer" class="headerlink" title="offer()"></a>offer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定元素插入此优先级队列。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 成功返回 true，不成功会抛出异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException  要添加的元素不能和队列中的元素比较</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException 要添加的元素为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 元素不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递增写次数</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取优先级队列元素个数</span></span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素个数达到最大容量，需要先扩容</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素个数加 1</span></span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列还没有元素，直接插入到数组第一个位置，不需要进行比较、调整堆</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列有元素，做自下而上的堆调整</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>要添加的元素不能为空（空了怎么参与比较呢）；</li><li>在添加元素之前，判断队列中元素个数是否达到队列最大容量阈值；</li><li>将队列中元素个数加 1；</li><li>如果队列中没有元素，那么直接将元素放到数组的第一个位置，也就是下标为 0 的位置，这样就不需要执行比较、调整堆的流程了；</li><li>如果队列中有元素，就执行堆的<strong>自下而上</strong>的调整逻辑；</li></ol><h5 id="grow"><a href="#grow" class="headerlink" title="grow()"></a>grow()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity 所需的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列原始长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">    <span class="comment">// 旧容量小于 64 时，容量翻倍 + 2</span></span><br><span class="line">    <span class="comment">// 旧容量大于等于 64 ，容量只增加旧容量的一半</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">            (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">            (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">// 保证新容量的大小不溢出</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建出一个新容量大小的新数组并把旧数组元素拷贝过去</span></span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grow 方法是 PriorityQueue 内部使用的方法，当队列中的元素个数达到队列容量时，就会使用该方法进行扩容。PriorityQueue 扩容可总结为 <strong>“一策略、一注意事项”</strong>，具体如下：</p><ul><li><strong>扩容策略：</strong>当队列（数组）比较小（小于 64）时，容量扩大一倍 + 2；不小于 64 时，容量扩大一半；</li><li><strong>扩展注意事项：</strong>计算出新的容量后，需要限制最大容量，不能超过 <code>Integer.MAX_VALUE</code>，这个是由 <code>hugeCapacity</code> 方法控制的： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 最大容量限制</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> minCapacity</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 容量不能 &lt; 0</span></span><br><span class="line">     <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 最大使用 Integer.MAX_VALU</span></span><br><span class="line">     <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">             Integer.MAX_VALUE :</span><br><span class="line">             MAX_ARRAY_SIZE;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="siftUp"><a href="#siftUp" class="headerlink" title="siftUp()"></a>siftUp()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k the position to fill 计划要插入的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the item to insert 要插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据是否有比较器，使用不同的方法</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 使用比较器排序</span></span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 按照元素自然顺序</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会根据是否指定了元素比较器，进而执行不同的分支<strong>自下而上</strong>调整堆。由于无论是使用元素自然顺序比较，还是使用比较器比较，逻辑是一致的，下面我们以按照元素自然顺序排序（实现 Comparable 接口)为例进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 按照元素自然顺序排序（实现 Comparable 接口）调整堆</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> k 要填补的位置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> x 要插入的元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 转化类型，这要求元素必须实现 Comparable 接口，否则必然报错</span></span><br><span class="line">       Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">       <span class="comment">// 自下向上调整堆</span></span><br><span class="line">       <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 找到父节点的位置， 因为元素是从0开始的，所以减1之后再除以2</span></span><br><span class="line">           <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 父节点的值</span></span><br><span class="line">           Object e = queue[parent];</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 比较插入的元素的值与父节点的值，如果比父节点大，则跳出循环，否则交换位置</span></span><br><span class="line">           <span class="comment">// todo 从这里也能看出是小顶堆</span></span><br><span class="line">           <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 与父节点交换位置，父节点位置空出来了</span></span><br><span class="line">           queue[k] = e;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 此时，元素要插入的位置移到了父节点的位置，继续与父节点再比较以调整堆</span></span><br><span class="line">           k = parent;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 最后找到应该插入的位置，放入元素</span></span><br><span class="line">       queue[k] = key;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上述方法的逻辑纯粹是堆添加元素时<strong>自下而上</strong>的调整堆的过程，使堆满足堆的特性。下面对该方法的细节之处进行说明：</p><ul><li>参数 k 表示目标元素 x 要插入的位置，这个 k 起始值其实就是数组最后一个元素的下个位置。注意，数组的下标是从 0 开始的，因此在从下往上找父节点时，先要减 1 再除以 2 才能获取正确的父节点的下标；</li><li>从代码来看，如果比父节点小就与父节点交换位置，直到出现比父节点大或者比较到了根节点为止。这也可以看出，默认情况下 PriorityQueue 是一个小顶堆；</li></ul><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><h4 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回堆顶元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取堆顶元素但不删除；</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列元素个数减 1</span></span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列写操作次数递增</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列首元素</span></span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列末元素</span></span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将队列末元素删除</span></span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队后队列中还有元素（因为移除的是堆顶元素，此时堆的特性不能满足，必须需要调整）</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将队列末元素移到队列首，再做自上而下的调整</span></span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回弹出的元素</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>队列为空，直接返回 null 即可；</li><li>队列非空，队列元素个数减 1；</li><li>将队列首元素弹出（此时堆顶元素就没了，堆的特性可能被破坏）；</li><li>取出队列末元素，将其作为<strong>参考的新的堆顶元素</strong>，为后续堆调整做准备；</li><li>如果队列在弹出元素后就为空了，那么就不需要调整堆了，否则需要做<strong>自上而下</strong>的堆调整；</li></ol><p><strong>注意：</strong>在出队的逻辑中，没有涉及到队列缩容的逻辑。</p><h5 id="siftDown"><a href="#siftDown" class="headerlink" title="siftDown()"></a>siftDown()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在位置 k 处插入项 x，即自上而下的堆调整。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k the position to fill 要填补的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the item to insert 要插入的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据是否有比较器，选择不同的方法进行元素的比较，进而调整堆</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，该方法会根据是否指定了元素比较器，进而执行不同的分支<strong>自上而下</strong>调整堆。由于无论是使用元素自然顺序比较，还是使用比较器比较，逻辑是一致的，这次我们以指定比较器的方式进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据比较器，自上而下调整堆</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 本质：将要插入的元素放入到它应该在的位置</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> k 要填补的位置</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> x 要插入的元素</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 调整的时候，是按照二分的思想往下寻找子节点的，这里只比较一半就可以了</span></span><br><span class="line">     <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 不断往下比较</span></span><br><span class="line">     <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 寻找子节点位置，这里加 1 是因为元素从 0 号位置开始</span></span><br><span class="line">         <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 左子节点的值</span></span><br><span class="line">         Object c = queue[child];</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 右子节点的位置</span></span><br><span class="line">         <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果右子节点存在，那么取左右节点中较小的值</span></span><br><span class="line">         <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                 comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">             c = queue[child = right];</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果要插入元素比子节点都小，则结束，说明找到对应的位置了</span></span><br><span class="line">         <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果比较小的子节点还大，则交换位置</span></span><br><span class="line">         queue[k] = c;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 指针移动到子节点位置，继续往下调整堆</span></span><br><span class="line">         k = child;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 找到正确的位置，放入元素</span></span><br><span class="line">     queue[k] = x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>同样地，上述方法的逻辑存粹是堆删除元素时<strong>自上而下</strong>的调整堆的过程，使堆满足堆的特性。下面堆该方法的细节之处进行说明：</p><ul><li>参数 k 表示目标元素要插入的位置，这个 k <strong>起始值是被删除的元素所在的下标</strong>。从上往下找子节点时先从左子节点开始，由于数组的下标是从 0 开始的，因此要先除以 2 再加 1 才能获取正确的左子节点下标；</li><li>从代码来看，使用的是比较器，因此 PriorityQueue 是小顶堆还是大顶堆取决于比较器；</li></ul><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 从队列中移除指定的元素，如果元素不存在，则返回 false</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o element to be removed from this queue, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this queue changed as a result of the call</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取指定元素在队列中的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果元素不存在，则返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果元素存在，则从队列中移除该元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 PriorityQueue 中移除指定的元素，需要执行两步操作：</p><ul><li>调用 indexOf 方法找到要移除的元素所在的下标；</li><li>调用 removeAt 方法将该下标所在元素置空，即删除该元素，然后从这个下标开始调整堆；</li></ul><h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定元素在优先级队列（数组）中的下标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回 -1 表示队列中没有该元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(queue[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="removeAt"><a href="#removeAt" class="headerlink" title="removeAt()"></a>removeAt()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队列中移除下标为 i 的元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert i &gt;= 0 &amp;&amp; i &lt; size;</span></span><br><span class="line">    <span class="comment">// 优先级队列写操作次数累加</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级队列数量减 1</span></span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是最后一个元素，直接删除即可</span></span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">// removed last element</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是最后一个元素，则需要从删除的位置，即下标 i 位置开始调整</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 moved 确实插入到了 i 位置，那么再尝试 自下而上调整堆</span></span><br><span class="line">        <span class="keyword">if</span> (queue[i] == moved) &#123;</span><br><span class="line">            siftUp(i, moved);</span><br><span class="line">            <span class="keyword">if</span> (queue[i] != moved)</span><br><span class="line">                <span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素过程涉及到的堆调整，和添加元素或弹出堆顶元素类似，唯一区别是前面两种是从数组末尾或数组的首开始调整，而上述方法是从<strong>中间位置</strong>开始调整的。逻辑都是一样的，唯一区别是在调整的位置。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>PriorityQueue 是一个优先级队列，内部使用数组作为存储数据的容器，<strong>元素的优先级依靠堆排序实现</strong>，排序的规则即可以根据元素自然顺序（元素实现 <code>Comparable</code> 接口），也可以根据自定义的元素比较器 <code>Comparator</code>。此外，该队列是一个无界队列(最大容量是 <code>Integer.MAX_VALUE</code> ，只会扩容不会缩容。</p><p>优先级队列 PriorityQueue 默认情况下是小顶堆，然而可以通过传入自定义的 Comparator 来实现大顶堆。注意，使用元素自然顺序只能实现小顶堆功能，从文中源码部分也能看出。具体如下：</p><blockquote><p>构造小顶堆：PriorityQueue small=new PriorityQueue&lt;&gt;();<br>构造大顶堆：PriorityQueue small=new PriorityQueue&lt;&gt;(Collections.reverseOrder());</p></blockquote><p>优先级队列 PriorityQueue 性能差，主要体现在添加元素、弹出元素时都有可能破坏堆的特性，为了保证堆的特性就需要调整堆。性能是和元素量成反比的。</p><p>优先级队列 PriorityQueue 是线程不安全的，从源码中也可以看出，没有使用锁机制，也没有使用 CAS 机制保证并发安全。与它对应的是 PriorityBlockingQueue 队列，这个队列是线程安全的，但是<strong>两者源码极其相似</strong>，后者使用了 <code>ReentrantLock lock</code> 和对应的 <code>Condition notEmpty</code> 以保证线程安全，其它的都类似。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;队列是一种&lt;strong&gt;先进先出（FIFO）的数据结构&lt;/strong&gt;。但有些情况下，操作的数据可能带有优先级，出队时需要优先级高的元素
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="Queue" scheme="https://gentryhuang.com/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 - 堆</title>
    <link href="https://gentryhuang.com/posts/d917ae55/"/>
    <id>https://gentryhuang.com/posts/d917ae55/</id>
    <published>2022-02-06T01:34:09.000Z</published>
    <updated>2022-05-10T02:34:29.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>堆是一种特殊的树，它有以下两个特点：</p><ul><li>堆是一颗完全二叉树；</li><li>堆中某个节点的值不大于或不小于父节点的值；</li></ul><p>其中，根节点的值是最大的堆叫做大顶堆，根节点的值是最小的堆叫做小顶堆。具体如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/data-structure/heap/heap-1.png" alt></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>前面也说了，堆是一颗完全二叉树。下图就是一颗完全二叉树，也是一个小顶堆：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/data-structure/heap/heap-2.png" alt></p><p>完全二叉树的节点都是比较紧凑的，并且具有一定的层次关系，所以可以使用数组来存储，这样比较节省空间。上图中的完全二叉树存放到数组中如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/data-structure/heap/heap-3.png" alt></p><p>这里为了方便描述，下标为 0 的位置不存储元素，从下标为 1 的位置开始存储元素。<strong>每层依次从左到右放到数组中，这样就可以保证父子节点的关系了</strong>。</p><ul><li>已知节点 8，那么 8 的父节点就是：5<code>/</code>2=2，也就是 5 这个节点的位置</li><li>已知节点 5，那么 5 的左右子节点分别是：2<code>*</code>2=4，也就是节点 7；2<code>*</code>2<code>+</code>1=5，也就是节点 8；</li></ul><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>堆中插入新的元素后，需要继续满足堆的两个特性：</p><ol><li>堆是一颗完全二叉树；</li><li>堆中某个节点的值要么不大于（或不小于）其父节点的值；</li></ol><p>为了满足特性 1，我们把新元素插入到最后一层的最后一个节点的后面，但是插入之后可能不再满足特性 2 ，这个时候就需要调整堆了。下面我们举例说明。</p><p>我们需要向前面的小顶堆中插入元素 2 ，我们把它放在 9 后面，这时虽然满足特性 1 ，但是不满足特性 2，这个时候就要调整堆。具体过程如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/data-structure/heap/heap-4.png" alt></p><p>上述调整过程的原则是，<strong>自下而上</strong>进行调整。</p><p><strong>从二叉树角度看：</strong>插入的节点与它的父节点相比，如果比父节点小，就交换它们的位置，重复这个过程，一直往上和父节点相比，直到比父节点大或者到根节点为止。<br><strong>从数组角度看：</strong>插入的节点与 <code>n/2</code> 位置的节点相比，如果比 <code>n/2</code> 位置的节点小，就交换它们的位置，再往前与 <code>n/4</code> 位置的节点相比，如果比 <code>n/4</code> 位置的节点小，就交换位置，以此类推，直到比 <code>n/(2^x)</code>位置的节点大或者到顶级父节点为止。</p><p>从插入元素的过程，我们可以知道插入元素的时间复杂度为 O(logn) 。</p><h3 id="弹出堆顶元素"><a href="#弹出堆顶元素" class="headerlink" title="弹出堆顶元素"></a>弹出堆顶元素</h3><p>从堆中弹出元素，同样需要继续满足堆的两个特性：</p><ol><li>堆是一颗完全二叉树；</li><li>堆中某个节点的值要么不大于（或不小于）其父节点的值；</li></ol><p>从堆顶弹出元素后，为了满足特性 1，我们把最有一个元素移到根节点（顶节点）的位置，但是不满足特性 2，这个时候需要调整堆。具体如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/data-structure/heap/heap-5.png" alt></p><p>上述调整过程的原则是，<strong>自上而下</strong>进行调整。</p><p><strong>从二叉树角度看：</strong>把最后一个节点放到堆顶，然后与左右子节点中较小的交换位置，重复这个过程，依次往下，直到其比左右子节点都小的或到达最后一层为止。<br><strong>从数组角度：</strong>把最后一个元素移到下标为 1 的位置，然后与下标为 2 和 3 的元素对比，发现 8 比 2 大，且 2 是下标为 2 和 3 中较小的，然后与 2 交换位置。依次类推，再和下标为 4 和 5 的元素对比，直到没有比其更小的元素或没有左右子节点为止。</p><p>从弹出堆顶元素的过程，我们可以知道对应的时间复杂度为 O(logn) 。</p><h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>建堆的过程其实就是依次插入元素的过程，一个元素的比较次数与它的高度成正比，建堆的时间复杂度为 O(n)。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>对于一个待排序的数组序列，可以将堆顶元素与第 n 个元素交换位置，再把前 n-1 个元素进行调整；再把堆顶元素与第 n-1 个元素交换位置，再把前 n-2 个元素进行调整；…..，以此类推。最后，数组中的元素就整个变成有序的了，排序也就完成了。</p><p>堆排序的时间复杂度为 O(nlogn)。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>堆是一种重要的数据结构，利用堆排序的场景有很多，比如 MySQL order by 语句可能会使用到堆排序；优先级队列会使用堆排序调整元素优先级；等等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;堆是一种特殊的树，它有以下两个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆是一颗完全二叉树；&lt;/li&gt;
&lt;li&gt;堆中某个节点的值不大于或不小于父节点
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
  </entry>
  
  <entry>
    <title>并发 - LinkedBlockingQueue</title>
    <link href="https://gentryhuang.com/posts/5d52709c/"/>
    <id>https://gentryhuang.com/posts/5d52709c/</id>
    <published>2022-02-04T01:05:14.000Z</published>
    <updated>2022-05-12T02:54:41.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LinkedBlockingQueue 是一个<strong>基于链表（单链表）</strong>实现的先进先出的阻塞队列，<strong>采用双锁技术</strong>，针对入队和出队操作分别使用了一把可重入的独占锁，在并发度上有一定的提升。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>LinkedBlockingQueue 相关的源码结构如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/linked-blocking-queue-1.png" alt></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 存放的元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        E item;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 后继指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 节点封装元素</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node(E x) &#123;</span><br><span class="line">            item = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的容量，默认容量是 Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列中元素的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的头节点，其封装的元素一直都是 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的尾节点，last.next 一直是 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 出队 take、poll 使用的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待出队的条件，即队列非空条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队 put、offer 使用的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待入队的条件，即队列非满条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>LinkedBlockingQueue 用于存放元素的结构是一个<strong>单向链表</strong>，链表中的每个节点是一个 Node 结构。此外，LinkedBlockingQueue 定义了以下的变量来<strong>描述和维护</strong>这个单向链表：</p><ul><li><strong>capacity:</strong> 队列的容量，即约束单向链表节点数量；</li><li><strong>count:</strong> 队列中元素的个数，即单向链表有效节点的数量；</li><li><strong>head:</strong> 单向链表的头节点，不存储元素，起到获取链表节点的作用；</li><li><strong>last:</strong> 单向链表的尾节点，用于添加元素时构建链表；</li><li><strong>takeLock、notEmpty:</strong> 队列元素出队的锁和出队的等待条件；</li><li><strong>putLock、notFull:</strong> 元素入队的锁和入队的等待条件；</li></ul><p>相比 ArrayBlockingQueue 内部定义一个循环数组，出队和入队用的是同一把锁，LinkedBlockingQueue 内部则定义了一个链表结构，入队用的是 putLock 锁，出队用的是 takeLock 锁。可以看出，后者在并发度上更好一些。</p><p>这里我们可能有个疑问，那就是两把锁是怎么保证线程安全的呢？这个问题的答案留在后文。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认无界的队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建给定容量的队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity&#125; is not greater</span></span><br><span class="line"><span class="comment"> *                                  than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 容量大小不能 &lt;= 0</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置队列容量大小</span></span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 LinkedBlockingQueue 的构造方法可知：</p><ul><li>LinkedBlockingQueue 队列默认是无界的，也就是队列大小为 <code>Integer.MAX_VALUE</code> 。在使用的时候，我们最好传入容量，不然会有内存溢出的风险。</li><li><strong>LinkedBlockingQueue 队列内部的链表是在构造方法中初始化的</strong>。</li></ul><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>添加元素的方法，主要的流程是判断队列满的情况的处理，以及添加元素成功后尝试唤醒阻塞等待元素的线程。添加元素是在队列尾部添加。</p><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在此队列的尾部插入指定元素，如有必要，等待空间可用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 要添加的元素不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个节点存元素 e</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取入队锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列中元素个数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列满了，则进入非满条件队列进行等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入队，链表操作，尾插法</span></span><br><span class="line">        enqueue(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并更新队列中元素个数</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 c+1 &lt; 队列容量，说明队列还可以继续添加元素，则唤醒在非满条件队列中等待的线程</span></span><br><span class="line">        <span class="comment">// 这里 c+1 是因为前面已经加入了一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放入队锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c == 0 说明原来queue是空的, 现在添加了元素，所以这里 signalNotEmpty 一下, 唤醒正在 poll/take 等待中的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>put 方法主要包括以下流程：</strong></p><ul><li>获取可中断的入队锁；</li><li>判断队列是否满了，满了则进入非满条件队列进行等待；</li><li>元素入队，链表的尾插操作；</li><li>元素入队后，如果队列还没满，那么可以继续添加元素，则唤醒在非满条件队列中等待的线程；</li><li>释放可中断的入队锁；</li><li>如果在添加元素之前，队列是空的，那么尝试唤醒正在 poll/take 等待中的线程；</li></ul><h5 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue()"></a>enqueue()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元素入队底层操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    <span class="comment">// 链表尾插法</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="signalNotEmpty"><a href="#signalNotEmpty" class="headerlink" title="signalNotEmpty()"></a>signalNotEmpty()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒等待获取元素的线程。仅从 put/offer 调用（通常不会锁定 takeLock。）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 唤醒前先拿到出队锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 唤醒阻塞在非空条件队列中的某个线程，以使其继续获取元素</span></span><br><span class="line">        notEmpty.signal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放出队锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="offer"><a href="#offer" class="headerlink" title="offer()"></a>offer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在不超出队列容量的情况下立即在此队列的尾部插入指定元素，成功时返回 true，如果此队列已满则返回 false。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要添加的元素不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列中元素的个数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个节点存元素 e</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取入队锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列没有满，则入队元素，即链表尾插法</span></span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            enqueue(node);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取并更新队列中元素个数</span></span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 c+1 &lt; 队列容量，说明队列还可以继续添加元素，则唤醒在非满条件队列中等待的线程</span></span><br><span class="line">            <span class="comment">// 这里 c+1 是因为前面已经加入了一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放入队锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c == 0 说明原来queue是空的, 现在添加了元素，所以这里 signalNotEmpty 一下, 唤醒正在 poll/take 等待中的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 count.get() &lt; capacity 不成立，直接释放锁，此时 c==-1</span></span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出上述方法和 put 方法基本一致，唯一区别点在，如果队列满了直接返回失败，不阻塞等待。</p><p>LinkedBlockingQueue 基于 offer 方法进行了优化，支持超时添加元素的功能，是在 put 方法和 offer 方法之间取了个折中。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此队列的尾部插入指定元素，如有必要，等待指定的等待时间以使空间可用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 和 put 方法基本类似，唯一区别是，该方法不会一直阻塞等待，有个最大等待时长</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful, or &#123;<span class="doctag">@code</span> false&#125; if</span></span><br><span class="line"><span class="comment"> * the specified waiting time elapses before space is available</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要添加的元素不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时等待时间</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取入队锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列满了，则等待指定的时间，尽最大努力添加元素</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 超时了还没有空的空间，那么就不添加了</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 入队，可能条件如下：</span></span><br><span class="line">        <span class="comment">// 1）队列没有满  2）在指定的超时时间内有空的空间了，线程提前被唤醒</span></span><br><span class="line">        enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并更新队列中元素个数</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 c+1 &lt; 队列容量，说明队列还可以继续添加元素，则唤醒在非满条件队列中等待的线程</span></span><br><span class="line">        <span class="comment">// 这里 c+1 是因为前面已经加入了一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放入队锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c == 0 说明原来queue是空的, 现在添加了元素，所以这里 signalNotEmpty 一下, 唤醒正在 poll/take 等待中的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><p>获取元素的方法，主要的流程是判断队列空的情况的处理，以及获取元素成功后尝试唤醒阻塞添加元素的线程。获取元素是从队列头部获取，也就是链表的第一个有效节点（非头节点）。</p><h4 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列中元素的个数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取可中断出队锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列为空，则进入 notEmpty 等待队列进行等待队列非空</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出队，链表操作</span></span><br><span class="line">        x = dequeue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取并更新队列中元素的个数</span></span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明队列中还有元素，唤醒在 notEmpty 等待队列进行等待的线程</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放出队锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c == capacity 说明队列在本次出队之前是满的，现在出队了一个元素，有空的空间了，可以唤醒 put/offer 操作阻塞的线程（如果有的话）</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>take 方法主要包括以下流程：</strong></p><ul><li>获取可中断的出队锁；</li><li>判断队列是否空的，空了则进入非空条件队列进行等待；</li><li>元素出队，链表操作；</li><li>元素出队后，如果队列还是非空的，那么可以继续出队，则唤醒在非空条件队列中等待的线程；</li><li>释放可中断的出队锁；</li><li>如果在获取元素之前，队列是满的，那么尝试唤醒正在 put/offer 等待中的线程；</li></ul><h5 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue()"></a>dequeue()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 出队底层操作</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the node</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">     <span class="comment">// assert head.item == null;</span></span><br><span class="line">     Node&lt;E&gt; h = head;            <span class="comment">// head 是一个虚节点</span></span><br><span class="line">     Node&lt;E&gt; first = h.next;      <span class="comment">// 获取虚节点后一个节点，也就是真正的节点</span></span><br><span class="line">     h.next = h;                  <span class="comment">// help GC</span></span><br><span class="line">     head = first;                <span class="comment">// 重新设置 head</span></span><br><span class="line">     E x = first.item;            <span class="comment">// 获取出队的值</span></span><br><span class="line">     first.item = <span class="keyword">null</span>;           <span class="comment">// 置空元素</span></span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="signalNotFull"><a href="#signalNotFull" class="headerlink" title="signalNotFull()"></a>signalNotFull()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 唤醒等待添加元素的线程。仅从 take/poll 调用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 唤醒前先拿到入队锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">     putLock.lock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 唤醒阻塞在非满条件队列中的某个线程</span></span><br><span class="line">         notFull.signal();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 释放入队锁</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         putLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取队列中元素的个数</span></span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，则直接返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取出队锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列不为空，那么出队</span></span><br><span class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 出队</span></span><br><span class="line">            x = dequeue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取并更新队列中元素的个数</span></span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 说明队列中还有元素，唤醒在 notEmpty 等待队列进行等待的线程</span></span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放出队锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c == capacity 说明队列在本次出队之前是满的，现在出队了一个元素，有空的空间了，可以唤醒 put/offer 操作阻塞的线程（如果有的话）</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法和 take 方法基本一致，唯一区别点是，队列为空时直接返回，不会阻塞等待元素。</p><p>LinkedBlockingQueue 基于 poll 方法进行了优化，支持超时获取元素的功能，是在 take 和 poll 方法之间取个折中。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 超时出队</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     E x = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 超时等待时长</span></span><br><span class="line">     <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取队列元素的个数</span></span><br><span class="line">     <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取可中断出队锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">     takeLock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 队列为空，则进入超时等待</span></span><br><span class="line">         <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">// 等待超时也没有元素</span></span><br><span class="line">             <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             <span class="comment">// 超时等待</span></span><br><span class="line">             nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 出队，可能情况如下：</span></span><br><span class="line">         <span class="comment">// 1）队列没有空  2）在指定的超时时间内队列又有元素了，线程提前被唤醒</span></span><br><span class="line">         x = dequeue();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获取并更新队列中元素的个数</span></span><br><span class="line">         c = count.getAndDecrement();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 说明队列中还有元素，唤醒在 notEmpty 等待队列进行等待的线程</span></span><br><span class="line">         <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">             notEmpty.signal();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 释放出队锁</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         takeLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// c == capacity 说明队列在本次出队之前是满的，现在出队了一个元素，有空的空间了，可以唤醒 put/offer 操作阻塞的线程（如果有的话）</span></span><br><span class="line">     <span class="keyword">if</span> (c == capacity)</span><br><span class="line">         signalNotFull();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 获取但不移除队列头部元素</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 队列为空，直接返回 null</span></span><br><span class="line">     <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取出队锁</span></span><br><span class="line">     <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">     takeLock.lock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 获取有效节点</span></span><br><span class="line">         Node&lt;E&gt; first = head.next;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 返回元素</span></span><br><span class="line">         <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             <span class="keyword">return</span> first.item;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 释放出队列锁</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         takeLock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="遍历链表操作"><a href="#遍历链表操作" class="headerlink" title="遍历链表操作"></a>遍历链表操作</h3><p>前面介绍了 LinkedBlockingQueue 的入队和出队操作，它们也是最核心的方法。其中入队时都会先获取入队锁，获取成功才可以执行后续的入队流程；出队时也是一样，先获取出队锁，获取成功才可以执行后续的出队流程。这两类操作各自用到了一把锁，这两把锁各自独立。</p><p>在涉及到遍历链表的操作时，需要<strong>同时使用两把锁，也就是入队锁和出队锁</strong>，因为遍历链表的过程不能有出队和入队的操作，否则就不安全了。具体方法包括：判断是否包含 contains 、删除元素 remove、清除 clear、toString、toArray 等。</p><p>相比其他操作，入队和出队使用的更频繁。入队和出队虽然各自使用一把锁，但是结合<strong>等待通知机制</strong>，这两个类型操作是安全的。这两类操作外的遍历链表操作，会同时使用两把锁，因此总体还是线程安全的。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/linked-blocking-queue-2.png" alt></p><p>至此，我们就知道了 LinkedBlockingQueue 为什么可以保证线程安全，并且并发度相对更大。</p><h2 id="ArrayBlockingQueue-VS-LinkedBlockingQueue"><a href="#ArrayBlockingQueue-VS-LinkedBlockingQueue" class="headerlink" title="ArrayBlockingQueue VS LinkedBlockingQueue"></a>ArrayBlockingQueue VS LinkedBlockingQueue</h2><ol><li>ArrayBlockingQueue 是有界的，而 LinkedBlockingQueue 默认是无界的。在使用 LinkedBlockingQueue 时要考虑内存实际使用问题，防止内存溢出问题的发生。</li><li>ArrayBlockingQueue 内部使用一个锁来控制元素的添加和取出操作，而 LinkedBlockingQueue 则是使用两个锁来控制。可以看出，前者不管是添加还是获取元素，都可能被阻塞，而后者在添加和获取时分别使用了两个锁，只会相同操作有阻塞可能，因此性能方面后者更强。</li><li>ArrayBlockingQueue 内部使用的是固定内存，而 LinkedBlockingQueue 内部使用的是动态内存，无论是分配内存还是释放内存（甚至GC），动态内存的性能自然都会比固定内存要差。</li></ol><h3 id="ArrayBlockingQueue-双锁问题"><a href="#ArrayBlockingQueue-双锁问题" class="headerlink" title="ArrayBlockingQueue 双锁问题"></a>ArrayBlockingQueue 双锁问题</h3><p>LinkedBlockingQueue 使用两个锁来保证并发安全，性能更好。那为什么 ArrayBlockingQueue 不使用双锁实现呢？</p><p>在不考虑设计的情况下，ArrayBlockingQueue 完全可以按照 LinkedBlockingQueue 的双锁设计思路无脑式实现。但是不要忘了，忽略了最初的设计，那么就失去了初衷，存在即合理嘛。</p><p>此外，ArrayBlockingQueue 还支持公平的特性，这是 LinkedBlockingQueue 双锁没有实现的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>LinkedBlockingQueue 是一个基于链表（单链表）实现的先进先出的阻塞队列。在入队和出队时（不含删除、清除），分别使用两把独占锁保证安全，也提高了并发度，其他操作基本都会同时使用两把锁，因此线程安全问题没问题。</p><p>LinkedBlockingQueue 虽然性能比 ArrayBlockingQueue 好，但是在内存处理上却不如后者好。此外，ConcurrentLinkedQueue 不再使用锁机制，而是采用 CAS 的方式，在性能上更强于 LinkedBlockingQueue 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;LinkedBlockingQueue 是一个&lt;strong&gt;基于链表（单链表）&lt;/strong&gt;实现的先进先出的阻塞队列，&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="Queue" scheme="https://gentryhuang.com/tags/Queue/"/>
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>并发 - ArrayBlockingQueue</title>
    <link href="https://gentryhuang.com/posts/3e4e955c/"/>
    <id>https://gentryhuang.com/posts/3e4e955c/</id>
    <published>2022-01-22T02:03:10.000Z</published>
    <updated>2022-05-10T02:29:54.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ArrayBlockingQueue 是 Java 并发包下一个以<strong>数组</strong>实现的阻塞队列，它是<strong>线程安全</strong>的。</p><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>ArrayBlockingQueue 是使用一个固定长度的数组来存储元素的，并使用一系列属性来描述这个数组。虽然这个数组是固定大小，但是使用了<strong>复用数组</strong>的设计思想，它的空间可以循环写入。循环写入不是无条件地覆盖式写入，而是采用等待可用空间地方式进行写入。从工作原理来说，它有以下特点：</p><ul><li>循环数组有一个写指针 putIndex，表示在数组 items 中的要写入的位置。如果写指针 putIndex 已经指向了数组末尾，那么此时再写入元素，写指针 putIndex 就会重新指向数组的头部，下次添加元素就可以复用数组了。</li><li>循环数组同时有一个读指针 takeIndex，表示在数组 items 中要读取的位置。如果读指针 takeIndex 指向了数组末尾，那么也会把读指针 takeIndex 重新指向数组头部，下次从数组头部开始继续读取元素。</li></ul><p>下图展示了循环数组的写指针工作机制，读指针也是类似的。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/array-blocking-queue-1.jpg" alt></p><p>循环写入非覆盖式写入，具体体现在下图，当写指针 putIndex 追上读指针 takeIndex（也就是队列满了） ，那么就必须阻塞等待读指针向前推进，只有读指针 takeIndex 向前推进了才能继续写。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/array-blocking-queue-2.jpg" alt></p><p>同理，当读指针 takeIndex 追上写指针 putIndex（也就是队列空了），那么也必须阻塞等待写指针向前推进，保证队列不为空才能继续读取。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>ArrayBlockingQueue 相关源码结构如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/java-base/queue/array-blocking-queue-3.png" alt></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放元素的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取元素时的下标；</span></span><br><span class="line"><span class="comment">     * 每从队列中取出一个元素，takeIndex 递增 1，到数组尾部会重置为 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素的下标</span></span><br><span class="line"><span class="comment">     * 每向队列添加一个元素，putIndex 递增 1，满了会重置为 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 并发控制使用经典双条件算法。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可重入独占锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当队列为空时，会调用 notEmpty 的 wait 方法，让当前线程等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当队列满了，会调用 notFull 的 wait 方法，让当前线程等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  并发控制使用经典双条件算法。 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环数组本身被设计为一个 <strong>Object 类型的素组 items</strong> ，然后 ArrayBlockingQueue 设计了以下的变量来描述循环数组的状态：</p><ul><li><strong>count:</strong> 记录队列中元素的个数。</li><li><strong>putIndex:</strong> 记录循环数组的写指针，即循环数组接下来写数据时应该写入的位置。</li><li><strong>takeIndex:</strong> 记录循环数组的读指针，即循环数组接下来读数据时应该读取的位置。</li><li><strong>lock:</strong> 可重入独占锁，用来保证队列安全的。</li><li><strong>notEmpty:</strong> 数组非空的等待条件，当队列为空时，会调用 notEmpty 的 wait 方法，让当前线程等待。</li><li><strong>notFull:</strong> 数组非满的等待条件，当队列满了，会调用 notFull 的 wait 方法，让当前线程等待。</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 根据指定的大小创建 fair 类型的 ArrayBlockingQueue；这个公平指的是锁的公平性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue  队列大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity &lt; 1&#125; 大小 &lt; 1 抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an &#123;<span class="doctag">@code</span> ArrayBlockingQueue&#125; with the given (fixed)</span></span><br><span class="line"><span class="comment"> * capacity and the specified access policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair     if &#123;<span class="doctag">@code</span> true&#125; then queue accesses for threads blocked</span></span><br><span class="line"><span class="comment"> *                 on insertion or removal, are processed in FIFO order;</span></span><br><span class="line"><span class="comment"> *                 if &#123;<span class="doctag">@code</span> false&#125; the access order is unspecified.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity &lt; 1&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 阻塞队列的大小必须 &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化指定大小的 Object 数组</span></span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建可重入锁，是否公平取决于 fair</span></span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建锁的条件对象，用来等待队列非空</span></span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建锁的条件对象，用来等待队列非满</span></span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ul><li><strong>add():</strong> 在不超出队列容量的情况下，在队列尾部插入指定的元素，成功返回 true，如果队列已满则抛出异常。其底层使用的是 offer 方法。</li><li><strong>offer():</strong> 在不超出队列容量的情况下，在队列尾部插入指定的元素，成功时返回 true，如果队列已满则返回 false。</li><li><strong>put():</strong> 在队列尾部添加指定元素，如果队列满了，则阻塞等待，直到空间可用。</li></ul><h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果可以在不超出队列容量的情况下立即插入指定元素，则在此队列的尾部插入指定元素，</span></span><br><span class="line"><span class="comment"> * 成功时返回 &#123;<span class="doctag">@code</span> true&#125;，如果此队列已满则抛出 &#123;<span class="doctag">@code</span> IllegalStateException&#125;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add 要添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;) 添加成功返回 true</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if this queue is full 队列满了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException  if the specified element is null 要添加的元素 e 不能为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用父类的 add 方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *     public boolean add(E e) &#123;</span></span><br><span class="line"><span class="comment">     *         // 调用 offer 方法</span></span><br><span class="line"><span class="comment">     *         if (offer(e))</span></span><br><span class="line"><span class="comment">     *             return true;</span></span><br><span class="line"><span class="comment">     *         else</span></span><br><span class="line"><span class="comment">     *             throw new IllegalStateException("Queue full");</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="offer"><a href="#offer" class="headerlink" title="offer()"></a>offer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果可以在不超出队列容量的情况下立即插入指定元素，则在此队列的尾部插入指定元素，成功时返回 &#123;<span class="doctag">@code</span> true&#125;，</span></span><br><span class="line"><span class="comment"> * 如果此队列已满则返回 &#123;<span class="doctag">@code</span> false&#125;。此方法通常比方法 &#123;<span class="doctag">@link</span> add&#125; 更可取，后者仅通过抛出异常可能无法插入元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified element is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 检查要插入的元素 e 不能为空</span></span><br><span class="line">       checkNotNull(e);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 加锁</span></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 如果队列满了，直接返回 false ，不插入元素</span></span><br><span class="line">           <span class="keyword">if</span> (count == items.length)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 如果队列没有满，则向队列的尾部插入元素 e ，插入成功后返回 true</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               enqueue(e);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 释放锁</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 检查要添加的元素 e 不能为空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加获取可中断锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 判断队列是否满了，满了则阻塞在 notFull 等待被唤醒</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列不满，则在队列尾部插入元素</span></span><br><span class="line">        enqueue(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="enqueue"><a href="#enqueue" class="headerlink" title="enqueue()"></a>enqueue()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 在 putIndex 下标位置添加元素；该方法仅在获取到锁时调用</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">     <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取全局数组</span></span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 在 putIndex 下标位置添加元素</span></span><br><span class="line">     items[putIndex] = x;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 向后移动 putIndex ，如果队列满了，则重置 putIndex 为 0</span></span><br><span class="line">     <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">         putIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 数组元素个数累加</span></span><br><span class="line">     count++;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 尝试唤醒阻塞在 notEmpty 上等待的线程（如果有的话）</span></span><br><span class="line">     notEmpty.signal();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>该方法是添加元素的最底层方法，涉及到写指针 putIndex 的更新，以及尝试唤醒阻塞在 notEmpty 上等待的线程（如果有的话）。需要注意的是，判断队列是否满了的条件是：<code>putIndex==items.length</code>。</p><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><ul><li><strong>remove():</strong> 从队列中删除指定元素（如果存在）。</li><li><strong>poll():</strong> 尝试删除并返回队列头部的元素，队列为空返回 null 即可。</li><li><strong>take():</strong> 阻塞式删除并返回队列头部的元素，如果队列为空会一直等待，直到有元素才返回。</li><li><strong>peek():</strong> 返回队列头部元素，但不从队列中删除该元素，队列为空则返回 null。</li></ul><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要删除的元素为空，则返回 false，不进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取全局数组</span></span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果队列非空</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">                <span class="keyword">int</span> i = takeIndex;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历数组，找到要删除的元素</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (o.equals(items[i])) &#123;</span><br><span class="line">                        <span class="comment">// 删除该元素并移动元素</span></span><br><span class="line">                        removeAt(i);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 数组是循环使用的</span></span><br><span class="line">                    <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                        i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 追上 putIndex ，说明已经遍历完了</span></span><br><span class="line">                &#125; <span class="keyword">while</span> (i != putIndex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 队列为空，或者没有找到要删除的元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">---</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除数组下标 removeIndex 处的元素并移动元素使元素连续。仅在获取到锁时调用；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> removeIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">        <span class="comment">// assert items[removeIndex] != null;</span></span><br><span class="line">        <span class="comment">// assert removeIndex &gt;= 0 &amp;&amp; removeIndex &lt; items.length;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取全局数组</span></span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果要删除下标正好是下一个要取出的元素对应的下标，那么同取出元素操作逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (removeIndex == takeIndex) &#123;</span><br><span class="line">            <span class="comment">// removing front item; just advance</span></span><br><span class="line">            <span class="comment">// 置空</span></span><br><span class="line">            items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新 takeIndex 下标</span></span><br><span class="line">            <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">                takeIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新队列元素个数</span></span><br><span class="line">            count--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新迭代器状态</span></span><br><span class="line">            <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">                itrs.elementDequeued();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果要删除的下标非 takeIndex ，那么说明就是"中间位置"，需要移动元素以覆盖删除的位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// an "interior" remove</span></span><br><span class="line">            <span class="comment">// 以要删除的下标 removeIndex 为基准，"向前"移动元素，直到追上 putIndex</span></span><br><span class="line">            <span class="comment">// todo 注意数组循环使用的情况</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> putIndex = <span class="keyword">this</span>.putIndex;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = removeIndex; ; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> next = i + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 从头开始</span></span><br><span class="line">                <span class="keyword">if</span> (next == items.length)</span><br><span class="line">                    next = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 没有追上 putIndex，就向前移动</span></span><br><span class="line">                <span class="keyword">if</span> (next != putIndex) &#123;</span><br><span class="line">                    items[i] = items[next];</span><br><span class="line">                    i = next;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 后退 putIndex </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    items[i] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">this</span>.putIndex = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新队列元素个数</span></span><br><span class="line">            count--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新迭代器</span></span><br><span class="line">            <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">                itrs.removedAt(removeIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试唤醒阻塞在 notFull 上等待的线程</span></span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>删除元素相对复杂一些，移动数组元素时要考虑数组是循环使用的。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试获取队列头部的元素，队列为空返回 null 即可</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 获取锁</span></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 队列为空，返回 null ;队列非空返回 takeIndex 下标位置的元素</span></span><br><span class="line">           <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 释放锁</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上述方法是快速获取的方式，如果没有就立即返回 null。ArrayBlockingQueue 还支持超时获取元素，尽最大努力获取到元素。该方法是在 poll() 方法的基础上增加了超时等待条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 尝试超时获取元素</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">// 获取元素的超时时间</span></span><br><span class="line">       <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取可中断锁</span></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lockInterruptibly();</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 如果队列为空，等待 nanos 纳秒时长</span></span><br><span class="line">           <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// 等待 nanos 纳秒后，队列还是为空</span></span><br><span class="line">               <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 执行到这里有两种可能： 1）队列非空，直接获取  2）队列为空，但在等待时长内队列又有元素了</span></span><br><span class="line">           <span class="keyword">return</span> dequeue();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 释放锁</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="take"><a href="#take" class="headerlink" title="take()"></a>take()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 阻塞式获取元素</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">// 获取可中断锁</span></span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 队列为空，则阻塞等待，直到队列有元素</span></span><br><span class="line">           <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">               notEmpty.await();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 获取 takeIndex 下标位置的元素</span></span><br><span class="line">           <span class="keyword">return</span> dequeue();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 释放锁</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>take() 方法相比超时等待的 poll() 方法，前者没有等待时间，会一直等待，直到队列有元素或线程被中断。</p><h4 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取队列头部元素，但不移除该元素；队列为空，则返回 null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接从数组中获取下标为 takeIndex 的元素</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue()"></a>dequeue()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取出 takeIndex 下标位置的元素；该方法仅在获取到锁时调用；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取全局数组</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 takeIndex 下标位置的元素</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 null，便于 GC</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 takeIndex ，如果到达了数组的末尾，则重置 takeIndex 为 0 ，即下次从数组头开始取元素</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组元素个数递减</span></span><br><span class="line">    count--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新迭代器状态</span></span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试唤醒阻塞在 notFull 上等待的线程（如果有的话）</span></span><br><span class="line">    notFull.signal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回元素</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是获取元素的最底层方法，涉及到读指针 takeIndex 的更新，以及尝试唤醒阻塞在 notFull 上等待的线程（如果有的话）。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>典型的使用场景就是生产者-消费者问题。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章简单介绍了 ArrayBlockingQueue 的模型，并分析了核心的源码。核心点有以下两点：</p><ul><li>以固定大小数组作为元素的容器，并定义系列描述数组的属性。这个固定大小的数组是可以循环使用的。存取数据遵循：队头取、队尾插，从读写指针也可以看出。</li><li>基本的增、删、查都要先加锁才能操作，使用的锁是 Reentrant 保证了安全性，并使用等待通知机制来实现阻塞的功能。<strong>也就是，同一时刻只有一个线程可操作队列。</strong></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ArrayBlockingQueue 是 Java 并发包下一个以&lt;strong&gt;数组&lt;/strong&gt;实现的阻塞队列，它是&lt;strong&gt;
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="Queue" scheme="https://gentryhuang.com/tags/Queue/"/>
    
      <category term="JUC" scheme="https://gentryhuang.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="https://gentryhuang.com/posts/4eb3381c/"/>
    <id>https://gentryhuang.com/posts/4eb3381c/</id>
    <published>2022-01-08T02:10:15.000Z</published>
    <updated>2022-01-10T06:04:49.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要分布式锁？"><a href="#为什么需要分布式锁？" class="headerlink" title="为什么需要分布式锁？"></a>为什么需要分布式锁？</h1><p>分布式系统中，同一系统的不同主机共享同一资源，在访问的时候需要添加互斥语义以保护资源。这种情况下就需要使用分布式锁，<strong>锁是保存在一个共享存储系统中的，所有进程都可以去该系统上申请加锁和释放锁</strong>。</p><h1 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h1><p>用于存储“锁”的共享存储系统，可以是 <code>MySQL</code>、<code>Redis</code>、<code>Zookeeper</code> 以及 <code>Etcd</code> 等。对应的，每种共享存储系统都可以实现分布式锁。</p><h2 id="基于数据库实现"><a href="#基于数据库实现" class="headerlink" title="基于数据库实现"></a>基于数据库实现</h2><p>用于实现分布锁的数据表结构定义如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> TDistributedLock (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">' 主键 '</span>,</span><br><span class="line">  <span class="string">`lock_key`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">' 锁的键值 '</span>,</span><br><span class="line">  <span class="string">`lock_timeout`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NOW</span>() <span class="keyword">COMMENT</span> <span class="string">' 锁的超时时间 '</span></span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uidx_lock_key`</span> (<span class="string">`lock_key`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">' 分布式锁表 '</span>;</span><br></pre></td></tr></table></figure><p>当进程申请加锁时，只需要插入一条数据即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TDistributedLock(lock_key, lock_timeout) <span class="keyword">values</span>(<span class="string">'order_lock_key'</span>, <span class="string">'2022-01-07 20:30:00'</span>);</span><br></pre></td></tr></table></figure><p>当对共享资源的操作完毕后，可以释放锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> TDistributedLock <span class="keyword">where</span> lock_key=<span class="string">'order_lock_key'</span>;</span><br></pre></td></tr></table></figure><p>基于数据库实现的方案简单、方便，核心点是利用数据库表的<strong>唯一索引</strong>约束，保证多个进程同时申请加锁时，只有一个能获得锁。</p><p>虽然基于数据库实现的方案简单，但是存在一些问题。下面我们对问题进行说明，并给出解决方式。</p><ul><li>获得锁的进程意外 crash ，来不及释放锁。<blockquote><p>在插入锁记录时，同时设置了锁的过期时间 lock_timeout ，可以启动一个扫描清理线程 lock_cleaner，将超时的锁记录删除。</p></blockquote></li><li>如何支持可重入锁<blockquote><p>可以在锁记录表中增加一个字段，记录当前获取锁的主机信息和进程信息，在获取锁时先判断是否是重入锁。如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给它就可以了。此时需要考虑业务的复杂程度，判断是否要延长锁的更新时间。</p></blockquote></li><li>锁的可靠性怎么保证<blockquote><p>数据库支持主从、一主多从、多主多从等复制方案，可保证一个数据库实例宕机，其它实例可以接管过来继续提供服务。但是，有些复制方案是异步的，可能会导致锁丢失，进而导致分布锁失效。</p></blockquote></li></ul><h2 id="基于-Zookeeper-实现"><a href="#基于-Zookeeper-实现" class="headerlink" title="基于 Zookeeper 实现"></a>基于 Zookeeper 实现</h2><p>Zookeeper 是一个分布式协调框架，以目录结构的形式存储数据。基于 Zookeeper 的一些特性，实现分布式锁的逻辑如下：</p><ol><li>使用 Zookeeper 的临时有序节点，每个进程获取锁需要在 Zookeeper 上创建一个临时有序节点，如在 /lock/ 目录下；</li><li>创建节点成功后，获取 /lock 目录下的所有临时节点，再判断当前进程创建的节点是否是所有的节点中序号最小的节点；</li><li>如果当前进程创建的节点是所有节点序号最小的节点，则获取锁成功。</li><li>如果当前进程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。 比如当前进程获取到的节点序号为/lock/003,然后所有的节点列表为 [/lock/001,/lock/002,/lock/003],则对 /lock/002 这个节点添加一个事件监听器。</li></ol><p>当进程处理完共享资源后，就可以释放锁了，也就是删除它创建的临时节点。Zookeeper 添加其上的监听器会捕捉到移除事件，然后唤醒下一个序号的节点，然后执行第 3 步，继续抢锁。比如/lock/001 被删除了，/lock/002 监听到事件，此时节点集合为[/lock/002,/lock/003],则 /lock/002 为最小序号节点，获取到锁。</p><p><strong>注意：</strong>不使用 Zookeeper 的持久节点，是避免加锁成功后出现异常，节点来不及删除，导致后面的节点会一直等待节点删除，从而出现死锁，临时节点因为会随着客户端的下线被删除，可以避免死锁的问题。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>Zookeeper <strong>无需考虑锁的过期时间问题</strong>，它采用的是临时节点和主动删除策略。客户端获取到锁后，只要连接不断开，除非主动删除临时节点，否则一直持有锁。即使客户端异常宕机，因为是临时节点，因此会自动删除，避免了死锁。</p><p>没有锁过期的问题，而且还能在异常时自动释放锁。一切看起来很安全，但是我们考虑下客户端获取到锁后，连接断开的情况。</p><p>我们知道，客户端和 Zookeeper 之间的连接是通过客户端<strong>定时心跳</strong>来维持的，如果 Zookeeper 长时间收不到客户端的心跳，就认为这个连接过期了，会把这个临时节点删除。对于长时间的 GC ，客户端应用程序就无法给 Zookeeper 发送心跳，一旦超时 Zookeeper 就会把锁节点删除，GC 结束后其它客户端也来获取锁，也获取到了。此时，同时有两个客户端持有锁，这是有问题的。</p><p>可以知道，<strong>Zookeeper 在进程 GC、网络延迟异常场景下的安全性得不到保证</strong>。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>优点</strong></p><ul><li>数据一致性得到保证</li><li>不需要考虑锁的过期时间</li><li>使用 watch 机制，避免了等候锁的客户端不停地轮循锁是否可用，当锁的状态发生变化时可以自动得到通知。</li></ul><p><strong>劣势</strong></p><ul><li>性能问题，体现在读写和数据同步上</li><li>客户端与 Zookeeper 长时间失联，锁被释放问题</li><li>羊群效应，要尽量避免大量节点监控一个节点的行为，做到按需监听</li></ul><h2 id="基于单个-Redis-节点实现"><a href="#基于单个-Redis-节点实现" class="headerlink" title="基于单个 Redis 节点实现"></a>基于单个 Redis 节点实现</h2><p>Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁。而且 Redis 的读写性能高，可以应对高并发的锁操作场景。</p><h3 id="SETNX-实现"><a href="#SETNX-实现" class="headerlink" title="SETNX 实现"></a>SETNX 实现</h3><p>SETNX 命令在执行时会判断键是否存在，如果不存在，就设置键值对，如果存在，就不做任何设置。</p><p>我们可以用 SETNX 和 DEL 命令组合来实现加锁和释放锁操作。下面的伪代码示例显示了锁操作的过程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">SETNX lock_key <span class="number">1</span></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">DO THINGS</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">DEL lock_key</span><br></pre></td></tr></table></figure><p>不难看出，上述方案存在很多问题，如下：</p><ul><li>没有过期时间，进程异常退出会导致死锁</li><li>不能区分来自不同客户端的锁操作，容易导致误删锁</li></ul><p>避免死锁的一个最直接的方法就是设置一个过期时间，也就是租期。假设业务逻辑不会超过 3s，那么在加锁时，可以设置 3s 过期时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">SETNX lock_key <span class="number">1</span></span><br><span class="line"><span class="comment">// 设置 3s 租期</span></span><br><span class="line">EXPIRE lock_key <span class="number">3</span></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">DO THINGS</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">DEL lock_key</span><br></pre></td></tr></table></figure><p>设置了租期后，也不能保证不会死锁。因为加锁、设置过期是 2 个操作，可能只执行了第一个操作，第二个操作没有执行，这种情况就有潜在的风险，死锁仍然可能发生。</p><p>好在 Redis 扩展了 SET 命令，可以使用一条命令替换上述存在问题的两条命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁并设置 3s 租期</span></span><br><span class="line">SET lock_key <span class="number">1</span> EX <span class="number">3</span> NX</span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">DO THINGS</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">DEL lock_key</span><br></pre></td></tr></table></figure><p>这样就解决了死锁问题。</p><h3 id="SET-实现"><a href="#SET-实现" class="headerlink" title="SET 实现"></a>SET 实现</h3><p>为了能达到和 SETNX 命令一样的效果，Redis 扩展了 SET 命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [EX seconds | PX milliseconds]  [NX]</span><br></pre></td></tr></table></figure><p>虽然 SET 命令可以解决 SETNX 命令中存在的<strong>死锁问题</strong>，但是没有解决误删锁问题。这个问题的主要原因是，每个客户端在释放锁时，都是直接操作，<strong>没有检查锁是否还是自己持有</strong>。如以下场景：</p><ol><li>客户端 A 加锁成功，开始操作共享资源；</li><li>客户端 A 操作共享资源的时间超过了锁的过期时间，执行还没有完成，锁就自动释放了；</li><li>客户端 B 加锁成功，开始操作共享资源；</li><li>客户端 A 执行完成，释放锁，此时释放的事客户端 B 的锁。</li></ol><p>导致以上问题的关键有两个：</p><ul><li><strong>锁过期</strong>：客户端 A 执行时间过长，导致锁提前释放了，之后被客户端 B 持有。</li><li><strong>误释放锁</strong>：客户端 A 执行完成后，以为还是自己的锁，结果释放了客户端 B 的锁。</li></ul><p>下面我们对以上两个潜在问题进行分析并解决。</p><h4 id="解决锁被被人释放问题"><a href="#解决锁被被人释放问题" class="headerlink" title="解决锁被被人释放问题"></a>解决锁被被人释放问题</h4><p>在加锁操作中，每个客户端都使用一个唯一标识，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// $uuid 是当前客户端的唯一标识</span><br><span class="line">127.0.0.1:6379&gt; SET lock_key $uuid EX 3 NX</span><br></pre></td></tr></table></figure><p>在释放锁操作时，我们需要判断锁变量的值，是否等于执行释放锁操作的客户端的唯一标识，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放锁 比较unique_value是否相等，避免误释放</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="built_in">end</span></span><br></pre></td></tr></table></figure><p>上面是使用 Lua 脚本（unlock.script）实现的释放锁操作的伪代码，其中，KEYS[1]表示 lock_key，ARGV[1]是当前客户端的唯一标识，这两个值都是我们在执行 Lua 脚本时作为参数传入的。</p><p><strong>在释放锁操作中，我们使用了 Lua 脚本，这是因为，释放锁操作的逻辑也包含了读取锁变量、判断值、删除锁变量的多个操作，而 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</strong></p><h4 id="锁提前过期问题"><a href="#锁提前过期问题" class="headerlink" title="锁提前过期问题"></a>锁提前过期问题</h4><p>锁的过期时间如果评估不好，那么就会有提前释放的风险。但是，面对不同的业务场景过期时间很难精确预估。这个时候，我们可以使用<strong>续租</strong>的方式，延续锁的过期时间。</p><p>在加锁时，先设置一个过期时间，然后启动一个后台线程，定时检测锁的实效时间，如果锁快要过期了，但操作共享资源还没有处理完成，那么就对锁进行续期，重新设置过期时间。Java 中的 Redission 在使用分布式锁时，就采用了自动续期的方式来避免锁提前过期，这个后台线程一般称做<strong>看门狗线程</strong>。</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h3><p>下面对基于 Redis 实现的分布式锁出现的问题以及解决方案进行梳理：</p><ul><li>针对死锁问题，可以通过设置过期时间来解决；</li><li>针对锁提前释放，可以使用自动续期来解决；</li><li>针对锁被误删除，可以通过检查锁的唯一标识来决定是否可以释放。</li></ul><h2 id="基于多个-Redis-节点实现"><a href="#基于多个-Redis-节点实现" class="headerlink" title="基于多个 Redis 节点实现"></a>基于多个 Redis 节点实现</h2><p>在使用 Redis 时，为了可靠性，一般会采用哨兵或集群的方式部署。那这种可靠性对于分布式锁有什么影响呢？我们以哨兵模式为例，分析主从切换对分布式锁的影响。</p><ol><li>客户端 A 在主库上执行 SET 命令申请加锁成功；</li><li>主库异常宕机，申请加锁的 SET 命令还未同步到从库上；</li><li>从库被提升为新主库，此时锁的数据在新的主库上丢失了；</li><li>其它客户端向主库申请加锁也会成功，此时分布式锁失效了。</li></ol><p>可以看到，因为 Redis 的主从复制是异步的，高可用机制不能保证锁的可靠性。因此，Redis 的作者提出了 Redlock 方案。</p><h3 id="Redlock"><a href="#Redlock" class="headerlink" title="Redlock"></a>Redlock</h3><p>Redlock 算法的基本思路，是让客户端和多个独立的 Redis 实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，并且总耗时不超过锁的有效时间，那么就认为客户端成功地获得分布式锁了，否则加锁失败。这样一来，即使有单个 Redis 实例发生故障，还有其它实例，锁的可靠性得到了保障。</p><p>可以看出，Redlock 的特点如下：</p><ul><li>不是部署主从库，而是只部署主库；</li><li>主库要部署多个，官方推荐至少 5 个实例；</li></ul><p>也就是说，Redlock 要求至少部署 5 个 Redis 实例，而且都是主库，它们之间没有任何关系，都是一个个孤立的实例。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>Redlock 算法的步骤一共分为 5 步：</p><ol><li>客户端获取当前时间戳。</li><li>客户端按顺序依次向 N 个 Redis 实例执行加锁操作。这里的加锁操作和在单实例上执行的加锁操作一样，使用 SET 命令，带上 NX，EX/PX 选项，以及带上客户端的唯一标识。为了保证某个实例加锁失败（实例宕机、网络超时、锁被其它客户端持有） Redlock 算法能够继续运行，需要给加锁操作设置一个超时时间。如果客户端在和一个 Redis 实例请求加锁时，一直到超时都没有成功，那么此时，客户端会和下一个 Redis 实例继续请求加锁。加锁操作的超时时间需要远远地小于锁的有效时间，一般也就是设置为几十毫秒。</li><li>客户端只有在满足下面的这两个条件时，才能认为是加锁成功。<ul><li>客户端从超过半数（大于等于 N/2+1）的 Redis 实例上成功获取到了锁；</li><li>计算客户端获取锁的总耗时，必须没有超过锁的有效时间。</li></ul></li><li>加锁成功，操作共享资源。</li><li>加锁失败，向全部节点发起释放锁的请求。和在单实例上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了。</li></ol><h4 id="关键步骤分析"><a href="#关键步骤分析" class="headerlink" title="关键步骤分析"></a>关键步骤分析</h4><p>Redlock 算法的关键如下：</p><ul><li>必须是大多数节点加锁成功；<blockquote><p>为了实现容错功能。</p></blockquote></li><li>大多数节点加锁的总耗时要小于锁设置的过期时间；<blockquote><p>即使大多数节点加锁成功，但如果加锁的累计耗时已经超过了锁的过期时间，那此时有些实例上的锁可能已经失效了，这个锁也就没有意义了。</p></blockquote></li><li>释放锁要向全部节点发起释放锁请求。<blockquote><p>可能存在实例上加锁成功了，但是获取响应结果时是失败的，如网络问题导致超时。</p></blockquote></li></ul><h4 id="Redlock-存在问题"><a href="#Redlock-存在问题" class="headerlink" title="Redlock 存在问题"></a>Redlock 存在问题</h4><h5 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h5><p>为了效率可以使用单节点 Redis ，即使偶尔发生锁失效（宕机、主从切换），有些业务不会产生严重后果，最差可以做幂等。毕竟，使用 Redlock 太重了。</p><h5 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h5><p>在进程暂停、时钟跳跃、节点奔溃恢复等情况下，Redlock 是不安全的。</p><h6 id="进程暂停"><a href="#进程暂停" class="headerlink" title="进程暂停"></a>进程暂停</h6><p>在 Java 中进行 GC 时，会使进程暂停，时间序列如下：</p><ol><li>客户端 1 依次向节点 A、B、C、D、E 请求加锁；</li><li>客户端 1 获得锁后，进入 GC ，这个时间假设很长；</li><li>大多数或全部 Redis 节点上的锁都过期了；</li><li>客户端 2 依次向节点 A、B、C、D、E 请求加锁，获取锁成功；</li><li>客户端 1 和客户端 2 都获取到了锁，发生了冲突。</li></ol><h6 id="时钟跳跃"><a href="#时钟跳跃" class="headerlink" title="时钟跳跃"></a>时钟跳跃</h6><p>当多个 Redis 节点时钟发生问题时，也会导致 Redlock 锁失效。</p><ol><li>客户端 1 依次向节点 A、B、C、D、E 请求加锁，获取到了节点 A、B、C 上的锁，但由于网络问题，无法访问 D 和 E；</li><li>节点 C 上的时钟向前跳跃，导致锁过期了。</li><li>客户端 2 依次向节点 A、B、C、D、E 请求加锁，获取节点 C、D、E 上的锁，由于网络问题，无法访问 A 和 B；</li><li>客户端 1 和客户端 2 都获取到了锁，发生了冲突。</li></ol><p>机器的时钟发生错误，是很有可能发生的，比如：</p><ul><li>系统管理员手动修改了机器时钟</li><li>机器时钟在同步 NTP 时间时，发生了大的跳跃</li></ul><p>Redis 节点奔溃重启，如果锁信息没有持久化，那么也会造成和时钟跳跃一样的问题。</p><h4 id="解决-Redlock-问题"><a href="#解决-Redlock-问题" class="headerlink" title="解决 Redlock 问题"></a>解决 Redlock 问题</h4><h5 id="时钟跳跃问题"><a href="#时钟跳跃问题" class="headerlink" title="时钟跳跃问题"></a>时钟跳跃问题</h5><p>针对时钟问题，Redlock 并不需要完全一致的时钟，只需要大体一致就可以了。避免手动修改机器时钟，并通过正确的运维保证机器时钟不会大幅度跳跃。</p><h5 id="进程暂停问题"><a href="#进程暂停问题" class="headerlink" title="进程暂停问题"></a>进程暂停问题</h5><p>对于 Redlock 来说，如果进程暂停、网络延迟发生在获得锁之前，那么 Redlock 是可以检测出来的，如果超出了锁设置的过期时间，就认为加锁失败，之后释放所有节点的锁；如果发生在获得锁之后，也就是在客户端操作共享资源的过程发生问题导致锁失效，那 Redlock 确实没有办法了，但是这不仅仅是 Redlock 的问题，其它分布式锁实现也有类似问题，比如 Zookeeper 实现的分布式锁也会因一定时间没有保持心跳而断开连接，导致分布式锁失效。</p><p>总的来说，Redlock 在保证时钟正确的基础上，是可以保证正确性的。</p><h4 id="Redlock-实践"><a href="#Redlock-实践" class="headerlink" title="Redlock 实践"></a>Redlock 实践</h4><p>追求性能，并能容忍一定的可靠性和安全，可以直接使用单节点的 Redis；对可靠性有追求，可以考虑使用 Redis 的可靠性机制。毕竟，Redlock 较重，而且部署成本高，时钟跳跃问题也不是那么容易解决或避免。</p><h2 id="基于-Etcd-实现"><a href="#基于-Etcd-实现" class="headerlink" title="基于 Etcd 实现"></a>基于 Etcd 实现</h2><p>Etcd 是 CoreOS 团队于 2013 年 6 月发起的开源项目，它的目标是构建一个高可用的分布式键值 (key-value) 数据库。Etcd 内部基于 raft 一致性算法，使用 Go 语言实现。</p><p>Etcd 分布式锁的逻辑如下：</p><ul><li>Lease 机制:即租约机制(TTL，Time To Live)，etcd 可以为存储的 KV 对设置租约，当租约到期，KV 将失效删除;同时也支持续约， 即 KeepAlive。</li><li>Revision 机制:每个 key 带有一个 Revision 属性值，etcd 每进行一次事务对应的全局 Revision 值都会加一，因此每个 key 对应的 Revision 属性值都是全局唯一的。通过比较 Revision 的大小就可以知道进行写操作的顺序。 </li><li>在实现分布式锁时，多个程序同时抢锁，根据 Revision 值大小依次获得锁，可以避免 “羊群效应” (也称 “惊群效应”)，实现公平 锁。</li><li>Prefix 机制:即前缀机制，也称目录机制。可以根据前缀(目录)获取该目录下所有的 key 及对应的属性(包括 key, value 以及 revision 等)。</li><li>Watch 机制:即监听机制，Watch 机制支持 Watch 某个固定的 key，也支持 Watch 一个目录(前缀机制)，当被 Watch 的 key 或目录 发生变化，客户端将收到通知。</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章对分布式锁的几种实现方式进行了介绍，重点分析了 Redis 分布式锁的实现方式，通过不断演进，最终出现了 Redlock ，并对 Redlock 存在的问题进行了说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么需要分布式锁？&quot;&gt;&lt;a href=&quot;#为什么需要分布式锁？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要分布式锁？&quot;&gt;&lt;/a&gt;为什么需要分布式锁？&lt;/h1&gt;&lt;p&gt;分布式系统中，同一系统的不同主机共享同一资源，在访问的时候需要添加互斥语义以
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://gentryhuang.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式锁" scheme="https://gentryhuang.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构 - SDS续</title>
    <link href="https://gentryhuang.com/posts/1a7fe47d/"/>
    <id>https://gentryhuang.com/posts/1a7fe47d/</id>
    <published>2021-12-12T03:10:07.000Z</published>
    <updated>2022-01-19T11:02:30.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://gentryhuang.com/posts/f7ccc3b4/">SDS</a> 中，我们对 Redis 中的简单动态字符串进行了说明。本篇文章将对 SDS 的使用进行简单介绍，主要对 String 类型的 Set 命令、字符串对象的编码、字符串对象的缩容这三个方面进行分析。</p><h2 id="Set命令的实现"><a href="#Set命令的实现" class="headerlink" title="Set命令的实现"></a>Set命令的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+-- t_string.c</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *expire = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> unit = UNIT_SECONDS;</span><br><span class="line">    <span class="keyword">int</span> flags = OBJ_NO_FLAGS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 解析并设置选项参数</span></span><br><span class="line">    <span class="keyword">if</span> (parseExtendedStringArgumentsOrReply(c, &amp;flags, &amp;unit, &amp;expire, COMMAND_SET) != C_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 尝试对值对象进行编码优化，以节省内存</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 执行 set 通用命令方法</span></span><br><span class="line">    setGenericCommand(c, flags, c-&gt;argv[<span class="number">1</span>], c-&gt;argv[<span class="number">2</span>], expire, unit, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数是 SET 命令的处理函数，主要的步骤已经标注，其中 2、3 两步涉及的内容有点多，我们先对涉及的字符串对象编码情况以及缩容进行说明。</p><h2 id="字符串对象的编码"><a href="#字符串对象的编码" class="headerlink" title="字符串对象的编码"></a>字符串对象的编码</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;a href=&quot;https://gentryhuang.com/posts/f7ccc3b4/&quot;&gt;SDS&lt;/a&gt; 中，我们对 Redi
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构 - SDS</title>
    <link href="https://gentryhuang.com/posts/f7ccc3b4/"/>
    <id>https://gentryhuang.com/posts/f7ccc3b4/</id>
    <published>2021-12-04T08:34:15.000Z</published>
    <updated>2021-12-08T11:31:09.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>字符串作为我们日常开发常见的数据类型，几乎任何地方都可能用到，这就要求字符串的实现需要满足以下要求：</p><ul><li>能支持丰富且高效的字符串操作，如字符串追加、获取长度等。</li><li>能保存任意二进制数据，比如图片等</li><li>能尽可能地节省内存开销</li></ul><h1 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C 字符串"></a>C 字符串</h1><p>在 C 语言中可以使用 <strong>char* 字符数组</strong> 来实现字符串，本质就是<strong>一块连续的内存空间，依次存放了字符串中的每个字符</strong>。比如，下图显示的就是字符串“redis”的char*数组结构：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/data_structure/redis-sds-c-array.jpg" alt></p><p>从图中可以看到，字符数组的最后一个字符是“\0”，这个字符的作用是什么呢？其实，C 语言在对字符串进行操作时，<strong>char* 指针只是指向字符数组的起始位置，而字符数组的结尾位置就用“\0”表示，意思是指字符串的结束</strong>。</p><p>C 语言标准库 <code>string.h</code>中也定义了多种字符串的操作函数，比如字符串比较函数 strcmp、字符串长度计算函数 strlen、字符串追加函数 strcat 等，这样就便于开发者直接调用这些函数来完成字符串操作。从以上角度来看，Redis 好像完全可以复用 C 语言中对字符串的实现。但 C 字符串没有很好地解决系列问题。</p><h2 id="字符串高效操作"><a href="#字符串高效操作" class="headerlink" title="字符串高效操作"></a>字符串高效操作</h2><p>C 语言标准库中字符串的操作函数，是通过检查字符数组中是否有<code>\0</code>来判断字符串是否结束，基于此 C 语言操作函数复杂度是不可观的。比如：</p><ul><li>strlen 函数：该函数需要遍历字符数组中的每一个字符，才能得到字符串长度，所以这个操作函数的复杂度是 O(N)。</li><li>strcat 函数：将一个源字符串 src 追加到一个目标字符串的末尾，一方面要先遍历目标字符串找到末尾，然后再遍历源字符串才能完成追加。另一方面，还需要确认目标字符串具有足够的可用空间，否则就无法追加。</li></ul><p>操作函数的复杂度一旦增加，就会影响字符串的操作效率，这就<strong>不符合 Redis 对字符串高效操作的需求了</strong>。</p><h2 id="二进制数安全"><a href="#二进制数安全" class="headerlink" title="二进制数安全"></a>二进制数安全</h2><p>C 语言中 char* 字符串以<code>\0</code>表示字符串的结束，这样决定了它存储数据的局限性。如果我们要保存的数据中本身就有<code>\0</code>，那么数据在<code>\0</code>处就会被截断，这<strong>不符合 Redis 希望保存任意二进制数据的需求</strong>。</p><h2 id="内存分配与释放"><a href="#内存分配与释放" class="headerlink" title="内存分配与释放"></a>内存分配与释放</h2><p>C 语言中 char* 字符串的长度和底层数组的长度之间存在<strong>关联性</strong>，每次增加或者缩短一个 C 字符串，程序都需对保存这个 C 字符串的数组进行一次分配操作，该过程涉及到内存分配和释放。内存操作通常是个比较耗时的操作，这<strong>不符合 Redis 对字符串高效操作的需求了</strong>。</p><h1 id="Redis-中字符串"><a href="#Redis-中字符串" class="headerlink" title="Redis 中字符串"></a>Redis 中字符串</h1><p>综合 C 语言中字符串的不足，Redis 对字符串的实现进行了设计和考虑：</p><ul><li><strong>操作效率高：</strong>Redis 专门设计了 SDS 数据结构，在字符数组的基础上，增加了字符数组存储数据长度和分配空间大小等元数据。这样一来，需要<strong>基于字符串长度</strong>进行的追加、复制、比较等操作，就可以直接读取元数据，效率也就提升了。</li><li><strong>二进制安全：</strong>SDS 数据结构定义了字符数组存储数据长度和分配空间大小等元数据，不需要通过字符数组中的<code>\0</code>字符判断字符串结束，所以可存储包含 \0 的数据，这样就可以存储图片等二进制数据。</li><li><strong>优化内存操作：</strong>SDS 为了避免频繁操作字符串时带来的内存开销，使用了内存预分配和惰性空间释放（多余内存不释放）。</li><li><strong>节省内存空间：</strong>SDS通过设计不同的 SDS 类型来表示不同大小的字符串，并使用<code>__attribute__ ((__packed__))</code>编译优化来实现紧凑型内存布局，达到节省内存的目的。</li><li><strong>兼容C字符串：</strong>可以直接使用 C 语言标准库函数。</li></ul><h2 id="SDS-结构设计"><a href="#SDS-结构设计" class="headerlink" title="SDS 结构设计"></a>SDS 结构设计</h2><p>由于 Redis 是使用 C 语言开发的，所以<strong>为了保证能尽量复用 C 标准库中的字符串操作函数，Redis 保留了使用字符数组来保存实际的数据。但是和 C 语言仅用字符数组不同，Redis 还专门设计了 SDS（即简单动态字符串）的数据结构，内部存储数据使用的还是 C 语言中的字符数组，但定义了几个描述字符数组的元数据</strong>。SDS 结构如下：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/data_structure/redis-sds-struct.jpg" alt></p><p>首先，SDS 结构里包含了一个<strong>字符数组 buf[]，用来保存实际数据</strong>。同时，SDS 结构里还包含了三个元数据，分别是<strong>字符数组现有长度 len</strong>、<strong>分配给字符数组的空间长度 alloc</strong>，以及 <strong>SDS 类型 flags</strong>。其中，<strong>Redis 给 len 和 alloc 这两个元数据定义了多种数据类型，进而可以用来表示不同类型的 SDS</strong>。<strong>注意：</strong>sds 可用的（空闲的）长度:  avail = alloc - len 。</p><p>此外，Redis 使用 typedef 给 char* 类型定义了一个别名，这个别名就是 sds ，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 类型别名，是 SDS 中用于存储字符数据的属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>SDS 本质上还是一个字符数组，因为<strong>核心的存储数据还是使用 C 语言中的字符数组，只是在字符数组的基础上增加了额外的元数据。</strong>在 Redis 中需要用到字符数组时，就直接使用 sds 这个别名，它是 SDS 结构体中用于存储字符的属性。<strong>注意 sds 和 SDS 结构体的区别与联系。</strong></p><h2 id="创建-SDS"><a href="#创建-SDS" class="headerlink" title="创建 SDS"></a>创建 SDS</h2><p>了解了 SDS 结构设计后，我们简单看下 Redis 是如何创建字符串的。Redis 会调用 SDS 中的创建函数 sdsnewlen 新建 SDS 结构体，并把 SDS 结构体中的数组 buf[] 赋给 sds 类型变量，然后把要创建的字符串拷贝给 sds 变量。下面的代码显示了创建 SDS 的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据给定的初始化字符串 init 和字符串长度 initlen 创建一个新的 SDS 字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param init 初始化字符串指针</span></span><br><span class="line"><span class="comment"> * @param initlen 初始化字符串长度</span></span><br><span class="line"><span class="comment"> * @param trymalloc</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sds _sdsnewlen(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen, <span class="keyword">int</span> trymalloc) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向 SDS 结构体的指针</span></span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sds 类型变量，即 char* 字符数组</span></span><br><span class="line">    sds s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据初始化字符串长度选择对应类型的 sds</span></span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8 since type 5 is not good at this. */</span></span><br><span class="line">    <span class="comment">// 创建空字符串通常是为了追加。利用 类型8 因为 类型5 不擅长这个。</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  type 对应的 SDS 结构体中元数据的长度</span></span><br><span class="line">    <span class="comment">// todo hdrlen 是SDS结构体中元数据的长度</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line">    <span class="keyword">size_t</span> usable;</span><br><span class="line"></span><br><span class="line">    assert(initlen + hdrlen + <span class="number">1</span> &gt; initlen); <span class="comment">/* Catch size_t overflow */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据是否尝试 malloc，新建SDS结构，并分配内存空间</span></span><br><span class="line">    <span class="comment">// todo sh 指向当前新建的 SDS 结构，即 sh指向SDS结构体起始位置</span></span><br><span class="line">    sh = trymalloc ?</span><br><span class="line">         s_trymalloc_usable(hdrlen + initlen + <span class="number">1</span>, &amp;usable) :</span><br><span class="line">         s_malloc_usable(hdrlen + initlen + <span class="number">1</span>, &amp;usable);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区相关</span></span><br><span class="line">    <span class="keyword">if</span> (init == SDS_NOINIT)</span><br><span class="line">        init = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有初始化内容</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen + initlen + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sh + hdrlen 表示将指向 SDS 结构的指针移动到 SDS 结构体中的 buf</span></span><br><span class="line">    <span class="comment">// todo 把 SDS 结构体中的数组 buf[] 赋给 sds 类型变量</span></span><br><span class="line">    s = (<span class="keyword">char</span> *) sh + hdrlen;</span><br><span class="line"></span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span> *) s) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防御性编程，防止超过当前 SDS 能表示的字符数组长度</span></span><br><span class="line">    usable = usable - hdrlen - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (usable &gt; sdsTypeMaxSize(type))</span><br><span class="line">        usable = sdsTypeMaxSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类型，为 SDS 结构体属性赋值</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="comment">// 已废弃</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// 根据不同的 SDS 类型，初始化 SDS 结构体属性</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>, s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = usable;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有指定初始化内容，将它们拷贝给 sdshdr 的 buf 中</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以 \0 结尾，表示字符串结束，用于兼容 C 字符串</span></span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 buf 部分，而不是整个 SDS 结构</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SDS-操作效率"><a href="#SDS-操作效率" class="headerlink" title="SDS 操作效率"></a>SDS 操作效率</h2><p>因为 SDS 结构中<strong>记录了字符数组已占用的空间和被分配的空间</strong>，这就比传统 C 语言实现的字符串基础长度操作会带来更高的操作效率。</p><p>以字符串追加操作为例进行介绍。Redis 中实现字符串追加的函数是 sds.c 文件中的 sdscatlen 函数。这个函数的参数一共有三个，分别是目标字符串 s、源字符串 t 和要追加的长度 len，源码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将长度为 len 的字符串 t 追加到 sds 的字符串末尾</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s 目标字符串</span></span><br><span class="line"><span class="comment"> * @param t 源字符串</span></span><br><span class="line"><span class="comment"> * @param len 要追加的字符串长度</span></span><br><span class="line"><span class="comment"> * @return 追加成功返回新 sds ，失败返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取目标字符串s的当前长度</span></span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line">    <span class="comment">//根据要追加的长度len和目标字符串s的现有长度，判断是否要扩容</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将源字符串t中len长度的数据拷贝到目标字符串结尾</span></span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    <span class="comment">//设置目标字符串的最新长度：拷贝前长度curlen加上拷贝长度</span></span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    <span class="comment">//拷贝后，在目标字符串结尾加上\0</span></span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，和 C 语言中的字符串操作相比，SDS 通过记录字符数组的使用长度和分配空间大小，避免了对字符串的遍历操作，降低了操作开销，进一步就可以帮助诸多字符串操作更加高效地完成，比如创建、追加、复制、比较等。</p><h2 id="内存预分配"><a href="#内存预分配" class="headerlink" title="内存预分配"></a>内存预分配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对 SDS 中 buf 的长度进行扩展，确保在函数执行之后，buf 至少会有 addlen + 1 长度的空余空间。</span></span><br><span class="line"><span class="comment"> * （额外的 1 字节是为 \0 准备的）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s buf</span></span><br><span class="line"><span class="comment"> * @param addlen 预计新增的字符串长度</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh, *newsh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 获取 sds 目前可用的空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> avail = sdsavail(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 s 对应的 SDS 类型（在创建 SDS 时，内部属性 buf[-1] 保存的就是 SDS 类型）</span></span><br><span class="line">    <span class="keyword">char</span> type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    <span class="keyword">int</span> hdrlen;</span><br><span class="line">    <span class="keyword">size_t</span> usable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 sds 目前的剩余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-- 执行到这里，说明 sds 剩余空间不足，需要进行扩容 ----*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 获取 sds 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 获取 sds 所在的 SDS 结构体</span></span><br><span class="line">    sh = (<span class="keyword">char</span> *) s - sdsHdrSize(oldtype);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5 获取新的长度，sds 当前长度 + addlen</span></span><br><span class="line">    newlen = (len + addlen);</span><br><span class="line">    assert(newlen &gt; len);   <span class="comment">/* Catch size_t overflow */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6 判断是否需要扩容，以实现预分配</span></span><br><span class="line">    <span class="comment">// todo 小于 1MB 翻倍扩容，大于 1MB 按 1MB 扩容</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7 根据预扩容的大小，获取对应类型的 SDS</span></span><br><span class="line">    <span class="comment">// todo 为了有效节省内存空间，使用不同的 SDS 类型保存相应大小的数据</span></span><br><span class="line">    type = sdsReqType(newlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SDS_TYPE_5 已经废弃，如果是 SDS_TYPE_5 ，则默认使用 SDS_TYPE_8</span></span><br><span class="line">    <span class="comment">/* Don't use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*---- 确定了 SDS 类型，就可以进行空间分配了 --------*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8 获取结构头的大小，即 SDS 结构体的元数据大小</span></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    assert(hdrlen + newlen + <span class="number">1</span> &gt; len);  <span class="comment">/* Catch size_t overflow */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.1 如果 SDS 类型还是之前的类型</span></span><br><span class="line">    <span class="keyword">if</span> (oldtype == type) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结构头大小不变，无需要将字符串向前移动，即无需数据拷贝</span></span><br><span class="line">        <span class="comment">// 新的指向 SDS 指针</span></span><br><span class="line">        newsh = s_realloc_usable(sh, hdrlen + newlen + <span class="number">1</span>, &amp;usable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内容不足，分配失败</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 SDS 中的 char buf[]</span></span><br><span class="line">        s = (<span class="keyword">char</span> *) newsh + hdrlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8.2 如果 SDS 类型是新的类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于结构头大小改变，需要将字符串向前移动，不能使用 realloc</span></span><br><span class="line">        <span class="comment">// 新的指向 SDS 指针</span></span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,and can't use realloc */</span></span><br><span class="line">        newsh = s_malloc_usable(hdrlen + newlen + <span class="number">1</span>, &amp;usable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内容不足，分配失败</span></span><br><span class="line">        <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原来的字符串数据拷贝到新的 SDS 中的 buf 中</span></span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span> *) newsh + hdrlen, s, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放原来的 SDS 结构体</span></span><br><span class="line">        s_free(sh);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 SDS 中的 char buf[]</span></span><br><span class="line">        s = (<span class="keyword">char</span> *) newsh + hdrlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// todo 标记 buf 属于哪种 SDS 类型</span></span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 sds 实际长度</span></span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9 获取 SDS 结构体最大可存储字符串的长度，这里 -1 是包括数组最后一位 \0</span></span><br><span class="line">    usable = usable - hdrlen - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防御性编程</span></span><br><span class="line">    <span class="keyword">if</span> (usable &gt; sdsTypeMaxSize(type))</span><br><span class="line">        usable = sdsTypeMaxSize(type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 sds 分配的长度，注意，这里并不是直接使用扩容后的 newlen ,而是使用计算得来。</span></span><br><span class="line">    <span class="comment">// 注意，分配的长度不包括 \0 占用的字符</span></span><br><span class="line">    sdssetalloc(s, usable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 sds</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用内存预分配，可以减少连续执行字符串增长操作所需的内存重新分配次数，也可以避免缓冲区溢出。</p><h2 id="紧凑型字符串结构"><a href="#紧凑型字符串结构" class="headerlink" title="紧凑型字符串结构"></a>紧凑型字符串结构</h2><p>SDS 结构中有一个元数据 flags，表示的是 SDS 类型。事实上，SDS 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。这 5 种类型的<strong>主要区别就在于：</strong>它们数据结构中的<strong>字符数组现有长度 len 和分配空间长度 alloc，这两个元数据的数据类型不同</strong>。下面以 sdshdr8 为例，它的定义如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="comment">// 字符数组现有长度。 8 位无符号整型，占用 1 字节的内存空间</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="comment">// 字符数组已经分配的长度, 不包括结构体和\0结束符</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="comment">// SDS 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="comment">// 字符数组，用来保存实际数据</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到，现有长度 len 和已分配空间 alloc 的数据类型都是 uint8_t，它是 8 位无符号整型，会占用 1 字节的内存空间。当字符串类型是 sdshdr8 时，<strong>它能表示的字符数组长度（包括数组最后一位\0）不会超过 256 字节（2 的 8 次方等于 256）</strong>。</p><p>实际上，<strong>SDS 之所以设计不同的结构头（即不同类型），是为了能灵活保存不同大小的字符串，从而有效节省内存空间</strong>。因为在保存不同大小的字符串时，结构头占用的内存空间也不一样，这样一来，在保存小字符串时，结构头占用空间也比较少。</p><h2 id="使用编译优化来节省内存空间"><a href="#使用编译优化来节省内存空间" class="headerlink" title="使用编译优化来节省内存空间"></a>使用编译优化来节省内存空间</h2><p>除了设计不同类型的结构头，Redis 在编程上还 <strong>使用了专门的编译优化来节省内存空间</strong>。</p><p>在定义不同类型的结构头时，使用了 <code>__attribute__ ((__packed__))</code> ，目的是告诉编译器，在编译结构时，不要使用字节对齐的方式，而是<strong>采用紧凑的方式分配内存</strong>。下面以 sdshdr8 结构定义为例进行分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span></span></span><br></pre></td></tr></table></figure><p>在默认情况下，编译器会按照 8 字节对齐的方式，给变量分配内存。也就是说，即使一个变量的大小不到 8 个字节，编译器也会给它分配 8 个字节。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>针对 C 语言中 char* 实现字符串的缺陷，Redis 基于 char* 基础之上设计了 SDS 结构。这一设计是从 <code>操作效率</code>、<code>二进制安全</code>、<code>内存开销</code> 以及<code>兼容 C 字符串</code> 方面思考的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;字符串作为我们日常开发常见的数据类型，几乎任何地方都可能用到，这就要求字符串的实现需要满足以下要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能支持丰富且
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis原理 - Redis主流程</title>
    <link href="https://gentryhuang.com/posts/19fe4bc5/"/>
    <id>https://gentryhuang.com/posts/19fe4bc5/</id>
    <published>2021-11-27T16:00:00.000Z</published>
    <updated>2021-12-07T03:19:06.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本篇文章将从源码层面对 Redis 主干轮廓进行说明。以主线程执行流程为主干，对途径的枝枝蔓蔓简单介绍，不会过度展开，后续将针对每一个模块进行详细分析。由于 Redis 是用 C 语言实现的，当然应该从 main 函数开启阅读源码旅程。</p><h1 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h1><p>Redis 服务器启动的入口是 main 函数，其它的无需多说，下面直接上代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis Server 启动入口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *  Redis是用C语言实现的，从 main 函数启动。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">char</span> config_from_stdin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INIT_SETPROCTITLE_REPLACEMENT</span></span><br><span class="line">    <span class="comment">// 1 初始化库</span></span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 检查服务器是否以 Sentinel 模式启动</span></span><br><span class="line">    <span class="comment">// 这一点非常重要，因为 Sentinel 和普通的实例不同</span></span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3  初始化服务器配置</span></span><br><span class="line">    initServerConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4 ACL 初始化（6.0 对 ACL 进行了功能丰富）</span></span><br><span class="line">    ACLInit(); <span class="comment">/* The ACL subsystem must be initialized ASAP because the</span></span><br><span class="line"><span class="comment">                  basic networking code and client creation depends on it. */</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 5 如果服务器以 Sentinel 模式启动，那么需要进行 Sentinel 功能相关的初始化，并为要监视的主服务器创建一些相应的数据结构</span></span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">        <span class="comment">// Sentinel 所属的属性覆盖服务器默认的属性</span></span><br><span class="line">        initSentinelConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哨兵模式初始化</span></span><br><span class="line">        initSentinel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 6 是否需要在 redis-check-rdb/aof模式下启动，这样可以校验持久化文件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>], <span class="string">"redis-check-rdb"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_rdb_main(argc, argv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(argv[<span class="number">0</span>], <span class="string">"redis-check-aof"</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        redis_check_aof_main(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7 检查用户是否指定了配置文件，或者配置选项</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">background</span> = server.daemonize &amp;&amp; !server.supervised;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8 将服务器设置为守护进程运行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">background</span>) daemonize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9 创建并初始化服务器</span></span><br><span class="line">    initServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 🌟 服务器不是运行在 SENTINEL 模式，那么执行以下代码</span></span><br><span class="line">    <span class="keyword">if</span> (!server.sentinel_mode) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 10  bio 和 io 线程的初始化</span></span><br><span class="line">        InitServerLast();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 11 从 AOF 文件或者 RDB 文件中载入数据</span></span><br><span class="line">        loadDataFromDisk();</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (verifyClusterConfigWithData() == C_ERR) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                          <span class="string">"You can't have keys in a DB different than DB 0 when in "</span></span><br><span class="line">                          <span class="string">"Cluster mode. Exiting."</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 以 SENTINEL 模式运行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ACLLoadUsersAtStartup();</span><br><span class="line">        <span class="comment">// bio 和 io 线程的初始化</span></span><br><span class="line">        InitServerLast();</span><br><span class="line">        <span class="comment">// Sentinel 准备就绪后执行</span></span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12 🌟 启动事件处理循环</span></span><br><span class="line">    <span class="comment">// 主要围绕 IO多路复用 展开的，驱动注册的时间事件回调和 IO 事件回调</span></span><br><span class="line">    aeMain(server.el);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12 退出事件循环，回收内存</span></span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retun 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 服务启动后，主线程 main 会依次执行以上流程，直到进入 <strong>aeMain</strong> 事件处理循环方法中。需要说明的是，上述代码片段删除掉了不关心的逻辑，本篇文章我们只关注以下两个逻辑：</p><ul><li>执行各种初始化</li><li>执行事件循环</li></ul><p>Redis 服务器初始化逻辑较为复杂，从底层的数据结构到服务器不同的角色，初始化的逻辑和属性都不一样，这里就不展开了。下面对流程进行概括：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/themory/redis-outline-main-process.jpg" alt></p><h1 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h1><p>事件循环逻辑是 Redis 核心的直接体现，它就是在这个循环中不断处理网络请求和内部自身逻辑的。下面我们直接上代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;<span class="built_in">stop</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程进入主循环，一直处理事件，直到服务器关闭</span></span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;<span class="built_in">stop</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始处理事件</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS |</span><br><span class="line">                                   AE_CALL_BEFORE_SLEEP |</span><br><span class="line">                                   AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，只要事件循环 <code>aeEventLoop</code> 没有被停止，主线程 main 就会一直自旋，不断执行 <code>aeProcessEvents</code> 方法。不难看出 <code>aeProcessEvents</code> 方法封装了 Redis 的所有功能逻辑，这里提前说下，Redis 的功能逻辑总共两大类：一个是网络事件，也称为文件事件；另一个是时间事件；前者用于处理网络中的交互，后者用于处理 Redis 自身的一些逻辑。</p><p>下面继续贴出 <code>aeProcessEvents</code> 方法的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing to do? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line">        <span class="keyword">int64_t</span> usUntilTimer = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 获取最近的时间事件</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            usUntilTimer = usUntilEarliestTimer(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.1 使用 usUntilTimer 来决定文件事件的阻塞时间</span></span><br><span class="line">        <span class="keyword">if</span> (usUntilTimer &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            tv.tv_sec = usUntilTimer / <span class="number">1000000</span>;</span><br><span class="line">            tv.tv_usec = usUntilTimer % <span class="number">1000000</span>;</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.2 执行到这里，说明没有时间事件。那么根据 AE_DONT_WAIT 是否设置来决定是否阻塞，以及阻塞的时间长度</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                <span class="comment">// 设置文件事件不阻塞</span></span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Otherwise we can block */</span></span><br><span class="line">                <span class="comment">// 文件事件阻塞直到有事件到达为止</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">            tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2 前置回调函数 - beforeSleep */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_BEFORE_SLEEP)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">        <span class="number">3</span> 调用多路复用 API，只会在超时或某些事件触发时返回。即等待事件产生</span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">        <span class="comment">/* 4 后置回调函数 - beforeSleep */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.1 从已就绪数组中获取文件描述符信息</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> fired = <span class="number">0</span>; <span class="comment">/* Number of events fired for current fd. */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.2 如果是套接字上发生读事件，调用读事件处理器处理读事件</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">                fired++;</span><br><span class="line">                fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Fire the writable event. */</span></span><br><span class="line">            <span class="comment">// 5.3 如果是套接字上发生写事件，调用写事件处理器处理写事件</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we have to invert the call, fire the readable event now</span></span><br><span class="line"><span class="comment">             * after the writable one.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 如果需要反转调用，在可写事件之后触发可读事件</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (invert) &#123;</span><br><span class="line">                fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">                <span class="keyword">if</span> ((fe-&gt;mask &amp; mask &amp; AE_READABLE) &amp;&amp;</span><br><span class="line">                    (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc)) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop, fd, fe-&gt;clientData, mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 6 如果是时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        <span class="comment">// 执行时间事件</span></span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码片段中也可以看到，主线程在不断轮询时间事件和文件事件，找到就尝试执行。上述代码虽然简短，但是却几乎包含了 Redis 的所有功能，秘密就在以下几个组件中：</p><ul><li>前置处理器 beforeSleep </li><li>IO多路复用库（及多种回调函数）</li><li>后置处理器 afterSleep</li></ul><p>关于以上代码片段背后的信息，会在后面的文章中介绍 Redis 事件一文中详细说明，这里先不展开。下面对以上方法进行概括：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/themory/redis-outline-multi-process.jpg" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章简单介绍了 Redis 启动的入口以及执行的主干流程，这里有个印象即可，后续会对每个模块展开说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本篇文章将从源码层面对 Redis 主干轮廓进行说明。以主线程执行流程为主干，对途径的枝枝蔓蔓简单介绍，不会过度展开，后续将针对每一个模块进
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis 源码结构总览</title>
    <link href="https://gentryhuang.com/posts/adccc332/"/>
    <id>https://gentryhuang.com/posts/adccc332/</id>
    <published>2021-11-27T06:59:01.000Z</published>
    <updated>2021-12-07T03:20:43.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从本篇文章开始，将对 Redis 核心原理以及相关源码进行分析，需要说明的是，笔者阅读的 Redis 版本是 <code>#define REDIS_VERSION &quot;6.2.4&quot;</code>，之所以选择较新的版本，因为笔者对 Redis 一些新特性比较感兴趣，特别是 Redis 在 6.0 版本中提出的 IO 多线程。</p><h1 id="Redis-源码结构"><a href="#Redis-源码结构" class="headerlink" title="Redis 源码结构"></a>Redis 源码结构</h1><p>了解源码的整体目录结构是快速对代码进行认知的一个行之有效的方法。下面我们对 Redis 的源码目录进行简单介绍。</p><h2 id="Redis-源码整体结构"><a href="#Redis-源码整体结构" class="headerlink" title="Redis 源码整体结构"></a>Redis 源码整体结构</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/redis-summary-struct.jpg" alt></p><p>对于 Redis 来说，在它的源码总目录下，一共包含了 <strong>deps</strong>、<strong>src</strong>、<strong>tests</strong>、<strong>utils</strong> 四个子目录，这四个子目录分别对应了 Redis 中发挥不同作用的代码，下面我们具体来看看。</p><h3 id="deps-目录"><a href="#deps-目录" class="headerlink" title="deps 目录"></a>deps 目录</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/redis-deps-struct.jpg" alt></p><p>这个目录<strong>主要包含了 Redis 依赖的第三方代码库</strong>，包括 Redis 的 C 语言版本客户端代码 hiredis、jemalloc 内存分配器代码、readline 功能的替代代码 linenoise，以及 lua 脚本代码。</p><p>这部分代码的一个显著特点，就是<strong>它们可以独立于 Redis src 目录下的功能源码进行编译</strong>，也就是说，它们可以独立于 Redis 存在和发展。</p><h3 id="src-目录"><a href="#src-目录" class="headerlink" title="src 目录"></a>src 目录</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/redis-src-struct.jpg" alt></p><p>目录里面包含了 Redis 所有功能模块的代码文件，也是 Redis 源码的重要组成部分。src 目录下只有一个 modules 子目录，剩余的源码文件都是在 src 目录下，没有再分下一级子目录。因为 Redis 的功能模块实现是典型的 C 语言风格，不同功能模块之间不再设置目录分隔，而是通过头文件包含来相互调用。</p><h3 id="tests-目录"><a href="#tests-目录" class="headerlink" title="tests 目录"></a>tests 目录</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/redis-tests-struct.jpg" alt></p><p>在 Redis 的代码目录中，将功能测试和单元测试分代码用一个 tests 目录统一管理了起来。Redis 实现的测试代码可以分成四部分，分别是单元测试（对应 unit 子目录），Redis Cluster 功能测试（对应 cluster 子目录）、哨兵功能测试（对应 sentinel 子目录）、主从复制功能测试（对应 integration 子目录）。这些子目录中的测试代码使用了 Tcl 语言（通用的脚本语言）进行编写，主要目的就是方便进行测试。</p><p>在 tests 目录中，除了有针对特定功能模块的测试代码外，还有一些代码是用来支撑测试功能的，这些代码在 assets、helpers、modules、support 四个目录中。</p><h3 id="utils-目录"><a href="#utils-目录" class="headerlink" title="utils 目录"></a>utils 目录</h3><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/redis/redis-utils-struct.jpg" alt></p><p>在 Redis 开发过程中，还有一些功能属于辅助性功能，包括用于创建 Redis Cluster 的脚本、用于测试 LRU 算法效果的程序，以及可视化 rehash 过程的程序。在 Redis 代码结构中，这些功能代码都被归类到了 utils 目录中统一管理。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Redis 源码的整体结构相对还是比较简单的，但定义的这些包结构涵盖了一个应用软件所具备的所有功能。通过本篇文章先从代码结构层面对 Redis 有个了解，后续将针对核心模块进行原理介绍，以及源码的阅读。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>笔者刚入门编程时学习的就是 C 语言，虽然掌握了 Redis 的核心模块的工作原理，但也只是停留在记忆和理解层面，也曾尝试过阅读 Redis 的源码，但并不系统。偶然的机会，看见极客时间推出的 Redis 源码课程，就决定重新对 Redis 源码进行梳理和补充，最终的目标就是 <strong>知其原理，懂其源码！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;从本篇文章开始，将对 Redis 核心原理以及相关源码进行分析，需要说明的是，笔者阅读的 Redis 版本是 &lt;code&gt;#define R
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://gentryhuang.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>限流算法</title>
    <link href="https://gentryhuang.com/posts/32609cb8/"/>
    <id>https://gentryhuang.com/posts/32609cb8/</id>
    <published>2021-11-23T16:00:00.000Z</published>
    <updated>2021-11-30T09:26:37.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>限流顾名思义是限制流量，目的是为了保障服务稳定运行，避免服务被流量冲垮。</p><p>为什么要限流？因为再厉害的系统总有所能承载的能力上限，一旦流量突破这个上限，就会引起实例宕机，进而发生系统雪崩，带来灾难性后果。限流是系统自我保护的最直接手段，当流量超出服务处理能力时，部分请求将会被限流组件拦截，根据具体业务场景选择丢失。</p><h1 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h1><h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>计算器算法的思想很简单，每当一个请求到来时，就将计数器加一，当计数器数值超过阈值后，就拒绝接收到的请求。在指定周期内，计数器会重置，开始新一轮的计数。计数器算法简单粗暴，易于实现。但是缺点也是很大的，容易造成前一个时间段非常忙碌，下一时间段又非常空闲。</p><h2 id="漏通算法"><a href="#漏通算法" class="headerlink" title="漏通算法"></a>漏通算法</h2><p>漏桶算法由流量容器、流量入口和流量出口组成。流量入口一般就是业务请求，流量容器用于暂存一定大小的业务流量，流量出口则是我们设定的限速值，比如 1000 QPS。漏桶算法如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/current_limiting/current-limiting-bucket.png" alt></p><p>如上图，流入漏桶流量的流速是不可控的，但流出流量的速度是恒定的，而漏桶的容量是有限的，这就会导致一旦流入流量超出漏桶容量，这部分流量只能被丢弃了。</p><p>漏桶算法可以通过暂存一定的流量达到流量整形的目的，但是漏桶不能处理突发流量。</p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>令牌桶和漏桶算法既有相似之处，又有很大的不同，不同之处也是令牌桶算法能够支持突发流量的原因。</p><p>令牌桶算法需要一个令牌工厂以一定周期向令牌桶中放入令牌，当令牌桶满了之后，多出的令牌会被丢弃。每当一个请求到来时都会先从令牌桶中取令牌，由于令牌桶中可能存放了很多令牌，因此允许多个请求同时取令牌，如果令牌够多就可以在一定程度上支持突发流量。当令牌桶中没有令牌后，无法获取到令牌的请求可以丢弃，或者重试。令牌桶算法如下图：</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/architecture/current_limiting/current-limiting-token.png" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本篇文章简单介绍了常见的三种限流算法，它们被落地到不同的实现中，如 Dubbo 中的 <code>TpsLimitFilter</code> 使用的就是计算器限流算法，Google 提供的 <code>RateLimiter</code> 开源包使用的是基于令牌桶算法。</p><p><strong>总体来说，限流既可以是在客户端限流，也可以是在服务端限流。此外，限流的实现方式既可支持 URL 以及方法级别的限流，也可支持基于 QPS 和线程的限流。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;限流顾名思义是限制流量，目的是为了保障服务稳定运行，避免服务被流量冲垮。&lt;/p&gt;
&lt;p&gt;为什么要限流？因为再厉害的系统总有所能承载的能力上限
      
    
    </summary>
    
    
      <category term="分布式" scheme="https://gentryhuang.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="限流" scheme="https://gentryhuang.com/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>并发 - JMM</title>
    <link href="https://gentryhuang.com/posts/11b0627b/"/>
    <id>https://gentryhuang.com/posts/11b0627b/</id>
    <published>2021-09-20T01:14:12.000Z</published>
    <updated>2022-01-07T07:54:44.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章将对 Java 的内存模型（JMM）进行介绍，本质上它是一种编程语言规范，用于尝试统一一个能够在各种处理器架构中为并发提供一致语义的内存模型（不同处理器架构一般具有不同强度的模型）。驱动 Java 内存模型产生的原因有很多，如编译器优化、处理器乱序执行和缓存等，这些因素导致并发程序中有些行为是非法的。因此，在介绍 Java 内存模型之前，我们先对并发编程相关概念进行说明，然后再引出 Java 内存模型。</p><h1 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h1><p>了解现代计算机硬件架构对理解 Java 内存模型非常重要，常见的硬件内存架构图如下：</p><p><img src="/posts/11b0627b/computer-hardware-memory-architecture.jpg" alt></p><p>下面我们重点对硬件内存架构的组成，缓存一致性问题进行介绍。</p><h2 id="硬件内存组成"><a href="#硬件内存组成" class="headerlink" title="硬件内存组成"></a>硬件内存组成</h2><p>现代计算机内存架构包括：多CPU、CPU寄存器、CPU缓存以及共享的内存。</p><p><strong>多CPU</strong></p><blockquote><p>现代计算机通常有 2 个或更多 CPU ，其中一些 CPU 可能具有多个核。当只有一个 CPU 时，要运行多个程序（进程）的话，就意味着要经常进行进程上下文切换。尽管单 CPU 是多核，也只是多个处理器核心，其他设备都是共用的，所以多个进程就必然要经常进行进程上下文切换，这个代价是很高的。</p></blockquote><p><strong>CPU多核</strong></p><blockquote><p>一个多核的 CPU 也就是一个 CPU 上有多个处理器核心。</p></blockquote><p><strong>CPU寄存器</strong></p><blockquote><p>每个 CPU 都包含一组寄存器，它们是 CPU 内存的基础。CPU 在寄存器上执行操作的速度远大于在主存上执行的速度。这是因为 CPU 访问寄存器的速度远大于主存。</p></blockquote><p><strong>CPU缓存</strong></p><blockquote><p>每个 CPU 还可能有一个 CPU 缓存存储器层。事实上，大多数现代 CPU 都有一定大小的缓存层，位于 CPU 与主内存间的一种容量较小但速度很高的存储器，但通常不如访问其内部寄存器的速度快。由于 CPU 的速度远高于主内存，CPU 直接从主内存中存取数据要等待一定时间周期。CPU 缓存中保存着 CPU 刚用过或循环使用的一部分数据，当 CPU 再次使用该部分数据时可从缓存中直接获取, 减少了 CPU 的等待时间，提高了系统的效率。</p></blockquote><p>一些 CPU 可能有多个缓存层，具体如下：</p><blockquote><ul><li><strong>一级缓存(L1 Cache)</strong>: 容量最小，速度最快，每个核独有。针对指令和数据分为数据缓存和指令缓存</li><li><strong>二级缓存(L2 Cache)</strong>: 容量比 L1 大，速度比 L1 慢，每个核独有</li><li><strong>三级缓存(L3 Cache)</strong>: 容量最大，速度最慢，<strong>多个核共享</strong></li></ul></blockquote><p>由于Cache的容量很小，一般都是充分的利用局部性原理，按<strong>行/块</strong>来和主存进行批量数据交换，以提升数据的访问效率。</p><p><strong>内存</strong></p><blockquote><p>计算机还包含一个主存储区 (RAM)，所有 CPU 都可以访问它。主内存区域通常比 CPU 的高速缓存大得多。</p></blockquote><p><strong>读取数据</strong></p><blockquote><ul><li><strong>取寄存器中的值</strong>: 只需要一步，直接读取即可。</li><li><strong>取L1中的值</strong>: 先锁住<strong>缓存行</strong>，然后取出数据，最后解锁。如果没有锁住说明慢了。</li><li><strong>取L2中的值</strong>: 先到 L1 中取，L1 中不存在再到 L2 中取。L2 开始加锁，将 L2 中的数据复制到 L1 ，再执行从 L1 中读取数据的步骤，解锁 L2。</li><li><strong>取L3中的值</strong>: 同样地，先将数据由 L3 复制到 L2，然后从 L2 复制到 L1 ，从 L1 读取数据。</li></ul></blockquote><p>CPU 在读取数据时，先在 L1 中寻找，再从 L2 中寻找，再从 L3 中寻找，然后是内存，最后是外存储器。</p><h2 id="CPU优化手段"><a href="#CPU优化手段" class="headerlink" title="CPU优化手段"></a>CPU优化手段</h2><p>为了提高程序运行的性能，现代 CPU 在很多方面对程序进行了优化。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>CPU 高速缓存，尽可能地避免处理器访问主内存的时间开销，处理器大多会利用缓存提高性能。</p><p><img src="/posts/11b0627b/cpu-cache-level.jpg" alt></p><h3 id="运行时指令重排"><a href="#运行时指令重排" class="headerlink" title="运行时指令重排"></a>运行时指令重排</h3><p>为了提高 CPU 处理性能，CPU 可能会乱序执行。如，当 CPU 写缓存时发现缓存曲块正被其它 CPU 占用，为了提高 CPU 处理性能，可能将后面的读缓存命令优先执行。</p><p><img src="/posts/11b0627b/cpu-command-process.jpg" alt></p><p>注意，CPU 指令重排并非随意重排，需要遵守 <strong>as-if-serial语义</strong> ，该语义表示：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，运行时和处理器都必须遵守 <strong>as-if-serial 语义</strong>。也就是说，编译器和处理器<strong>不会对存在数据依赖关系的操作做重排序</strong>。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>基于高速缓存很好地解决了处理器与内存的速度矛盾，但是也引入了新的问题-<strong>缓存一致性(CacheCoherence)</strong>。缓存中的数据与主内存的数据并不是实时同步的，各 CPU（或 CPU 核）间缓存的数据也不是实时同步。也就是说，在同一个时间点，各 CPU 所看到同一内存地址的数据的值可能不一致。如，当多个处理器执行的任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致的情况，这样不一致的情况如果同步回主内存时以哪个处理为准呢？</p><p><img src="/posts/11b0627b/computer-hardware-memory-architecture-issue.jpg" alt></p><p>运行在左侧 CPU 上的一个线程将共享对象复制到其 CPU 缓存中，并将其count变量更改为 2。此更改对运行在右侧 CPU 上的其他线程不可见，因为更新的count尚未刷新回主内存.</p><h3 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h3><p>所有内存的传输都发生在一条共享的总线上，所有的处理器都会使用该总线。虽然 CPU 缓存各自是独立的，但是主存是共享的，所有的内存访问都要经过总线加锁机制来决定是否可以进行内存的读写，也就是说在同一个指令周期中，只可能有一个 CPU 可以读写内存。</p><p>所谓总线锁就是使用处理器提供的一个 <code>LOCK#信号</code> ，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，只有该处理器可以独占共享内存。</p><h3 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h3><p>总线锁虽然可以保证缓存数据的一致性，但是它比较粗暴，当某个 CPU 对总线进行加锁后，所有后续其它 CPU 对主存的操作都是阻塞的，这样机制就必定会降低性能。因此，缓存一致性协议出现了，它是硬件程序的产物，用来保证缓存之间可见。</p><p>缓存一致性协议有多种，如 <strong>MSI</strong>、<strong>MESI</strong> 等，多数 CPU 厂商对缓存一致性协议进行了实现。下面我们以 <strong>MESI</strong> 协议为例，对其进行介绍。</p><p><strong>MESI协议</strong>规定每个缓存行有个状态位，同时定义了下面四个状态：</p><h4 id="专有态-Exclusive"><a href="#专有态-Exclusive" class="headerlink" title="专有态(Exclusive)"></a>专有态(Exclusive)</h4><p>锁住的缓存行内容只存在当前 CPU 缓存中且同于主存，不出现于其它缓存中，所以当 CPU 发现自己缓存中的共享数据是<strong>专有态(Exclusive)</strong>时，说明该数据是最新的，可以直接读取。</p><p>当缓存行处于<strong>专有态(Exclusive)</strong>时，在任何时刻当有其它 CPU 缓存了该数据时，那么缓存行会由<strong>专有态(Exclusive)</strong>变成<strong>共享态(Shared)</strong>。</p><h4 id="共享态-Shared"><a href="#共享态-Shared" class="headerlink" title="共享态(Shared)"></a>共享态(Shared)</h4><p>锁住的缓存行同于主存，且该缓存行可能被多个 CPU 缓存，各个缓存与主内存数据一致，所以当 CPU 发现自己缓存中的共享数据是<strong>共享态(Shared)</strong>时，说明该数据是最新值，可以直接读取。</p><p>当缓存行处于<strong>共享态(Shared)</strong>时，当任一个 CPU 修改缓存行时，其它 CPU 中该缓存行变成<strong>无效态(Invalid)</strong>。</p><h4 id="修改态-Modified"><a href="#修改态-Modified" class="headerlink" title="修改态(Modified)"></a>修改态(Modified)</h4><p>锁住的缓存行已被修改（脏行），内容已不同于主存。该状态是一个中间状态，缓存行的数据需要在未来某个时间点写回主内存，当被写回主内存之后，该缓存行就会变成专有状态。</p><p>当 CPU 对缓存行进行修改时，变为<strong>修改态(Modified)</strong>，并且同时会向其他缓存了该数据的 CPU 缓存发送一条 Invalid 指令，告诉其他缓存自己对数据进行了修改，让它们把数据对应的缓存行置为<strong>无效态(Invalid)</strong>； 当收到其它 CPU 缓存 Invalid 指令的成功响应时，当前 CPU 缓存会就会把数据同步到主存里面去，然后自己的缓存行由<strong>修改态(Modified)</strong>变为<strong>专有态(Exclusive)</strong>，当有其他 CPU 缓存从主存中读取到了最新的数据时，数据状态会变为<strong>共享态(Shared)</strong>。</p><h4 id="无效态-Invalid"><a href="#无效态-Invalid" class="headerlink" title="无效态(Invalid)"></a>无效态(Invalid)</h4><p>当缓存行处于<strong>无效态(Invalid)</strong>时，说明对应的数据已经被其它 CPU 修改过了，当前锁住的缓存行无效，必须从主存中重新读取。</p><p>无效态(Invalid)是由于收到其它 CPU 发来的 Invalid 指令，收到该指令的 CPU 缓存会把对应的缓存行状态标记为<strong>无效态(Invalid)</strong>，所以当数据处于<strong>无效态(Invalid)</strong>时表示数据已经被别人修改了，当前数据是无效的。</p><p>多处理器时，单个 CPU 对缓存中数据进行改动需要通知给其他 CPU 。也就意味着在缓存一致性协议下，CPU 处理要控制自己的读写操作，还要监听（嗅探）其它 CPU 发出的通知，从而保证<strong>最终一致</strong>。</p><p>这里需要说明下，MESI协议可以在 CPU 修改数据时向其他 CPU 发送消息，但不会出现两个CPU同时修改数据，进而向其他CPU进行消息通知。这样的并发修改通过缓存锁定机制解决的，它会锁定这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性。只有在数据修改的时候才会需要加缓存锁，修改数据的时候先锁定缓存行，不让其他CPU同时修改，其他CPU读取数据是允许的。缓存是否失效是由缓存一致性协议来处理的，它解决一个 CPU 修改其它 CPU 看不到的问题。缓存锁解决几个 CPU 并发修改的问题。</p><p><strong>以下两种情况下处理器会使用总线锁：</strong></p><ul><li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时</li><li>处理器不支持缓存锁定</li></ul><h4 id="Store-Buffer"><a href="#Store-Buffer" class="headerlink" title="Store Buffer"></a>Store Buffer</h4><p>前文在描述 MESI 协议时，如果对缓存行进行修改需要经历以下过程：</p><ol><li>某个CPU修改自己缓存的值</li><li>修改缓存后通知其它CPU，等待其它CPU响应</li><li>收到所有CPU的响应</li><li>将缓存中的数据同步到主存</li></ol><p>可以看到，以上整个过程都是同步的，CPU 发送完通知后必须同步等待所有其它 CPU 的响应，而这个过程中当前 CPU 又无法释放出来，所以为了避免这种 CPU 运算资源的浪费，就需要一种方式来进行优化了，此时 <strong>Store Buffer</strong> 就出来了。</p><p><img src="/posts/11b0627b/cpu-store-buffer.png" alt></p><p>当 CPU 对某个共享变量修改时，向其他 CPU 发出 Invalid 指令后不同步等待其他 CPU 指令的响应了，而是直接把最新值写入 Store Bufferes 缓冲区里，然后直接可以去干别的事情了，直到所有的 CPU 都对 Invalid 指令响应后，再把共享变量的值从 Store Buffere 里拿出来，然后写入到自己的缓存里同时同步到主存中。</p><h4 id="Store-Forward"><a href="#Store-Forward" class="headerlink" title="Store Forward"></a>Store Forward</h4><p>Store Forward 称为存储转发。具体是：当 CPU 读取数据时需要先检查它的 Store Buffer 缓冲区中有没有，如果有则直接读取该缓冲区中的值，没有才会读取自己缓存中的值。解决了 Store Buffer 优化过程中由于只读取缓存导致的缓存脏数据问题。</p><p><img src="/posts/11b0627b/cpu-store-buffer-forward.png" alt></p><p>至此，Store Buffer 优化提升了 CPU 效率。但由于修改共享变量先是放到了 Store Buffer 中，只有等到其它 CPU 返回 Invalid OK 后才会同步到缓冲和主存。可以看出执行写操作不是立即生效的，对于有相互依赖的共享数据相关指令，可能会出现CPU乱序执行的现象。解决手段是利用<strong>内存屏障</strong>禁用CPU缓存优化，也就是更新数据时必须立即更新到主存（也就是把store buffer里的指令全部执行完）。</p><h4 id="Invalid-Queue"><a href="#Invalid-Queue" class="headerlink" title="Invalid Queue"></a>Invalid Queue</h4><p>因为 Store Buffer 空间很小，如果有大量的变量修改，它会存储不下，那么这个时候又回到同步通知的状态。此外，有时候其它 CPU 很繁忙并不能马上进行响应，因此为了避免同步等待响应的时间太长，就为每个 CPU 加一个失效队列，当 Store Buffer 存不下的时候，就把失效通知发送到其它 CPU 的失效队列里，只要队列成功接收到了发送的消息就进行响应（发送 Invalid 指令的 CPU 就可以将修改同步到主存了），等到其他CPU闲下来了就从各自的失效队列里读取消息然后失效掉CPU的缓存数据。</p><p>MESI 优化到了 Invalid Queue 阶段，一般来说性能已经很高了，但是在极端的情况下会出现缓存可见性问题。具体来说就是，接收到 Invalid 指令的 CPU 没有来得及处理它的实效队列中的消息，没有及时失效掉对应的缓存行，导致继续使用了本应该失效的缓存数据。这种因为CPU缓存优化而导致后面的指令查看不到前面指令的执行结果，就好像指令之间的执行顺序错乱了一样，这类现象也就是我们俗称的<strong>CPU乱序执行</strong>。解决方法很简单，直接禁用 CPU 缓存优化即可，也就是修改共享数据的指令都同步完成就能保证数据的可见性了，但是这样又会降低整体的性能，这样有点得不偿失，因为毕竟大部分情况下数据都不存在这种共享的问题。不过我们必须要为这种场景提供一种手段来禁用CPU缓存优化，而这种手段同样也是<strong>内存屏障</strong>机制，读取数据时必须读取最新的数据（也就是必须先把失效队列的数据先读取应用完）。</p><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>前文我们说的内存屏障可以同时作用于 Store Buffer 和 Invalidate Queue 。而实际上，对于写操作只需关心 Store Buffer ，读操作只需关心 Invalidate Queue 。因此，大多数 CPU 架构将内存屏障分为了读屏障和写屏障。内存屏障本质上是 CPU 提供的一组指令，不同的操作系统有不同的实现。</p><p><strong>读屏障:</strong> 任何读屏障前的读操作都会先于读屏障后的读操作完成，即读屏障指令执行后就能保证后面的读取数据指令一定能读取到最新的数据。<br><strong>写屏障:</strong> 任何写屏障前的写操作都会先于写屏障后的写操作完成，即遇到写屏障指令就必须把该指令之前的所有写入指令执行完毕才可以往下执行，这样就可以让CPU修改的数据及时暴露给其它CPU。<br><strong>全屏障:</strong> 同时包含读屏障和写屏障的作用</p><p>实际的 CPU 架构中，可能提供多种内存屏障，常见的如下：</p><ul><li>LoadLoad: 相当于前面说的读屏障</li><li>LoadStore: 任何该屏障前的读操作都会先于该屏障后的写操作完成</li><li>StoreLoad: 任何该屏障前的写操作都会先于该屏障后的读操作完成</li><li>StoreStore: 相当于前面说的写屏障</li></ul><p>实现原理都是类似的，如作用于Store Buffer和Invalidate Queue 。</p><h3 id="指令重排问题"><a href="#指令重排问题" class="headerlink" title="指令重排问题"></a>指令重排问题</h3><p>CPU 指令重排虽然遵守了 <strong>as-if-serial</strong> 语义，但仅在单 CPU 执行的情况下能保证结果正确。在多核多线程中，指令逻辑无法分辨因果关联，为了更好地利用流水线可能出现<strong>乱序执行</strong>，导致程序运行结果错误。</p><p>前文中谈的是内存屏障的可见性功能，它能够让屏障前的操作（读/写）及时执行、刷新，被其它 CPU 看到。而内存屏障还有个功能就是限制指令重排（读/写指令），否则即使内存屏障可以保证可见性，但由于不能保证指令重排，保证可见性意义也不大。</p><p>也就是说，内存屏障提供了一套解决CPU缓存优化而导致的顺序性和可见性问题的方案，但是由于不同的硬件系统提供的内存屏障指令可能都不一样，因此像 JAVA 这种高级编程语言就把不同的内存屏障指令统一进行了封装，让开发者不需要关心到系统的底层，而封装这套解决方案的模型就是Java内存模型(Java Memory Model)。</p><p>注意，除了运行期间 CPU 的指令重排，编译器在编译期间，可能也对指令进行重排，以使其对CPU更友好。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>了解了硬件内存架构后，从本小节开始，我们简单聊聊并发。</p><h2 id="并发编程关键问题"><a href="#并发编程关键问题" class="headerlink" title="并发编程关键问题"></a>并发编程关键问题</h2><p>在并发编程中需要处理两个关键问题：线程之间如何通信及线程之间如何同步。</p><p>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种，共享内存和消息传递。共享内存通信机制中，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行<strong>隐式通信</strong>。消息传递通信机制中，线程之间没有公共状态，线程之间必须通过发送消息来<strong>显式通信</strong>。</p><p>同步是指程序中用于控制不同线程间操作发生的相对顺序的机制。在共享内存并发模型中，同步是显式进行的，也就是说程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型中，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</p><p>Java 的并发采用的是<strong>共享内存模型</strong>，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p><h2 id="并发特性"><a href="#并发特性" class="headerlink" title="并发特性"></a>并发特性</h2><p>随着 CPU、内存、I/O设备都在不断迭代，不断朝着更快的方向努力的同时，有一个核心矛盾一直存在，那就是这三者的速度差异。为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统和编译程序都做出了贡献，具体体现为：</p><ul><li>CPU 增加了缓存，以均衡与内存的速度差异。</li><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O设备的速度差异。</li><li>编译程序优化指令执行次序</li></ul><p><strong>总结起来就是：</strong>硬件增加缓存、软件增加线程、编译程序优化指令顺序。</p><p>以上优化带来好处的同时，也给并发程序埋下了祸根。带来的问题可以总结为：</p><ul><li>缓存导致可见性问题 </li><li>线程切换导致原子性问题 </li><li>指令优化导致有序性问题</li></ul><p>下面我们对以上问题详细说明。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为<strong>可见性</strong>。</p><p>在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。</p><p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存，它们是无法直接通信的。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>一个或者多个操作在 CPU 执行的过程中不被中断的特性称为<strong>原子性</strong>。</p><p>Java 并发程序都是基于多线程的，自然会涉及到线程切换，切换的时机大多数是在时间片结束的时候。操作系统做任务切换，可以发生在任何一条<strong>CPU 指令</strong>执行完，注意是 CPU 指令而非高级语言中的一条语句，因为高级语言中的一条语句可能包含多条 CPU 指令。<strong>也就是说，CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言级别。因此，很多时候需要我们自己在高级语言层面保证操作的原子性</strong>。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性指的是程序按照代码的先后顺序执行。但编译器、处理器为了优化性能有时会改变程序执行的次序，而这也是导致问题的原因。</p><p>缓存、线程、编译优化的目的都是提高程序性能的，但是技术在解决一个问题的同时，可能会带来另外一个问题，所以在采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避。</p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>Java 的内存模型（JMM）本质上是一种编程语言规范，屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为 Java 程序员呈现了一个一致的内存模型。不同点在于，JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型。JMM 通过定义多项规则对编译器和处理器进行限制，主要围绕原子性、有序性、可见性展开，具体来说包括 <strong>volatitle、synchronized 和 fianl 这三个关键字，以及系列 happens-before 原则</strong>。</p><p><strong>注意：</strong>JVM 内存模型和 Java 内存模型是完全不同的两个东西。JVM内存模型是一种内存逻辑划分，便于JVM 管理内存；JMM内存模型是对计算机硬件（处理器模型）的统一抽象，用来屏蔽差异。</p><h2 id="细化规范"><a href="#细化规范" class="headerlink" title="细化规范"></a>细化规范</h2><p>JMM 描述了程序的可能行为，程序执行产生的结果都可以由内存模型预测，它决定了在程序的每个点上可以读取什么值（读写是相互的，也就是写了后，读必须要读取到，这就要求写必须刷新到主内存）。既然 JMM 是一种规范，就需要给 JVM 开发者和厂商实现，需要细化规范。</p><h3 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h3><p>可以在线程之间共享的内存称为共享内存或堆内存。所有实例字段，静态字段和数组元素都存储在堆内存中。Java 内存模型的抽象示意图如下：</p><p><img src="/posts/11b0627b/jmm-model.jpg" alt></p><p>JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本，线程对变量的所有操作都必须在本地内存中进行，而不能直接操作主内存中的变量。注意，本地内存是 JMM 的一个抽象概念，并不真实存在。</p><p>如果线程 A 与线程 B 之间要通信的话，必须经历以下2个步骤：</p><ul><li>线程 A 把本地内存中更新过的共享变量刷新到主内存中去。</li><li>线程 B 到主内存中去读取线程 A 之前已更新过的共享变量</li></ul><p>关于主内存与本地内存之间的具体交互，即一个变量如何从主内存拷贝到本地内存、如何从本地内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成。  </p><blockquote><ol><li><strong>lock</strong>：作用于主内存，把变量标识为线程独占状态</li><li><strong>unlock</strong>：作用于主内存，解除独占状态</li><li><strong>read</strong>：作用主内存，把一个变量的值从主内存传输到线程的本地内存</li><li><strong>load</strong>：作用于本地内存，把 read 操作传过来的变量值放入本地内存的变量副本中</li><li><strong>use</strong>：作用本地内存，把本地内存当中的一个变量值传给执行引擎</li><li><strong>assign</strong>：作用本地内存，把一个从执行引擎接收到的值赋值给本地内存的变量</li><li><strong>store</strong>：作用于本地内存的变量，把本地内存的一个变量的值传送到主内存中</li><li><strong>write</strong>：作用于主内存的变量，把 store 操作传来的变量的值放入主内存的变量中</li></ol></blockquote><p>如果要把一个变量从主内存中复制到本地内存中，就需要按顺序地执行read和load操作， 如果把变量从本地内存中同步到主内存中，就需要按顺序地执行store和write操作。但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</p><p>如前所述，Java 内存模型和硬件内存架构是不同的。不管是本地内存的数据还是主内存的数据，对于计算机硬件来说都会存储在计算机主内存中，当然也有可能存储到CPU缓存或者寄存器中，因此总体上来说，Java内存模型和计算机硬件内存架构是一 个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉。具体如下图所示：</p><p><img src="/posts/11b0627b/jmm-cpu-memory-relation.jpg" alt></p><p>当对象和变量可以存储在计算机中各种不同的内存区域时，可能会出现某些问题，两个主要问题是：</p><ul><li>线程更新（写入）共享变量的可见性</li><li>读取、检查和写入共享变量时的竞争条件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本篇文章将对 Java 的内存模型（JMM）进行介绍，本质上它是一种编程语言规范，用于尝试统一一个能够在各种处理器架构中为并发提供一致语义的
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="JMM" scheme="https://gentryhuang.com/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>网络通信 - Reactor模型</title>
    <link href="https://gentryhuang.com/posts/ae5dbc38/"/>
    <id>https://gentryhuang.com/posts/ae5dbc38/</id>
    <published>2021-09-12T13:10:23.000Z</published>
    <updated>2021-09-12T05:53:02.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Reactor 模型是高性能网络系统实现高并发请求处理的一个解决方案，具体来说就是网络服务端处理高并发网络 IO 请求的一种编程模型。Reactor 编程模型具有以下特征：</p><ul><li><strong>三种事件类型：</strong>连接事件、读事件、写事件</li><li><strong>三种关键角色：</strong> Reactor、Acceptor、Handler </li></ul><p>Reactor 模型就是基于以上三种事件和三种角色来处理网络IO请求的，这就它工作的机制。</p><h1 id="演化"><a href="#演化" class="headerlink" title="演化"></a>演化</h1><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/reactor/reactor-classic-service-design-.jpg" alt></p><p>上图是传统阻塞IO模型，每个处理程序在自己的线程中运行。</p><p><strong>缺点如下：</strong></p><p>每个连接都需要独立线程处理，当并发数大时会创建多个线程，过度消耗资源。由于每个连接都对应一个线程，当连接没有就绪时线程就会阻塞等待。</p><p><strong>优化方案：</strong></p><ul><li>基于 IO 多路复用模型，多个连接可以共用一个线程。</li><li>使用线程池，将业务逻辑交给线程池处理。</li></ul><p>基于以上问题，为了高效处理网络 IO 的事件，演化出了 Reactor 模型，该模型的思想就是基于IO多路复用和线程池的结合。</p><h1 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h1><p>Reactor 模型处理的是客户端和服务器端的交互过程，而<strong>连接事件</strong>、<strong>读事件</strong>、<strong>写事件</strong>对应了客户端和服务器端交互过程中不同类型的请求在服务器端引发的待处理事件。</p><p>具体引发的待处理事件如下：</p><ul><li>客户端向服务器端发送连接请求以建立连接，这对应了服务器端的一个<strong>连接事件</strong>。</li><li>连接建立后，客户端会给服务器端发送读或写请求，服务器端需要从客户端读取请求内容，这对应了服务器端的<strong>读事件</strong>。</li><li>服务器端在处理完请求后，需要向客户端写回数据，这对应了服务器端的<strong>写事件</strong>。</li></ul><h1 id="关键角色"><a href="#关键角色" class="headerlink" title="关键角色"></a>关键角色</h1><p>Reactor 模型中的不同类型事件的处理是由对应的角色完成的，三种关键角色的任务如下：</p><ul><li>Acceptor 用于处理客户端连接事件，负责接收连接。</li><li>Handler 用于处理读写事件。</li><li>Reactor 负责监听和分派事件。当有连接请求时，Reactor 将产生的连接事件交给 Acceptor 处理；当有读写请求时，Reactor 将读写事件交给 Handler 处理。</li></ul><p>需要注意的是，以上三种角色是 Reactor 模型中实现功能的<strong>抽象</strong>。遵循 Reactor 模型进行服务器端网络框架开发时，需要对 Reactor、Acceptor 以及 Handler 进行逻辑实现。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>根据 Reactor 的数量和处理资源的线程数量的不同，可以分为三类：</p><ul><li>单 Reactor 单线程模型</li><li>单 Reactor 多线程模型</li><li>多 Reactor 多线程模型</li></ul><p>下面依次介绍以上三种 Reactor 线程模型。</p><h2 id="单Reactor单线程模型"><a href="#单Reactor单线程模型" class="headerlink" title="单Reactor单线程模型"></a>单Reactor单线程模型</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/reactor/reactor-basic-design.jpg" alt></p><p>在单 Reactor 单线程模型下，监听、分派事件由 Reactor 完成，处理连接事件由 Acceptor 完成，处理读写事件和业务逻辑由 Handler 完成，但<strong>始终只有一个线程去完成所有的工作</strong>。</p><p><strong>缺点如下：</strong></p><ul><li>仅使用一个线程完成所有工作，不能充分利用多核机器资源</li><li>当处理任务导致线程负载过高，处理速度会下降，任务会堆积。请求并发量比较低的时候还是可以抗住的，一旦高并发可能将不堪重负</li><li>单线程不能保证可靠性</li></ul><h2 id="单Reactor多线程模型"><a href="#单Reactor多线程模型" class="headerlink" title="单Reactor多线程模型"></a>单Reactor多线程模型</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/reactor/reactor-worker-thread-pool.jpg" alt></p><p>单 Reactor 多线程模型下，不再采用所有工作都由 Reactor 线程独自完成。监听、分派事件由 Reactor 完成，处理连接事件由 Acceptor 完成，处理读写事件由 Handler 完成，这些操作由 Reactor 线程执行。<strong>对于业务逻辑的处理交给线程池（多线程），不再是 Reactor 线程</strong>。相比 单 Reactor 单线程模型，充分利用多核机器的资源、提高性能并且增加可靠性。</p><p><strong>缺点如下：</strong><br>Reactor 线程承担了所有事件的处理，没有解决高并发场景下单线程存在的性能问题。如并发太高，Reactor 线程来不及处理连接请求和读写数据。</p><h2 id="多Reactor多线程模型"><a href="#多Reactor多线程模型" class="headerlink" title="多Reactor多线程模型"></a>多Reactor多线程模型</h2><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/reactor/reactor-multiple-reactor.jpg" alt></p><p>多 Reactor 多线程模型是将 Reactor 拆分成了 mainReactor 和 subReactor 两个部分。主要有一个 mainReactor，多个 subReactor 以及每个 subReactor 附带一个线程池。mainReactor 主要负责监听客户端的连接请求，当有连接请求到达会分派给 Acceptor（位于 mainReactor 中）处理，并将产生的连接信息交给 subReactor ，后续 subReactor 监听到读写事件后，分派给 Handler 处理，业务逻辑交给线程池处理。</p><h1 id="事件驱动框架"><a href="#事件驱动框架" class="headerlink" title="事件驱动框架"></a>事件驱动框架</h1><p>至此，我们已经了解了 Reactor 模型的组件和工作机制，但是 Reactor 中的角色和事件是怎么联动起来的呢？这就需要事件驱动框架了。</p><p>在实现 Reactor 模型时，利用事件驱动框架对整体流程进行控制。事件驱动框架在设计时包括但不限于以下内容：</p><ul><li>事件定义及初始化</li><li>事件监听、分派(分派给对应的程序处理)、处理</li><li>轮询（一般是循环逻辑）</li></ul><h2 id="事件初始化"><a href="#事件初始化" class="headerlink" title="事件初始化"></a>事件初始化</h2><p>Reactor 模型是基于事件和角色工作的，事件驱动框架的实现自然也离不开事件的定义以及初始化。事件初始化的作用主要是创建需要监听的事件类型，并为该类型事件关联对应的处理程序，也就是处理连接事件的 Acceptor、处理读写事件的 Handler以及处理业务逻辑的其它处理程序。</p><h2 id="事件分派、处理"><a href="#事件分派、处理" class="headerlink" title="事件分派、处理"></a>事件分派、处理</h2><p>监听、分派事件是由 Reactor 来完成的，在事件驱动框架中通常会用一个<strong>主循环程序</strong>实现。在这个主循环中，监听发生的事件，并根据事件类型将待处理的事件分派给与之关联的 Acceptor 和 Handler 处理。</p><h2 id="串联部件"><a href="#串联部件" class="headerlink" title="串联部件"></a>串联部件</h2><p>Reactor 模型的工作机制：客户端不同类型请求和服务器端结果处理会在服务器端触发连接、读、写事件，这三类事件的监听、分派和处理又是由 Reactor、Acceptor、Handler 三类角色来完成的，这三类角色会通过事件驱动框架来实现交互和事件处理。不难发现，实现一个 Reactor 模型的关键就是要实现一个事件驱动框架串联起 Reactor 所有部件。</p><p><strong>Reactor 模型的工作机制整体流程图如下：</strong></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/network/reactor/reactor-event-process.jpg" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 Reactor 模型进行了介绍。先是对 Reactor 中涉及的部件及功能进行说明，接着对 Reactor 的演化进行了简单介绍，然后分别对不同种类的 Reactor 进行了逐一说明，最后介绍了事件驱动框架，它是串联 Reactor 模型下所有部件的关键程序。</p><p><strong>参考：</strong><br><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;Reactor 模型是高性能网络系统实现高并发请求处理的一个解决方案，具体来说就是网络服务端处理高并发网络 IO 请求的一种编程模型。Rea
      
    
    </summary>
    
    
      <category term="网络通信" scheme="https://gentryhuang.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>并发 - ThreadLocal</title>
    <link href="https://gentryhuang.com/posts/151f44ae/"/>
    <id>https://gentryhuang.com/posts/151f44ae/</id>
    <published>2021-09-03T04:30:12.000Z</published>
    <updated>2021-09-13T15:06:41.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ThreadLocal 提供了线程局部变量，它是将线程需要访问的数据存储在线程对象自身中，从而避免多线程的数据竞争问题。ThreadLocal 实现原理如下图所示：<br><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-struct.png" alt></p><p>理解 ThreadLocal 原理，其实就是理解 <strong>Thread</strong>、<strong>ThreadLocal</strong> 以及 <strong>ThreadLocalMap</strong> 三者之间的关系。线程类 Thread 内部持有 ThreadLocalMap 的成员变量，而 ThreadLocalMap 是 ThreadLocal 的内部类，ThreadLocal 对外暴露操作数据的 API 都是操作 ThreadLocalMap 中的数据。<strong>总得来说，线程 Thread 在向 ThreadLocal 中设置值时，其实都是向自己所持有的 ThreadLocalMap 中设置数据；读的时候同理，先是从线程自身中取出持有的 ThreadLocalMap ，然后再根据 ThreadLocal 引用作为 key 取出对应的元素 Entry 进而取出 value</strong>。因此 ThreadLocal 可以轻松实现变量的线程隔离，毕竟变量都是维护在各个线程中的，自然没有竞争。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>根据前文中的 ThreadLocal 实现原理图可以发现 ThreadLocal 是 Thread 使用的一个工具，下面我们剥离出 Thread 中相关 ThreadLocal 信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 与此线程相关的 ThreadLocal 值，这个映射由 ThreadLocal 类维护 */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 与此线程相关的 InheritableThreadLocal 值。这个映射由 InheritableThreadLocal 类维护。*/</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thread 中维护了两个 ThreadLocalMap 类型的变量，<strong><code>threadLocals</code> 用于存储当前线程使用的 ThreadLocal 相关信息；<code>inheritableThreadLocals</code> 用于存储当前线程使用的 InheritableThreadLocal 相关信息。使用 InheritableThreadLocal 可以实现多个线程访问 ThreadLocal 的值，即父线程中创建一个 InheritableThreadLocal 的实例，然后在子线程中就可以得到这个 InheritableThreadLocal 中设置的值</strong>。关于共享线程的 ThreadLocal 数据将在下面的内容中分析。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><strong>ThreadLocal 相关的 UML 类图如下所示：</strong></p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-uml.jpg" alt></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1 作为 ThreadLocal 实例的变量，私有、不可变。每当创建 ThreadLocal 时这个值都会累加 HASH_INCREMENT</span></span><br><span class="line"><span class="comment">    * 2 主要为了多个 ThreadLocal 实例的情况下，让哈希码能均匀的分布在2的N次方的数组里, 即 Entry[] table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二进制：-10011110001101110111100110111001</span></span><br><span class="line"><span class="comment">    * 十进制：-2654435769</span></span><br><span class="line"><span class="comment">    * 说明：</span></span><br><span class="line"><span class="comment">    * 1 Entry[] table 的大小必须是 2^N，那 2^N-1 的二进制表示就是低位连续的N个1，</span></span><br><span class="line"><span class="comment">    * 2 key.threadLocalHashCode &amp; (len-1) 的值就是 threadLocalHashCode 的低 N 位，这里使用位运算实现取模，和 HashMap 计算下标类似</span></span><br><span class="line"><span class="comment">    * 3 要求 threadLocalHashCode 的值要均匀，这里给出 0x61c88647 就能达到。</span></span><br><span class="line"><span class="comment">    * 原因：</span></span><br><span class="line"><span class="comment">    * 取该值与fibonacci hashing(斐波那契散列法)以及黄金分割有关，目的就是为了让哈希码能均匀的分布在2的n次方的数组里, 也就是Entry[] table中。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 作为 ThreadLocal 类变量</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * 基于当前 ThreadLocal ，下一个要给出的哈希码，自动更新，从 0 开始计数。</span></span><br><span class="line"><span class="comment">    * 每次获取当前值并加上固定的 HASH_INCREMENT</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回下一个 ThreadLocal 的 hash</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal 关键属性分为两类。一类是 ThreadLocal 实例变量，另一类是 ThreadLocal 类变量。其中类变量在 ThreadLocal 类加载过程就进行初始化，也就是 <code>nextHashCode</code> 的初始化，后续实例变量 <code>threadLocalHashCode</code> 随着对象的创建而调用 <code>nextHashCode</code> 方法进行赋值，可以看出每次递增为 <strong>HASH_INCREMENT</strong> ，至于为什么选择这个值，是和斐波那契散列法以及黄金分割有关，目的就是为了让哈希码能均匀的分布在 2^n 次方的数组里，这个和 HashMap 中 hash 实现目的是一致的。</p><p>了解了核心属性后，下面以几个方法做为入口分析 ThreadLocal 源码。</p><h3 id="Set-方法"><a href="#Set-方法" class="headerlink" title="Set 方法"></a>Set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置当前线程变量的值 value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 根据当前线程获取其成员变量 threadLocals 所指向的 ThreadLocalMap 对象</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 判断当前线程的 ThreadLocalMap 是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 3.1 如果不为空，说明当前线程内部已经有ThreadLocalMap对象了</span></span><br><span class="line">            <span class="comment">// 那么直接将当前对应的 ThreadLocal 对象的引用作为键，存入的 value 作为值存储到 ThreadLocalMap 中</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 3.2 创建一个 ThreadLocalMap 对象并将值存入到该对象中，并赋值给当前线程的threadLocals成员变量</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>ThreadLocal 中的增、删、查方法基本都会有三个步骤。下面对 Set 方法进行小结:</strong></p><blockquote><ol><li>获取当前线程</li><li>根据当前线程获取其持有的 ThreadLocalMap 映射表</li><li>操作映射表 ThreadLocalMap ，如果映射表存在就调用映射表的 set 方法放入数据，映射表不存在则先创建映射表再放入数据</li></ol></blockquote><h3 id="Get-方法"><a href="#Get-方法" class="headerlink" title="Get 方法"></a>Get 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程的线程副本变量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 根据当前线程获取其 ThreadLocalMap 实例</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 如果当前线程的 ThreadLocalMap 不为空</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T) e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 如果当前线程的 ThreadLocalMap 为空或 ThreadLocalMap 中没有当前 ThreadLocal 对应的元素，则调用 initialValue() 方法初始化值</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>下面对 Get 方法进行小结:</strong></p><blockquote><ol><li>获取当前线程</li><li>根据当前线程获取其持有的 ThreadLocalMap 映射表</li><li>操作映射表 ThreadLocalMap ，如果映射表存在就调用映射表的 getEntry 方法查询数据；映射表不存在或从映射表中没有找到当前 ThreadLocal 对应的元素，则调用 setInitialValue 方法完成映射表的创建或初始值的获取</li></ol></blockquote><p>Get 方法相比 Set 方法会涉及查询不到元素的情况，如果当前线程持有的映射表还没有或者找不到元素，那么 ThreadLocal 会尝试以初始化值的方式进行兜底处理，初始值的情况通过方法 <code>initialValue()</code> 交给具体实现。</p><h4 id="setInitialValue-方法"><a href="#setInitialValue-方法" class="headerlink" title="setInitialValue 方法"></a>setInitialValue 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置初始化值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 调用 initialValue() 方法获取指定的初始化值，默认为 null</span></span><br><span class="line">        T value = initialValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 获取当前线程的 ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 如果 ThreadLocalMap 不为空，则直接将初始值设置到 ThreadLocalMap 中</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 如果 ThreadLocalMap 为空，则创建 ThreadLocalMap 对象，并设置初始值</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化值，子类覆盖</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Remove-方法"><a href="#Remove-方法" class="headerlink" title="Remove 方法"></a>Remove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取当前线程持有的 ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 删除 ThreadLocalMap 中当前 ThreadLocal 相关的信息</span></span><br><span class="line">        <span class="comment">// 包括清理对应的引用和值</span></span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">            m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>下面对 Remove 方法进行小结:</strong></p><blockquote><ol><li>获取当前线程</li><li>根据当前线程获取其持有的 ThreadLocalMap 映射表</li><li>操作映射表 ThreadLocalMap ，如果映射表存在就调用映射表的 remove 方法根据当前 ThreadLocal 清理对应数据，可以防止内存泄漏</li></ol></blockquote><h3 id="createMap-方法"><a href="#createMap-方法" class="headerlink" title="createMap 方法"></a>createMap 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为线程 t 初始化 ThreadLocalMap 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t          当前线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>线程中的 ThreadLocalMap 使用的是延迟初始化，即第一次调用 get() 或者 set() 方法的时候才会进行初始化。</p><h3 id="getMap-方法"><a href="#getMap-方法" class="headerlink" title="getMap 方法"></a>getMap 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">// 返回线程 t 的 threadLocals</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述方法用于获取每个线程持有自身的 ThreadLocalMap 实例，因此它们是不存在并发竞争的，这就是我们说的每个线程都有自己的变量副本。</p><p>至此，ThreadLocal 相关属性以及暴露的方法已经分析完毕。可以看出，ThreadLocal 中并没有持有 ThreadLocalMap 的引用，该引用是在 Thread 类中。此外，ThreadLocal 暴露的 API 操作都是基于 ThreadLocalMap 的。因此，我们理解了 ThreadLocalMap 才算是掌握了 ThreadLocal 。下面我们重点对 ThreadLocalMap 进行分析。</p><h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><p>ThreadLocalMap 是 ThreadLocal 的静态内部类，本质上是一个 Map ，和 HashMap 类似，依然是 key-value 的形式，具体由 Entry 结构封装。</p><p><img src="https://blog-picture-oss.oss-cn-hangzhou.aliyuncs.com/concurrent/thread/thread-local-map-struct.jpg" alt></p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组初始化容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储数据的 Entry 数组，长度是 2 的幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组中元素的个数，初始值为 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组扩容阈值，默认为0，创建了 ThreadLocalMap 对象后会被重新设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置调整大小阈值，以保持在最坏 2/3 的负载因子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ThreadLocalMap使用 开放地址法-线性探测法 来解决哈希冲突 */</span></span><br><span class="line"><span class="comment">// 向后一个位置找，注意从头开始的情况</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向前一个位置找，注意跳到尾部的情况</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体属性类似 HashMap ，各个值的含义已经详细注释就不再说明。需要注意的是，由于 ThreadLocalMap 使用的是线性探测法解决 hash 冲突，因此定义向前和向后探测的方法以便于寻找合适的位置及定位元素。</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 与传入 ThreadLocal 关联的值，也就是线程局部变量值</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Entry的 key 是对 ThreadLocal 的弱引用，当抛弃掉 ThreadLocal 对象时，垃圾收集器会忽略这个 key 的引用而清理掉 ThreadLocal 对象。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一个线程可以使用多个 ThreadLocal 将不同的值存储到当前线程的 ThreadLocalMap 中。熟悉 HashMap 存储结构的可以发现，ThreadLocalMap 中的存储结构有两大不同点：</p><ul><li>没有链表相关的指针，更没有树节点的左右链接</li><li>元素节点结构 Entry 继承了 <code>WeakReference</code> 类，以实现弱引用功能</li></ul><p>作为一个映射表，必然会有元素冲突的可能，虽然和 HashMap 结构类似，但是没有 HashMap 中链表和树形结构，那么 ThreadLocalMap 是怎么解决 hash 冲突的呢？答案是<strong>线性探测法</strong>。关于 Entry 继承 <code>WeakReference</code> 的原因我们在后面的文章中进行分析。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstKey   ThreadLocal 引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue 设置的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="comment">// 1 初始化 Entry 数组，大小为 16</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取 ThreadLocal 的 hash 值(该值是累加的)</span></span><br><span class="line">        <span class="comment">// 计算当前 key 对应的数组下标位置， 和 HashMap 的位运算代替取模原理一样</span></span><br><span class="line">        <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 将 Entry 对象存入到数组指定的位置</span></span><br><span class="line">        table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4 记录数组元素个数</span></span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5 初始化扩容阈值</span></span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当线程 Thread 持有的 ThreadLocalMap 还没有初始化时，在使用 ThreadLocal 存储或获取数据时都会先创建一个 ThreadLocalMap 对象然后挂载到当前线程 Thread 上，后续不管该线程使用了多少个 ThreadLocal ，都会使用创建的 ThreadLocalMap 进行储存相应值，有冲突就使用<strong>线性探测法</strong>解决。</p><p>了解了 ThreadLocalMap 的底层数据结构后，下面我们依然从它的核心操作方法出发分析底层实现。</p><h3 id="getEntry-方法"><a href="#getEntry-方法" class="headerlink" title="getEntry 方法"></a>getEntry 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取与 key 关联的 Entry</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 根据 key 计算下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 根据下标获取 Entry</span></span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 通过下标直接得到的 Entry 不是要找的，那么就线性探测找</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>获取线程局部变量值的 getEntry 方法是 ThreadLocal 暴露的 get() 方法的底层实现，它的主要流程如下：</p><ul><li>根据 ThreadLocal 引用计算对应的数组下标，这个和 HashMap 类似</li><li>根据计算得到的下标尝试直接获取对应的 Entry，如果当前 Entry 为空或对应的 key 不是当前传入的 key ，那么进行线性探测获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * getEntry方法的版本，用于在键未在其直接散列槽中找到时使用。</span></span><br><span class="line"><span class="comment">         * 注意，该方法会清理无效 Entry</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i   the table index for key's hash code</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e   the entry at table[i]</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the entry associated with key, or null if no such</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 线性探测</span></span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取 Entry 的 key</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.1 命中，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (k == key)</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="comment">// 2.2 无效 Entry，执行连续段删除</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.3 获取下个位置</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3 遍历完也没查到，返回 null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>之所以要进行线性探测获取其实是和链表查询一样，可能目标元素由于 hash 冲突放到了后续位置。<strong>注意：查询流程也就是 get() 方法可能也会清理无效的元素，以防止内存泄漏，但不能保证</strong>。关于连续段清理无效元素逻辑暂略过。</p><h3 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置与 key 关联的值</span></span><br><span class="line"><span class="comment">         * 说明：</span></span><br><span class="line"><span class="comment">         * ThreadLocal 的 set 方法，就是为了将指定的值存入到指定线程的 ThreadLocalMap 对象中，具体还是通过 ThreadLocalMap 的 set 方法</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key   the thread local object</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value the value to be set</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1 获取数组信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 计算当前 ThreadLocal 对象引用作为键在数组中的下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 根据获取到的下标进行线性探测，寻找空的位置。</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1 获取当前 Entry 中的 key ，即 ThreadLocal 的引用，注意是弱引用。</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 判断和当前的 ThreadLocal 对象是否是同一个对象，如果是，那么直接进行值替换，并结束方法，</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.3 判断当前 Entry 是否失效，即是否被回收（弱引用），如果失效，说明当前位置可以重新使用，就使用新的 key-value 将其替换</span></span><br><span class="line">                <span class="comment">// 该过程还会进行连续段删除其它无效的 entry</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 找到某个空位置，直接将键值对设置到该位置上。</span></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 尝试随机清理无效 entry ，如果没有可清理的 entry 且数组元素大小 &gt;= 扩容阈值，则进行 rehash</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>设置线程局部变量值的 set 方法稍微复杂点，下面对其主要流程进行说明：</strong></p><blockquote><ol><li>根据传入的 key 计算数组下标位置</li><li>根据计算得到的下标进行线性探测，寻找空的位置以存放元素<ul><li>检测到存在相同 key 的元素，进行值覆盖，然后结束流程即可</li><li>检测到无效的元素，则重用无效元素位置，并尝试清理无效的元素</li><li>在某个空位置存放数据</li></ul></li><li>如果不是值覆盖或重用无效元素位置的情况，那么需要判断是否需要 rehash  </li></ol></blockquote><p>下面我们对上述关联的核心方法进行拆解分析。</p><h4 id="replaceStaleEntry-方法"><a href="#replaceStaleEntry-方法" class="headerlink" title="replaceStaleEntry 方法"></a>replaceStaleEntry 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 替换无效 Entry ，并尝试删除其它无效的 Entry。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> key key</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> staleSlot 无效 entry 的位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取数组信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            Entry e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标志 Table 中是否存在无效 Entry。slotToExpunge != staleSlot 说明 table 中存在无效 Entry 需要进行清理，否则说明没有。</span></span><br><span class="line">            <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 根据传入的无效 Entry 的位置 staleSlot 向前扫描一段连续非空的 Entry ，并记录最后一个无效的 Entry 的位置。或者扫描完也没有找到。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; i = prevIndex(i, len))</span><br><span class="line">                <span class="comment">// 2.1 如果是无效 Entry ，则更新删除标记 slotToExpunge</span></span><br><span class="line">                <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 根据传入的无效 Entry 向后扫描一段连续的 Entry（根据线性探测，具有相同的 key 的元素一定是从后找的） ,以寻找是否有相同 key 的 Entry，以及在需要时更新删除标记位 slotToExpunge</span></span><br><span class="line">            <span class="comment">// 找到相同 key 的元素或末尾的空槽，以最先出现的为准</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1 获取当前 Entry 的 key</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 如果找到了具有相同的 key ，则更新其值。也就是更新其值并将其与传入的无效 Entry 替换，即与 table[staleSlot] 进行替换</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    <span class="comment">// 3.2.1 更新为传入的 value</span></span><br><span class="line">                    e.value = value;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.2.2 使用相同 key 的 Entry 重用失效位置以避免新创建一个 Entry，以维持散列表的顺序。</span></span><br><span class="line">                    tab[i] = tab[staleSlot];</span><br><span class="line">                    tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.2.3 如果向前查找没有找到无效的 Entry，则更新删除标记位 slotToExpunge 为当前位置 i，此时 i 位置对应的是无效 Entry</span></span><br><span class="line">                    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                        slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.3.4 将新过时的槽或在其上面遇到的任何其他过时槽发送到expungeStaleEntry，以删除或重新散列运行中的所有其他条目。</span></span><br><span class="line">                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果向前查找没有找到无效 entry，并且当前向后扫描的entry无效，则更新 slotToExpunge 为当前值 i</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 执行到这里，说明 table 中不存在相同 key 的 Entry，此时只需直接重用无效位置即可</span></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5 slotToExpunge != staleSlot 说明 table 中存在无效 Entry 需要进行清理</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>重用无效 Entry 位置有两种可能：</strong></p><ul><li>如果扫描到的 Table 中存在和要插入的 key 相同的 Entry，那么就使用更新 value 后的该 Entry 替换无效 Entry 以避免新创建 Entry，同时该 Entry 成为了无效 Entry，只需等待后续删除即可。</li><li>如果扫描到的 Table 中不存在和要插入的 key 相同的 Entry ，那么直接创建 Entry 替换无效 Entry 即可。</li></ul><p>此外，上述方法还会对无效 Entry 进行清理，触发条件就是检测到其它无效 Entry 的存在。</p><h4 id="rehash-操作"><a href="#rehash-操作" class="headerlink" title="rehash 操作"></a>rehash 操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * rehash 操作</span></span><br><span class="line"><span class="comment">         * 1 扫描整个 Table ，删除无效的 Entry</span></span><br><span class="line"><span class="comment">         * 2 执行清理后，如果还需要扩容，则将表扩大一倍</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 清理所有无效 Entry</span></span><br><span class="line">            expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  2 threshold - threshold / 4 = 1en / 2，降低扩容阈值是因为上面做了一次全清理 size 可能会减小</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Table 容量扩大为原来 2 倍</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] oldTab = table;</span><br><span class="line">            <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 容量扩大为原来 2 倍</span></span><br><span class="line">            <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">            Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 重新映射旧数组中的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">                Entry e = oldTab[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 清理无效 Entry</span></span><br><span class="line">                    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 线性探测重新设置值</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, newLen);</span><br><span class="line">                        newTab[h] = e;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4 设置新的阈值</span></span><br><span class="line">            setThreshold(newLen);</span><br><span class="line">            size = count;</span><br><span class="line">            table = newTab;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>新增数据后，如果达到阈值就会触发 rehash 流程，进行<strong>数组扩容和数据重新映射</strong>，这个没什么可说的。</p><h3 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 计算 key 对应的下标</span></span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 进行线性探测，查找正确的 Entry</span></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 找到对应的 Entry</span></span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    <span class="comment">// 调用 WeakReference.clear() 方法清除对应的引用</span></span><br><span class="line">                    e.clear();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 连续段删除 Entry</span></span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上述方法是 ThreadLocal 暴露的 remove() 方法的底层实现，用来清理当前 ThreadLocal 关联的信息。具体清理信息如下：</p><ul><li>清除对当前 ThreadLocal 的弱引用</li><li>清除当前 ThreadLcoal 对应的 Entry 中的 value </li><li>清除当前 ThreadLocal 对应的 Entry </li></ul><h3 id="expungeStaleEntry-方法"><a href="#expungeStaleEntry-方法" class="headerlink" title="expungeStaleEntry 方法"></a>expungeStaleEntry 方法</h3><p>expungeStaleEntry 方法用于彻底删除指定位置的 Entry 所以信息，接着向后连续段扫描删除无效 Entry ，并对可能存在 hash 冲突的 Entry 进行 rehash 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除过期的元素，是连续段方式的删除</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 获取 Table 信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 清理 staleSlot 位置的无效 Entry ，并递减元素个数</span></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">            Entry e;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 从 stateSlot 开始向后扫描一段连续的非空的 Entry</span></span><br><span class="line">            <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.1 获取当前 Entry 的 k</span></span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 如果遇到key为null,表示无效entry，进行清理.</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// value 置空</span></span><br><span class="line">                    e.value = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 元素置空</span></span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 元素个数递减</span></span><br><span class="line">                    size--;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.3 如果 key 不为 null ，则对可能存在 hash 冲突的 Entry 进行 rehash</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 计算 key 对应的下标，如果与现在所在位置不一致，认为存在 hash 冲突，置空当前 table[i] ，</span></span><br><span class="line">                    <span class="comment">// 并从 h 开始向后线性探测到第一个空的 slot，把当前的 entry 移动过去。</span></span><br><span class="line">                    <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                        tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                        <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                        <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        tab[h] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下一个为空的下标</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上述方法用于删除过期的元素，具体删除策略如下：</p><ul><li>根据传入的 stateSlot 清理对应的无效 Entry，这个是绝对删除。</li><li>根据传入的 stateSlot 向后扫描一段连续非空的 Entry ，对可能存在 hash 冲突的 Entry 进行 rehash ，并且清理遇到的无效 Entry 。</li></ul><h3 id="expungeStaleEntries-方法"><a href="#expungeStaleEntries-方法" class="headerlink" title="expungeStaleEntries 方法"></a>expungeStaleEntries 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扫描整个 Table ，删除无效的 Entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="comment">// 无效 Entry ，则调用 expungeStaleEntry 方法删除对应位置及连坐删除 Entry</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是在 expungeStaleEntry 方法的基础上，对整个 Table 中无效元素进行清理，一定会清理截止到当前 Table 中所有的无效 Entry 。需要说明的是，ThreadLocal 的所有一些列操作都是单线程的，也就是当前线程。</p><h3 id="cleanSomeSlots-方法"><a href="#cleanSomeSlots-方法" class="headerlink" title="cleanSomeSlots 方法"></a>cleanSomeSlots 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 启发式的扫描清除，扫描次数由传入的参数n决定</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i 从i向后开始扫描（不包括i，因为索引为i的Slot肯定为null）</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> n  控制扫描次数，正常情况下为 log2(n) ，如果找到了无效 Entry ，会将 n 重置为 table 的长度 len 进行阶段删除</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> true if any stale entries have been removed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1 删除标志</span></span><br><span class="line">            <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2 数组信息</span></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 i 位置向后遍历，删除无效的 Entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">                Entry e = tab[i];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果当前 Entry 无效，则进行清理并进行连坐</span></span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    n = len;</span><br><span class="line">                    removed = <span class="keyword">true</span>;</span><br><span class="line">                    i = expungeStaleEntry(i);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 无符号的右移动，可以用于控制扫描次数在log2(n)</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> removed;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>启发式扫描删除具有随机性，启发式思想也用在其他代码中，如 Redis 中的定期删除逻辑。</p><p>自此，ThreadLocalMap 的源码实现分析完毕。</p><h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><p>一般来说 ThreadLocal 数据都是线程独享的，但是 ThreadLocal 继承体系支持子线程共享父线程的变量副本数据。共享线程的 ThreadLocal 数据可以使用 <strong>InheritableThreadLocal</strong> 来实现。通过在父线程中创建一个 <strong>InheritableThreadLocal</strong> 的实例，然后在子线程中就可以获取该实例中设置的值。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 创建 InheritableThreadLocal 对象</span></span><br><span class="line">    ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 创建的 ThreadLocalMap 挂载到当前 Thread 的 inheritableThreadLocals 属性</span></span><br><span class="line">    threadLocal.set(<span class="string">"小芒果!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 创建并启动子线程</span></span><br><span class="line">    Runnable runnable = () -&gt; &#123;</span><br><span class="line">        <span class="comment">// 打印子线程 ThreadLocal 的线程变量值</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt; "</span> + threadLocal.get());</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印父线程（这里是主线程） ThreadLocal 的线程变量值</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt; "</span> + threadLocal.get());</span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main-&gt; 小芒果!</span><br><span class="line">Thread-0-&gt; 小芒果!</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>线程变量传递逻辑很简单，它隐藏在 Thread 的 init 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+--- Thread</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">        init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 获取初始化当前线程的线程</span></span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果 parent 线程使用了 InheritableThreadLocal ，那么就把 parent 的 inheritableThreadLocals 给当前线程的 inheritableThreadLocals 。</span></span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 设置到当前线程的 inheritableThreadLocals 属性中</span></span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">        <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set thread ID */</span></span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从线程初始化逻辑中可以看出，如果父线程 ThreadLocalMap 类型的变量 <code>inheritableThreadLocals</code> 不为空，那么就把父线程的该属性设置给当前线程的 <code>inheritableThreadLocals</code> 属性。具体设置逻辑在 ThreadLocal 的 createInheritedMap 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+--- ThreadLocal</span><br><span class="line">    <span class="comment">// 继承式创建 ThreadLocal</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅由 createInheritedMap 方法调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocal.ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1 获取 parentMap 的 Table 信息</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">        setThreshold(len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 创建新的 Table</span></span><br><span class="line">        table = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 将 parentMap 中的数据依次映射到新创建的 Table 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">// 3.1 获取当前 Entry</span></span><br><span class="line">            ThreadLocal.ThreadLocalMap.Entry e = parentTable[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.2 获取 Entry 中的 key</span></span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3.3 Entry 有效的话就进行映射</span></span><br><span class="line">                <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 用于获取父线程变量值的转换，默认就是父线程 Entry.value 值</span></span><br><span class="line">                    Object value = key.childValue(e.value);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 线性探测存储元素</span></span><br><span class="line">                    ThreadLocal.ThreadLocalMap.Entry c = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(key, value);</span><br><span class="line">                    <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    table[h] = c;</span><br><span class="line"></span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过以上逻辑可以发现，如果要使用线程变量共享需要使用到 <strong>InheritableThreadLocal</strong> 类，线程 Thread 的映射属性使用 <code>inheritableThreadLocals</code> 而非 <code>threadLocals</code> 。</p><h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认是 Entry 的 value 值，使用方可继承 InheritableThreadLocal 覆盖该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentValue the parent thread's value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the child thread's initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程 t 的 ThreadLocalMap ，注意取的是 inheritableThreadLocals 属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建当前线程 t 的 ThreadLocalMap ，注意设置的是 inheritableThreadLocals 属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstValue value for the initial entry of the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InheritableThreadLocal 继承了 ThreadLocal ，重写了以上三个方法，主要是将映射表挂在到 Thread 的 <code>inheritableThreadLocals</code> 属性上，用以实现线程变量的共享。注意，线程变量独享使用的是 Thread 中的 <code>threadLocals</code> 属性。InheritableThreadLocal 对比 ThreadLocal 唯一不同是子线程会继承父线程变量，并支持自定义赋值函数。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>ThreadLocalMap 使用 ThreadLocal 的弱引用做为元素 Entry 的 key ,如果一个 ThreadLocal 没有外部强引用来引用它，那么系统 GC 时这个 ThreadLocal 会被回收。此时，ThreadLocalMap 中就会出现 key 为 null 的 Entry ，这样就没有办法访问这些 Entry，这些 Entry 理论上属于无效的，应该被 GC 回收。但是，如果存在持有这些 Entry 的线程迟迟不结束（如使用线程池），那么这些 key 为 null 的 Entry 的 value 就会一直存在一条强引用链 <strong>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</strong>，导致无法回收，造成内存泄漏。</p><p>ThreadLocal 为了尽可能避免内存泄漏问题，在 <code>get()</code>、<code>set()</code> 以及 <code>remove()</code> 方法中都有清除线程的 ThreadLocalMap 中 key 为 null 的 value 逻辑。<strong>注意，其中 get()、set() 两个方法都不能完全防止内存泄漏，存在无效 Entry 无法扫描到的情况，因为只有在线性探测流程中才会尝试连续段清理无效 Entry 。最好的方式是每次使用完 ThreadLocal 都手动 remove 一下</strong>。</p><p>此外，以下措施会增加内存泄漏的风险：</p><ul><li>使用 static 的 ThreadLocal ，这种方式延长了 ThreadLocal 的生命周期</li><li>分配使用了 ThreadLocal ，而不再调用其 <code>get()</code>、<code>set()</code> 以及 <code>remove()</code> 方法</li></ul><h2 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h2><ul><li><strong>key 使用强引用：</strong>ThreadLocal 对象没有外部引用，但是 ThreadLocalMap 持有 ThreadLocal 的强引用，如果没有手动删除，ThreadLocal 不会被回收，这会导致 Entry 内存泄漏。</li><li><strong>key 使用弱引用：</strong>ThreadLocal 对象没有外部引用，由于 ThreadLocalMap 持有 ThreadLocal 的弱引用，即使没有手动删除，ThreadLcoal 也可以被回收。value 在下一次执行方法时被清除。 </li></ul><p>Entry 继承 WeakReference，并且使用 ThreadLocal 的弱引用作为 key，这样可以将 ThreadLocal 对象的生命周期和线程生命周期解绑。持有弱引用可以使得 ThreadLocal 在没有其他强引用的时候被回收掉，这样可以避免因为线程得不到销毁导致 ThreadLocal 对象无法被回收。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>每次使用完 ThreadLocal 都应该调用它的 remove() 方法，进行数据清理，防止内存泄漏。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>多线程之间需要拥有同一个信息，那么通常可以采用 <code>initialValue()</code> 方法进行初始化，直接将需要拥有的变量副本存储到 ThreadLocal 中。</li><li>多个线程中存储不同的信息，那么需要使用 set() 方法设置变量副本到 ThreadLocal 中。</li></ul><p>上述描述<strong>存储到 ThreadLocal 中</strong>是不对的，需要注意，数据其实是存储到线程持有的 ThreadLocalMap 对象中，该对象是一个散列表。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章对 ThreadLocal 进行了深入的分析，它能保证数据安全是因为每个线程都有自己的线程变量，不会发生多个线程共享变量的情况。首先对 ThreadLocal 的关系进行了介绍，从总体上认识 ThreadLocal 。接着对 ThreadLocal 进行了分析，从其属性到暴露的 API 。然后对 ThreadLocal 底层的支持类 ThreadLocalMap 进行了分析，同样从属性到支撑上层的方法的分析。最后对父子线程就 ThreadLocal 如何共享线程变量进行了分析。在文章的最后，对内存泄漏问题进行了介绍。</p><p><strong>参考资料</strong><br><a href="https://www.cnblogs.com/lqlqlq/p/13302901.html" target="_blank" rel="noopener">https://www.cnblogs.com/lqlqlq/p/13302901.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;ThreadLocal 提供了线程局部变量，它是将线程需要访问的数据存储在线程对象自身中，从而避免多线程的数据竞争问题。ThreadLoca
      
    
    </summary>
    
    
      <category term="JDK" scheme="https://gentryhuang.com/categories/JDK/"/>
    
    
      <category term="Thread" scheme="https://gentryhuang.com/tags/Thread/"/>
    
  </entry>
  
</feed>
